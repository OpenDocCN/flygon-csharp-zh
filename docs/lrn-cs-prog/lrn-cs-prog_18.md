# 第十八章：评估

# 章节 1

1.  C#语言的第一个版本 1.0 于 2002 年发布，与.NET Framework 1.0 和 Visual Studio .NET 2002 捆绑在一起。在撰写本书时，该语言的当前版本是 C# 8。

1.  CLI 是一种规范，描述了如何在不为特定架构重写的情况下，在不同的计算机平台上使用运行时环境。CLI 描述了四个主要组件：**公共类型系统**（**CTS**）、**公共语言规范**（**CLS**）、**虚拟执行系统**（**VES**）以及程序结构和内容的元数据。

1.  CIL 是一个平台中立的中间语言，代表了 CLI 定义的中间语言二进制指令集。当您编译程序的源代码时，编译器将其转换为 CIL 字节码，并生成 CLI 程序集。当执行 CLI 程序集时，字节码通过即时编译器传递，以生成本机代码，然后由计算机处理器执行。

1.  要查看程序集的内容，您必须使用反汇编器。反汇编器的示例包括与.NET Framework 一起分发的 ildasm.exe，或者 ILSpy，一个开源的.NET 程序集浏览器和反编译器。

1.  公共语言运行时是.NET Framework 对 VES 的实现。CLR 提供诸如内存管理、类型安全、垃圾回收、异常处理、线程管理等服务。

1.  BCL 是标准库的一个组件，提供了用于表示 CLI 内置类型、简单文件访问、自定义属性、字符串处理、格式化、集合、流等类型。

1.  当前的主要.NET 框架是.NET Framework、.NET Core 和 Xamarin。由于微软计划使.NET Core 成为用于构建桌面、服务器、Web、云和移动应用程序的唯一框架；.NET Framework 被放置在维护模式，并且只包括安全更新。

1.  程序集是部署、版本控制和安全性的基本单位。它们有两种形式：可执行文件（`.exe`）和动态链接库（`.dll`）。程序集是类型、资源和元信息的集合，形成一个逻辑功能单元。程序集的标识由名称、版本、文化和公钥令牌组成。

1.  GAC 是一个机器范围的代码缓存，它可以在应用程序之间共享程序集。其默认位置是`%windir%\Microsoft.NET\assembly`。Runtime Package Store 是.NET Core 应用程序的等效物。它可以实现更快的部署和更低的磁盘空间要求。通常，该存储在 macOS 和 Linux 上可用于`/usr/local/share/dotnet/store`，在 Windows 上可用于`C:/Program Files/dotnet/store`。

1.  为了编译和执行，C#程序必须包含一个包含名为`Main()`的静态方法的类。

# 章节 2

1.  C#中的内置整数类型是`byte`、`sbyte`、`ushort`、`short`、`uint`、`int`、`ulong`和`long`。

1.  `float`和`double`类型使用 2 的倒数来表示数字的小数部分。因此，它们无法准确表示诸如 1.23 或 19.99 之类的数字，而只能近似表示它们。尽管`double`具有 15 位精度，而`float`只有 7 位；但在执行重复计算时，精度损失会累积。`decimal`类型使用实数的十进制表示，计算速度要慢得多，但提供更好的精度。`decimal`类型具有 28 位精度，适用于金融应用等类别的应用程序，这是关键。

1.  字符串可以使用`+`运算符进行连接。除了连接，您还可以使用`String.Format()`静态方法或字符串插值来组成字符串，这是该方法的一种语法快捷方式。

1.  一些字符在字符串中具有特殊含义。这些称为转义序列，并以反斜杠（`\`）为前缀。例如单引号（`\'`）、双引号（`\"`）、换行字符（`\n`）和反斜杠（`\\`）。逐字字符串是以`@`标记为前缀的字符串。对于逐字字符串，编译器不解释转义序列。这使得编写多行文本或文件路径变得更容易。

1.  隐式类型变量使用`var`关键字声明，而不是实际类型，并且必须在声明时初始化。编译器从用于初始化它们的值或表达式中推断出实际类型。

1.  值类型和引用类型是 C#和.NET 中的两种主要类型类别。值类型的变量直接存储值。引用类型的变量存储指向（地址）包含实际对象的内存位置的引用。值类型具有值语义（简单来说，当你复制一个对象时，它的值被复制），引用类型具有值语义（当你复制一个对象时，它的引用被复制）。通常，值类型存储在堆栈上，引用类型存储在堆上，但这是一个实现细节，而不是类型的特征。

1.  装箱是将值类型存储在`object`中的过程，拆箱是将`object`的值转换为值类型的相反操作。

1.  可空类型是`System.Nullable<T>`的实例，它是一个可以表示基础`T`类型的值的泛型值类型，该类型只能是值类型，以及额外的空值。可空整数变量可以声明为`Nullable<int>`或`int?`。

1.  C#中有三种类型的数组。第一种类型是一维数组，它是单维数组。例如`int[6]`，它是一个包含 6 个整数的数组。第二种类型是多维数组，它是两个或更多维度的数组，最多 32 个。例如`int[2,3]`，它是一个具有 2 行 3 列的整数数组。第三种类型是交错数组，它是数组的数组。交错数组是一个一维数组，其元素是其他数组，每个数组可以是另一个维度。

1.  系统定义的类型转换有隐式转换（例如从`int`到`double`），显式转换（例如从`double`到`int`）。显式类型转换也称为强制转换，在两种类型之间进行转换时可能会丢失信息时是必要的。用户定义的转换可以通过为某种类型定义隐式或显式操作符或使用辅助类来实现。

# 第三章

1.  C#语言中的选择语句是`if`和`switch`。

1.  `switch`语句的`default`情况可以出现在列表的任何位置。在所有情况标签被评估之后，它总是最后被评估。

1.  `for`循环允许我们执行一段代码，只要布尔表达式评估为 true。`foreach`循环允许我们遍历实现`IEnumerable`接口的集合的元素。

1.  `while`循环是一个入口控制循环。这意味着只要指定的布尔表达式评估为 true，它就会执行一系列语句。在执行块之前检查表达式。`do-while`循环是一个出口控制循环。这意味着布尔表达式将在循环结束时被检查。这确保了`do-while`循环至少会执行一次，即使条件在第一次迭代中评估为 false。

1.  要从函数返回，可以使用`return`、`yield`或`throw`。前两个表示正常返回。`throw`语句表示由于执行流中的错误情况而返回。

1.  `break`语句可用于退出`switch`情况或终止循环的执行。它适用于所有循环：`for`、`while`、`do-while`和`foreach`。

1.  它表示方法、运算符或`get`访问器是一个迭代器，它出现在`return`或`break`语句之前。从迭代器方法返回的序列可以使用`foreach`语句消耗。`yield`语句使得可以在生成时返回值并在可用时消耗它们，这在异步上下文中特别有用。

1.  您可以通过`catch(Exception)`捕获函数调用的所有异常，这样您就可以访问有关异常的信息，或者使用简单的`catch`语句（不指定异常类型），这样您就无法获取有关异常的任何信息。

1.  `finally`块包含在`try`部分之后执行的代码。无论执行是否正常恢复或控制是否因`break`、`continue`、`goto`或`return`语句而离开`try`块，都会发生这种情况。

1.  .NET 中所有异常类型的基类是`System.Exception`类。

# 第四章

1.  类是指定对象形式的模板或蓝图。它包含操作该数据的数据和代码。对象是类的一个实例。类是用`class`关键字引入的，并定义了一个引用类型。结构是用`struct`关键字引入的，并定义了一个值类型。与类不同，结构不支持继承，不能有显式的默认构造函数，并且除非它们被声明为`const`或`static`，否则字段不能在声明时初始化。

1.  只读字段是使用`readonly`修饰符定义的字段。这样的字段只能在构造函数中初始化，其值以后不能被改变。

1.  表达式体定义是一种替代语法，通常用于方法和属性，它们只是评估表达式并可能返回评估结果。它们的形式是`member => expression`。它们支持所有类成员，不仅仅是方法，还有字段、属性、索引器、构造函数和终结器。表达式评估的结果值的类型必须与方法的返回类型匹配。

1.  默认构造函数是一个没有任何参数的类的构造函数。另一方面，静态构造函数是用`static`关键字定义的构造函数，没有参数或访问修饰符，并且不能被用户调用。当首次访问类的第一个静态成员时，CLR 会自动调用静态构造函数，或者在首次实例化类时，CLR 会自动调用静态构造函数。静态构造函数用于初始化静态字段。

1.  自动实现属性是编译器将提供私有字段和`get`和`set`访问器的属性。

1.  索引器是一个类成员，允许对象像数组一样被索引。索引器定义了`get`和`set`访问器，就像属性一样。索引器没有显式的名称。它是通过使用`this`关键字创建的。索引器有一个或多个可以是任何类型的参数。

1.  静态类是用`static`关键字声明的类。它只能包含静态成员，不能被实例化。静态类成员是使用类名而不是通过对象访问的。静态类基本上与非静态类相同，具有私有构造函数，并且所有成员都声明为`static`。

1.  可用的参数修饰符是`ref`、`out`和`in`。`ref`修饰符修改参数，使其成为参数的别名，参数必须是一个变量。它允许我们创建按引用调用的机制，而不是隐式的按值调用。`in`修饰符类似，它导致参数按引用传递，但不允许函数修改它。它基本上与`readonly ref`相同。`out`关键字也定义了按引用调用的机制，但它要求函数在返回之前初始化参数。它保证在指定的函数调用期间变量被赋值。

1.  具有可变数量参数的方法必须具有一个参数，该参数是由`params`关键字引导的一维数组。这不必是函数的唯一参数，但必须是最后一个参数。

1.  枚举是一组命名的整数常量。您必须使用`enum`关键字声明枚举。枚举是值类型。当我们想要为特定目的使用有限数量的整数值时，枚举非常有用。

# 第五章

1.  面向对象编程是一种范例，允许我们围绕对象编写程序。它的核心原则是抽象、封装、继承和多态。

1.  封装允许我们将类内部的数据隐藏在外部世界之外。封装很重要，因为它通过为不同组件定义最小的公共接口来减少它们之间的依赖关系。它还增加了代码的可重用性和安全性，并使代码更容易进行单元测试。

1.  继承是一种机制，通过它一个类可以继承另一个类的属性和功能。C#支持单继承，但仅适用于引用类型。

1.  虚方法是在基类中具有实现但可以在派生类中被重写的方法，这有助于更改或扩展实现细节。基类中的实现使用`virtual`关键字定义。派生类中的实现称为重写方法，并使用`override`关键字定义。

1.  您可以通过使用`sealed`关键字声明虚成员来防止派生类中的成员被重写。

1.  抽象类不能被实例化，这意味着我们不能创建抽象类的对象。抽象类使用`abstract`关键字声明。它们可以有抽象成员和非抽象成员。抽象成员不能是私有的，也不能有实现。抽象类必须为它实现的所有接口的所有成员提供实现（如果有的话）。

1.  接口定义了一个由所有实现接口的类型支持的契约。接口是使用`interface`关键字引入的类型，包含一组必须由实现接口的任何类或结构实现的成员。通常，接口只包含成员的声明，而不包含实现。从 C# 8 开始，接口可以包含默认方法。

1.  有两种类型的多态性：编译时多态性，由方法重载表示，以及运行时多态性。运行时多态性有两个方面。一方面，派生类的对象可以无缝地用作基类的对象，放在数组或其他类型的集合、方法参数和其他位置。另一方面，类可以定义虚方法，可以在派生类中重写。在运行时，CLR 将调用与对象的运行时类型相对应的虚成员的实现。当派生类的对象在基类的对象位置上使用时，对象的声明类型和运行时类型不同。

1.  重载方法是具有相同名称但具有不同类型或不同数量参数的方法。返回类型不考虑方法重载。运算符也可以重载。当一个或两个操作数是该类型时，类型可以为重载运算符提供自定义实现。使用`operator`关键字声明运算符。这样的方法必须是`public`和`static`。

1.  SOLID 原则包括：**单一责任原则（S）**，**开闭原则（O）**，**里氏替换原则（L）**，**接口隔离原则（I）**和**依赖注入原则（D）**。

# 第六章

1.  通用是用其他类型参数化的类型。通用提供可重用性，促进类型安全，并且可以提供更好的性能（通过避免值类型的装箱和拆箱）。

1.  用于为通用类型或方法参数化的类型称为类型参数。

1.  通用类的定义方式与非通用类相同，只是在类名后的尖括号内（如`<T>`）指定一个或多个类型参数的列表。通用方法也是如此；类型参数在类名后指定。

1.  类可以派生自通用类型。结构不支持显式继承，但可以实现任意数量的通用接口。

1.  构造类型是从通用类型构造的类型，通过用实际类型替换类型参数。例如，对于`Shape<T>`通用类型，`Shape<int>`是一个构造类型。

1.  协变类型参数是使用`out`关键字声明的类型参数。这样的类型参数允许接口方法具有比指定类型参数更派生的返回类型。

1.  逆变类型参数是使用`in`关键字声明的类型参数。这样的类型参数允许接口方法具有比指定类型参数更不派生的参数。

1.  类型参数约束是为类型参数指定的限制，通知编译器类型参数必须具有什么样的能力。应用约束会限制可以用于从通用类型构造类型的类型。

1.  `new()`类型约束指定类型必须提供公共默认构造函数。

1.  C# 8 中引入的类型参数约束是`notnull`。它只能在可空上下文中使用，否则编译器会生成警告。它指定类型参数必须是非空类型。它可以是非空引用类型（在 C#8 中）或非空值类型。

# 第七章

1.  包含通用集合的 BCL 命名空间是`System.Collections.Generic`。

1.  定义用于通用集合功能的所有其他接口的基本接口是`IEnumerable<T>`。

1.  通用集合优于非通用集合，因为它们提供类型安全性的好处，对值类型有更好的性能（因为它们避免了装箱和拆箱），并且在某些情况下，它们提供非通用集合中不可用的功能。

1.  `List<T>`通用类表示可以通过它们的索引访问的元素集合。`List<T>`与数组非常相似，只是集合的大小不是固定的，而是可变的，可以随着元素的添加或删除而增长或减少。您可以使用`Add()`，`AddRange()`，`Insert()`和`InsertRange()`添加元素。您可以使用`Remove()`，`RemoveAt()`，`RemoveRange()`，`RemoveAll()`和`Clear()`删除元素。

1.  `Stack<T>`通用类表示具有后进先出语义的集合。元素使用`Push()`方法添加到顶部，并使用`Pop()`方法从顶部移除。

1.  `Queue<T>`泛型类表示具有先进先出语义的集合。`Dequeue()`方法从队列的前端移除并返回项目。`Peek()`方法返回队列前端的项目，但不移除它。

1.  `LinkedList<T>`泛型类表示双向链表。它的元素是`LinkedListNode<T>`类型。要向链表添加元素，可以使用`AddFirst()`、`AddLast()`、`AddAfter()`和`AddBefore()`方法。

1.  `Dictionary<TKey, TValue>`泛型类表示键值对的集合，允许基于键进行快速查找。这个字典类的元素是`KeyValuePair<TKey, TValue>`类型。

1.  `HashSet<T>`泛型类表示一组不同的项目，可以以任何顺序存储在一起。哈希集在逻辑上类似于字典，其中值也是键。但是，与`Dictionary<TKey, TValue>`不同，`HashSet<T>`是一个非关联容器。

1.  `BlockingCollection<T>`是一个实现了`IProducerConsumerCollection<T>`接口定义的生产者-消费者模式的类。它实际上是`IProducerConsumerCollection<T>`接口的一个简单包装器，没有内部基础存储，但必须提供一个（实现了`IProducerConsumerCollection<T>`接口的集合）。如果没有提供实现，它默认使用`ConcurrentQueue<T>`类。它适用于需要边界和阻塞的场景。

# 第八章

1.  回调是作为参数传递给另一个函数以立即调用（同步回调）或在以后调用（异步回调）的函数的函数（或更一般地说，任何可执行代码）。委托是一种强类型的回调。

1.  使用`delegate`关键字定义委托。声明看起来像函数签名，但实际上编译器引入了一个可以持有方法引用的类，其签名与委托的签名匹配。事件是使用`event`关键字声明的委托类型的变量。

1.  C#中有两种元组：引用元组，由`System.Tuple`类表示，和值元组，由`System.ValueTuple`结构表示。引用元组最多只能容纳八个元素，而值元组可以容纳任意数量的元素，但至少需要两个。值元组可以具有编译时命名字段，并且具有更简单但更丰富的语法来创建、赋值、解构和比较值。

1.  命名元组是具有字段名称的值元组。这些名称是字段`Item1`、`Item2`等的同义词，但仅在源代码级别可用。

1.  模式匹配是检查值是否具有特定形状以及在匹配成功时从值中提取信息的过程。它可以与`is`和`switch`表达式一起使用。

1.  空值不匹配类型模式，无论变量的类型如何。可以在具有类型模式匹配的`switch`表达式中添加一个用于匹配空值的`switch` case 标签，以专门处理空值。使用`var`模式时，空值始终匹配。因此，在使用`var`模式时，必须添加显式的空值检查，因为值可能为空。

1.  .NET 中用于处理正则表达式的类是`System.Text.RegularExpressions`命名空间中的`Regex`类。默认情况下，它使用 UTF-8 编码进行字符串匹配。

1.  `Match()`方法检查输入字符串中与正则表达式匹配的子字符串，并返回第一个匹配项。`Matches()`方法执行相同的搜索，但返回所有匹配项。

1.  扩展方法是扩展类型功能而不改变其源代码的方法。它们很有用，因为它们允许扩展而不改变实现，创建派生类型或重新编译代码，一般来说。

1.  扩展方法被定义为静态方法，属于静态、非嵌套、非泛型类，它们的第一个参数是它们扩展的类型，前面加上`this`关键字。

# 第九章

1.  栈是编译器分配的相对较小的内存段，用于跟踪运行应用程序所需的内存。栈具有 LIFO 语义，并随着程序执行调用函数或从函数返回而增长和缩小。另一方面，堆是程序可能在运行时用来分配内存的大内存段，在.NET 中由 CLR 管理。通常，值类型的对象分配在栈上，引用类型的对象分配在堆上。

1.  托管堆有三个内存段，称为代。它们被命名为代 0、1 和 2。代 0 包含小的、通常是短寿命的对象，比如局部变量或在函数调用的生命周期内实例化的对象。代 1 包含在代 0 的内存回收中幸存下来的小对象。代 2 包含在代 1 的内存回收中幸存下来的长寿命小对象和大对象（总是分配在这个段上）。

1.  垃圾收集有三个阶段。首先，垃圾收集器构建所有活动对象的图形，以便找出仍在使用的对象和可能被删除的对象。其次，将要压缩的对象的引用被更新。第三，死对象被移除，幸存的对象被压缩。通常，包含大对象的大对象堆不会被压缩，因为移动大块数据会产生性能成本。

1.  终结器是一个类的特殊方法（与类名相同，但前缀为`~`），应该处理类拥有所有权的非托管资源。当对象被回收时，垃圾收集器会调用这个方法。这个过程是非确定性的，这是终结和处理之间的关键区别。后者是一个确定性的过程，发生在显式调用`Dispose()`方法时（对于实现了`IDisposable`接口的类）。

1.  `GC.SuppressFinalize()`方法请求 CRL 不要调用指定对象的终结器。通常在实现`IDisposable`接口时调用这个方法，以便非托管资源不会被处理两次。

1.  `IDisposable`是一个接口，有一个名为`Dispose()`的方法，定义了对象的确定性处理的模式。

1.  `using`语句表示对实现`IDisposable`接口的类型的对象进行确定性处理的简写语法。`using`语句引入了在语句中定义的变量的作用域，并确保在退出作用域之前正确处理对象。实际的处理细节取决于资源是值类型、可空值类型、引用类型还是动态类型。

1.  可以使用平台调用服务（Platform Invocation Services，或 P/Invoke）在 C#中调用来自本机 DLL 的函数。为此，必须定义一个与本机函数签名匹配的`static` `extern`方法（使用等效的托管类型作为其参数）。这个托管函数必须用`DllImport`属性修饰，该属性定义了运行时调用本机函数所需的信息。

1.  不安全代码是 CLR 无法验证其安全性的代码。不安全代码使得可以使用指针类型并支持指针算术。不安全代码不一定是危险的，但您完全有责任确保不会引入指针错误或安全风险。使用不安全代码的典型场景包括调用从本机 DLL 或 COM 服务器导出的需要指针类型作为参数的函数，并优化一些性能关键的算法。

1.  使用`unsafe`关键字定义不安全代码，可以应用于类型（类、结构、接口和委托）、类型成员（方法、字段、属性、事件、索引器、运算符、实例构造函数和静态构造函数）和语句块。

# 第十章

1.  函数式编程的主要特征是不可变性（对象具有不变的状态）和无副作用的函数（函数不修改值或状态在它们的局部范围之外）。函数式编程的优点包括以下几点：首先，代码更容易理解和维护，因为函数不改变状态，只依赖于它们接收的参数。其次，由于同样的原因，代码更容易测试。第三，实现并发更简单和更有效，因为数据是不可变的，函数没有副作用，避免了数据竞争。

1.  高阶函数是一个接受一个或多个函数作为参数、返回一个函数或两者兼有的函数。

1.  C#提供了将函数作为参数传递、从函数返回函数、将函数分配给变量、将函数存储在数据结构中、定义匿名函数、嵌套函数以及测试函数引用是否相等的能力。所有这些特性使 C#成为一种被称为将函数视为一等公民的语言。

1.  Lambda 表达式是一种方便的编写匿名函数的方式。这是一段代码，可以是一个表达式或一个或多个行为像函数一样的语句，并且可以被分配给一个委托。因此，lambda 表达式可以作为参数传递给函数或从函数返回。它们是编写 LINQ 查询、将函数传递给高阶函数（包括应该由`Task.Run()`异步执行的代码）以及创建表达式树的一种方便的方式。Lambda 表达式由 lambda 声明运算符`=>`分隔成两部分。左部是参数列表，右部是一个表达式或一个语句。Lambda 表达式的一个例子是`n => n%2==1`。

1.  Lambda 表达式中变量作用域的规则如下：首先，lambda 表达式中引入的变量在 lambda 之外是不可见的。其次，lambda 不能捕获封闭方法中的`in`、`ref`或`out`参数。第三，lambda 捕获的变量在委托被垃圾回收之前不会被垃圾回收，即使它们本来应该超出作用域。第四，最后，lambda 表达式的返回语句仅与 lambda 所代表的匿名方法有关，并不会导致封闭方法返回。

1.  LINQ 是一组技术，使开发人员能够以一致的方式查询多种数据源。LINQ 标准查询操作符是一组在实现`IEnumerable<T>`或`IQueryable<T>`的序列上操作的扩展方法。LINQ 查询语法基本上是标准查询操作符的语法糖。编译器将用查询语法编写的查询转换为使用标准查询操作符的查询。查询语法比标准查询操作符更简单、更易读，但它们在语义上是等价的。然而，并非所有的标准查询操作符在查询语法中都有等价物。

1.  `Select()`方法将序列的每个元素投影到一个新形式中。这需要一个选择器，即一个转换函数，为集合的每个元素产生一个新值。然而，当集合的元素本身是集合时，通常需要将它们展平为单个集合。这就是`SelectMany()`方法所做的事情。

1.  部分函数应用是将具有*N*个参数和一个参数的函数进行处理，并在将参数固定为函数的一个参数后返回另一个具有*N-1*个参数的函数的过程。这种技术是柯里化的相反，柯里化是将具有*N*个参数的函数进行处理，并将其分解为接受一个参数的*N*个函数的过程。

1.  幺半群是具有单一可结合二元运算和单位元素的代数结构。任何具有这两个元素的 C#类型都是幺半群。

1.  单子是封装在值之上的一些功能的容器。单子有两个操作：第一个将一个值`v`转换为封装它的容器（`v -> C(v)`）。在函数式编程中，这个函数被称为返回。第二个将两个容器展平为一个单一的容器（`C(C(v)) -> C(v)`）。在函数式编程中，这被称为绑定。一个单子的例子是带有 LINQ 查询运算符`SelectMany()`的`IEnumerable<T>`。

# 第十一章

1.  在.NET 中，部署的单位是程序集。程序集是一个文件（可执行文件或动态链接库），其中包含 MSIL 代码以及有关程序集内容的元数据，以及可选的资源。

1.  反射是运行时类型发现和对其进行更改的过程。这意味着我们可以在运行时检索有关类型、其成员和属性的信息。反射使得可以轻松构建可扩展的应用程序；执行私有或具有其他访问级别的类型和成员，否则这些类型和成员将无法访问，这对于测试很有用；在运行时修改现有类型或创建全新类型并使用它们执行代码；以及通常在运行时更改系统行为，通常使用属性。

1.  提供有关类型的元信息的类型是`System.Type`。可以使用`GetType()`方法、`Type.GetType()`静态方法或 C#的`typeof`运算符创建此类型的实例。

1.  共享程序集旨在被多个应用程序使用，通常位于全局程序集缓存（GAC）下，这是程序集的系统存储库。私有程序集旨在被单个应用程序使用，并存储在应用程序目录或其子目录中。共享程序集必须具有强名称并强制版本约束；这些要求对于私有程序集并非必需。

1.  在.NET 中，程序集可以在以下上下文中加载：加载上下文（包含从 GAC、应用程序目录或其子目录加载的程序集）、从其他路径加载的程序集的加载上下文、仅用于反射目的加载的反射上下文，或者根本没有上下文（例如从字节数组加载程序集时）。

1.  早期绑定是在编译时创建程序集依赖关系（引用）的过程。这使得编译器可以完全访问程序集中可用的类型。晚期绑定是在运行时加载程序集的过程，在这种情况下，编译器无法访问程序集的内容。然而，这对于构建可扩展的应用程序非常重要。

1.  动态语言运行时是.NET 平台的一个组件，它定义了一个运行时环境，该环境在 CLR 之上添加了一组服务，以便使动态语言能够在 CLR 上运行，并为静态类型的语言添加动态特性。

1.  `dynamic`类型是静态类型，意味着在编译时将变量分配给`dynamic`类型。但是，它们绕过了静态类型检查。这意味着对象的实际类型只在运行时才知道，编译器无法知道也无法强制执行对该类型对象执行的任何操作。您可以调用任何带有任何参数的方法，编译器不会检查也不会抱怨；但是，如果操作无效，运行时将抛出异常。`dynamic`类型通常用于在 Interop 程序集不可用时简化对 COM 对象的使用。

1.  属性是从`System.Attribute`抽象类派生的类型，提供有关程序集、类型和成员的元信息。这些元信息由编译器、CLR 或使用反射服务读取它们的工具消耗。属性在方括号中指定，例如`[SerializableAttribute]`。属性的命名约定是类型名称总是以`Attribute`一词结尾。C#语言提供了一种语法快捷方式，允许在不带后缀`Attribute`的情况下指定属性的名称，例如`[Serializable]`。

1.  要创建用户定义的属性，必须从`System.Attribute`类型派生，并遵循将类型后缀命名为`Attribute`的命名约定。

# 第十二章

1.  当需要执行一些长时间运行的、CPU 密集型的代码时，手动创建一个专用线程是首选。另一个选项是使用`TaskCreationOptions.LongRunning`创建一个任务，或者在大多数高级场景下，编写一个自定义任务调度程序。

1.  最有效的同步技术是不使用内核对象而是用户模式对象的技术。为了原子地在文件和内存中写入某个值，关键部分是最合适的技术，并且通过 C#语言的`lock`关键字可用。

1.  `Task.Delay` API 是最合适的延迟，因为它在指定的毫秒数后*调度*继续执行的代码，同时让线程在此期间被重用。相反，操作系统的`Sleep` API 在.NET 中暴露为`Thread.Sleep`，它会暂停线程的执行一定的毫秒数，但会使线程无法被重用。

1.  Task 库提供了`WaitHandle.WaitAny`和`WaitHandle.WaitAll`方法，分别在*任何*或*所有*操作完成时立即调用继续执行的代码。可以在返回的任务完成后立即访问任务结果。

1.  `TaskCompletionSource`是一个用于创建和控制`Task`的类。它可以用于将任何异步行为（如 CLR 事件）转换为基于任务的操作。客户端代码可以等待从`TaskCompletionSource`获得的任务，而不是订阅事件。

1.  `Task`库提供了预构建的`Task.CompletedTask`来返回一个空的`Task`，以及`Task.FromResult`、`Task.FromCanceled`和`Task.FromException`方法来创建返回结果、报告取消或抛出异常的任务。

1.  通过在`Task`构造函数中指定`TaskCreationOptions.LongRunning`可以创建长时间运行的任务。

1.  需要使用`Control.Invoke`（或 WPF 中的`Dispatcher.Invoke`）可以通过`Control.InvokeRequired`（或 WPF 中的`Dispatcher.CheckAccess()`）进行验证，并取决于用于访问资源的库是否已经在主线程中调度了结果。如果库已经包含了任务，并且库作者没有调用`Task.ConfigureAwait(false)`，那么可以直接使用结果，因为在`await`关键字之后执行的继续操作是由 UI 框架提供的同步上下文在主线程中调用的。

1.  `ConfigureAwait`方法可用于避免在进程中使用同步上下文时发生的无用调度操作。这通常由 UI 框架和 ASP.NET 应用程序创建。`ConfigureAwait`的主要用户是不需要访问只能从主线程使用的应用程序对象的库开发人员。

1.  首先必须验证异步操作是否在主线程中完成（例如，通过在 Windows Forms 中使用`Control.InvokeRequired`或在 WPF 中使用`Dispatcher.CheckAccess()`）。如果在不同的线程中完成，需要通过`Control.Invoke`或`Dispatcher.Invoke`访问 UI。

# 第十三章

1.  `System.IO`命名空间中与系统对象一起工作的最重要的类是`Path`用于路径，`File`和`FileInfo`用于文件，`Directory`和`DirectoryInfo`用于目录。

1.  连接路径的首选方法是使用`Path.Combine()`静态方法。

1.  可以使用`Path.GetTempPath()`静态方法检索当前用户的临时文件夹的路径。

1.  `File`和`FileInfo`类提供类似的功能，但`File`是一个静态类，`FileInfo`是一个非静态类。同样，`Directory`是一个静态类，`DirectoryInfo`是一个非静态类，尽管它们的功能类似。

1.  要创建目录，可以使用`Create()`和`CreateSubdirectory()`方法。前者在其直接父目录存在时创建目录。后者创建一个子目录，以及必要时一直到根目录的所有其他子目录。要枚举目录，使用`EnumerateDirectories()`方法，它检索一个可枚举的目录集合，在整个集合返回之前可以枚举。有多个重载用于各种搜索选项。

1.  .NET 中流的三个类别是后备存储（表示字节序列的源或目的地的流）、装饰器（从另一个流中读取或写入数据，以某种方式转换它）、适配器（实际上不是流，而是帮助我们以比字节更高级别的方式处理数据源的包装器）。

1.  .NET 中流的基类是`System.IO.Stream`类。这是一个提供从流中读取和写入的方法和属性的抽象类。其中许多是抽象的，并在派生类中实现。

1.  默认情况下，`BinaryReader`和`BinaryWriter`都使用 UTF-8 编码处理字符串。但是，它们都有重载的构造函数，允许使用`System.Text.Encoding`类指定另一个编码。

1.  `System.Xml.Serialization`命名空间中的`XmlSerializer`类可用于序列化和反序列化数据。`XmlSerializer`通过将类型的所有公共属性和字段序列化为 XML 来工作。它使用一些默认设置，例如类型变为节点，属性和字段变为元素。类型、属性或字段的名称成为节点或元素的名称，字段或属性的值成为其文本。

1.  .NET Core 附带的 JSON 序列化器称为`System.Text.Json`。对于.NET Framework 和.NET Standard 项目，它作为 NuGet 包提供，名称相同。您可以使用`JsonSerializer.Serialize()`静态方法来序列化数据，使用`JsonSerializer.Deserialize<T>()`静态方法来反序列化数据。您可以使用特定属性来控制序列化过程。另一方面，如果您想更多地控制写入或读取的内容，可以使用`Utf8JsonWriter`和`Utf8JsonReader`类。

# 第十四章

1.  可能会引发异常的代码必须放在`try`块中。

1.  在`catch`块中，您可能主要想尝试恢复错误。恢复策略可能非常不同，可能从向用户报告友好的错误到使用不同参数重复操作。记录是`catch`块中执行的另一个典型操作。

1.  在`catch`块中指定的异常类型捕获与相同类型或任何派生类型匹配的异常。因此，层次结构中较低的异常必须最后指定。在任何情况下，如果顺序不正确，C#编译器将生成错误。

1.  通过在`catch`语句中指定变量名，您可以访问异常对象。它提供了诸如消息和其他信息的重要信息，在记录错误时非常宝贵。异常对象还可以在创建新的更具体的异常时用作内部异常参数。

1.  在检查异常对象后，您可能会意识到无法对操作进行任何恢复。在这种情况下，更合适的是让异常继续传递给调用者。这可以通过使用无参数的`throw`语句来完成，或者通过在构造函数中传递异常对象来创建并抛出新异常。

1.  `finally`块用于声明一个无论`try`块中指定的代码是失败还是成功都必须执行的代码块。

1.  当您不需要被通知`try`块内部代码的失败时，可以指定一个不带`catch`的`finally`块。`finally`代码将在任何情况下执行。

1.  首次异常代表异常在非常早期阶段的情况，即它们被抛出并在跳转到其处理程序之前。调试器可能会在这些异常处停止，从而更准确地指示潜在的错误。

1.  Visual Studio 调试器允许我们选择我们想要在其中停止的首次异常。这可以通过**异常设置**窗口完成。

1.  在应用程序即将崩溃之前触发`UnhandledException`事件。此事件可用于向用户提供更好的建议，记录错误，甚至自动重新启动应用程序。

# 第十五章

1.  通过启用 C# 8 可空引用类型功能并在代码中装饰引用类型，您将大大减少代码中`NullReferenceException`异常的发生。

1.  访问数组中的最后一项的新简洁语法是`[¹]`，它利用了`System.Index`类型。

1.  在 switch 表达式中，丢弃（`_`）字符等同于`default`，通常用于 switch 语句中。

1.  C# 8 引入了异步处理特性，以在处理资源时提供异步行为。这样，我们可以等待`DisposeAsync`方法的异步关闭操作，避免在`Dispose`中使用`Task.Wait`方法的危险。

1.  空合并赋值`??=`用于在左侧（在我们的示例中为`orders`）不为 null 时避免执行赋值右侧（`GetOrders()`方法）的代码。

1.  为了能够与`async foreach`一起迭代，一个序列必须表现出一种无法使用`IEnumerable`和`IEnumerator`接口及其通用对应项来完成的异步行为。新的`IAsyncEnumerable<T>`和`IAsyncEnumerator<T>`接口专门设计用于支持`async foreach`语句使用的异步行为。

# 第十六章

1.  `global.json`文件用于确定在给定目录树中将使用哪个 SDK。您可以使用`dotnet new globaljson`命令在解决方案根文件夹（或任何父文件夹）中创建此文件，并手动编辑它以匹配`dotnet --info`命令返回的版本之一。

1.  `Path.Combine`方法是在 Windows 和 Linux 上连接路径的最佳方法，两者使用不同的路径分隔符。这种方法也非常方便，可以避免在连接相对路径时出现错误，并且可以避免重复或省略分隔符。

1.  符合.NET Standard 规范的库与支持它的任何框架都是二进制兼容的。当您需要在不同的框架之间共享代码时，请验证它们支持的最新版本的.NET Standard，并创建一个使用它的库。如果您需要使用的 API 不受所需版本的.NET Standard 支持，您可以改变策略，创建单独的库，并将它们打包在一个单独的 NuGet 包中。包清单将需要将每个程序集与库可以运行的特定框架、平台或架构相关联。

1.  由于新的项目文件格式，现在可以从一个项目复制所需的`PackageReference`标签到另一个项目。当解决方案打开时，也可以在 Visual Studio 中执行此操作，并且一旦文件保存，NuGet 包将自动恢复。

1.  在分析了架构影响之后，第一步是将当前解决方案升级到最新版本的.NET Framework，至少是 4.7.2 版本。

1.  为了最小化启动时间，.NET Core 3 提供了两个新的发布选项。第一个是**AOT**编译，它立即生成程序集代码，大大减少了对**JIT**编译器的需求。第二个是启用**Quick JIT**编译器，它在运行时使用，比传统的**JIT**编译器更快，但生成的代码不太优化。

# 第十七章

1.  单元测试是一种软件测试类型，其中测试单个代码单元，以验证它们是否按照设计要求工作。单元测试有助于在开发周期的早期识别和修复错误，因此有助于节省时间和金钱。它有助于开发人员更好地理解代码，并允许他们更容易地进行更改。它通过要求代码更模块化来帮助代码重用。它可以作为项目文档。它还有助于调试，因为当测试失败时，只需要检查和调试最新的更改。

1.  用于单元测试的 Visual Studio 工具包括**Test Explorer**（您可以在其中查看、运行、调试和分析测试）、用于托管代码的 Microsoft 单元测试框架、代码覆盖工具（确定单元测试覆盖的代码量）和 Microsoft Fakes 隔离框架（允许您为类和方法创建替代品）。

1.  Visual Studio 中的**Test Explorer**允许您查看可用的单元测试，按不同级别（项目、类等）分组。您可以从**Test Explorer**运行和调试单元测试，并查看它们的执行结果。

1.  要指定一个类包含单元测试，必须使用`TestClass`属性对其进行修饰。包含单元测试的方法必须使用`TestMethod`属性进行修饰。

1.  用于执行断言的类称为`Assert`，并且位于`Microsoft.VisualStudio.TestTools.UnitTesting`命名空间中。它包含许多静态方法，例如`AreEqual()`、`AreNotEqual()`、`IsTrue()`、`IsFalse()`、`AreSame()`、`AreNotSame()`、`IsNull()`和`IsNotNull()`。

1.  代码覆盖率可以根据**测试资源管理器**或**测试**顶级菜单中的可用单元测试来确定。结果可在**代码覆盖率结果**窗格中查看。

1.  您可以通过提供使用`ClassInitialize`和`ClassCleanup`属性修饰的方法来提供每个类执行一次的固定装置。前者在执行所有测试之前每个类执行一次，后者在执行所有测试之后执行一次。对于在每个单元测试之前和之后执行的固定装置，您必须提供使用`TestInitialize`和`TestCleanup`属性修饰的方法。

1.  数据驱动的单元测试意味着编写从外部源（如文件或数据库）获取测试数据的单元测试。然后，测试方法针对数据源中的每一行执行一次。

1.  `DynamicData`属性允许您指定单元测试类的方法或属性作为数据源。`DataSource`属性允许您指定外部数据源。

1.  Microsoft 单元测试框架支持的数据驱动测试的外部数据源包括 SQL 数据库、CSV 文件、Excel 文档和 XML 文档。
