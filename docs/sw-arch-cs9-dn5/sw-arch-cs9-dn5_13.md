# 第十三章：13

# 在 C# 9 中实现代码重用

代码重用是软件架构中最重要的主题之一。本章旨在讨论如何启用代码重用的方法，以及帮助你了解.NET 5 如何朝着解决管理和维护可重用库的问题的方向发展。

这一章将涵盖以下主题：

+   理解代码重用的原则

+   使用.NET 5 与.NET Standard 的优势

+   使用.NET Standard 创建可重用的库

尽管代码重用是一种非常好的实践，作为软件架构师，你必须意识到这对你正在处理的场景非常重要。许多优秀的软件架构师都同意，由于试图使事物可重用，往往会出现过度设计或者单次使用或者理解不足。

# 技术要求

这一章需要以下内容：

+   你需要免费的 Visual Studio 2019 社区版或更高版本，并安装所有数据库工具。

+   你可以在[`github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5`](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)找到本章的示例代码。

# 理解代码可重用性的原则

你可以用来证明代码重用的唯一理由是-如果在其他场景中已经运行良好，你就不必花费宝贵的时间重新发明轮子。这就是为什么大多数工程领域都基于可重用性原则。想想你家里的开关。

你能想象可以用相同的接口组件制作多少应用程序吗？代码重用的基本原则是相同的。再次强调，这是一个规划一个好的解决方案的问题，这样一部分可以在以后重用。

在软件工程中，代码重用是可以为软件项目带来许多优势的技术之一，例如以下：

+   考虑到重用的代码片段已经在另一个应用程序中经过测试，因此对软件有信心。

+   软件架构师和高级团队的使用更好，因为他们可以专注于解决这种问题。

+   有可能将市场上已经接受的模式引入项目中。

+   由于已经实现的组件，开发速度加快。

+   维护更容易。

这些方面表明，只要可能，应该进行代码重用。作为软件架构师，你有责任确保利用前述优势，并且更重要的是，你要鼓励团队在他们创建的软件中启用重用。

## 什么不是代码重用？

你必须明白的第一件事是，代码重用并不意味着从一个类中复制和粘贴代码到另一个类中。即使这段代码是由另一个团队或项目编写的，这也不表示你正在正确地遵循可重用性原则。让我们想象一种场景，我们将在本书的用例中找到，WWTravelClub 评估。

在这个项目场景中，你可能想评估不同种类的主题，比如**Package**，**DestinationExpert**，**City**，**Comments**等等。无论你参考哪个主题，获取评估平均值的过程都是相同的。因此，你可能想通过复制和粘贴每个评估的代码来*启用*重用。结果（不好的）将会是这样：

![](img/B16756_13_01.png)

图 13.1：糟糕的实现-这里没有代码重用

在前面的图表中，计算评估平均值的过程是分散的，这意味着相同的代码将在不同的类中重复。这将带来很多麻烦，特别是如果相同的方法在其他应用程序中也被使用。例如，如果有关如何计算平均值的新规范，或者如果计算公式中出现错误，你将不得不在所有代码实例中修复它。如果你忘记在所有地方更新它，你可能最终会得到一个不一致的实现。

## 什么是代码重用？

在前一节提到的问题的解决方案非常简单：你必须分析你的代码，并选择其中需要从你的应用程序中解耦的部分。

你应该解耦它们的最大原因与你如何确信这段代码可以在应用程序的其他部分甚至其他应用程序中重用有关：

![](img/B16756_13_02.png)

图 13.2：专注于代码重用的实现

代码的集中化给你作为软件架构师带来了不同的责任。你必须记住，这段代码中的一个错误或不兼容性可能会对应用程序的许多部分或不同的应用程序造成损害。另一方面，一旦你测试并运行了这段代码，你就可以毫无顾虑地传播它的使用。此外，如果你需要改进平均计算过程，你只需要更改单个类中的代码。

值得一提的是，你使用相同的代码越多，这种开发就会变得越便宜。成本需要提到，因为一般来说，可重用软件的构思在开始阶段成本更高。

# 在开发生命周期中的可重用性

如果你明白了可重用性将带你到另一个代码实现层次，你应该一直在考虑如何在你的开发生命周期中使用这种技术。

事实上，创建和维护一个组件库并不容易，因为你将承担的责任和缺乏支持搜索现有组件的好工具。

另一方面，有一些东西你可能要考虑在每次启动新开发时在你的软件开发过程中实现：

+   **使用**已经在用户库中实现的组件，选择软件需求规格中需要它们的功能。

+   **识别**软件需求规格中作为库组件设计候选的功能。

+   **修改**规格，考虑使用可重用组件开发这些功能。

+   **设计**可重用组件，并确保它们具有适当的接口，可以在许多项目中使用。

+   **构建**具有新组件库版本的项目架构。

+   **记录**组件库版本，以便每个开发人员和团队都知道它。

*使用-识别-修改-设计-构建*过程是一种你可能要考虑在每次需要启用软件重用时实施的技术。一旦你有了为这个库编写的组件，你就需要决定提供这些组件的技术。

在软件开发的历史中，有许多方法来做到这一点；其中一些在*第五章*，*将微服务架构应用于企业应用程序*中讨论过，在*微服务和模块概念的演变*部分。

# 使用.NET 5 或.NET 标准进行代码重用

.NET 自第一个版本以来已经发展了很多。这种发展不仅与命令数量和性能问题有关，还与支持的平台有关。正如我们在*第一章*中讨论的*理解软件架构的重要性*，即使在运行 Linux、Android、macOS 或 iOS 的数十亿设备上，您也可以运行 C# .NET。因此，.NET Standard 是首次与.NET Core 1.0 一起宣布的，但.NET Standard 在.NET Standard 2.0 时变得特别重要，当时.NET Framework 4.6、.NET Core 和 Xamarin 与之兼容。

关键点是，.NET Standard 不仅仅是一种 Visual Studio 项目。更重要的是，它是一个对所有.NET 实现都可用的正式规范。正如您在下表中所看到的，它涵盖了从.NET Framework 到 Unity 的所有内容：

| .NET Standard | 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 | 2.0 | 2.1 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| .NET Core 和.NET 5 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 2.0 | 3.0 |
| .NET Framework | 4.5 | 4.5 | 4.5.1 | 4.6 | 4.6.1 | 4.6.1 | 4.6.1 | 4.6.1 | N/A |

您可以在[`docs.microsoft.com/en-us/dotnet/standard/net-standard`](https://docs.microsoft.com/en-us/dotnet/standard/net-standard)找到完整的.NET Standard 概述。

前面的表格表明，如果您构建一个符合这一标准的类库，您将能够在所呈现的任何平台上重用它。想象一下，如果您计划在所有项目中都这样做，您的开发过程会变得多么快速。

显然，一些组件不包括在.NET Standard 中，但它的发展是持续的。值得一提的是，微软的官方文档指出*版本越高，可用的 API 就越多*。

拥有一个适用于所有平台的单一框架的倡议使我们走向了.NET 5。微软指出，从现在开始，net5.0 或更高版本将在任何地方运行。作为软件架构师，您可能会问的下一个问题是：.NET Standard 会发生什么？

对这个问题的答案在 dotnet 博客上由 Immo Landwerth 做了很好的解释：[`devblogs.microsoft.com/dotnet/the-future-of-net-standard/`](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)。基本答案是，.NET 5.0（以及未来的版本）需要被视为未来共享代码的基础。

## 创建一个.NET Standard 库

创建一个与.NET Standard 兼容的类库非常简单。基本上，您需要在创建库时选择以下项目：

![](img/B16756_13_03.png)

图 13.3：创建一个.NET Standard 库

一旦您完成了这一部分，您会注意到一个普通类库和您创建的类库之间唯一的区别是项目文件中定义的目标框架：

```cs
<Project Sdk="Microsoft.NET.Sdk">
<PropertyGroup>
<TargetFramework>netstandard2.0</TargetFramework>
</PropertyGroup>
</Project> 
```

一旦您的项目加载完成，您就可以开始编写您打算重用的类。使用这种方法构建可重用类的优势是，您将能够在我们之前检查过的所有项目类型中重用编写的代码。另一方面，您会发现在这种类型的项目中，一些在.NET Framework 中可用的 API 在这里是不存在的。

# C#如何处理代码重用？

C#帮助我们处理代码重用的方法有很多。正如我们在前一节中所做的那样，构建库的能力是其中之一。最重要的是，这种语言是面向对象的。此外，值得一提的是泛型为 C#语言带来的便利。本节将讨论我们提到的最后两个。

## 面向对象分析

面向对象的分析方法使我们能够以不同的方式重用代码，从继承的便利性到多态的可变性。完全采用面向对象编程将让您实现抽象和封装。

以下图表显示了使用面向对象方法使重用变得更容易。正如你所看到的，有不同的方法来计算评估的等级，考虑到你可以是系统的基本用户或高级用户：

![](img/B16756_13_04.png)

图 13.4：面向对象的案例分析

在这个设计中，代码重用有两个方面需要分析。第一个是在每个子类中不需要声明属性，因为继承已经为你做了这件事。

第二个是使用多态的机会，使相同方法产生不同的行为。

```cs
public class PrimeUsersEvaluation : Evaluation
{
    /// <summary>
    /// The business rule implemented here indicates that grades that 
    /// came from prime users have 20% of increase
    /// </summary>
    /// <returns>the final grade from a prime user</returns>
    public override double CalculateGrade()
    {
         return Grade * 1.2;
    }
} 
```

在前述代码中，你可以看到多态原则的使用，高级用户的评估计算会增加 20%。现在，看看通过相同类继承的不同对象调用是多么容易。由于集合内容实现了相同的接口`IContentEvaluated`，它也可以有基本用户和高级用户。

```cs
public class EvaluationService
{
    public IContentEvaluated content { get; set; }
    /// <summary>
    /// No matter the Evaluation, the calculation will always get     
    /// values from the method CalculateGrade
    /// </summary>
    /// <returns>The average of the grade from Evaluations</returns>
    public double CalculateEvaluationAverage()
    {
            return content.Evaluations
                .Select(x => x.CalculateGrade())
                .Average();
    }
} 
```

面向对象的采用在使用 C#时可以被视为强制性的。然而，更具体的用法需要学习和实践。作为软件架构师，你应该始终鼓励你的团队学习面向对象的分析。他们拥有更多的抽象能力，代码重用就会变得更容易。

## 泛型

泛型在 C# 2.0 版本中引入，被认为是一种增加代码重用的方法。它还能最大化类型安全性和性能。

泛型的基本原则是，你可以在接口、类、方法、属性、事件，甚至委托中定义一个占位符，当使用前述实体之一时，它将在以后被特定类型替换。你可以使用这个特性的机会是不可思议的，因为你可以使用相同的代码来运行类型的不同版本，通用地。

以下代码是对前一节中介绍的`EvaluationService`的修改。这里的想法是使服务的泛化，让我们有机会自定义评估的目标：

```cs
public class EvaluationService<T> where T: IContentEvaluated 
```

这个声明表明，任何实现了`IContentEvaluaded`接口的类都可以用于这个服务。此外，服务将负责创建评估内容。

以下代码实现了自从服务构建以来创建的评估内容。这段代码使用了`System.Reflection`和类的泛型定义：

```cs
public EvaluationService()
{
    var name = GetTypeOfEvaluation();
    content = (T)Assembly.GetExecutingAssembly().CreateInstance(name);
} 
```

值得一提的是，这段代码将会工作，因为所有的类都在同一个程序集中。此外，在使用泛型时，反射并不是必需的。这个修改的结果可以在服务的实例创建中检查到：

```cs
var service = new EvaluationService<CityEvaluation>(); 
```

好消息是，现在你有了一个通用的服务，它将自动用你需要的内容的评估实例化列表对象。值得一提的是，泛型显然需要更多的时间用于第一个项目的构建。然而，一旦设计完成，你将拥有良好、快速和易于维护的代码。这就是我们所说的重用！

# 如果代码不能被重用怎么办？

事实上，任何代码都可以重用。关键在于你打算重用的代码是否写得好，并且遵循了良好的重用模式。有几个原因可以说明为什么代码不应该被考虑为可重用：

+   **代码在重用之前没有经过测试**：在重用代码之前，保证它能够正常工作是一个很好的方法。

+   **代码是重复的**：如果你有重复的代码，你需要找到它被使用的每个地方，这样你就只有一个版本的代码被重用。

+   **代码过于复杂，难以理解**：在许多地方重用的代码需要简单编写，以便易于理解。

+   **代码耦合度太高**：这是一个关于组合与继承的讨论，当构建独立的类库时。类（带接口）通常比可以被继承的基类更容易重用。

在任何这些情况下，考虑到重构策略可能是一个很好的方法。当你重构代码时，你正在以更好的方式编写它，同时尊重这段代码将处理的输入和输出数据。这将使得在改变代码时更全面、成本更低。Martin Fowler 指出了一些我们应该考虑重构的原因：

+   **它改善软件设计**：你的团队变得越来越专业，设计就会变得越来越好。更好的软件设计不仅会带来更快的编码，还会为我们提供在更短的时间内处理更多任务的机会。

+   **它使软件更易理解**：无论是初级开发人员还是高级开发人员，好的软件都需要被团队中的每个开发人员理解。

+   **它帮助我们找到错误**：在重构时，你会发现可能没有被良好编程的业务规则，所以你会发现错误。

+   **它让我们更快地编程**：重构的结果将是能够在未来实现更快开发的代码。

重构的过程取决于我们将要遵循的一些步骤，以确保良好的结果并在旅程中尽量减少错误：

+   **确保你有一套测试来保证正确处理**：你拥有的测试集将消除清理代码的恐惧。

+   **消除重复**：重构是消除代码重复的好机会。

+   **最小化复杂性**：考虑到你的目标是使代码更易理解，遵循编程的最佳实践，如*第十七章*中提到的*C# 9 编码最佳实践*，将减少代码的复杂性。

+   **清理设计**：重构是重新组织你的库设计的好时机。不要忘记也要更新它们。这是消除错误和安全问题的好方法。

作为软件架构师，你会收到团队的许多重构需求。持续做这件事的动力必须是持续的。但你必须提醒你的团队，没有遵循先前步骤的重构可能是有风险的。因此，你有责任以一种既能够实现快速编程又能够减少影响的方式来实现它，从而提供真正的商业价值。

# 我有我的库。我该如何推广它们？

考虑到你已经做出了所有必要的努力来确保你有好的库，这些库必须在你的许多项目中被重复使用，当启用可重用性时，你会发现另一个困难的情况出现了：让程序员知道你已经准备好可以重用的库并不简单。

有一些简单的方法来记录一个库。正如我们在谈论开发生命周期时提到的，文档是帮助开发人员注意到他们拥有的库的好方法。这里有两个关于记录可重用代码的例子我们想提一下。

## 使用 DocFX 记录.NET 库

这个工具是一个很好的选择，可以使用代码中的注释来记录库。通过简单地添加 NuGet 包`docfx.console`，该工具允许你创建一个任务，一旦你的库构建完成就会运行：

![](img/B16756_13_05.png)

图 13.5：docfx.console NuGet 库

这个编译的输出是一个时尚的静态网站，包含了你的代码文档：

![](img/B16756_13_06.png)

图 13.6：DocFx 结果

这个网站很有用，因为你可以把文档分发给你的团队，这样他们就可以搜索你拥有的库。你可以检查输出的自定义，并在[`dotnet.github.io/docfx/`](https://dotnet.github.io/docfx/)找到更多信息。

## 使用 Swagger 记录 Web API

毫无疑问，Web API 是促进代码重用的技术之一。因此，做好它的文档工作，更重要的是，遵守标准，是一个良好的做法，并表明你对这种方法是跟上了时代的。

OpenAPI 规范被认为是描述现代 API 的标准。在 ASP.NET Core Web API 中，最常用的用于对其进行文档化的工具之一是`Swashbuckle.AspNetCore`。

实现`Swashbuckle.AspNetCore`库的好处在于，你可以为你的 Web API 设置 Swagger UI 查看器，这是一种良好的图形方式来分发 API。

我们将在下一章学习如何在 ASP.NET Core Web API 中使用这个库。在那之前，重要的是要理解，这份文档不仅会帮助你的团队，还会帮助任何可能使用你正在开发的 API 的开发人员。

# 用例 - 将代码重用作为快速交付良好和安全软件的途径

WWTravelClub 评估内容的最终设计可以如下所示。这种方法包括了本章讨论的许多主题。首先，所有的代码都放在一个.NET 标准类库中。这意味着你可以将这些代码添加到不同类型的解决方案中，比如.NET Core web 应用程序和用于 Android 和 iOS 平台的 Xamarin 应用程序：

![](img/B16756_13_07.png)

图 13.7：WWTravelClub 重用方法

这种设计利用了面向对象的原则，比如继承，因此你不需要在多个类中重复编写属性和方法；以及多态性，这样你可以改变代码的行为而不改变方法的名称。

最后，这个设计通过引入泛型来抽象内容的概念，泛型可以简化对类似类的对象的处理，比如我们在 WWTravelClub 中用来评估城市、评论、目的地专家和旅行套餐的类。

一个鼓励代码重用的团队和一个不鼓励的团队之间的最大区别是向最终用户交付良好软件的速度。当然，开始这种方法并不容易，但请放心，在一段时间后你将会取得良好的结果。

# 总结

本章旨在帮助你了解代码重用的优势。它还让你了解了什么才是正确的代码重用。本章还介绍了代码重用和重构的方法。

考虑到没有流程的技术是无法带你走向任何地方的，因此提出了一个流程，帮助实现代码重用。这个流程涉及到使用已经完成的组件库中的组件；识别软件需求规范中可以设计为库组件的特性；修改规范以考虑这些特性；设计可重用组件；并使用新的组件库版本构建项目架构。

最后，本章介绍了.NET 标准库作为在不同的 C#平台上重用代码的一种方法，表明.NET 5 和新版本应该用于在不同平台上重用代码。本章还强调了在重用代码时面向对象编程的原则，并介绍了泛型作为简化具有相同特征的对象处理的一种复杂实现。在下一章中，我们将学习如何在.NET Core 中应用面向服务的架构（SOA）。

值得一提的是，SOA 被认为是在复杂环境中实现代码重用的一种方式。

# 问题

1.  复制和粘贴可以被视为代码重用吗？这种方法的影响是什么？

1.  如何在不复制和粘贴代码的情况下实现代码重用？

1.  有没有一个流程可以帮助实现代码重用？

1.  .NET Standard 和.NET Core 之间有什么区别？

1.  创建.NET Standard 库的优势是什么？

1.  面向对象分析如何帮助代码重用？

1.  泛型如何帮助代码重用？

1.  .NET Standard 将被.NET 5 取代吗？

1.  与重构相关的挑战是什么？

# 进一步阅读

这些是一些书籍和网站，您将在其中找到有关本章的更多信息：

+   《干净的代码：敏捷软件工艺的手册》（Martin，Robert C. Pearson Education，2012 年）。

+   《干净的架构：软件结构和设计的工匠指南》（Martin，Robert C. Pearson Education，2018 年）。

+   《设计模式：可重用面向对象软件的元素》（Erica Gamma 等人著，Addison-Wesley，1994 年）。

+   《设计原则和设计模式》（Robert C. Martin，2000 年）。

+   《重构》（Martin Fowler，2018 年）。

+   [`devblogs.microsoft.com/dotnet/introducing-net-standard/`](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)

+   [`www.packtpub.com/application-development/net-standard-20-cookbook`](https://www.packtpub.com/application-development/net-standard-20-cookbook)

+   [`github.com/dotnet/standard/blob/master/docs/versions.md`](https://github.com/dotnet/standard/blob/master/docs/versions.md)

+   [`docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/`](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)

+   [`devblogs.microsoft.com/dotnet/the-future-of-net-standard/`](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)

+   [`dotnet.github.io/docfx/`](https://dotnet.github.io/docfx/)

+   [`github.com/domaindrivendev/Swashbuckle.AspNetCore`](https://github.com/domaindrivendev/Swashbuckle.AspNetCore)

+   [`docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger`](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger)
