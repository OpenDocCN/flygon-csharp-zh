# 第二十三章：答案

# 第一章

1.  软件架构师需要了解任何可以帮助他们更快解决问题并确保他们能够创建更高质量软件的技术。

1.  Azure 提供并不断改进许多组件，软件架构师可以在解决方案中实现这些组件。

1.  最佳的软件开发过程模型取决于您所拥有的项目、团队和预算的类型。作为软件架构师，您需要考虑所有这些变量，并了解不同的过程模型，以便满足环境的需求。

1.  软件架构师要注意任何可能影响性能、安全性、可用性等的用户或系统需求。

1.  所有这些，但非功能性需求需要更多关注。

1.  设计思维和设计冲刺是帮助软件架构师准确定义用户需求的工具。

1.  用户故事在我们想要定义功能需求时很好。它们可以快速编写，并通常不仅提供所需的功能，还提供解决方案的验收标准。

1.  缓存、异步编程和正确的对象分配。

1.  为了检查实现是否正确，软件架构师将其与已经设计和验证的模型和原型进行比较。

# 第二章

1.  纵向和横向。

1.  是的，您可以自动部署到已定义的 Web 应用程序，或者直接使用 Visual Studio 创建一个新的 Web 应用程序。

1.  通过最小化空闲时间来利用可用的硬件资源。

1.  代码行为是确定性的，因此很容易调试。执行流程模仿了顺序代码的流程，这意味着更容易设计和理解。

1.  因为正确的顺序可以最大程度地减少填写表单所需的手势数量。

1.  因为它允许以独立于操作系统的方式操作路径文件。

1.  它可以与多个.NET Core 版本一起使用，也可以与经典.NET 框架的多个版本一起使用。

1.  控制台、.NET Core 和.NET 标准类库；ASP.NET Core、测试和微服务。

# 第三章

1.  不，它适用于多个平台。

1.  自动、手动和负载测试计划。

1.  是的，它们可以 - 通过 Azure DevOps feeds。

1.  管理需求并组织整个开发过程。

1.  史诗工作项代表由多个功能组成的高级系统子部分。

1.  父子关系。

# 第四章

1.  当您从本地解决方案迁移或者拥有基础设施团队时，IaaS 是一个不错的选择。

1.  PaaS 是在团队专注于软件开发的系统中快速安全地交付软件的最佳选择。

1.  如果您打算提供的解决方案是由知名厂商提供的，比如 SaaS，您应该考虑使用它。

1.  在构建新系统时，无服务器绝对是一个选择，如果您没有专门从事基础设施的人员，并且不想担心可伸缩性。

1.  Azure SQL Server 数据库可以在几分钟内启动，之后您将拥有 Microsoft SQL Server 的所有功能。

1.  Azure 提供了一组名为 Azure 认知服务的服务。这些服务提供了视觉、语音、语言、搜索和知识的解决方案。

1.  在混合场景中，您可以灵活决定系统的每个部分的最佳解决方案，同时尊重解决方案未来的发展路径。

# 第五章

1.  代码的模块化和部署的模块化。

1.  不。其他重要优势包括很好地处理开发团队和整个 CI/CD 周期，以及轻松有效地混合异构技术的可能性。

1.  帮助我们实现弹性通信的库。

1.  一旦在开发机器上安装了 Docker，您就可以开发、调试和部署 Docker 化的.NET Core 应用程序。您还可以将 Docker 映像添加到使用 Visual Studio 处理的 Service Fabric 应用程序中。

1.  编排器是管理微服务和微服务集群中的节点的软件。Azure 支持两个相关的编排器：Azure Kubernetes 服务和 Azure Service Fabric。

1.  因为它解耦了通信中发生的参与者。

1.  消息代理。它负责服务与服务之间的通信和事件。

1.  同一条消息可能会被接收多次，因为发送方在超时之前没有收到接收确认，因此发送方会再次发送消息。因此，接收一条消息一次或多次的效果必须相同。

# 第六章

1.  可靠服务是本机的 Azure Service Fabric 服务。但是，Azure Service Fabric 也可以托管其他类型的服务，例如 Docker 化服务。

1.  无状态和有状态。无状态服务用于实现不需要存储任何状态的微服务，而有状态服务用于实现需要存储状态信息的微服务。

1.  这是`HostBuilder`方法，您可以在其中放置您的依赖注入容器。

1.  暴露给集群外部流量并通过集群的 URI 访问的对象。

1.  为了在有状态服务中实现*分片*的写入/修改并行性。

1.  使用只读端点。通过提供`ServiceReplicaListener`的`IEnumerable`可以添加自定义通信协议。

# 第七章

1.  由于服务需要将通信分派到 Pod，因为 Pod 没有稳定的 IP 地址。

1.  服务了解 TCP/IP 等低级协议，但大多数 Web 应用程序依赖于更复杂的 HTTP 协议。这就是为什么 Kubernetes 提供了称为`Ingresses`的更高级实体，这些实体建立在服务之上。

1.  Helm 图表是组织模板和安装包含多个`.yaml`文件的复杂 Kubernetes 应用程序的一种方法。

1.  是的，使用`---`分隔符。

1.  使用`livenessProbe`。

1.  因为 Pod 没有稳定的位置，无法依赖于它们当前运行的节点的存储。

1.  `StatefulSet`通信可以被分片以实现写/更新并行性。

# 第八章

1.  借助依赖于数据库的提供程序。

1.  通过将它们称为`Id`或使用`Key`属性进行装饰。这也可以通过流畅的配置方法完成。

1.  使用`MaxLength`和`MinLength`属性。

1.  类似于以下内容：`builder.Entity<Package>().HasIndex(m => m.Name);`。

1.  使用类似于以下内容的东西：

```cs
builder.Entity<Destination>()
.HasMany(m => m.Packages)
.WithOne(m => m.MyDestination)
.HasForeignKey(m => m.DestinationId)
.OnDelete(DeleteBehavior.Cascade); 
```

1.  Add-Migration 和 Update-Database。

1.  不，但您可以使用`Include` LINQ 子句或在配置`DbContext`时使用`UseLazyLoadingProxies`选项强制包含它们。

1.  是的，谢谢`Select` LINQ 子句。

1.  通过调用`context.Database.Migrate()`。

# 第九章

1.  不，它是一个可以用作缓存或其他内存存储需求的内存字典。

1.  是的，它们是。本章的大部分部分都致力于解释为什么。

1.  写操作。

1.  NoSQL 数据库的主要弱点是它们的一致性和事务性，而它们的主要优势是性能，特别是在处理分布式写入时。

1.  最终一致性前缀，会话，有界不一致性，强一致性。

1.  不，它们在分布式环境中效率不高。基于 GUID 的字符串性能更好，因为它们的唯一性是自动的，不需要同步操作。

1.  `OwnsMany`和`OwnsOne`。

1.  是的，可以。一旦使用`SelectMany`，索引就可以用于搜索嵌套对象。

# 第十章

1.  Azure Functions 是 Azure 的 PaaS 组件，允许您实现 FaaS 解决方案。

1.  您可以使用不同的语言编写 Azure Functions，例如 C＃，F＃，PHP，Python 和 Node。您还可以使用 Azure 门户和 Visual Studio Code 创建函数。

1.  Azure Functions 有两种计划选项。第一个计划是按照您使用的数量收费的消耗计划。第二个计划是应用服务计划，您可以在该计划中与函数的需求共享应用服务资源。

1.  在 Visual Studio 中部署函数的过程与 Web 应用程序部署相同。

1.  我们可以通过许多方式触发 Azure 函数，例如使用 Blob 存储，Cosmos DB，事件网格，事件中心，HTTP，Microsoft Graph 事件，队列存储，服务总线，定时器和 Webhooks。

1.  Azure Functions v1 需要.NET Framework 引擎，而 v2 需要.NET Core 2.2，v3 需要.NET Core 3.1 和.NET 5。

1.  每个 Azure 函数的执行都可以通过应用程序洞察监控。在这里，您可以检查处理所需的时间，资源使用情况，错误以及每个函数调用中发生的异常。

# 第十一章

1.  设计模式是解决软件开发中常见问题的好方法。

1.  设计模式为我们在开发中面临的典型问题提供了代码实现，设计原则则帮助您在实现软件架构时选择最佳选项。

1.  生成复杂对象而无需在您将要使用它们的类中定义它们的生成器模式将有所帮助。

1.  工厂模式在您有多种来自相同抽象的对象并且在编码开始时不知道哪个对象需要被创建时非常有用。

1.  单例模式在软件执行期间需要只有一个实例的类时非常有用。

1.  代理模式用于在需要提供控制对另一个对象的访问时。

1.  命令模式用于执行将影响对象行为的*命令*。

1.  当您需要向一组其他对象提供有关对象的信息时，发布者/订阅者模式非常有用。

1.  DI 模式在实现控制反转原则时非常有用。

# 第十二章

1.  专家使用的语言和单词含义的变化。

1.  域映射。

1.  不；整个通信都通过实体即聚合根进行。

1.  因为聚合代表部分-整体层次结构。

1.  只有一个，因为存储库是以聚合为中心的。

1.  应用层操作存储库接口。存储库实现被注册到依赖注入引擎中。

1.  在单个事务中协调对多个聚合的操作。

1.  更新和查询的规范通常非常不同，特别是在简单的 CRUD 系统中。其最强形式的原因主要是优化查询响应时间。

1.  依赖注入。

1.  不；必须进行严格的影响分析，以便我们可以采用它。

# 第十三章

1.  不，因为在这种方法中会有大量重复的代码，这将在维护时造成困难。

1.  代码重用的最佳方法是创建库。

1.  是的。您可以在以前创建的库中找到已经创建的组件，然后通过创建可以在将来重用的新组件来增加这些库。

1.  .NET 标准是一种规范，允许.NET 的不同框架之间的兼容性，从.NET Framework 到 Unity。 .NET Core 是一种.NET 实现，是开源的。

1.  通过创建一个.NET 标准库，您将能够在不同的.NET 实现中使用它，例如.NET Core，.NET Framework 和 Xamarin。

1.  您可以使用面向对象的原则（继承，封装，抽象和多态）实现代码重用。

1.  泛型是一种复杂的实现，通过定义一个在编译时将被具体类型替换的占位符，简化了具有相同特征的对象的处理方式。

1.  这个问题的答案由 Immo Landwerth 在 dotnet 博客上得到了很好的解释：[`devblogs.microsoft.com/dotnet/the-future-of-net-standard/`](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)。基本答案是，.NET 5.0（以及未来的版本）需要被认为是未来共享代码的基础。

1.  当您重构代码时，您正在以更好的方式编写它，尊重该代码将处理的数据的输入和输出的合同。

# 第十四章

1.  不，因为这将违反服务对请求的反应必须依赖于请求本身的原则，而不是依赖于先前与客户端交换的其他消息/请求。

1.  不，因为这将违反互操作性约束。

1.  可以。`POST`的主要操作必须是创建，但删除可以作为副作用执行。

1.  三，即头部和正文的 Base64 编码加上签名。

1.  从请求体中。

1.  使用`ApiController`属性。

1.  `ProducesResponseType`属性。

1.  使用`Route`和`Http<verb>`属性。

1.  类似于`services.AddHttpClient<MyProxy>()`。

# 第十五章

1.  开发人员错误页面和开发人员数据库错误页面，生产错误页面，主机，HTTPS 重定向，路由，身份验证和授权以及端点调用者。

1.  不。

1.  错误。可以在同一个标签上调用多个标签助手。

1.  `ModelState.IsValid`。

1.  `@RenderBody()`.

1.  我们可以使用`@RenderSection("Scripts", required: false)`。

1.  我们可以使用`return View("viewname", ViewModel)`。

1.  三。

1.  不；还有`ViewState`字典。

# 第十六章

1.  这是一个 W3C 标准：在符合 W3C 的浏览器中运行的虚拟机的组装。

1.  一个 Web UI，其中动态 HTML 是在浏览器本身中创建的。

1.  根据当前浏览器 URL 选择页面。

1.  一个带有路由的 Blazor 组件。因此，Blazor `router`可以选择它。

1.  定义 Blazor 组件类的.NET 命名空间。

1.  一个本地服务，负责存储和处理所有与表单相关的信息，比如验证错误和 HTML 输入的更改。

1.  `OnInitialized`或`OnInitializedAsync`。

1.  回调和服务。

1.  Blazor 与 JavaScript 交互的方式。

1.  获取对组件或 HTML 元素实例的引用。

# 第十七章

1.  可维护性使您有机会快速交付您设计的软件。它还允许您轻松修复错误。

1.  圈复杂度是一种检测方法具有的节点数的度量标准。数字越高，影响越糟。

1.  版本控制系统将保证您的源代码的完整性，使您有机会分析您所做的每次修改的历史。

1.  垃圾收集器是.NET Core/.NET Framework 系统，它监视您的应用程序并检测您不再使用的对象。它处理这些对象以释放内存。

1.  `IDisposable`接口首先很重要，因为它是一种确定性清理的良好模式。其次，它在需要由程序员处理的实例化对象的类中是必需的，因为垃圾收集器无法处理它们。

1.  .NET Core 在其某些库中封装了一些设计模式，以一种可以保证更安全的代码的方式，比如依赖注入和构建器。

# 第十八章

1.  因为大多数测试必须在任何软件更改后重复进行。

1.  因为在单元测试和其关联的应用程序代码中发生完全相同错误的概率非常低。

1.  当测试方法定义多个测试时使用`[Theory]`，而当测试方法只定义一个测试时使用`[Fact]`。

1.  `Assert`。

1.  `Setup`，`Returns`和`ReturnsAsync`。

1.  是的；使用`ReturnAsync`。

# 第十九章

1.  良好编写的代码是任何精通该编程语言的人都可以处理、修改和发展的代码。

1.  Roslyn 是在 Visual Studio 内部用于代码分析的.NET 编译器。

1.  代码分析是一种考虑代码编写方式的实践，在编译之前检测不良实践。

1.  代码分析可以发现即使是表面上良好的软件中出现的问题，例如内存泄漏和不良的编程实践。

1.  Roslyn 可以在设计时检查您的代码风格、质量、可维护性、设计和其他问题。这是在设计时完成的，因此您可以在编译代码之前检查错误。

1.  Visual Studio 扩展是在 Visual Studio 内部运行的工具。这些工具可以在某些情况下帮助您，其中 Visual Studio IDE 没有适合您使用的功能。

1.  微软代码分析，SonarLint 和 Code Cracker。

# 第二十章

1.  DevOps 是持续向最终用户交付价值的方法。为了成功地做到这一点，必须进行持续集成、持续交付和持续反馈。

1.  持续集成允许您在每次提交更改时检查您正在交付的软件的质量。您可以通过在 Azure DevOps 中启用此功能来实现这一点。

1.  持续交付允许您在确保所有质量检查都通过了您设计的测试之后部署解决方案。Azure DevOps 通过提供相关工具来帮助您实现这一目标。

1.  持续反馈是在 DevOps 生命周期中采用工具，使得在性能、可用性和应用程序的其他方面快速获得反馈成为可能。

1.  构建管道将让您运行用于构建和测试应用程序的任务，而发布管道将为您提供定义应用程序在每种情况下如何部署的机会。

1.  应用程序洞察是一个有用的工具，用于监视您部署的系统的健康状况，这使其成为一个出色的持续反馈工具。

1.  测试和反馈是一种工具，允许利益相关者分析您正在开发的软件，并与 Azure DevOps 建立连接，以打开任务甚至错误。

1.  最大化软件为目标组织提供的价值。

1.  不；它需要获得最大化软件增加值所需的所有能力。

1.  因为当新用户订阅时，其租户必须自动创建，并且因为新软件更新必须分发到所有客户的基础设施。

1.  是的；Terraform 就是一个例子。

1.  Azure 管道。

1.  您的业务依赖于 SaaS 供应商，因此其可靠性至关重要。

1.  不；可伸缩性和容错性以及自动故障恢复同样重要。

# 第二十一章

1.  这是一种方法，确保代码存储库中的每个提交都经过构建和测试。这是通过频繁地将代码合并到主体代码中来完成的。

1.  是的，您可以单独拥有 DevOps，然后稍后启用持续集成。您也可以在没有持续交付的情况下启用持续集成。您的团队和流程需要准备好并密切关注这一点。

1.  您可能会误解 CI 为持续交付过程。在这种情况下，您可能会对生产环境造成损害。在最坏的情况下，您可能会有一个尚未准备好但已部署的功能，您可能会在客户的糟糕时刻停止，或者甚至由于不正确的修复而遭受糟糕的副作用。

1.  多阶段环境在启用 CI-CD 时保护生产环境免受糟糕的发布。

1.  自动化测试可以预测预览场景中的错误和不良行为。

1.  拉取请求允许在提交到主分支之前进行代码审查。

1.  不；拉取请求可以帮助您在任何开发方法中，其中 Git 是您的源代码控制。

# 第二十二章

1.  不；这取决于用户界面的复杂性以及其变化频率。

1.  ASP.NET Core 管道不会被执行，而是直接将输入传递给控制器。

1.  使用`Microsoft.AspNetCore.Mvc.Testing` NuGet 包。

1.  使用`AngleSharp` NuGet 包。
