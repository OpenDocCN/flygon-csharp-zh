# 前言

我仍然记得我生命中的那一刻，当我害怕告诉我的父母我要学习游戏开发。在那个时候和我所在的地方，大多数父母认为那是一个孩子的愿望，是一个没有未来的职业，但我足够固执，不在乎并追随我的梦想。如今，游戏开发是最大的产业之一，产生的收入甚至超过了电影产业。

当然，追逐我的梦想比我想象的更困难。追求这个特定梦想的人迟早都必须面对这样一个事实，即开发游戏是一项需要在不同领域具有深入知识的艰巨任务。不幸的是，大多数人因为这种困难程度而放弃，但我坚信通过适当的指导和工具，你可以使自己的职业道路更容易跟随。在我的情况下，帮助我降低学习曲线的是学习使用 Unity。

欢迎来到这本关于 Unity 2020 的书。在这里，你将学习如何使用最新的 Unity 功能以最简单的方式创建你的第一个视频游戏。Unity 是一个提供强大但易于使用功能的工具，用来解决游戏开发中最常见的问题，如渲染、动画、物理、声音、特效等。我们将使用所有这些功能来创建一个简单但完整的游戏，学习处理 Unity 所需的所有细微差别。

在本书结束时，你将能够以一种方式使用 Unity，使你能够开始深入研究你感兴趣的游戏开发领域，或者简单地使你能够创建业余游戏，只是为了乐趣。Unity 是一个多功能的工具，既可以用于专业项目，也可以用于业余项目，而且每天都有越来越多的人在使用它。

值得一提的是，Unity 不仅可以用来创建游戏，还可以用来创建任何类型的交互式应用程序，从简单的移动应用到复杂的培训或教育应用（称为严肃游戏），使用最新的技术，如增强现实和虚拟现实。因此，即使我们在这里创建游戏，你正在开始一条可能通向许多可能专业化的学习路径。

# 这本书适合谁

由于书的结构，具有不同背景的人可以利用整本书或其中的部分。如果你具有基本的面向对象编程（OOP）知识，但以前从未创建过游戏，或者从未在 Unity 中创建过游戏，你会发现本书是游戏开发和 Unity 概念的一个很好的介绍，从基础到高级。即使你是一名经验丰富的 Unity 开发人员，想要学习如何使用其最新功能，你也会发现本书大部分内容都很有用。

另一方面，如果你没有任何编程知识，你也可以从本书中受益，因为大多数章节不需要编程经验来学习。这些章节将为你提供一个强大的基本技能集，你可以从中开始学习如何在 Unity 中编码，当你学会了这些基础的编码知识后，你可以进入本书的面向脚本的章节。

# 本书涵盖的内容

第一章《从零开始设计游戏》是我们在打开 Unity 之前讨论本书中要创建的游戏的细节的地方。

第二章《设置 Unity》是你将学习如何在计算机上安装和设置 Unity 的地方，也是你将创建你的第一个项目的地方。

第三章《与场景和游戏对象一起工作》是我们将学习有关场景和游戏对象的概念的地方，这些是 Unity 用来描述你的游戏世界由什么组成的一部分。

第四章，使用地形和 ProBuilder 进行灰盒设计，是我们将创建我们的第一个级别布局，并使用 Unity 的地形和 ProBuilder 功能进行原型设计。

第五章，导入和集成资产，介绍了图形。由于 Unity 不是用来创建图形的工具，而是用来显示它们的，我们将学习如何通过将图形导入 Unity 来改进我们场景的艺术。

第六章，使用 URP 和 Shader Graph 的材质和效果，我们将学习如何使用最新的 Unity 渲染系统（Universal Render Pipeline），以及如何使用 Shader Graph 功能创建效果。

第七章，使用粒子系统和 VFX 图创建视觉效果，是您将学习如何使用两个主要的 Unity 工具来创建视觉效果，比如水和火：粒子系统和 VFX 图。

第八章，使用通用渲染管线进行照明，涵盖了照明。照明是一个足够大的概念，有自己的章节。在这里，我们将加深对通用渲染管线的了解，特别是看看它的照明能力。

第九章，使用后期处理进行全屏效果，深入研究了效果和后期处理。为了获得大多数现代游戏所具有的电影效果，我们将学习如何在我们场景图形的顶部添加一层效果，使用通用渲染管线的后期处理功能。

第十章，声音和音乐集成，涉及一个经常被忽视的领域：声音。在大多数初学者开发者看来被低估了，这里我们将学习如何正确地将声音和音乐添加到我们的游戏中，并考虑其对性能的影响。

第十一章，用户界面设计，探讨了用户界面（UI）的使用。在所有基于图形的向用户传达信息的方式中，使用 UI 是最直接的。我们将学习如何使用 Unity UI 系统以文本、图像和生命条的形式显示信息。

第十二章，使用 Animator、Cinemachine 和 Timeline 创建动画，让我们摆脱简单的静态场景。在这一章中，我们将开始使用动画移动角色，并使用最新的 Unity 功能创建过场动画。

第十三章，使用 C#进行 Unity 脚本编程的介绍，是本书的第一个编程章节。我们将学习如何按照 Unity 的方式使用 C#创建我们的第一个脚本。

第十四章，实现移动和生成，是我们将学习如何编写对象的移动以及如何生成它们。从现在开始，假设具有一般的编程知识。

第十五章，物理碰撞和生命系统，是您将学习如何配置对象的物理设置以侦测它们何时发生碰撞并对碰撞做出反应。为了将其付诸实践，我们将创建一个生命系统。

第十六章，胜利和失败条件，是我们将检测游戏何时应该结束的地方，当玩家赢得游戏或输掉游戏时。

*第十七章*，*UI、声音和图形脚本*，我们将制作先前创建的 UI，以显示游戏的相关和当前信息，如玩家的健康和得分。此外，我们将研究在必要时播放声音以及使用视觉效果来反映玩家的行为。

*第十八章*，*实现游戏 AI 以构建敌人*，我们将使用 Unity 的几个功能创建基本的 AI，以在游戏中创建具有挑战性的敌人。

*第十九章*，*场景性能优化*，探讨了性能问题。使我们的游戏表现良好并不容易，但如果我们想发布游戏，这当然是必须的。在这里，我们将学习如何分析游戏的性能并解决最常见的性能问题。

*第二十章*，*构建项目*，我们将学习如何将 Unity 项目转换为可执行格式，以便将其分发给其他人并在没有安装 Unity 的情况下运行。

*第二十一章*，*最后的修饰*，我们将简要讨论在完成本书后如何推进游戏的开发，讨论诸如如何迭代和发布游戏等主题。

*第二十二章*，*Unity 中的增强现实*，为您介绍了**增强现实**（**AR**）。在这个额外的章节中，我们将学习如何使用 Unity 的 AR Foundation 包创建 AR 应用程序，这是最近发布的一种使用 Unity 创建 AR 应用程序的方式。

# 为了充分利用本书

在本书的各章中，您将开发一个完整的项目，虽然您可以只阅读各章，但我强烈建议您在阅读本书的过程中练习项目中的所有步骤，以获得适当学习这里所讨论概念所需的经验。各章的设计使您可以根据自己的喜好定制游戏，但请考虑不要偏离主要思想。

项目文件按章节分成文件夹，并以累积方式设计，每个文件夹只包含该章引入的新文件或与以前章节不同的文件。这意味着，例如，如果一个文件自*第一章*以来没有改变，您将在*第二章*以后的文件夹中找不到它。您可以在每个章节文件夹中打开场景文件，以查看游戏在该章节结束时应该是什么样子。这样可以让您看到每章节中发生的变化，并且意味着您可以轻松识别必要的变化。例如，如果由于某种原因，您无法完成*第三章*，您可以直接从已解决的*第四章*文件夹中继续。

![](img/Preface_Table_01.jpg)

我们建议您自己输入代码，或者通过 GitHub 存储库访问代码（链接在下一节中提供）。这样做将有助于避免与复制和粘贴代码相关的任何潜在错误。

请注意，本书及其示例是使用 Unity 2020.1.0f1 编写的，这是目前可用的最新版本。这是 Unity 2020 的第一个版本，虽然可能有更新版本，但请考虑，如果您使用它们，书中所示的截图或步骤可能会有轻微差异，但并不难解决。

# 下载示例代码文件

您可以从您的帐户在[www.packt.com](http://packt.com)下载本书的示例代码文件。如果您在其他地方购买了本书，您可以访问[www.packtpub.com/support](https://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。

您可以按照以下步骤下载代码文件：

1.  登录或注册，请访问[www.packt.com](http://packt.com)。

1.  选择**支持**选项卡。

1.  点击**代码下载**。

1.  在**搜索**框中输入书名，并按照屏幕上的说明操作。

下载文件后，请确保使用最新版本的解压缩或提取文件夹：

+   Windows 的 WinRAR/7-Zip

+   Mac 的 Zipeg/iZip/UnRarX

+   Linux 的 7-Zip/PeaZip

该书的代码包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/Hands-On-Unity-2020-Game-Development`](https://github.com/PacktPublishing/Hands-On-Unity-2020-Game-Development)。如果代码有更新，将会在现有的 GitHub 存储库中更新。

我们还有其他代码包，来自我们丰富的书籍和视频目录，可在 https://github.com/PacktPublishing/ 上找到。看看吧！

# 下载彩色图片

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图片。您可以在这里下载：

[`static.packt-cdn.com/downloads/9781838642006_ColorImages.pdf`](https://static.packt-cdn.com/downloads/9781838642006_ColorImages.pdf)。

# 使用的约定

本书中使用了许多文本约定。

`文本中的代码`：指示文本中的代码词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄。这是一个例子：“将其着色器设置为`Universal Render Pipeline/Particles/Unlit`。”

**粗体**：表示一个新术语、重要单词或您在屏幕上看到的单词。例如，菜单或对话框中的单词会以这种方式出现在文本中。这是一个例子：“创建一个新的空 GameObject（使用**GameObject** | **Create Empty**）。”

提示或重要说明

像这样出现。

# 联系我们

我们始终欢迎读者的反馈。

**一般反馈**：如果您对本书的任何方面有疑问，请在消息主题中提及书名，并发送电子邮件至 customercare@packtpub.com。

**勘误**：尽管我们已经尽一切努力确保内容的准确性，但错误是难免的。如果您在本书中发现错误，我们将不胜感激。请访问[www.packtpub.com/support/errata](https://www.packtpub.com/support/errata)，选择您的书籍，点击**勘误提交表**链接，并输入详细信息。

**盗版**：如果您在互联网上发现我们作品的任何非法副本，请向我们提供位置地址或网站名称，我们将不胜感激。请通过 copyright@packt.com 与我们联系，并提供材料链接。

**如果您有兴趣成为作者**：如果您在某个专题上有专业知识，并且有兴趣撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com/)。

# 评论

请留下评论。当您阅读并使用本书后，为什么不在购买书籍的网站上留下评论呢？潜在读者可以看到并使用您的公正意见来做出购买决定，我们在 Packt 可以了解您对我们产品的看法，我们的作者也可以看到您对他们书籍的反馈。谢谢！

有关 Packt 的更多信息，请访问[packt.com](http://packt.com)。

# 目录

## 前言

## *第一章*：从头开始设计游戏

### 游戏概念 10

### 输入控制 11

### 赢和输 12

### 游戏角色 13

### 英雄 13

### 敌人 14

### 游戏玩法 14

### 游戏世界布局 15

### 起始条件 16

### 结束条件 16

### 积分系统 17

### HUD17

### 难度平衡 18

### 难度平衡问题 19

### 实施计划 20

### 文档 21

### 游戏设计文件（GDD）21

### GDD 格式 22

### GDD 创建工具 22

### 电梯演讲 24

### 一个高概念 25

### 创建 GDD 的提示 26

### 总结 29

## *第二章*：设置 Unity

### 为什么要使用 Unity 等游戏引擎？32

### 过去和现在的行业见解 32

### 游戏引擎 33

### Unity 的优势 33

### 安装 Unity34

### Unity 版本 35

### 使用 Unity Hub 安装 Unity35

### 创建项目 41

### 创建项目 41

### 项目结构 44

### 总结 46

## *第三章*：处理场景和游戏对象

### 操作场景 48

### 场景的目的 48

### 场景视图 49

### 我们的第一个游戏对象 50

### 导航场景视图 51

### 操作游戏对象 52

### 游戏对象和组件 56

### 组件 57

### 操作组件 58

### 对象层次结构 64

### 对象的父子关系 64

### 可能的用途 65

### 预制 66

### 创建预制 67

### 预制实例关系 68

### 预制变体 71

### 保存场景和项目 73

### 保存我们的更改 73

### 项目结构 74

### 总结 76

## *第四章*：使用地形和 ProBuilder 进行灰盒设计

### 使用地形创建景观 78

### 讨论高度图 78

### 创建和配置高度图 80

### 编写高度图 83

### 添加高度图细节 86

### 使用 ProBuilder 创建形状 89

### 安装 ProBuilder89

### 创建形状 91

### 操作网格 92

### 添加细节 98

### 总结 102

## *第五章*：导入和集成资产

### 导入资产 103

### 从互联网导入资产 104

### 从资产商店导入资产 106

### 集成资产 112

### 集成地形纹理 112

### 集成网格 115

### 集成纹理 117

### 配置资产 119

### 配置网格 120

### 配置纹理 122

### 组装场景 124

### 总结 127

## *第六章*：使用 URP 和 Shader Graph 创建材质和效果

### 介绍着色器 130

### 着色器管线 130

### 渲染管线和 URP133

### URP 内置着色器 135

### 使用 Shader Graph 创建着色器 139

### 创建我们的第一个 Shader Graph 资产 140

### 使用纹理 144

### 合并纹理 153

### 应用透明效果 157

### 总结 159

## *第七章*：使用粒子系统和 VFX Graph 创建视觉效果

### 粒子系统介绍 162

### 创建基本粒子系统 163

### 使用高级模块 168

### 创建流体模拟 169

### 创建瀑布效果 170

### 创建篝火效果 172

### 使用 VFX Graph 创建复杂模拟 174

### 安装 VFX Graph175

### 创建和分析 VFX Graph177

### 创建雨效果 181

### 总结 185

## *第八章*：使用通用渲染管线进行照明

### 应用照明 188

### 讨论照明方法 188

### 使用天空盒配置环境照明 193

### 在 URP 中配置照明 198

### 应用阴影 201

### 了解阴影计算 202

### 配置高性能阴影 206

### 优化照明 209

### 了解静态照明 209

### 烘焙光照图 210

### 将静态照明应用于静态对象 217

### 总结 220

## *第九章*：使用后期处理创建全屏效果

### 使用后期处理 222

### 设置配置文件 222

### 使用基本效果 225

### 使用高级效果 228

### 高级效果 228

### 总结 238

## *第十章*：声音和音乐集成

### 导入音频 239

### 音频类型 240

### 配置导入设置 241

### 集成和混合音频 246

### 使用 2D 和 3D AudioSources246

### 使用音频混音器 250

### 总结 255

## *第十一章*：用户界面设计

### 了解画布和 RectTransform259

### 使用画布创建 UI259

### 使用 RectTransform 定位元素 261

### 画布对象类型 264

### 为 UI 集成资产 264

### 创建 UI 控件 271

### 创建响应式 UI278

### 调整对象位置 279

### 调整对象大小 282

### 总结 286

## *第十二章*：使用动画器、Cinemachine 和时间轴创建动画

### 使用动画器进行骨骼动画 288

### 了解蒙皮 288

### 导入骨骼动画 291

### 使用动画控制器集成 295

### 使用 Cinemachine 创建动态摄像机 301

### 创建推车轨道 305

### 使用时间轴创建过场动画 309

### 创建动画片段 309

### 顺序我们的开场过场动画 313

### 总结 318

## *第十三章*：使用 C#介绍 Unity 脚本

### 创建 C#脚本 320

### 初始设置 320

### 创建基于 MonoBehaviour 的类 323

### 添加字段 326

### 使用事件和指令 329

### 事件和指令 329

### 在指令中使用字段 333

### 常见初学者错误 334

### 总结 337

## *第十四章*：实现移动和生成

### 实现移动 340

### 通过 Transform 移动对象 340

### 使用输入 344

### 理解 Delta Time349

### 实现生成 351

### 生成对象 351

### 定时操作 359

### 销毁对象 363

### 总结 364

## *第十五章*：物理碰撞和健康系统

### 配置物理 366

### 设置形状 366

### 物理对象类型 369

### 过滤碰撞 373

### 检测碰撞 376

### 检测触发事件 377

### 修改其他对象 379

### 使用物理移动 382

### 施加力 382

### 微调物理 384

### 总结 387

## *第十六章*：胜利和失败条件

### 创建对象管理器 390

### 实现 Singleton 设计模式 390

### 使用 Singleton 创建管理器 394

### 创建游戏模式 398

### 使用事件改进我们的代码 402

### 总结 409

## *第十七章*：脚本化 UI、声音和图形

### 脚本化 UI412

### 在 UI 中显示信息 412

### 编程暂停菜单 419

### 脚本化反馈 424

### 脚本化视觉反馈 424

### 脚本化音频反馈 428

### 脚本化动画 430

### 总结 433

## *第十八章*：实现游戏 AI 以构建敌人

### 使用传感器收集信息 436

### 创建三种传感器 436

### 使用 Gizmos 进行调试 442

### 使用 FSM 进行决策 446

### 创建 FSM446

### 创建转换 448

### 执行 FSM 动作 452

### 计算我们的场景寻路 453

### 使用寻路 455

### 添加最终细节 458

### 摘要 463

## *第十九章*：场景性能优化

### 优化图形 466

### 图形引擎简介 466

### 使用帧调试器 468

### 使用批处理 470

### 其他优化 473

### 优化处理 477

### 检测 CPU 和 GPU 负载 477

### 使用 CPU 使用率分析器 480

### 通用 CPU 优化技术 484

### 优化内存 486

### 内存分配和垃圾收集器 487

### 使用内存分析器 491

### 摘要 495

## *第二十章*：构建项目

### 构建项目 497

### 调试构建 502

### 调试代码 503

### 性能分析 506

### 摘要 508

## *第二十一章*：最后的修饰

### 迭代游戏 509

### 测试和反馈 510

### 解释反馈 512

### 发布游戏 514

### 预发布 514

### 发布 516

### 发布后 517

### 摘要 518

## *第二十二章*：Unity 中的增强现实

### 使用 AR Foundation519

### 创建 AR Foundation 项目 520

### 使用跟踪功能 524

### 为移动设备构建 532

### 为 Android 构建 532

### 为 iOS538 构建

### 创建简单的 AR 游戏 541

### 生成玩家和敌人 542

### 编写玩家和敌人行为 545

### 摘要 550
