# 第十三章：重构 C# 代码 - 识别代码异味

在这一章中，我们将看看问题代码以及如何重构它。在行业中，问题代码通常被称为**代码异味**。它是编译、运行并完成其预期功能的代码。问题代码之所以成为问题是因为它变得难以阅读，具有复杂的性质，并使得代码库难以维护和进一步扩展。这样的代码应该在可行的情况下尽快重构。这是技术债务，在长期来看，如果你不处理它，它将使项目陷入困境。当这种情况发生时，你将面临昂贵的重新设计和从头开始编码应用程序。

那么什么是重构？重构是将现有的工作代码重写，使得代码变得干净的过程。正如你已经发现的那样，干净的代码易于阅读、易于维护和易于扩展。

在这一章中，我们将涵盖以下主题：

+   识别应用级别的代码异味以及我们如何解决它们

+   识别类级别的代码异味以及我们如何解决它们

+   识别方法级别的代码异味以及我们如何解决它们

通过本章的学习，您将获得以下技能：

+   识别不同类型的代码异味

+   理解为什么代码被归类为代码异味

+   重构代码异味，使其成为干净的代码

我们将从应用级别的代码异味开始看重构代码异味。

# 技术要求

您需要本章的以下先决条件：

+   Visual Studio 2019

+   PostSharp

对于本章的代码文件，您可以使用以下链接：[`github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH13`](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH13)。

# 应用级别的代码异味

应用级别的代码异味是散布在应用程序中的问题代码，影响每一层。无论您身处软件的哪一层，您都会看到相同的问题代码一遍又一遍地出现。如果您现在不解决这些问题，那么您将发现您的软件将开始缓慢而痛苦地死去。

在这一部分，我们将看看应用级别的代码异味以及我们如何去除它们。让我们从布尔盲目开始。

## 布尔盲目

布尔数据盲目指的是由处理布尔值的函数确定的信息丢失。使用更好的结构提供更好的接口和类来保存数据，使得在处理数据时更加愉快。

让我们通过这段代码示例来看看布尔盲目的问题：

```cs
public void BookConcert(string concert, bool standing)
{
    if (standing)
   {
        // Issue standing ticket.
    }
    else
    {
        // Issue sitting ticket.
    }
}
```

这个方法接受音乐会名称的字符串和一个布尔值，指示人是站立还是坐着。现在，我们将如下调用代码：

```cs
private void BooleanBlindnessConcertBooking()
{
    var booking = new ProblemCode.ConcertBooking();
    booking.BookConcert("Solitary Experiments", true);
}
```

如果一个新手看到`BooleanBlindnessConcertBooking()`方法，你认为他们会本能地知道`true`代表什么吗？我认为不会。他们对它的含义会一无所知。所以他们要么使用智能感知，要么找到被引用的方法来找到含义。他们是布尔盲目的。那么我们如何治愈他们的盲目呢？

嗯，一个简单的解决方案是用枚举替换布尔值。让我们首先添加我们的名为`TicketType`的枚举：

```cs
[Flags]
internal enum TicketType
{
    Seated,
    Standing
}
```

我们的枚举标识了两种类型的票。这些是`Seated`和`Standing`。现在让我们添加我们的`ConcertBooking()`方法：

```cs
internal void BookConcert(string concert, TicketType ticketType)
{
    if (ticketType == TicketType.Seated)
    {
        // Issue seated ticket.
    }
    else
    {
        // Issue standing ticket.
    }
}
```

以下代码显示了如何调用新重构的代码：

```cs
private void ClearSightedConcertBooking()
{
    var booking = new RefactoredCode.ConcertBooking();
    booking.BookConcert("Chrom", TicketType.Seated);
}
```

现在，如果有新人来看这段代码，他们会看到我们正在预订一场音乐会，看`Chrom`乐队，并且我们想要座位票。

## 组合爆炸

组合爆炸是同一段代码使用不同参数组合执行相同操作的副产品。让我们看一个添加数字的例子：

```cs
public int Add(int x, int y)
{
    return x + y;
}

public double Add(double x, double y)
{
    return x + y;
}

public float Add(float x, float y)
{
    return x + y;
}
```

这里，我们有三种方法都是对数字进行加法。返回类型和参数都不同。有更好的方法吗？有，通过使用泛型。通过使用泛型，你可以有一个单一的方法，能够处理不同类型的工作。因此，我们将使用泛型来解决我们的加法问题。这将允许我们有一个单一的加法方法，可以接受整数、双精度或浮点数。让我们来看看我们的新方法：

```cs
public T Add<T>(T x, T y)
{
    dynamic a = x;
    dynamic b = y;
    return a + b;
}
```

这个泛型方法被调用时，为`T`分配了特定类型。它执行加法并返回结果。只需要一个版本的方法来处理可以相加的不同.NET 类型。要调用`int`、`double`和`float`值的代码，我们将这样做：

```cs
var addition = new RefactoredCode.Maths();
addition.Add<int>(1, 2);
addition.Add<double>(1.2, 3.4);
addition.Add<float>(5.6f, 7.8f);
```

我们刚刚消除了三种方法，并用一个执行相同任务的单一方法替代了它们。

## 人为复杂

当你可以用简单的架构开发代码，但却实现了一个先进而相当复杂的架构时，这被称为**人为复杂**。不幸的是，我曾经不得不在这样的系统上工作，这是一种真正的痛苦和压力来源。你会发现这样的系统往往有很高的员工流动率。它们缺乏文档，似乎没有人知道系统或者有能力回答接受培训的人的问题——那些不得不学习系统来维护和扩展它的可怜人。

对所有超级智能软件架构师的建议是，当涉及软件时，**保持简单，愚蠢**（**KISS**）。记住，永久就业和终身工作似乎已经成为过去的事情。通常情况下，程序员更多地追逐金钱，而不是对企业的终身忠诚。因此，由于企业依赖软件来获取收入，你需要一个易于理解、接纳新员工、维护和扩展的系统。问问自己这个问题：如果你负责的系统突然经历了你和所有分配给它们的员工离职并找到新机会，接管的新员工能立即上手吗？还是他们会感到压力重重，摸不着头脑？

还要记住，如果团队中只有一个人了解该系统，而他们去世、搬到新地方或退休了，那么你和团队的其他人会怎么样？甚至更重要的是，这对企业意味着什么？

我无法再强调你真的要简单了。创建复杂系统并不记录它们并分享架构知识的唯一原因是为了让企业束手就擒，让他们留住你并榨干他们。不要这样做。根据我的经验，系统越复杂，死亡速度越快，必须重写。

在第十二章中，*使用工具提高代码质量*，你学会了如何使用 Visual Studio 2019 工具来发现*圈复杂度*和*继承深度*。你还学会了如何使用 ReSharper 生成依赖关系图。使用这些工具来发现代码中的问题区域，然后专注于这些区域。将圈复杂度降至 10 或更低。并将所有对象的继承深度降至不超过 1。

然后，确保所有类只执行它们的本职任务。力求使方法简短。一个很好的经验法则是每个方法不超过大约 10 行代码。对于方法参数，用参数对象替换长参数列表。在有很多`out`参数的地方，重构方法以返回元组或对象。识别任何多线程，并确保被访问的代码是线程安全的。你已经在第九章中看到了如何用不可变对象替换可变对象来提高线程安全性。

此外，寻找快速提示图标。它们通常会建议单击重构所突出显示的代码行。我建议你使用它们。这些在第十二章中提到过，*使用工具提高代码质量*。

考虑的下一个代码异味是数据团。

## 数据团

**数据团**是指在不同的类和参数列表中看到相同字段一起出现。它们的名称通常遵循相同的模式。这通常是系统中缺少一个类的迹象。通过识别缺失的类并将其概括，可以减少系统复杂性。不要被这个类可能很小的事实吓到，也永远不要认为一个类不重要。如果需要一个类来简化代码，那就添加它。

## 除臭注释

当注释使用美好的词语来为糟糕的代码开脱时，这被称为**除臭注释**。如果代码糟糕，那就重构它使之变好，并删除注释。如果你不知道如何重构使之变好，那就寻求帮助。如果没有人可以帮助你，请在 Stack Overflow 上发布你的代码。那个网站上有一些非常优秀的程序员，他们可以真正帮助你。只要确保在发布时遵守规则！

## 重复代码

**重复代码**是指出现多次的代码。重复代码带来的问题包括每次重复增加的维护成本。当开发人员修复一段代码时，这会花费企业的时间和金钱。修复一个错误就是 *技术债务（程序员的工资） x 1*。但如果有 10 个代码重复，那就是 *技术债务 x 10*。因此，代码重复的次数越多，维护成本就越高。此外，还有在多个位置修复相同问题的无聊因素。还有重复可能被进行错误修复的程序员忽视的事实。

最好重构重复代码，使之只存在一份。通常，最简单的方法是将其添加到当前项目中的一个新的可重用类中，并将其放在一个类库中。将可重用代码放入类库的好处是其他项目可以使用相同的文件。

在当今，最好使用.NET 标准类库来构建可重用的代码。原因在于.NET 标准库可以在 Windows、Linux、macOS、iOS 和 Android 上的所有 C#项目类型中访问。

另一个消除样板代码的选择是使用**面向方面的编程（AOP）**。我们在上一章中看过 AOP。你可以将样板代码移入一个方面。然后，该方面装饰应用于的方法。当方法被编译时，样板代码就被编织到位。这使你只需在方法内编写满足业务需求的代码。应用于方法的方面隐藏了必要但不属于业务要求的代码。这种编码技术既美观又干净，而且效果非常好。

你也可以使用装饰者模式编写装饰器，就像你在上一章中看到的那样。装饰器以一种可以添加新代码而不影响代码预期操作的方式包装具体类操作。一个简单的例子是将操作包装在一个`try`/`catch`块中，就像你之前在第十一章中看到的那样，*解决横切关注点*。

## 失去意图

如果你无法轻松理解源代码的意图，那它就失去了意图。

首先要做的是查看命名空间和类名。它们应该指示类的目的。然后，检查类的内容，寻找看起来不合适的代码。一旦你识别出这样的代码，就重构代码并将其放在正确的位置。

接下来要做的是看每个方法。它们只做一件事还是做多件事不太好？如果是的话，就重构它们。对于大型方法，寻找可以提取到方法中的代码。目标是使类的代码读起来像一本书。不断重构代码，直到意图清晰，类中只需要的东西才在类中。

不要忘记运用你在第十二章中学会的工具来提高代码质量。变量的变异是我们接下来要看的代码异味。

## 变量的变异

变量的变异意味着它们很难理解和推理。这使得它们很难重构。

可变变量是指被不同操作多次更改的变量。这使得理解值的原因更加困难。不仅如此，因为变量是从不同操作中变异的，这使得将代码片段提取到其他小而更易读的方法中变得困难。可变变量还可能需要更多的检查，增加了代码的复杂性。

试着重构代码的小部分，将它们提取到方法中。如果有很多分支和循环，请看看是否有更简单的方法来做事情，以消除复杂性。如果你使用多个`out`值，请考虑返回一个对象或元组。目标是消除变量的可变性，使其更容易理解，并知道它的值是什么，以及它是从哪里设置的。记住，持有变量的方法越小，确定变量设置位置和原因就越容易。

看下面的例子：

```cs
[InstrumentationAspect]
public class Mutant
{
    public int IntegerSquaredSum(List<int> integers)
    {
        var squaredSum = 0;
        foreach (var integer in integers)
        {
            squaredSum += integer * integer;
        }
        return squaredSum;
    }
}
```

该方法接受一个整数列表。然后它循环遍历整数，对它们进行平方，然后将它们添加到在方法退出时返回的`squaredSum`变量中。注意迭代次数，以及本地变量在每次迭代中的更新。我们可以使用 LINQ 来改进这一点。以下代码显示了改进后的重构版本：

```cs
[InstrumentationAspect]
public class Function
{
    public int IntegerSquaredSum(List<int> integers)
    {
            return integers.Sum(integer => integer * integer);
    }
}
```

在我们的新版本中，我们使用了 LINQ。正如你在前面的章节中所了解的，LINQ 采用了函数式编程。正如你在这里看到的，这里没有循环，也没有本地变量被变异。

编译并运行程序，你会看到以下内容：

![](img/ef28bf84-6935-4be5-8510-a00d02d8009e.png)

代码的两个版本都产生了相同的输出。

你会注意到代码的两个版本都应用了`[InstrumentationAspect]`。我们在第十二章中将这个方面添加到了我们的可重用库中，*解决横切关注点*。当你运行代码时，你会在`Debug`文件夹中找到一个`Logs`文件夹。在记事本中打开`Profile.log`文件，你会看到以下输出：

```cs
Method: IntegerSquaredSum, Start Time: 01/07/2020 11:41:43
Method: IntegerSquaredSum, Stop Time: 01/07/2020 11:41:43, Duration: 00:00:00.0005489
Method: IntegerSquaredSum, Start Time: 01/07/2020 11:41:43
Method: IntegerSquaredSum, Stop Time: 01/07/2020 11:41:43, Duration: 00:00:00.0000027
```

输出显示`ProblemCode.IntegerSquaredSum()`方法是最慢的版本，运行时间为**548.9**纳秒。而`RefactoredCode.IntegerSquaredSum()`方法要快得多，只需要**2.7**纳秒。

通过重构循环使用 LINQ，我们避免了对本地变量的变异。我们还减少了处理计算所需的时间**546.2**纳秒。这样微小的改进对人眼来说并不明显。但如果你在大数据上执行这样的计算，那么你会体验到明显的差异。

现在我们来讨论奇异解决方案。

## 奇异解决方案

当你在源代码中看到以不同方式解决问题时，这被称为**奇异解决方案**。这可能是因为不同的程序员有他们自己的编程风格，没有制定标准。也可能是由于对系统的无知，即程序员没有意识到已经存在一个解决方案。

重构奇怪的解决方案的一种方法是编写一个新类，其中包含以不同方式重复的行为。以最高效的方式将行为添加到类中。然后，用新重构的行为替换奇怪的解决方案。

您还可以使用**适配器模式**来统一不同的系统接口：

![](img/4139a381-b2cd-40a3-a22f-c7ec6fd8ad68.png)

`Target`类是由`Client`使用的特定于域的接口。需要适应的现有接口称为`Adaptee`。`Adapter`类将`Adaptee`类适配到`Target`类。最后，`Client`类通信符合`Target`接口的对象。让我们实现适配器模式。添加一个名为`Adaptee`的新类：

```cs
public class Adaptee
{
    public void AdapteeOperation()
    {
        Console.WriteLine($"AdapteeOperation() has just executed.");
    }
}
```

`Adaptee`类非常简单。它包含一个名为`AdapteeOperation()`的方法，该方法将消息打印到控制台。现在添加`Target`类：

```cs
public class Target
{
    public virtual void Operation()
    {
        Console.WriteLine("Target.Operation() has executed.");
    }
}
```

`Target`类也非常简单，包含一个名为`Operation()`的虚方法，该方法将消息打印到控制台。现在我们将添加将`Target`和`Adaptee`连接在一起的`Adapter`类：

```cs
public class Adapter : Target
{
    private readonly Adaptee _adaptee = new Adaptee();

    public override void Operation()
    {
        _adaptee.AdapteeOperation();
    }
}
```

`Adapter`类继承了`Target`类。然后我们创建一个成员变量来保存我们的`Adaptee`对象并对其进行初始化。然后我们有一个单一方法，即`Target`类的重写`Operation()`方法。最后，我们将添加我们的`Client`类：

```cs
    public class Client
    {
        public void Operation()
        {
            Target target = new Adapter();
            target.Operation();
        }
    }
```

`Client`类有一个名为`Operation()`的方法。此方法创建一个新的`Adapter`对象并将其分配给`Target`变量。然后调用`Target`变量上的`Operation()`方法。如果调用`new Client().Operation()`方法并运行代码，您将看到以下输出：

![](img/37077c85-28de-4054-bffa-13dd96722844.png)

您可以从屏幕截图中看到执行的方法是`Adaptee.AdapteeOperation()`方法。现在您已成功学会了如何实现适配器模式来解决奇怪的解决方案，我们将继续看散弹手术。

## 散弹手术

进行单个更改需要对多个类进行更改被称为**散弹手术**。这有时是由于代码过多重构导致遇到不同变化而产生的。这种代码异味增加了引入错误的倾向，例如由于错过机会而导致的错误。您还增加了合并冲突的可能性，因为代码需要在许多领域进行更改，程序员最终会互相干扰。代码如此复杂，以至于会导致程序员的认知负荷过重。新程序员由于软件的性质而面临陡峭的学习曲线。

版本控制历史将提供随时间对软件所做更改的历史记录。这可以帮助您识别每次添加新功能或遇到错误时所更改的所有区域。一旦确定了这些区域，那么您可以考虑将更改移动到代码库的更局部的区域。这样，当需要进行更改时，您只需专注于程序的一个区域，而不是许多区域。这使得项目的维护变得更加容易。

重复的代码是重构为一个适当命名的单个类的良好候选，并放置在正确的命名空间中。还要考虑应用程序的所有不同层。它们真的有必要吗？事情可以简化吗？在基于数据库的应用程序中，真的有必要拥有 DTO、DAO、领域对象等吗？数据库访问可以以任何方式简化吗？这些只是一些减少代码库大小的想法，从而减少必须修改以实现更改的区域数量。

其他要考虑的是耦合度和内聚度。耦合度需要保持在绝对最低限度。实现这一点的一种方法是通过构造函数、属性和方法注入依赖项。注入的依赖项将是特定接口类型。我们将编写一个简单的示例。添加一个名为`IService`的接口：

```cs
public interface IService
{
    void Operation();
}
```

接口包含一个名为`Operation()`的方法。现在，添加一个实现`IService`的类`Dependency`：

```cs
public class Dependency : IService
{
    public void Operation()
    {
        Console.WriteLine("Dependency.Operation() has executed.");
    }
}
```

`Dependency`类实现了`IService`接口。在`Operation()`方法中，向控制台打印了一条消息。现在让我们添加`LooselyCoupled`类：

```cs
public class LooselyCoupled
{
    private readonly IService _service;

    public LooselyCoupled(IService service)
    {
        _service = service;
    }

    public void DoWork()
    {
        _service.Operation();
    }
}
```

如您所见，构造函数接受`IService`类型并将其存储在成员变量中。对`DoWork()`的调用调用`IService`类型内的`Operation()`方法。`LooselyCoupled`类就是松耦合的，很容易测试。

通过减少耦合度，使类更容易测试。通过删除不属于类的代码并将其放在应该属于的地方，可以提高应用程序的可读性、可维护性和可扩展性。您减少了任何新人上手的学习曲线，并且在进行维护或新开发时减少了引入错误的机会。

现在让我们来看一下解决方案扩散。

## 解决方案扩散

在不同方法、类甚至库中实现的单一责任会导致解决方案扩散。这会使代码变得非常难以阅读和理解。结果是代码变得更难维护和扩展。

为了解决问题，将单一责任的实现移入同一类中。这样，代码就只在一个位置，做它需要做的事情。这样做使得代码易于阅读和理解。结果是代码可以很容易地维护和扩展。

## 不受控制的副作用

不受控制的副作用是那些在生产中出现的问题，因为质量保证测试无法捕捉到它们。当遇到这些问题时，您唯一的选择就是重构代码，使其完全可测试，并且在调试期间可以查看变量，以确保它们被适当设置。

一个例子是通过引用传递值。想象两个线程通过引用将一个人的对象传递给修改人的对象的方法。一个副作用是，除非有适当的锁定机制，否则每个线程都可以修改另一个线程的人的对象，使数据无效。您在第八章中看到了可变对象的一个例子，*线程和并发*。

这就结束了我们对应用级代码异味的讨论。现在，我们将继续看一下类级代码异味。

# 类级代码异味

类级代码异味是与所讨论的类有关的局部问题。可能困扰类的问题包括圈复杂度和继承深度、高耦合度和低内聚度。编写类时的目标是保持其小而功能齐全。类中的方法应该确实存在，并且应该很小。在类中只做需要做的事情 - 不多，也不少。努力消除类的依赖性，并使您的类可测试。将应该放在其他地方的代码移除到它应该属于的地方。在本节中，我们将解决类级代码异味以及如何重构它们，从圈复杂度开始。

## 圈复杂度

当一个类有大量的分支和循环时，它的圈复杂度会增加。 理想情况下，代码的圈复杂度值应该在*1 到 10 之间*。 这样的代码简单且没有风险。 圈复杂度为 11-20 的代码复杂但风险较低。 当代码的圈复杂度在 21-50 之间时，代码需要关注，因为它太复杂并对项目构成中等风险。 如果代码的圈复杂度超过 50，则这样的代码是高风险的，无法进行测试。 圈复杂度超过 50 的代码必须立即进行重构。

重构的目标是将圈复杂度值降低到 1-10 之间。 首先，通过替换`switch`语句后跟`if`表达式来开始。

### 用工厂模式替换`switch`语句

在本节中，您将看到如何用工厂模式替换`switch`语句。 首先，我们需要一个报告枚举：

```cs
[Flags]
public enum Report
{
    StaffShiftPattern,
    EndofMonthSalaryRun,
    HrStarters,
    HrLeavers,
    EndofMonthSalesFigures,
    YearToDateSalesFigures
}
```

`[Flags]`属性使我们能够提取枚举的名称。 `Report`枚举提供了报告列表。 现在让我们添加我们的`switch`语句：

```cs
public void RunReport(Report report)
{
    switch (report)
    {
        case Report.EndofMonthSalaryRun:
            Console.WriteLine("Running End of Month Salary Run Report.");
            break;
        case Report.EndofMonthSalesFigures:
            Console.WriteLine("Running End of Month Sales Figures Report.");
            break;
        case Report.HrLeavers:
            Console.WriteLine("Running HR Leavers Report.");
            break;
        case Report.HrStarters:
            Console.WriteLine("Running HR Starters Report.");
            break;
        case Report.StaffShiftPattern:
            Console.WriteLine("Running Staff Shift Pattern Report.");
            break;
        case Report.YearToDateSalesFigures:
            Console.WriteLine("Running Year to Date Sales Figures Report.");
            break;
        default:
            Console.WriteLine("Report unrecognized.");
            break;
    }
}
```

我们的方法接受一个报告，然后决定执行什么报告。 当我 1999 年作为初级 VB6 程序员开始时，我负责为 Thomas Cook，ANZ，BNZ，Vodafone 和其他一些大公司构建了一个报告生成器。 有很多报告，我负责编写一个庞大的 case 语句，使得这个 case 语句相形见绌。 但我的系统运行得非常好。 但是，按照今天的标准，有更好的方法来执行相同的代码，我会做一些非常不同的事情。

让我们使用工厂方法来运行我们的报告，而不使用`switch`语句。 添加一个名为`IReportFactory`的文件，如下所示：

```cs
public interface IReportFactory
{
    void Run();
}
```

`IReportFactory`接口只有一个名为`Run()`的方法。 实现类将使用此方法来运行其报告。 我们只添加一个名为`StaffShiftPatternReport`的报告类，它实现了`IReportFactory`：

```cs
public class StaffShiftPatternReport : IReportFactory
{
    public void Run()
    {
        Console.WriteLine("Running Staff Shift Pattern Report.");
    }
}
```

`StaffShiftPatternReport`类实现了`IReportFactory`接口。 实现的`Run()`方法在屏幕上打印一条消息。 添加一个名为`ReportRunner`的报告：

```cs
public class ReportRunner
{
    public void RunReport(Report report)
    {
        var reportName = $"CH13_CodeRefactoring.RefactoredCode.{report}Report, CH13_CodeRefactoring";
        var factory = Activator.CreateInstance(
            Type.GetType(reportName) ?? throw new InvalidOperationException()
        ) as IReportFactory;
        factory?.Run();
    }
}
```

`ReportRunner`类有一个名为`RunReport`的方法。 它接受一个类型为`Report`的参数。 由于`Report`是带有`[Flags]`属性的枚举，我们可以获取`report`枚举的名称。 我们使用这个名称来构建报告的名称。 然后，我们使用`Activator`类来创建报告的实例。 如果在获取类型时`reportName`返回 null，则抛出`InvalidOperationException`。 工厂被转换为`IReportFactory`类型。 然后我们调用工厂上的`Run`方法来生成报告。

这段代码绝对比一个非常长的`switch`语句要好得多。 我们需要知道如何提高`if`语句中条件检查的可读性。 我们接下来会看一下。

### 提高`if`语句中条件检查的可读性

`if`语句可能会违反单一职责和开闭原则。 请参阅以下示例：

```cs
public string GetHrReport(string reportName)
{
    if (reportName.Equals("Staff Joiners Report"))
        return "Staff Joiners Report";
    else if (reportName.Equals("Staff Leavers Report"))
        return "Staff Leavers Report";
    else if (reportName.Equals("Balance Sheet Report"))
        return "Balance Sheet Report";
}
```

`GetReport()`类有三个职责：员工入职报告，员工离职报告和资产负债表报告。 这违反了 SRP，因为该方法应该只关心 HR 报告，但它返回 HR 和财务报告。 就开闭原则而言，每次需要新报告时，我们都必须扩展此方法。 让我们重构该方法，以便不再需要`if`语句。 添加一个名为`ReportBase`的新类：

```cs
public abstract class ReportBase
{
    public abstract void Print();
}
```

`ReportBase`类是一个带有抽象`Print()`方法的抽象类。 我们将添加`NewStartersReport`类，它继承了`ReportBase`类：

```cs
    internal class NewStartersReport : ReportBase
    {
        public override void Print()
        {
            Console.WriteLine("Printing New Starters Report.");
        }
    }
```

`NewStartersReport`类继承了`ReportBase`类并重写了`Print()`方法。 `Print()`方法在屏幕上打印一条消息。 现在，我们将添加`LeaversReport`类，它几乎相同：

```cs
    public class LeaversReport : ReportBase
    {
        public override void Print()
        {
            Console.WriteLine("Printing Leavers Report.");
        }
    }
```

`LeaversReport`继承了`ReportBase`类并重写了`Print()`方法。`Print()`方法向屏幕打印一条消息。现在我们可以这样调用报告：

```cs
ReportBase newStarters = new NewStartersReport();
newStarters.Print();

ReportBase leavers = new LeaversReport();
leavers.Print();
```

两个报告都继承了`ReportBase`类，因此可以被实例化并分配给`ReportBase`变量。然后可以在变量上调用`Print()`方法，并且将执行正确的`Print()`方法。现在的代码遵循了单一责任原则和开闭原则。

接下来，我们将看一看分歧变化代码异味。

## 分歧变化

当您需要在一个位置进行更改，并发现自己不得不更改许多不相关的方法时，这被称为**分歧变化**。分歧变化发生在单个类中，是糟糕的类结构的结果。复制和粘贴代码是导致此问题出现的另一个原因。

为了解决问题，将导致问题的代码移动到自己的类中。如果行为和状态在类之间共享，则考虑使用适当的基类和子类来实现继承。

修复分歧变化相关问题的好处包括更容易的维护，因为更改将位于单个位置。这使得支持应用程序变得更加容易。它还从系统中删除了重复的代码，这恰好是我们接下来将讨论的内容。

## 向下转型

当基类被转换为其子类之一时，这被称为**向下转型**。这显然是一种代码异味，因为基类不应该知道继承它的类。例如，考虑`Animal`基类。任何类型的动物都可以继承基类。但动物只能是一种类型。例如，猫科动物是猫科动物，犬科动物是犬科动物。将猫科动物转换为犬科动物，反之亦然，是荒谬的。

将动物向下转型为其子类型甚至更加荒谬。这就像说猴子和骆驼是一样的，非常擅长通过沙漠长距离运输人类和货物。这是毫无意义的。因此，您永远不应该进行向下转型。将各种动物（如猴子和骆驼）向上转型为类型`Animal`是有效的，因为猫科动物、犬科动物、猴子和骆驼都是动物的类型。

## 过度使用文字

在使用文字时，很容易引入编码错误。一个例子是字符串文字中的拼写错误。最好将文字文字分配给常量变量。字符串文字应放在资源文件中以进行本地化。特别是如果您计划将软件部署到世界各地的不同位置。

## 特征嫉妒

当一个方法在除了它自己所在的类之外的其他类中花费更多时间处理源代码时，这被称为**特征嫉妒**。我们将在我们的“授权”类中看到这样的例子。但在我们这样做之前，让我们来看看我们的“认证”类：

```cs
public class Authentication
{
    private bool _isAuthenticated = false;

    public void Login(ICredentials credentials)
    {
        _isAuthenticated = true;
    }

    public void Logout()
    {
        _isAuthenticated = false;
    }

    public bool IsAuthenticated()
    {
        return _isAuthenticated;
    }
}
```

我们的“认证”类负责登录和注销用户，以及确定他们是否经过身份验证。添加我们的“授权”类：

```cs
public class Authorization
{
    private Authentication _authentication;

    public Authorization(Authentication authentication)
    {
        _authentication = authentication;
    }

    public void Login(ICredentials credentials)
    {
        _authentication.Login(credentials);
    }

    public void Logout()
    {
        _authentication.Logout();
    }

    public bool IsAuthenticated()
    {
        return _authentication.IsAuthenticated();
    }

    public bool IsAuthorized(string role)
    {
        return IsAuthenticated && role.Contains("Administrator");
    }
}
```

正如您在我们的“授权”类中所看到的，它所做的事情远远超出了它应该做的范围。有一个方法用于验证用户是否被授权承担某个角色。传入的角色将被检查，以确定它是否是管理员角色。如果是，那么该人被授权。但如果角色不是管理员角色，那么该人就没有被授权。

然而，如果您看一下其他方法，它们所做的不过是调用“认证”类中的相同方法。因此，在这个类的上下文中，认证方法是特征嫉妒的一个例子。让我们从“授权”类中移除特征嫉妒：

```cs
public class Authorization
{
    private ProblemCode.Authentication _authentication;

    public Authorization(ProblemCode.Authentication authentication)
    {
        _authentication = authentication;
    }

    public bool IsAuthorized(string role)
    {
        return _authentication.IsAuthenticated() && role.Contains("Administrator");
    }
}
```

您会发现“授权”类现在要小得多，只做了它需要做的事情。不再有特征嫉妒。

接下来，我们将看一看不适当的亲密关系代码异味。

## 不适当的亲密关系

当一个类依赖于另一个类中保存的实现细节时，它就会参与不恰当的亲密关系。这种依赖的类真的需要存在吗？它能否与它所依赖的类合并？或者有没有共享功能最好被提取到自己的类中？

类不应该相互依赖，因为这会导致耦合，并且也会影响内聚性。一个类理想上应该是自包含的。类应该尽可能少地了解彼此。

## 不检点的暴露

当一个类暴露其内部细节时，这被称为**不检点的暴露**。这违反了面向对象编程的**封装**原则。只有应该是公共的才应该是公共的。所有不需要公开的实现都应该通过适当的访问修饰符进行隐藏。

数据值不应该是公共的。它们应该是私有的，只能通过构造函数、方法和属性进行修改。它们只能通过属性进行检索。

## 大类（又名上帝对象）

大类，也被称为“上帝”对象，对系统的所有部分都是一切。它是一个庞大而笨重的类，做了太多的事情。当你尝试阅读对象时，当你读到类名并看到它所在的命名空间时，代码的意图可能是清晰的，但当你来看代码时，代码的意图可能会变得模糊。

一个写得好的类应该有其意图的名称，并且应该放在适当的命名空间中。类的内容应该遵循公司的编码标准。方法应该尽可能保持小，方法参数应该尽可能保持绝对最少。只有属于类的方法应该在类中。不属于类的成员变量、属性和方法应该被移除，并放在正确的文件和正确的命名空间中。

为了保持类的小型和专注，如果没有必要，就不要继承类。如果有一个类有五个方法，而你只会使用其中一个，那么是否可能将该方法移出到自己可重用的类中？记住单一职责原则。一个类应该只有一个职责。例如，文件类应该只处理与文件相关的操作和行为。文件类不应该执行数据库操作。你明白了。

当编写一个类时，你的目标是使它尽可能小，干净和可读。

## 懒惰类（又名搭便车和懒惰对象）

一个**搭便车**的类几乎没有任何用处。当你遇到这样的类时，你可以将它们的内容与具有相同意图的其他类合并。

你也可以尝试折叠继承层次结构。记住，理想的继承深度是*1*。因此，如果你的类的继承深度较大，那么它们是将向上移动继承树的良好候选者。你可能还想考虑使用内联类来处理非常小的类。

## 中间人类

中间人类只是将功能委托给其他对象。在这种情况下，你可以摆脱中间人，直接处理负责的对象。

还要记住，你需要保持继承深度。所以如果你不能摆脱这个类，就要考虑将它与现有的类合并。看看代码区域的整体设计。是否可以以某种方式重构所有代码，以减少代码量和不同类的数量？

## 变量和常量的孤立类

拥有一个独立的类来保存应用程序多个不同部分的变量和常量并不是一个好的做法。当你遇到这种情况时，变量可能很难有任何真正的含义，它们的上下文可能会丢失。最好将常量和变量移动到使用它们的地方。如果常量和变量将被多个类使用，那么它们应该分配给命名空间根目录中的一个文件。

## 原始偏执

源代码使用原始值而不是对象来执行某些任务，比如范围值和格式化字符串，比如信用卡、邮政编码和电话号码，这就是原始偏执。其他迹象包括用于字段名称的常量，以及不适当存储在常量中的信息。

## 拒绝遗赠

当一个类继承自另一个类，但不使用其所有方法时，这被称为**拒绝遗赠**。发生这种情况的常见原因是子类与基类完全不同。例如，一个`building`基类被不同的建筑类型使用，但然后一个`car`对象继承`building`，因为它具有与窗户和门相关的属性和方法。这显然是错误的。

当你遇到这种情况时，考虑是否需要一个基类。如果需要，那么创建一个，然后从中继承。否则，将功能添加到从错误类型继承的类中。

## 投机泛化

一个类被编程为具有现在不需要但将来可能需要的功能，这就是投机泛化。这样的代码是死代码，会增加维护开销和代码膨胀。最好在发现这些类时将其删除。

## 告诉，不要问

*告诉，不要问*软件原则告诉我们作为程序员，我们应该将数据与将操作该数据的方法捆绑在一起。我们的对象不应该要求数据然后对其进行操作！它们必须告诉对象的逻辑在对象的数据上执行特定任务。

如果你发现包含逻辑并要求其他对象提供数据来执行其操作的对象，那么将逻辑和数据合并到一个类中。

## 临时字段

临时字段是不需要在对象的整个生命周期中的成员变量。

你可以通过将临时字段和操作它们的方法移除到它们自己的类中来进行重构。你最终会得到更清晰、更有组织的代码。

# 方法级别的异味

方法级别的代码异味是方法本身的问题。方法是使软件功能良好或糟糕的工作马。它们应该组织良好，只做它们预期要做的事情——不多也不少。了解由于构造不良的方法可能出现的问题和问题的种类是很重要的。我们将讨论在方法级别的代码异味方面要注意的问题，以及我们可以做些什么来解决它们。我们将首先从黑羊方法开始。

## 黑羊方法

在类中的所有方法中，黑羊方法将明显不同。当你遇到黑羊方法时，你必须客观地考虑这个方法。它的名字是什么？方法的意图是什么？当你回答了这些问题，然后你可以决定删除这个方法，并将它放在它真正属于的地方。

## 圈复杂度

当一个方法有太多的循环和分支时，这被称为圈复杂度。这种代码异味也是一个类级别的代码异味，我们已经看到了如何在替换`switch`和`if`语句时可以减少分支的问题。至于循环，它们可以被替换为 LINQ 语句。LINQ 语句的额外好处是它是一个函数式代码，因为 LINQ 是一个函数式查询语言。

## 人为复杂

当一个方法不必要地复杂并且可以简化时，这种复杂性被称为人为复杂性。简化方法以确保其内容是人类可读和可理解的。然后，尝试重构方法并将其大小减小到实际可行的最小行数。

## 死代码

当存在但未被使用的方法时，这被称为死代码。构造函数、属性、参数和变量也是如此。它们应该被识别并移除。

## 过多的数据返回

当一个方法返回的数据比每个调用它的客户端所需的数据更多时，这种代码异味被称为过多的数据返回。应该只返回所需的数据。如果发现有不同要求的对象组，那么可能需要考虑编写不同的方法，以满足两组的需求，并且只返回对这些组有必要的数据。

## 特性嫉妒

特性嫉妒的方法花费更多时间访问其他对象中的数据，而不是在自己的对象中。当我们在类级别代码异味中看到特性嫉妒时，我们已经看到了这一点。

方法应该保持小巧，最重要的是，其主要功能应该局限于该方法。如果它在其他方法中做的事情比自己的方法还多，那么就有可能将一些代码从该方法中移出并放入自己的方法中。

## 标识符大小

标识符可能太短或太长。标识符应该具有描述性和简洁性。在命名变量时要考虑的主要因素是上下文和位置。在局部循环中，一个字母可能是合适的。但如果标识符在类级别，那么它将需要一个人能理解的名称来给它上下文。避免使用缺乏上下文、模糊或引起混淆的名称。

## 不恰当的亲密性

过于依赖其他方法或类中的实现细节的方法显示出不恰当的亲密性。这些方法需要被重构，甚至可能被移除。要牢记的主要事情是这些方法使用另一个类的内部字段和方法。

要进行重构，您可以将方法和字段移动到实际需要使用它们的地方。或者，您可以将字段和方法提取到它们自己的类中。当子类与超类亲密关联时，继承可以取代委托。

## 长行（又称上帝行）

长行代码很难阅读和解释。这使得程序员很难调试和重构这样的代码。在可能的情况下，可以格式化该行，使得任何句点和逗号后的代码出现在新行上。但这样的代码也应该被重构成更小的代码。

## 懒惰的方法

懒惰的方法是指做很少工作的方法。它可能将工作委托给其他方法，也可能只是调用另一个类的方法来完成它应该完成的工作。如果有任何这些情况，那么可能需要摆脱这些方法，并将代码放在需要的方法中。例如，您可以使用内联函数，比如 lambda。

## 长方法（又称上帝方法）

长方法是指已经超出自身范围的方法。这样的方法可能会失去其意图，并执行比预期更多的任务。您可以使用 IDE 选择方法的部分，然后选择提取方法或提取类，将方法的部分移动到自己的方法甚至自己的类中。方法应该只负责执行单一任务。

## 长参数列表（又称参数过多）

三个或更多参数被归类为长参数列表代码异味。您可以通过用方法调用替换参数来解决这个问题。另一种方法是用参数对象替换参数。

## 消息链

当一个方法调用一个对象，该对象调用另一个对象，依此类推时，就会出现消息链。之前，我们在看到迪米特法则时已经了解了如何处理消息链。消息链违反了这个法则，因为一个类只应该与其最近的邻居通信。重构类，将所需的状态和行为移动到需要它的地方。

## 中间人方法

当一个方法的全部工作只是委托给其他人完成时，它就是一个中间人方法，可以进行重构和删除。但如果有功能无法删除，那么将其合并到使用它的区域。

## 古怪解决方案

当看到多个方法做同样的事情但以不同的方式时，这就是一个古怪的解决方案。选择最好实现任务的方法，然后将对其他方法的调用替换为对最佳方法的调用。然后，删除其他方法。这将只留下一个方法和一种可以重复使用的实现任务的方法。

## 推测性泛化

一个在代码中没有被使用的方法被称为推测性泛化代码异味。它本质上是死代码，所有死代码都应该从系统中删除。这样的代码会增加维护成本，也会提供不必要的代码膨胀。

# 总结

在本章中，您已经了解了各种代码异味以及如何通过重构来消除它们。我们已经指出，有应用级别的代码异味渗透到应用程序的所有层，类级别的代码异味贯穿整个类，方法级别的代码异味影响个别方法。

首先，我们讨论了应用级别的代码异味，其中包括布尔盲目、组合爆炸、人为复杂、数据团、除臭剂注释、重复代码、意图丢失、变量突变、古怪解决方案、散弹手术、解决方案蔓延和不受控制的副作用。

然后，我们继续查看类级别的代码异味，包括圈复杂度、分歧变更、向下转型、过多的文字使用、特性嫉妒、不当亲密、不检狂露和大对象，也称为上帝对象。我们还涵盖了懒惰类，也称为吃白食者和懒惰对象；中间人；变量和常量的孤立类；原始偏执；拒绝继承；推测性泛化；告诉，不要问；和临时字段。

最后，我们转向了方法级别的代码异味。我们讨论了黑羊；圈复杂度；人为复杂；死代码；特性嫉妒；标识符大小；不当亲密；长行，也称为上帝行；懒惰方法；长方法，也称为上帝方法；长参数列表，也称为参数过多；消息链；中间人；古怪解决方案；和推测性泛化。

在下一章中，我们将继续使用 ReSharper 来查看代码重构。

# 问题

1.  代码异味的三个主要类别是什么？

1.  命名不同类型的应用级代码异味。

1.  命名不同类型的类级别代码异味。

1.  命名不同类型的方法级代码异味。

1.  您可以执行哪些重构以清理各种代码异味？

1.  什么是圈复杂度？

1.  我们如何克服圈复杂度？

1.  什么是人为复杂？

1.  我们如何克服人为复杂？

1.  什么是组合爆炸？

1.  我们如何克服组合爆炸？

1.  当发现除臭剂注释时，你应该怎么办？

1.  如果你有糟糕的代码但不知道如何修复，你应该怎么办？

1.  在处理编程问题时，哪里是提问和获取答案的好地方？

1.  如何减少长参数列表？

1.  如何重构一个大方法？

1.  一个干净方法的最大长度是多少？

1.  您的程序的圈复杂度应该在什么范围内？

1.  继承深度的理想值是多少？

1.  什么是投机泛化，以及你应该怎么做？

1.  如果你遇到一个奇怪的解决方案，你应该采取什么行动？

1.  如果你遇到一个临时字段，你会进行哪些重构？

1.  什么是数据团，以及你应该怎么做？

1.  解释拒绝遗赠的代码异味。

1.  消息链违反了什么法则？

1.  消息链应该如何重构？

1.  什么是特征嫉妒？

1.  你如何消除特征嫉妒？

1.  你可以使用什么模式来替换返回对象的`switch`语句？

1.  我们如何替换返回对象的`if`语句？

1.  什么是解决方案蔓延，以及可以采取什么措施来解决它？

1.  解释“告诉，不要问！”原则。

1.  “告诉，不要问！”原则是如何被打破的？

1.  霰弹手术的症状是什么，应该如何解决？

1.  解释失去意图以及可以采取的措施。

1.  循环可以如何重构，重构会带来什么好处？

1.  什么是分歧变化，你会如何重构它？

# 进一步阅读

+   *重构-改善现有代码的设计* by Martin Fowler and Kent Beck.

+   [`refactoring.guru/refactoring`](https://refactoring.guru/refactoring)：一个关于设计模式和代码异味的好网站。

+   [`www.dofactory.com/net/design-patterns`](https://www.dofactory.com/net/design-patterns)：一个关于各种设计模式的非常好的基于 C#的网站。
