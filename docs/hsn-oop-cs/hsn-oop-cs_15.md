# 第十五章：理解设计模式和原则

多年来，软件变得越来越复杂。现在，软件不仅用于数学计算或简单的**创建、读取、更新和删除**（CRUD）操作：我们正在使用它来执行复杂的任务，如控制火箭发动机或每天管理大量数据。来自各个行业的企业已经开始采用软件系统，包括银行、保险公司、研究机构、教育机构和政府机构。对软件的需求越高，越多的人开始在软件开发领域建立职业。从汇编语言编程开始，经过了过程式编程，然后是**面向对象编程**（OOP）时代的介绍，尽管出现了其他类型的编程，如函数式编程，但 OOP 仍然是最受欢迎的模型。OOP 帮助开发人员编写易于维护和扩展的良好模块化软件。在本章中，我们将讨论一些最重要的设计原则和模式，这些原则和模式被成千上万的开发人员遵循，我们将涵盖以下主题：

+   软件开发中的设计原则

+   软件开发中的不同设计模式

+   创建设计模式

+   行为设计模式

+   结构设计模式

+   **模型-视图-控制器**（MVC）模式

# 设计原则

在我们开始讨论设计原则之前，让我们思考一下在软件开发中我们所说的**设计原则**是什么意思。当我们开发软件时，我们首先设计其架构，然后开始编写其代码。我们希望以这样的方式编写我们的代码，即它不会产生错误，或者如果有错误，很容易找到。我们还希望在阅读代码时能够轻松理解它，并且希望它的结构能够在以后需要时进行更改。虽然很难编写最佳代码，但有许多在软件开发中由经验丰富的计算机科学家开发的原则。使用这些原则，开发人员可以编写非常干净的代码。

软件开发人员 Robert C. Martin，也被称为 Uncle Bob，提出了五个软件设计原则。这些原则对开发人员非常有效和有帮助，以至于它们已经成为软件行业的一种规范。它们统称为 SOLID 原则，代表以下不同的定义：

+   **S**代表**单一职责原则**

+   **O**代表**开闭原则**

+   **L**代表**Liskov 替换原则**

+   **I**代表**接口隔离原则**

+   **D**代表**依赖反转原则**

让我们逐一讨论这些原则。

# 单一职责原则

"一个类应该有一个，只有一个更改的原因。"

– *Robert C. Martin*

这意味着当我们编写一个类时，我们应该以只有一个职责的方式设计它。您应该只需要更改类的一个原因。如果您有多个更改类的原因，它就违反了单一职责原则。

如果一个类具有多个职责，并且您对一段代码进行更改，这可能会破坏另一段代码，因为它们位于同一个类中并共享一些依赖关系。您的代码可能不太解耦。

# 开闭原则

代码需要以这样的方式编写，即在软件实体（如类、模块或函数）中添加新内容是好的，但不应允许修改实体本身。这减少了产生错误的可能性。

# Liskov 替换原则

"派生类型必须完全可替代其基本类型。"

– *Barbara Liskov*

该原则规定，当你编写一个类时，如果它是从另一个类派生的，它应该能够被基类替换。否则，你的代码将非常脆弱和耦合。这个原则是由芭芭拉·利斯科夫首次发现的，因此以她的名字命名。

# 接口隔离原则

有时，开发人员会创建包含太多信息的大接口。许多类可能使用这个接口，但它们可能并不需要其中的所有内容。为了遵循这个原则，你应该避免这种情况。这个原则支持小接口而不是大接口，如果必要，一个类可以继承多个适用于该类的小接口。

# 依赖反转原则

“高层模块不应该依赖低层模块；两者都应该依赖抽象。抽象不应该依赖细节。细节应该依赖抽象。”

- *罗伯特·C·马丁*

我们知道，在软件开发中，我们使用层。为了使这些层解耦，我们必须以这样的方式设计这些层的依赖关系，以便这些层不是相互依赖，而是依赖于抽象。因此，如果你改变高层模块或低层模块中的某些内容，它不会损害系统。当我们创建这些抽象时，我们必须以这样的方式设计它们，使它们不依赖于实现细节。这些抽象应该是独立的，实现这些接口或抽象类的类应该依赖于这些抽象。

# 创造性设计模式

在面向对象编程中，一切都被视为对象，因此跟踪对象的创建和管理非常重要。如果开发人员不太关注这个话题，软件的对象可能会使软件变得脆弱和耦合。保持对象适当地维护对于保持应用程序易于扩展非常重要。创造性设计模式是帮助以避免对象创建的最常见问题的方式创建对象的模式。

创造性设计模式中存在两个主要概念：

+   封装系统使用的具体类的知识

+   隐藏具体类的创建和组合实例

创造性设计模式分为对象创建模式和类创建模式，其中**对象创建模式**处理对象的创建，**类创建模式**处理类的发现。

行业中有五种主要的创造性设计模式：

+   抽象工厂模式

+   建造者模式

+   工厂方法模式

+   原型模式

+   单例模式

# 抽象工厂模式

《设计模式：可复用面向对象软件的元素》一书中，四人组提出的这种模式的定义是提供一种组合来构建类似或依赖对象家族，而不指定它们的具体类。

这种模式提供的最重要的东西是对象创建的分离或抽象。如果你不遵循任何模式，当你创建一个对象时，最简单的方法就是在需要的地方使用`new`关键字创建一个对象。例如，如果我在我的`Bank`类中需要一个`Person`对象，最简单的方法就是在`Bank`类中使用`new`关键字实例化一个`Person`对象。然而，使用这种方法有时会使软件变得复杂。为了避免这种情况，我们可以使用抽象工厂模式。

抽象工厂模式主要用于有着相同家族的对象，或者以某种方式相关或依赖的情况。其思想是创建工厂类来执行对象创建的工作。如果一个对象`A`需要另一个对象`B`的实例，对象`A`应该要求对象`B`的工厂创建一个`B`的对象并将其传递给对象`A`。这样，对象`A`独立于对象`B`的创建。现在，在抽象工厂模式中，还有另一层抽象。工厂类也被抽象化了。这意味着对象`A`不会直接调用对象`B`的工厂，而是使用一个抽象。应该有一个机制来确定需要调用哪个`Factory`类。这意味着对象`A`不依赖于另一个对象的任何特定工厂。

# 建造者模式

将复杂对象的计划与其实现分离是建造者模式的主要思想。在面向对象的软件开发中，我们有时需要创建相当复杂的对象。例如，我们可能创建一个使用其他对象的对象，而这些对象又使用其他对象。当你只需要该对象执行另一种工作时，创建或实例化这种对象可能会很困难。这可能使代码变得更加复杂，降低其可读性。

让我们想想一个例子。想象一下，你正在制作一些汉堡，其中一些是鸡肉汉堡，一些是牛肉汉堡。在创建鸡肉汉堡对象时，你必须每次创建一个鸡肉汉堡对象时创建一个鸡肉汉堡肉饼对象、一个番茄酱对象、一个奶酪对象和一个面包对象，这会导致混乱的代码。当创建牛肉汉堡对象时，你也必须遵循相同的流程。这是一种处理和创建这些对象的非常复杂的方式。

建造者模式提供了一种解决这种复杂性的好方法。使用这种模式，我们创建一个名为`Builder`的类，其主要任务是创建复杂对象并返回新创建的对象。使用建造者模式，我们使用另一种类型的类，通常称为`director`类。这个类的任务是调用`Builder`类并从中获取对象。

让我们回到我们的汉堡示例。我们可以有一个`ChickenBurgerBuilder`类和一个`BeefBurgerBuilder`类。这些类将在类中设置项目、汉堡肉饼、面包、番茄酱和奶酪。当`BurgerDirector`类想要创建一个`鸡肉汉堡`时，它将调用`ChickenBurgerBuilder`。要创建一个`牛肉汉堡`，它将调用`BeefBurgerBuilder`。创建`汉堡肉饼`和其他配料的复杂性将由`Builder`类处理。

# 工厂方法模式

工厂方法模式与抽象工厂模式非常相似。不同之处在于，在工厂方法模式中，工厂层不是抽象的。使用这种模式意味着你将创建一个工厂类，该类将处理实现相同抽象的类的创建。这意味着，如果有一个由许多子类定义的接口，`Factory`类可以根据传递给`Factory`的逻辑创建任何这些子类中的任何一个。

让我们来想一个例子。我们将使用工厂方法模式来解决我们在生成器模式示例中提到的制作汉堡的问题。我们将创建一个名为`BurgerFactory`的`Factory`，它将接受一个输入，比如`typeOfBurger`（鸡肉或牛肉）。然后，`BurgerFactory`将决定应该创建哪种`Burger`类型的对象。假设我们有一个名为`Burger`的接口，`ChickenBurger`和`BeefBurger`都实现了这个接口。这意味着`BurgerFactory`将返回一个`Burger`类型的对象。客户端将不知道将创建和返回哪个`Burger`对象。通过使用这种模式，我们将客户端与特定对象隔离开来，从而增加了代码的灵活性。

# 原型模式

当你想要避免使用传统的对象创建机制（如 new 关键字）创建相同类型或子类型的新类时，可以使用这种设计模式。简而言之，这种模式规定我们应该克隆一个对象，然后将克隆的对象作为另一个新创建的对象来处理。这样就避免了传统的对象创建方法。

# 单例模式

单例模式是一个非常简单的设计模式。它涉及在整个应用程序中只创建一个类的对象。**单例对象**是一个不能有多个实例的对象。每当一段代码需要使用这个单例对象时，它不会创建一个新对象，而是使用已经存在的旧对象。

当你只想处理来自一个来源的一些信息时，可以使用这种设计模式。单例模式的最佳示例是数据库连接字符串。在应用程序中，如果使用了多个数据库连接，数据库可能会损坏并导致应用程序异常。在这种情况下，最好将连接字符串作为单例对象，这意味着所有通信都使用同一个实例。这减少了出现差异的机会。

# 结构设计模式

在软件开发中有一些与代码结构相关的设计模式。这些模式可以帮助你以一种能够避免常见结构问题的方式设计你的代码。在《设计模式：可复用面向对象软件的元素》一书中，由四人组成的设计模式一书中有七种结构设计模式。在本节中，我们只讨论其中的四种，分别是：

+   适配器模式

+   装饰器模式

+   外观模式

+   代理模式

如果你想了解其他三种模式的更多信息，请参阅四人组的《设计模式：可复用面向对象软件的元素》一书。起初，开始使用这些模式可能会有点困惑，但随着经验的增加，识别哪种模式适合哪种情况将变得更容易。

# 适配器模式

通常，当我们想到适配器这个词时，我们会想到一个小设备，它可以帮助我们将电子设备插入具有不同接口的电源插座。适配器设计模式实际上在软件代码中做同样的事情。这种设计模式规定，如果软件的两个模块想要相互通信，但一个模块期望的接口与另一个模块具有的接口不同，那么应该使用适配器，而不是改变一个接口以匹配另一个接口。这样做的好处是，将来如果你想让你的代码与另一个接口通信，你不需要改变你的代码，只需要使用另一个适配器。

例如，想象一下，你有一个接口`A`，但你想要与之通信的代码需要另一个接口`B`。你可以使用一个适配器将接口`A`转换为接口`B`，而不是将接口`A`更改为接口`B`。这样，使用接口`A`的代码不会出错，你将能够与要求接口`B`的代码进行通信。

# 装饰者模式

装饰者模式允许我们动态地向对象添加新的行为。当这种新行为被添加到对象时，它不应该影响对象上已经存在的任何其他行为。当你需要在运行时向对象添加新行为时，这种模式提供了一种解决方案。它还消除了创建子类只是为了向任务添加行为的需要。

# 外观模式

有时，如果你有复杂的对象关系，很难将它们全部映射并在代码中使用。外观模式指出，你应该使用一个中间对象来处理对象关系问题，并为客户端提供一个简单的联系点。让我们想想一个例子：当你去餐厅点餐时，你实际上不会去找厨师或厨房里的人收集食物，然后自己做饭；你告诉服务员你想要什么食物。你不知道这个项目将如何准备或者谁会准备它。你无法控制食物的制作，你只知道你会得到你要求的项目。在这里，接受订单的人就是一个外观。他们接受你的订单，并要求不同的人准备你要求的项目。

假设你点了一份牛肉汉堡。你调用一个`GetBeefBurger()`方法，外观实际上会调用以下内容：

```cs
Bread.GetBread()
Sauce.PutSauceOnBread(Bread)
SliceTomato()
PutTomatoOnBread()
Beef.FryBeefPatty()
PutBeefPattyOnBread()
WrapTheBurger()
ServeTheBurger()
```

上述方法并不是真正的方法。我只是想给你一个想法，外观的工作实际上是隐藏客户端的复杂性。

# 代理模式

这种模式与我们讨论过的其他结构设计模式非常相似。如果有一种情况，一个代码片段不应该直接调用另一个代码片段，不管出于什么原因，都可以使用代理模式。代理模式在代码片段没有权限调用另一个代码片段或者直接调用代码片段在资源方面是昂贵的情况下特别有用。如果我们想在应用程序中使用第三方库，但出于安全原因不希望我们的代码直接调用该库，我们可以创建一个代理并让它与第三方代码进行通信。

# 行为设计模式

行为设计模式是处理对象之间通信的设计模式。这些设计模式允许你的对象以一种避免开发人员面临的与对象行为相关的常见问题的方式进行通信。在这个类别中有许多模式：

+   责任链模式

+   命令模式

+   解释器模式

+   迭代器模式

+   中介者模式

+   备忘录模式

+   观察者模式

+   状态模式

+   策略模式

+   模板方法模式

+   访问者模式

然而，在本书中，我们只会讨论以下行为设计模式：

+   命令模式

+   观察者模式

+   策略模式

如果你想了解更多，请参考我们之前提到的四人帮的《设计模式：可复用面向对象软件的元素》一书。

# 命令模式

这种模式规定，当一个对象想要通知另一个对象或调用另一个对象的方法时，它应该使用另一个对象而不是直接这样做。建立通信的对象称为命令对象。命令将封装持有要调用的方法、要调用的方法名称以及要传递的参数（如果有的话）的对象。命令模式有助于解耦调用者和接收者之间的关系。

# 观察者模式

**观察者模式**是解决一个问题的解决方案，即许多对象需要知道特定对象何时发生变化，因为它们可能需要更新其端上的数据。一种方法是所有对象或观察者应该询问对象或可观察对象数据是否已更改。如果可观察对象中的数据已更改，观察者将执行其工作。然而，如果这样做，观察者必须经常询问可观察对象关于数据变化，以避免减慢应用程序的速度。这需要大量资源。

观察者模式表示可观察对象应该知道想要了解主题数据变化的观察者列表，并在主题数据发生变化时通知每个观察者。这可以通过调用观察者的方法来实现。这种模式的一个很好的应用是 C#中的事件和委托。

# 策略模式

让我们来看一下《设计模式：可重用面向对象软件的元素》一书中的策略模式的定义：

例如，一个方法可以根据使用它的类的不同类型的实现而有所不同。因此，这个定义意味着我们需要使这些不同的算法实现一个基类或接口，以便它们属于同一个家族，并可以被客户端互换使用。定义的最后一部分意味着这种模式将允许客户端使用不同的算法而不影响其他客户端。

假设我们有一个名为`Animal`的类，它具有一些常见属性，如`eat`，`walk`和`noise`。现在，假设您想添加另一个属性，如`fly`。您的类中的大多数动物都可以飞，但有一些不能。您可以将`Animal`类分成两个不同的类，如`AnimalWhichCanFly`和`AnimalWhichCantFly`。然而，将`Animal`类分成两个可能会使事情过于复杂，因为这些动物可能还具有其他不同的属性。因此，您可以使用组合而不是继承，这意味着您可以在`Animal`类中添加一个名为`fly`的属性，并使用它来指示此行为。

策略模式规定，我们应该使用接口（例如`IFly`）而不是固定类型（`fly`）作为属性类型，然后创建实现`IFly`并具有不同算法的`子类`。然后，我们可以利用多态性，并在创建`Animal`类的子类时在运行时分配特定的子类。

让我们尝试将这种模式应用于前面的例子。在`Animal`类中，我们将使用`IFly`而不是使用`Fly`属性，然后实现实现`IFly`的不同类。例如，我们创建`CanFly：IFly`和`CannotFly：IFly`类。`CanFly`和`CannotFly`将有`Fly`方法的不同实现。如果我们创建一个实现`Animal`类的`Dog`类，我们将把`Fly`属性设置为`CannotFly`类。如果我们创建一个`Bird`类，我们将创建`CanFly`的实例并将其分配给`Fly`属性。通过应用这种模式，我们实现了一个不那么复杂的对象结构和易于更改的算法。

# MVC 模式

MVC 模式是行业中最流行的设计模式之一。您可能已经听说过它，即使您是行业的新手。这种模式在 Web 开发中被广泛使用。许多流行的 Web 开发框架使用这种设计模式。以下是一些使用 MVC 模式的流行框架：

+   C#: ASP.NET MVC Web Framework

+   **Java:** Spring 框架

+   **PHP:** Laravel 框架，Codeigniter 框架

+   **Ruby:** Rails 框架

MVC 设计模式规定我们应该将 Web 应用程序分为三个部分：

+   模型

+   视图

+   控制器

**模型**是将保存数据模型或对象并将用于数据库事务的部分。**视图**指的是应用程序的前端，用户或客户所看到的部分。最后，**控制器**是处理应用程序所有业务逻辑的部分。所有逻辑和决策部分都将在控制器中。

MVC 模式的好处在于您的应用程序是解耦的。您的视图独立于您的业务逻辑，您的业务逻辑独立于您的数据源。这样，您可以轻松地更改应用程序的一部分，而不会影响应用程序的其他部分。

# 摘要

软件开发之所以有趣，是因为它一直在变化。您可以以许多方式开发、设计或编写代码。这些方式都不能被归类为最佳方式，因为您的代码可能需要根据情况进行更改。然而，由于软件开发是一种工程类型，有各种规则可以使您的软件更加强大和可靠。软件设计原则和设计模式就是这些规则的例子。了解这些概念并将其应用于您自己的情况将使您作为开发人员的生活更加轻松。

本章希望给您一个设计模式基础的概念，并向您展示可以查找更多信息的地方。在下一章中，我们将了解一个非常强大和有趣的软件，叫做 Git。Git 是一个版本控制系统，有助于跟踪软件代码。
