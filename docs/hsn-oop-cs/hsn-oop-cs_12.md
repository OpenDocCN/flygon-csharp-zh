# 第十二章：理解设计模式和原则

多年来，软件变得越来越复杂。现在，软件不仅用于数学计算或简单的**创建、读取、更新和删除**（CRUD）操作：我们正在使用它来执行复杂的任务，如控制火箭发动机或每天管理大量数据。来自各行各业的企业已经开始采用软件系统，包括银行、保险公司、研究机构、教育机构和政府机构。对软件的需求越高，越多的人开始在软件开发领域建立职业。从汇编语言编程开始，经过过程式编程，然后引入了面向对象编程（OOP）时代，尽管出现了其他类型的编程，如函数式编程，但 OOP 仍然是最受欢迎的模型。OOP 帮助开发人员编写良好的、模块化的软件，易于维护和扩展。在本章中，我们将讨论一些最重要的设计原则和模式，这些原则和模式被成千上万的开发人员遵循，我们将涵盖以下主题：

+   软件开发中的设计原则

+   软件开发中的不同设计模式

+   创建设计模式

+   行为设计模式

+   结构设计模式

+   **模型-视图-控制器**（MVC）模式

# 设计原则

在我们开始讨论设计原则之前，让我们思考一下在软件开发中我们所说的**设计原则**是什么意思。当我们开发软件时，我们首先设计其架构，然后开始编写其代码。我们希望以这样的方式编写我们的代码，使其不会产生错误，或者如果有错误，很容易找到。当我们阅读代码时，我们也希望代码易于理解，并且希望它的结构能够在以后需要时进行更改。虽然编写最佳代码是困难的，但有许多在软件开发中由经验丰富的计算机科学家制定的原则。使用这些原则，开发人员可以编写非常干净的代码。

软件开发人员罗伯特·C·马丁，也被称为 Uncle Bob，提出了五个软件设计原则。这些原则对开发人员非常有效和有帮助，以至于它们已经成为软件行业的一种规范。它们统称为 SOLID 原则，代表以下不同的定义：

+   **S **代表**单一职责原则**

+   **O **代表**开闭原则**

+   **L **代表**里氏替换原则**

+   **I **代表**接口隔离原则**

+   **D **代表**依赖反转原则**

让我们逐一讨论这些原则。

# 单一职责原则

"一个类应该只有一个改变的原因。"

– *罗伯特·C·马丁*

这意味着当我们编写一个类时，我们应该以只有一个职责的方式设计它。你应该只需要为一个原因更改类。如果你有多个原因更改类，那么它违反了单一职责原则。

如果一个类有多个职责，并且你对一段代码进行了更改，这可能会破坏另一段代码，因为它们在同一个类中并共享一些依赖关系。你的代码可能并不是非常解耦的。

# 开闭原则

代码需要以这样的方式编写，即在软件实体（如类、模块或函数）中添加新内容是好的，但不应允许修改实体本身。这减少了产生错误的可能性。

# 里氏替换原则

"派生类型必须完全可替代其基本类型。"

– *芭芭拉·里斯科夫*

这个原则规定，当你编写一个类时，如果它是从另一个类派生的，它应该可以被基类替换。否则，你的代码将非常脆弱和耦合。这个原则是由芭芭拉·利斯科夫首次发现的，因此以她的名字命名。

# 接口隔离原则

有时，开发人员会创建包含过多信息的大接口。许多类可能会使用这个接口，但它们可能并不需要其中的所有内容。这就是你应该避免的，以便遵循这个原则。这个原则支持小接口而不是大接口，如果必要，一个类可以继承多个适用于该类的小接口。

# 依赖反转原则

"高层模块不应该依赖于低层模块；两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象"

- *罗伯特·C·马丁*

我们知道，在软件开发中，我们使用层。为了使这些层解耦，我们必须以这样一种方式设计这些层的依赖关系，即这些层不应该相互依赖，而应该依赖于抽象。因此，如果你改变高层模块或低层模块中的某些东西，它不会伤害系统。当我们创建这些抽象时，我们必须以这样一种方式设计它们，即它们不依赖于实现细节。这些抽象应该是独立的，而实现这些接口或抽象类的类应该依赖于这些抽象。

# 创建型设计模式

在面向对象编程中，所有的东西都被视为对象，跟踪对象的创建和管理方式非常重要。如果开发人员不太关注这个话题，软件的对象可能会使软件变得脆弱和耦合。保持对象适当地以保持应用程序易于扩展非常重要。创建型设计模式是帮助以避免对象创建方面的最常见问题的模式。

在创建型设计模式中存在两个主要概念：

+   封装关于系统使用的具体类的知识

+   隐藏创建和组合具体类的实例

创建型设计模式分为对象创建模式和类创建模式，其中**对象创建模式**处理对象的创建，**类创建模式**处理类的发现。

行业中有五种主要的创建型设计模式：

+   抽象工厂模式

+   建造者模式

+   工厂方法模式

+   原型模式

+   单例模式

# 抽象工厂模式

《设计模式：可复用面向对象软件的元素》一书中对这个模式的定义是提供一种组合来构建类似或相关对象族，而不指定它们的具体类。

这个模式提供的最重要的东西是对象创建的分离或抽象。如果你不遵循任何模式，当你创建一个对象时，最简单的方法就是在需要的地方使用`new`关键字创建一个对象。例如，如果我在我的`Bank`类中需要一个`Person`对象，最简单的方法就是在`Bank`类中使用`new`关键字实例化一个`Person`对象。然而，使用这种方法有时会使软件变得复杂。为了避免这种情况，我们可以使用抽象工厂模式。

抽象工厂模式主要用于具有相同家族的对象，或者以某种方式相关或依赖的情况。其思想是创建工厂类来执行对象的创建工作。如果一个对象 A 需要另一个对象 B 的实例，对象 A 应该要求对象 B 的工厂创建一个 B 对象并将其传递给对象 A。这样，对象 A 独立于对象 B 的创建。在抽象工厂模式中，还有另一层抽象。工厂类也被抽象化了。这意味着对象 A 不会直接调用对象 B 的工厂，而是使用一个抽象。应该有一个机制来确定需要调用哪个工厂类。这意味着对象 A 不依赖于另一个对象的任何特定工厂。

# 建造者模式

将复杂对象的计划与其实现分离是建造者模式的主要思想。在面向对象的软件开发中，我们有时需要创建相当复杂的对象。例如，我们可能创建一个使用其他对象的对象，而这些对象又使用其他对象。当你只需要该对象执行另一种工作时，创建或实例化这种对象可能会很困难。这也可能使代码更复杂，降低其可读性。

让我们想想一个例子。想象一下，你正在制作一些汉堡包，其中一些是鸡肉汉堡，另一些是牛肉汉堡。在创建鸡肉汉堡对象时，每次都必须创建鸡肉汉堡肉饼对象、番茄酱对象、奶酪对象和面包对象，这导致代码混乱。创建牛肉汉堡对象时也必须遵循相同的过程。这是一种处理和创建这些对象的非常复杂的方式。

建造者模式提供了一种解决这种复杂性的好方法。使用这种模式，我们创建一个称为 Builder 的类，其主要任务是创建复杂对象并返回新创建的对象。使用建造者模式，我们使用另一种类型的类，通常称为 director 类。这个类的任务是调用 Builder 类并从中获取对象。

让我们回到我们的汉堡例子。我们可以有一个 ChickenBurgerBuilder 类和一个 BeefBurgerBuilder 类。它们将在类中设置汉堡肉饼、面包、番茄酱和奶酪。当 BurgerDirector 类想要创建一个鸡肉汉堡时，它将调用 ChickenBurgerBuilder。要创建一个牛肉汉堡，它将调用 BeefBurgerBuilder。创建汉堡肉饼和其他配料的复杂性将由 Builder 类处理。

# 工厂方法模式

工厂方法模式与抽象工厂模式非常相似。不同之处在于，在工厂方法模式中，工厂层不是抽象的。使用这种模式意味着你将创建一个处理实现相同抽象的类的创建的工厂类。这意味着，如果有一个由许多子类定义的接口，Factory 类可以根据传递给 Factory 的逻辑创建任何这些子类中的任何一个。

让我们想一个例子。我们将使用工厂方法模式来解决我们在“生成器模式”示例中提到的制作汉堡的问题。我们将创建一个名为`BurgerFactory`的`Factory`，它将接受一个输入，比如`typeOfBurger`（鸡肉或牛肉）。然后，`BurgerFactory`将决定应该创建哪种`Burger`类型的对象。假设我们有一个名为`Burger`的接口，`ChickenBurger`和`BeefBurger`都实现了这个接口。这意味着`BurgerFactory`将返回一个`Burger`类型的对象。客户端将不知道将创建和返回哪个`Burger`对象。通过使用这种模式，我们将客户端与特定对象隔离开来，从而增加了代码的灵活性。

# 原型模式

当您想要避免使用传统的对象创建机制（如 new 关键字）创建相同类型或子类型的新类时，可以使用这种设计模式。简而言之，这种模式规定我们应该克隆一个对象，然后使用克隆的对象作为另一个新创建的对象。这样就避免了传统的对象创建方法。

# 单例模式

单例模式是一种非常简单的设计模式。它涉及在整个应用程序中只创建一个类的对象。**单例对象**是一个不能有多个实例的对象。每当一段代码需要使用这个单例对象时，它不会创建一个新对象；相反，它将使用已经存在的旧对象。

这种设计模式适用于当您只想处理来自一个来源的一些信息时。使用单例模式的最佳示例是在数据库连接字符串中。在应用程序中，如果使用多个数据库连接，数据库可能会损坏并导致应用程序异常。在这种情况下，最好将连接字符串设置为单例对象，这意味着所有通信都只使用一个实例。这减少了出现差异的机会。

# 结构设计模式

在软件开发中可用的一些设计模式与代码结构有关。这些模式可以帮助您以一种避免常见结构问题的方式设计代码。在《设计模式：可复用面向对象软件的元素》一书中，Gang of Four 提出了七种结构设计模式。在本节中，我们将讨论其中的四种，分别是：

+   适配器模式

+   装饰器模式

+   外观模式

+   代理模式

如果您想了解其他三种模式的更多信息，请参阅 Gang of Four 的《设计模式：可复用面向对象软件的元素》一书。起初，开始使用这些模式可能会有点困惑，但随着经验的增加，识别哪种模式适合哪种情况将变得更容易。

# 适配器模式

通常，当我们想到适配器这个词时，我们会想到一个小设备，它可以帮助我们将电子设备插入具有不同接口的电源插座。适配器设计模式实际上在软件代码中也是这样的。这种设计模式规定，如果软件的两个模块想要相互通信，但一个模块期望的接口与另一个模块具有的接口不同，那么应该使用适配器，而不是改变一个接口以匹配另一个接口。这样做的好处是，将来如果您希望您的代码与另一个接口进行通信，您不必更改您的代码，只需使用另一个适配器。

例如，想象一下你有一个接口`A`，但你想要与之交流的代码需要另一个接口`B`。你可以使用一个适配器将接口`A`转换为接口`B`，而不是将接口`A`更改为接口`B`。这样，使用接口`A`的代码不会出错，你将能够与要求接口`B`的代码进行通信。

# 装饰者模式

装饰者模式允许我们动态地向对象添加新的行为。当这种新行为被添加到一个对象时，它不应该影响该对象上已经存在的任何其他行为。当你需要在运行时向对象添加新的行为时，这种模式提供了一个解决方案。它还消除了创建子类只是为了向任务添加行为的需要。

# 外观模式

有时，如果你有复杂的对象关系，很难将它们全部映射并在代码中使用。外观模式表明，你应该使用一个中间对象来处理对象关系问题，并给客户端一个简单的接触点。让我们想想一个例子：当你去餐厅点餐时，你实际上不会去找厨师或厨房里的人收集食物，然后自己做饭；你告诉服务员你想要什么食物。你不知道食物将如何准备或谁会准备它。你无法控制食物的制作，你只知道你会得到你要的东西。在这里，接受订单的人就是一个外观。他们接受你的订单，并要求不同的人准备你要的东西。

假设你点了一份牛肉汉堡。你调用一个`GetBeefBurger()`方法，外观实际上会调用以下内容：

```cs
Bread.GetBread()
Sauce.PutSauceOnBread(Bread)
SliceTomato()
PutTomatoOnBread()
Beef.FryBeefPatty()
PutBeefPattyOnBread()
WrapTheBurger()
ServeTheBurger()
```

上述方法并不是真正的方法。我只是想给你一个概念，即外观的工作实际上是为了隐藏客户端的复杂性。

# 代理模式

这种模式与我们讨论过的其他结构设计模式非常相似。如果有一种情况，代码不应该直接调用另一段代码，无论出于什么原因，都可以使用代理模式。代理模式在代码没有权限调用另一段代码或直接调用一段代码在资源方面昂贵时特别有用。我们可能想使用代理模式的一个例子是，如果我们想在应用程序中使用第三方库，但出于安全原因，我们不希望我们的代码直接调用该库。在这种情况下，我们可以创建一个代理，让它与第三方代码进行通信。

# 行为设计模式

行为设计模式是处理对象之间通信的设计模式。这些设计模式允许你的对象以一种避免开发人员面临的与对象行为相关的常见问题的方式进行通信。在这个类别中有许多模式：

+   责任链模式

+   命令模式

+   解释器模式

+   迭代器模式

+   中介者模式

+   备忘录模式

+   观察者模式

+   状态模式

+   策略模式

+   模板方法模式

+   访问者模式

然而，在这本书中，我们只会讨论以下行为设计模式：

+   命令模式

+   观察者模式

+   策略模式

如果你想了解更多，请参考我们之前提到的《设计模式：可复用面向对象软件的元素》一书，作者是四人组。

# 命令模式

这种模式规定，当一个对象想要通知另一个对象或调用另一个对象的方法时，应该使用另一个对象而不是直接这样做。建立通信的对象被称为命令对象。命令将封装持有要调用的方法、要调用的方法名以及要传递的参数（如果有的话）的对象。命令模式有助于解耦调用者和接收者之间的关系。

# 观察者模式

**观察者模式**是解决一个问题的解决方案，即许多对象需要知道特定对象何时发生变化，因为它们可能需要更新其端上的数据。一种方法是，所有对象或观察者都应该询问对象或可观察对象数据是否发生了变化。如果可观察对象中的数据发生了变化，观察者将执行其工作。然而，如果这样做，观察者必须经常询问可观察对象关于数据变化，以避免减慢应用程序的速度。这需要大量的资源。

观察者模式表示可观察对象应该知道想要了解主题中数据变化的观察者列表，并在主题中的数据发生变化时通知每个观察者。这可以通过调用观察者的方法来实现。这种模式的一个很好的应用是 C#中的事件和委托。

# 策略模式

让我们来看一下《设计模式：可复用面向对象软件的元素》一书中四人帮对策略模式的定义：

例如，一个方法可以根据使用它的类的不同类型有不同的实现。因此，这个定义意味着我们需要使这些不同的算法实现一个基类或接口，以便它们属于同一个家族，并可以被客户端互换使用。定义的最后一部分意味着这种模式将允许客户端使用不同的算法而不影响其他客户端。

假设我们有一个名为`Animal`的类，它具有一些常见属性，如`eat`、`walk`和`noise`。现在，假设你想添加另一个属性，比如`fly`。你的类中的大多数动物都会飞，但有一些不会。你可以将`Animal`类分成两个不同的类，比如`AnimalWhichCanFly`和`AnimalWhichCantFly`。然而，将`Animal`类分成两个可能会使事情变得过于复杂，因为这些动物可能还有其他不同的属性。因此，你可以使用组合而不是继承，在`Animal`类中添加一个名为`fly`的属性，并用它来指示这种行为。

策略模式规定，我们应该使用接口（如`IFly`）而不是固定类型`fly`作为属性类型，然后创建实现`IFly`并具有不同算法的`子类`。然后，我们可以利用多态性，在创建`Animal`类的子类时在运行时分配特定的子类。

让我们尝试在前面的例子中应用这一点。在`Animal`类中，我们将使用`IFly`而不是`Fly`属性，然后实现实现`IFly`的不同类。例如，我们创建`CanFly：IFly`和`CannotFly：IFly`类。`CanFly`和`CannotFly`将有不同的`Fly`方法实现。如果我们创建一个实现`Animal`类的`Dog`类，我们将把`Fly`属性设置为`CannotFly`类。如果我们创建一个`Bird`类，我们将创建`CanFly`的实例并将其分配给`Fly`属性。通过应用这种模式，我们实现了一个不那么复杂的对象结构和易于更改的算法。

# MVC 模式

MVC 模式是行业中最流行的设计模式之一。即使你是行业的新手，你可能已经听说过它。这种模式在 web 开发中被广泛使用。许多流行的 web 开发框架都使用这种设计模式。一些使用 MVC 模式的流行框架如下：

+   C#: ASP.NET MVC Web Framework

+   **Java:** Spring 框架

+   **PHP:** Laravel 框架，Codeigniter 框架

+   **Ruby:** Rails 框架

MVC 设计模式规定我们应该将 web 应用程序分为三个部分：

+   模型

+   视图

+   控制器

**模型** 是将保存数据模型或对象并用于数据库事务的部分。**视图** 指的是应用程序的前端，用户或客户所看到的部分。最后，**控制器** 是处理应用程序所有业务逻辑的部分。所有逻辑和决策部分都将在控制器中。

MVC 模式的好处是你的应用程序是解耦的。你的视图独立于你的业务逻辑，你的业务逻辑独立于你的数据源。这样，你可以轻松地更改应用程序的一部分而不影响应用程序的其他部分。

# 总结

软件开发很有趣，因为它一直在变化。你可以用许多方式来开发、设计或编写某些东西。这些方式都不能被归类为最好的方式，因为你的代码可能需要根据情况进行更改。然而，因为软件开发是一种工程类型，有各种规则可以使你的软件更加强大和可靠。软件设计原则和设计模式就是这些规则的例子。了解这些概念并将它们应用到你自己的情况中将会让你作为开发者的生活变得更加容易。

本章节希望给你一个设计模式基础的概念，并告诉你在哪里可以寻找更多信息。在下一章中，我们将了解一个非常强大和有趣的软件，叫做 Git。Git 是一个版本控制系统，可以帮助跟踪软件代码的变化。
