# 第一章：探索测试驱动开发

为了打造健壮、可维护和可扩展的软件应用程序，软件开发团队和利益相关者必须在软件开发过程的不同阶段早期做出一些重要决策。这些决策者必须在整个软件开发过程中采用软件行业经过测试和证明的最佳实践和标准。

当开发人员使用开发方法、编码风格和实践来构建代码库时，这些方法会自动使源代码变得僵化且难以维护，软件项目的质量会迅速下降。本章指出了导致编写糟糕代码的习惯和实践，因此应该避免。解释了应该学习的编程习惯、开发风格和方法，以便编写清洁和可维护的代码。

在本章中，我们将涵盖以下主题：

+   维护代码的困难

+   糟糕的代码是如何变成糟糕的

+   我们可以做些什么来防止糟糕的代码

+   测试驱动开发的原则

+   测试驱动开发周期

# 维护代码的困难

有两种类型的代码——好的代码和糟糕的代码。这两种类型的代码在编译时语法可能是正确的，运行代码可以得到预期的结果。然而，由于编写方式的原因，糟糕的代码在扩展或甚至对代码进行小改动时会导致严重问题。

当程序员使用不专业的方法和风格编写代码时，通常会导致糟糕的代码。此外，使用难以阅读的编码风格或格式，以及未能正确有效地测试代码都是糟糕代码的先兆。当程序员为了满足即将到来的截止日期和项目里程碑而牺牲专业精神时，代码可能会写得很糟糕。

我曾遇到一些软件项目，它们迅速成为被遗弃的遗留软件项目，因为不断出现的生产错误和无法轻松地满足用户的变更请求。这是因为这些软件应用程序在投入生产时积累了严重的技术债务，这是由于软件开发人员编写了糟糕的代码，导致了糟糕的设计和开发决策，并使用了已知会导致未来维护问题的编程风格。

源代码元素——方法、类、注释和其他工件——应该易于阅读、理解、调试、重构和扩展，如果需要由原始开发人员以外的其他开发人员进行；否则，糟糕的代码已经被编写。

当你在扩展或添加新功能时，你会知道你的代码有问题，因为你会破坏现有的工作功能。当代码部分无法解码或对其进行任何更改会使系统停止时，也会发生这种情况。糟糕的代码通常是因为不遵守面向对象和“不要重复自己”（DRY）原则或错误使用这些原则。

DRY 是编程中的一个重要原则，旨在将系统分解为小组件。这些组件可以轻松管理、维护和重复使用，以避免编写重复的代码并使代码的不同部分执行相同的功能。

# 糟糕的代码是如何出现的？

糟糕的代码不仅仅出现在代码库中；程序员写了糟糕的代码。大多数情况下，糟糕的代码可能是由于以下任何原因之一而写成的：

+   开发人员在编写代码时使用错误的方法经常被归因于组件之间的紧密耦合

+   错误的程序设计

+   程序元素和对象的糟糕命名约定

+   编写不可读的代码以及没有适当的测试用例的代码库，因此在需要维护代码库时会导致困难

# 紧密耦合

大多数传统软件应用程序都被认为是紧密耦合的，灵活性和模块化性很少或根本没有。紧密耦合的软件组件会导致刚性的代码库，难以修改、扩展和维护。随着大多数软件应用程序随着时间的推移而发展，当应用程序的组件紧密耦合时，会产生大量的维护问题。这是由于需求变化、用户业务流程和操作的变化所导致的。

第三方库和框架可以减少开发时间，并允许开发人员集中精力实施用户的业务逻辑和需求，而无需浪费宝贵的生产时间通过实现常见或乏味的任务来重新发明轮子。然而，有时开发人员会将应用程序与第三方库和框架紧密耦合，从而创建维护瓶颈，需要大力修复当需要替换引用的库或框架时。

以下代码片段显示了与第三方`smpp`库紧密耦合的示例：

```cs
public void SendSMS()
{
    SmppManager smppManager= new SmppManager(); 
    smppManager.SendMessage("0802312345","Hello", "John");
}

public class SmppManager
{
    private string sourceAddress;
    private SmppClient smppClient;

    public SmppManager()
    {
       smppClient = new SmppClient();
       smppClient.Start();            
    }        

    public void SendMessage(string recipient, string message, string senderName)
    {
       // send message using referenced library            
    }    
}
```

# 代码异味

**代码异味**是由*Kent Beck*首次使用的一个术语，它指出了源代码中的更深层次的问题。代码库中的代码异味可能来自于源代码中的复制、使用不一致或模糊的命名约定和编码风格、创建具有长参数列表的方法以及具有庞大方法和类，即知道并做太多事情，从而违反了单一责任原则。列表还在继续。

在源代码中常见的代码异味是当开发人员创建两个或更多执行相同操作的方法，几乎没有变化或在应该在单个点中实现的程序细节或事实在多个方法或类中复制，导致代码库难以维护。

以下两个 ASP.NET MVC 动作方法有代码行，创建了一个强类型的字符串年份和月份列表。这些代码行本来可以被重构为第三个方法，并被这两个方法调用，但却在这两个方法中被复制：

```cs
[HttpGet]
public ActionResult GetAllTransactions()
{
    List<string> years = new List<string>();
    for (int i = DateTime.Now.Year; i >= 2015; i--)
         years.Add(i.ToString());
    List<string> months = new List<string>();
    for (int j = 1; j <= 12; j++)
         months.Add(j.ToString());
    ViewBag.Transactions= GetTransactions(years,months);
     return View();
}

[HttpGet]
public ActionResult SearchTransactions()
{
    List<string> years = new List<string>();
    for (int i = DateTime.Now.Year; i >= 2015; i--)
         years.Add(i.ToString());
    List<string> months = new List<string>();
    for (int j = 1; j <= 12; j++)
        months.Add(j.ToString());
    ViewBag.Years = years;
    ViewBag.Months = months;
    return View();
}
```

另一个常见的代码异味出现在开发人员创建具有长参数列表的方法时，就像以下方法中所示：

```cs
public void ProcessTransaction(string  username, string password, float transactionAmount, string transactionType, DateTime time, bool canProcess, bool retryOnfailure)
{
    //Do something
}
```

# 坏或破损的设计

在实施应用程序时，经常会出现结构或设计和模式导致糟糕的代码，尤其是在错误使用面向对象编程原则或设计模式时。一个常见的反模式是**意大利面条式编码**。这在对面向对象理解不深的开发人员中很常见，这涉及创建具有不清晰结构、几乎没有可重用性以及对象和组件之间没有关系的代码库。这导致应用程序难以维护和扩展。

在经验不足的开发人员中有一种常见的做法，即在解决应用程序复杂性时不必要或不适当地使用设计模式。当错误使用设计模式时，会给代码库带来糟糕的结构和设计。使用设计模式应该简化复杂性，并为软件问题创建可读和可维护的解决方案。当某个模式导致可读性问题并明显增加了程序的复杂性时，值得重新考虑是否使用该模式，因为该模式被误用了。

例如，单例模式用于创建对资源的单个实例。单例类的设计应该有一个私有构造函数，没有参数，一个静态变量引用资源的单个实例，以及一个管理的公共手段来引用静态变量。单例模式可以简化对单一共享资源的访问，但如果没有考虑线程安全性，也可能会导致很多问题。两个或更多线程可以同时访问`if (smtpGateway==null)`这一行，如果这行被评估为`true`，就会创建资源的多个实例，就像下面代码中所示的实现一样：

```cs
public class SMTPGateway
{
    private static SMTPGateway smtpGateway=null;

    private SMTPGateway()
    {
    }

    public static SMTPGateway SMTPGatewayObject
    {
        get
        {
            if (smtpGateway==null)
            {
                smtpGateway = new SMTPGateway();
            }
            return smtpGateway;
        }
    }
} 
```

# 命名程序元素

有意义和描述性的元素命名可以极大地提高源代码的可读性。它可以让程序的逻辑流程更容易理解。令人惊讶的是，软件开发人员仍然会给程序元素起太短或者不够描述性的名字，比如给变量起一个字母的名字，或者使用缩写来命名变量。

对元素使用通用或模糊的名称会导致歧义。例如，将一个方法命名为`Extract()`或`Calculate()`，乍一看会导致主观解释。对变量使用模糊的名称也是如此。例如：

```cs
int x2;

string xxya;
```

虽然程序元素的命名本身就是一门艺术，但是名称应该被选择来定义目的，并简要描述元素，并确保所选名称符合所使用的编程语言的标准和规则。

有关可接受的命名准则和约定的更多信息，请访问：[`docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines`](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines)。

# 源代码的可读性

一个良好的代码库可以通过一个新团队成员或者甚至是程序员在离开几年后能够轻松理解来轻松区分出一个糟糕的代码库。由于时间紧迫和截止日期临近，软件开发团队往往会妥协和牺牲专业精神来满足截止日期，不遵循推荐的最佳实践和标准。这经常导致他们产生不可读的代码。

以下代码片段将执行其预期的功能，尽管其中包含使用糟糕的命名约定编写的元素，这影响了代码的可读性：

```cs
public void updatetableloginentries()
{
   com.Connection = conn;
   SqlParameter par1 = new SqlParameter();
   par1.ParameterName = "@username";
   par1.Value = main.username;
   com.Parameters.Add(par1);
   SqlParameter par2 = new SqlParameter();
   par2.ParameterName = "@date";
   par2.Value = main.date;
   com.Parameters.Add(par2);
   SqlParameter par3 = new SqlParameter();
   par3.ParameterName = "@logintime";
   par3.Value = main.logintime;
   com.Parameters.Add(par3);
   SqlParameter par4 = new SqlParameter();
   par4.ParameterName = "@logouttime";
   par4.Value = DateTime.Now.ToShortTimeString(); ;
   com.Parameters.Add(par4);
   com.CommandType = CommandType.Text;
   com.CommandText = "update loginentries set logouttime=@logouttime where username=@username and date=@date and logintime=@logintime";
   openconn();
   com.ExecuteNonQuery();
   closeconn();
}
```

# 糟糕的源代码文档

当使用编程语言的编码风格和约定编写代码时，可以很容易地理解代码，同时避免之前讨论过的糟糕的代码陷阱。然而，源代码文档非常有价值，在软件项目中的重要性不可低估。对类和方法进行简要而有意义的文档编写可以让开发人员快速了解它们的内部结构和操作。

当没有适当的文档时，理解复杂或写得不好的类会变成一场噩梦。当原始编写代码的程序员不再提供澄清时，宝贵的生产时间可能会因为试图理解类或方法的实现而丢失。

# 未经测试的代码

尽管已经有很多文章和讨论在各种开发者会议上启动了不同类型的测试——测试驱动开发、行为驱动开发和验收测试驱动开发，但令人担忧的是，仍然有开发人员不断开发和发布未经彻底测试或根本没有经过测试的软件应用程序。

发布未经充分测试的应用程序可能会产生灾难性后果和维护问题。值得注意的是**美国国家航空航天局**于**1998 年 12 月 11 日**发射的**火星气候轨道飞行器**在接近火星时失败，原因是由于转换错误导致的软件错误，其中轨道飞行器的程序代码在计算时使用的是磅而不是牛顿。对负责计算度量标准的特定模块进行简单的单元测试可能会检测到错误并可能防止失败。

此外，根据 2016 年*测试优先方法的现状报告*，由名为**QASymphony**的测试服务公司对来自 15 个不同国家的 200 多家软件组织的测试优先方法的采用进行了调查，结果显示近一半的受访者在他们开发的应用程序中没有实施测试优先方法。

# 我们可以做些什么来防止糟糕的代码

编写干净的代码需要有意识地保持专业精神，并在软件开发过程的各个阶段遵循最佳行业标准。从软件项目开发的一开始就应该避免糟糕的代码，因为通过糟糕的代码积累的坏账可能会减慢软件项目的完成速度，并在软件部署到生产环境后造成未来问题。

要避免糟糕的代码，你必须懒惰，因为一般说来懒惰的程序员是最好的和最聪明的程序员，因为他们讨厌重复的任务，比如不得不回去修复本可以避免的问题。尽量使用避免编写糟糕代码的编程风格和方法，以避免不得不重写代码以修复可避免的问题、错误或支付技术债务。

# 松散耦合

**松散耦合**是紧密耦合的直接相反。这是一种良好的面向对象编程实践，通过允许组件几乎不知道其他组件的内部工作和实现来实现关注点的分离。通信是通过接口进行的。这种方法允许轻松替换组件，而不需要对整个代码库进行太多更改。在*紧耦合*部分的示例代码可以重构以实现松散耦合：

```cs
//The dependency injection would be done using Ninject
public ISmppManager smppManager { get; private set; }

public void SendSMS()
{    
    smppManager.SendMessage("0802312345","Hello", "John");
}

public class SmppManager
{
    private string sourceAddress;
    private SmppClient smppClient;

    public SmppManager()
    {
       smppClient = new SmppClient();
       smppClient.Start();            
    }        

    public void SendMessage(string recipient, string message, string senderName)
    {
       // send message using referenced library            
    }    
}
public interface ISmppManager
{
    void SendMessage(string recipient, string message, string senderName);
}
```

# 声音架构和设计

通过使用良好的开发架构和设计策略可以避免糟糕的代码。这将确保开发团队和组织具有高级架构、策略、实践、准则和治理计划，团队成员必须遵循以防止走捷径和避免在整个开发过程中出现糟糕的代码。

通过持续学习和改进，软件开发团队成员可以对编写糟糕的代码产生厚厚的皮肤。*糟糕或破损的设计*部分中的示例代码片段可以重构为线程安全，并避免与线程相关的问题，如下所示：

```cs
public class SMTPGateway
{
    private static SMTPGateway smtpGateway=null;
    private static object lockObject= new object();

    private SMTPGateway()
    {
    }

    public static SMTPGateway SMTPGatewayObject
    {
        get
        {
            lock (lockObject)
            {
                if (smtpGateway==null)
                {
                    smtpGateway = new SMTPGateway();
                }
            }
            return smtpGateway;
        }
    }
} 
```

# 预防和检测代码异味

应该避免导致代码异味的编程风格和编码格式。通过充分关注*代码异味*部分中讨论的糟糕代码指针，可以避免代码的重复。在*代码异味*部分提到的源代码的两种方法中的重复代码可以重构为第三种方法。这样可以避免代码的重复，并且可以轻松进行修改：

```cs
[HttpGet]
public ActionResult GetAllTransactions()
{
    var yearsAndMonths=GetYearsAndMonths();
    ViewBag.Transactions= GetTransactions(yearsAndMonths.Item1,yearsAndMonths.Item2);
    return View();
}

[HttpGet]
public ActionResult SearchTransactions()
{
    var yearsAndMonths=GetYearsAndMonths();
    ViewBag.Years = yearsAndMonths.Item1;
    ViewBag.Months = yearsAndMonths.Item2;
    return View();
}

private (List<string>, List<string>) GetYearsAndMonths(){
    List<string> years = new List<string>();
    for (int i = DateTime.Now.Year; i >= 2015; i--)
         years.Add(i.ToString());
    List<string> months = new List<string>();
    for (int j = 1; j <= 12; j++)
        months.Add(j.ToString());
    return (years,months);
}
```

此外，在*代码异味*部分中具有长参数列表的方法可以重构为使用**C# Plain Old CLR Object**（**POCO**）以实现清晰和可重用性：

```cs
public void ProcessTransaction(Transaction transaction)
{
    //Do something
}

public class Transaction
{
    public string  Username{get;set;}
    public string Password{get;set;}
    public float TransactionAmount{get;set;}
    public string TransactionType{get;set;}
    public DateTime Time{get;set;}
    public bool CanProcess{get;set;}
    public bool RetryOnfailure{get;set;}    
}
```

开发团队应该有由团队成员共同制定的准则、原则和编码约定和标准，并应不断更新和完善。有效使用这些将防止软件代码库中的代码异味，并允许团队成员轻松识别潜在的糟糕代码。

# C#编码约定

遵循 C#编码约定指南有助于掌握编写清晰、可读、易于修改和易于维护的代码。使用描述性的变量名称，代表它们的用途，如下面的代码所示：

```cs
int accountNumber;

string firstName;
```

此外，一行上有多个语句或声明会降低可读性。注释应该在新的一行上，而不是在代码的末尾。您可以在以下链接了解更多关于 C#编码约定的信息：[`docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions`](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions)。

# 简洁而恰当的文档

您应该始终尝试编写自解释的代码。这可以通过良好的编程风格实现。以这样一种方式编写代码，使得您的类、方法和其他对象都是自解释的。新的开发人员应该能够使用您的代码，而不必在理解代码及其内部结构之前感到紧张。

编码元素应该具有描述性和意义，以向读者提供洞察力。在必须记录方法或类以提供进一步澄清的情况下，采用“保持简单”的方法，简要说明某个决定的原因。检查以下代码片段；没有人希望为包含 200 行代码的类阅读两页文档：

```cs
///
/// This class uses SHA1 algorithm for encryption with randomly generated salt for uniqueness
///
public class AESEncryptor
{
    //Code goes here
}
```

KISS，也称为“保持简单，愚蠢”，是一种设计原则，它指出大多数系统在保持简单而不是使其不必要地复杂时运行得最好。该原则旨在帮助程序员尽可能简化代码，以确保未来可以轻松维护代码。

# 为什么要进行测试驱动开发？

每当我与不实践测试驱动开发的人进行讨论时，他们通常有一个共同点，那就是它消耗时间和资源，而且并不能真正带来投资回报。我通常会回答他们，问哪个更好，即在应用程序开发过程中检测错误和潜在瓶颈并修复它们，还是在应用程序处于生产状态时进行热修复？测试驱动开发将为您节省大量问题，并确保您生成健壮且无故障的应用程序。

# 面向长期发展

为了避免由于用户需求变化而对系统进行修改时可能导致的未来问题，以及由于代码库中固有的糟糕代码和累积的技术债务而暴露的错误，您需要具有以未来为考量并接受变化的思维方式。

使用灵活的模式，并且在编写代码时始终遵循良好的面向对象开发和设计原则。大多数软件项目的需求在其生命周期内都会发生变化。假设某个组件或部分不会发生变化是错误的，因此请尝试建立一个机制，使应用程序能够优雅地接受未来的变化。

# 测试驱动开发的原则

测试驱动开发（TDD）是一种迭代的敏捷开发技术，强调先测试开发，这意味着在编写生产就绪的代码之前编写测试。TDD 技术侧重于通过不断重构代码来确保代码通过先前编写的测试，从而编写干净和高质量的代码。

TDD 作为一种先测试的开发方法，更加强调构建经过充分测试的软件应用程序。这使开发人员能够根据在经过深思熟虑后定义的测试任务来编写代码。在 TDD 中，常见的做法是在编写实际应用程序代码之前编写测试代码。

TDD 引入了一个全新的开发范式，并改变了你的思维方式，开始在甚至开始编写代码之前考虑测试你的代码。这与传统的开发技术相反，传统技术将代码测试推迟到开发周期的后期阶段，这种方法被称为**最后测试开发**（**TLD**）。

TDD 已经在多个会议和黑客马拉松上进行了讨论。许多技术倡导者和博客作者都在博客中讨论了 TDD、它的原则和好处。与此同时，也有许多关于 TDD 的演讲和文章。诚实的事实是 TDD 很棒，它有效，当正确和一贯地实践时，它提供了巨大的好处。

你可能会想，就像每个新接触 TDD 的开发人员一样，为什么要先写测试，因为你相信自己的编码直觉可以编写始终有效的干净代码，并且通常在编码完成后会测试整个代码。你的编码直觉可能是正确的，也可能不是。在代码通过一组书面测试用例并通过验证之前，没有办法验证这个假设；信任是好的，但控制更好。

TDD 中的测试用例是通过用户故事或正在开发的软件应用程序的用例来准备的。然后编写代码并进行迭代重构，直到测试通过。例如，编写用于验证信用卡长度的方法可能包含用例来验证正确长度、不正确长度，甚至当空或空信用卡作为参数传递给方法时。

自 TDD 最初被推广以来，已经提出了许多变体。其中一种是**行为驱动开发**（**BDD**）或**验收测试驱动开发**（**ATDD**），它遵循 TDD 的所有原则，而测试是基于预期的用户指定行为。

# TDD 的起源

关于 TDD 实践是何时引入计算机编程或者是哪家公司首先使用的，实际上没有任何书面证据。然而，1957 年 D.D. McCracken 的《数字计算机编程》中有一段摘录，表明 TDD 的概念并不新鲜，早期的人们已经使用过，尽管名称显然不同。

在编码开始之前，可能会对结账问题进行第一次攻击。为了充分确定答案的准确性，有必要准备一个手工计算的检查案例，以便将来与机器计算的答案进行比较。这意味着存储程序机永远不会用于真正的一次性问题。总是必须有迭代的元素来使其付出。

此外，在 1960 年代初，IBM 的人们为 NASA 运行了一个项目（**Project Mecury**），他们利用了类似 TDD 的技术，进行了半天的迭代，并且开发团队对所做的更改进行了审查。这是一个手动过程，无法与我们今天拥有的自动化测试相比。

TDD 最初是由 Kent Beck 推广的。他将其归因于他在一本古老书中读到的一段摘录，其中 TDD 被描述为简单的陈述，*你拿输入磁带，手动输入你期望的输出磁带，然后编程直到实际输出磁带与期望输出相匹配*。当他在 Smalltalk 开发了第一个 xUnit 测试框架时，Kent Beck 重新定义了 TDD 的概念。

可以肯定地说，Smalltalk 社区在 TDD 变得普遍之前就已经使用了 TDD，因为社区中使用了**SUnit**。直到*Kent Beck*和其他爱好者将 SUnit 移植到**JUnit**之后，TDD 才变得广为人知。从那时起，不同的测试框架已经被开发出来。一个流行的工具是**xUnit**，可以为大量编程语言提供端口。

# TDD 的误解

在涉及 TDD 时，开发人员有不同的观点。大多数开发人员抱怨完全实践 TDD 所需的时间和资源，以及实践 TDD 可能不可行，基于紧迫的截止日期和时间表。这种看法在刚刚采用该技术的开发人员中很常见，因为 TDD 需要编写双倍的代码，而这些时间本可以用来开发其他功能，而且 TDD 最适合具有小功能或任务的项目，对于大型项目来说，可能会浪费时间，回报很少。

此外，一些开发人员抱怨模拟可能会使 TDD 变得非常困难和令人沮丧，因为所需的依赖关系不应该在实现依赖代码的同时实现，而应该进行模拟。使用传统的测试最后的方法，可以实现依赖关系，然后可以测试代码的所有不同部分。

另一个常见的误解是，在真正意义上，直到确定设计依赖于代码实现之前，测试才不能被编写。这是不正确的，因为采用 TDD 将确保对代码实现的计划清晰明了，从而产生一个适当的设计，可以帮助编写高效可靠的测试。

有时候，一些人会将 TDD 和单元测试混为一谈，认为它们是一样的。TDD 和单元测试并不相同。单元测试涉及在最小的编码单元或级别上实践 TDD，这是一种方法或函数，而 TDD 是一种技术和设计方法，包括单元测试、集成测试以及验收测试。

刚接触 TDD 的开发人员经常认为在编写实际代码之前必须完全编写测试。事实恰恰相反，因为 TDD 是一种迭代技术。TDD 倾向于探索性过程，你编写测试并编写足够的代码。如果失败，就重构代码直到通过，然后可以继续实现应用程序的下一个功能。

TDD 并不是一个可以自动修复所有糟糕编码行为的灵丹妙药。你可以实践 TDD，但仍然编写糟糕的代码甚至糟糕的测试。如果没有正确使用 TDD 原则和实践，或者试图在不适合使用 TDD 的地方使用 TDD，这是可能的。

# TDD 的好处

TDD，如果正确和适当地完成，可以带来良好的投资回报，因为它有助于开发自测代码，从而产生具有更少或没有错误的健壮软件应用程序。这是因为大部分可能出现在生产中的错误和问题在开发阶段已经被捕捉和修复了。

除了源代码文档，编写测试也是一种良好的编码实践，因为它们作为源代码的微型文档，可以快速理解代码的工作原理。测试将显示预期的输入以及预期的输出或结果。从测试中可以轻松理解应用程序的结构，因为所有对象都将有测试，以及对象方法的测试，显示它们的使用方式。

正确和持续地实践 TDD 有助于编写具有良好抽象、灵活设计和架构的优雅代码。这是因为，为了有效地测试应用程序的所有部分，各种依赖关系需要被分解成可以独立测试的组件，并在集成后进行测试。

代码的清晰性在于使用最佳行业标准编写代码，易于维护，可读性强，并且编写了用于验证其一致行为的测试。这表明没有测试的代码是糟糕的代码，因为没有直接验证其完整性的特定方式。

# 测试的类型

测试软件项目可以采用不同的形式，通常由开发人员和测试分析员或专家进行。测试是为了确定软件是否符合其指定的期望，如果可能的话，识别错误，并验证软件是否可用。大多数程序员通常认为测试和调试是一样的。调试是为了诊断软件中的错误和问题，并采取可能的纠正措施。

# 单元测试

这是测试的一个级别，涉及测试构成软件应用程序组件的每个单元。这是测试的最低级别，它在方法或函数级别进行。它主要由程序员完成，特别是为了显示代码的正确性和要求是否已经正确实现。单元测试通常具有一个或多个输入和输出。

这是通常在软件开发中进行的第一级测试，旨在隔离软件系统的单元并独立或隔离地测试它们。通过单元测试，系统中固有的问题和错误可以在开发过程的早期轻松检测到。

# 集成测试

集成测试是通过组合和测试不同的单元或组件来完成的，这些单元或组件必须在隔离状态下进行测试。这个测试是为了确保应用程序的不同单元可以共同工作以满足用户的需求。通过集成测试，您可以在不同组件交互和交换数据时发现系统中的错误。

这项测试可以由程序员、软件测试人员或质量保证分析员进行。可以使用不同的方法进行集成测试：

+   **自上而下**：在较低级别组件之前，先集成和测试顶层组件

+   **自下而上**：在顶层组件之前，先集成和测试较低级别的组件

+   **大爆炸**：所有组件一起集成并一次性测试

# 系统测试

这个测试级别是您验证整个集成系统以确保其符合指定的用户需求。这个测试通常在集成测试之后立即进行，由专门的测试人员或质量保证分析员进行。

整个软件系统套件是从用户的角度进行测试，以识别隐藏的问题或错误和可用性问题。对实施的系统进行了严格的测试，使用系统应处理的真实输入，并验证输出是否符合预期数据。

# 用户验收测试

用户验收测试通常用于指定软件应用程序的工作方式。这些测试是为业务用户和程序员编写的，用于确定系统是否符合期望和用户特定要求，以及系统是否根据规格完全和正确地开发。这项测试由最终用户与系统开发人员合作进行，以确定是否正式接受系统或进行调整或修改。

# TDD 的原则

TDD 的实践有助于设计清晰的代码，并作为大型代码库中回归的缓冲。它允许开发人员轻松确定新实施的功能是否通过运行测试时获得的即时反馈破坏了先前正常工作的其他功能。TDD 的工作原理如下图所示：

![](img/8df88590-65cc-4355-8b98-a6d3a80abea2.png)

# 编写测试

这是技术的初始步骤，您必须编写描述要开发的组件或功能的测试。组件可以是用户界面、业务规则或逻辑、数据持久性例程，或实现特定用户需求的方法。测试需要简洁，并应包含组件测试所需的数据输入和期望的预期结果。

在编写测试时，从技术上讲，你已经解决了一半的开发任务，因为通过编写测试来构思代码的设计。在编写的测试之后，更容易处理困难的代码，这就是已经编写的测试。在这一点上，作为 TDD 新手，不要期望测试是 100%完美或具有完整的代码覆盖率，但通过持续的练习和充分的重构，这是可以实现的。

# 编写代码

在编写完测试之后，你应该编写足够的代码来实现之前编写的测试所需的功能。请记住，这里的目标是尽量采用良好的实践和标准来编写代码，以使测试通过。应避免所有导致编写糟糕或糟糕代码的方法。

尽量避免测试过度拟合，即为了使测试通过而编写代码的情况。相反，你应该编写代码来实现功能或用户需求，以确保覆盖功能的每种可能用例，避免代码在测试用例执行和生产环境中执行时具有不同的行为。

# 运行测试

当你确信已经有足够的代码使测试通过时，你应该运行测试，使用你选择的测试套件。此时，测试可能会通过或失败。这取决于你如何编写代码。

TDD 的一个基本规则是多次运行测试，直到测试通过。最初，在代码完全实现之前运行测试时，测试将失败，这是预期的行为。

# 重构

为了实现完整的代码覆盖率，测试和源代码都必须进行重构和多次测试，以确保编写出健壮且干净的代码。重构应该是迭代的，直到实现完整的覆盖率。重构步骤应该删除代码中的重复部分，并尝试修复任何代码异味的迹象。

TDD 的本质是编写干净的代码，从而构建可靠的应用程序，这取决于所编写的测试类型（单元测试、验收测试或集成测试）。重构可以局部地影响一个方法，也可以影响多个类。例如，在重构一个接口或一个类中的多个方法时，建议您逐渐进行更改，一次一个测试，直到所有测试及其实现代码都被重构。

# 以错误的方式进行 TDD

尽管练习 TDD 可能很有趣，但也可能被错误地执行。对于 TDD 新手来说，有时可能会编写过大的怪物测试，这远远超出了测试简洁性和能够快速执行 TDD 循环的目的，导致了生产开发时间的浪费。

部分采用该技术也可能减少 TDD 的全部好处。在团队中只有少数开发人员使用该技术而其他人不使用的情况下，这将导致代码片段化，其中一部分代码经过测试，另一部分没有经过测试，从而导致应用程序不可靠。

应避免为自然微不足道或不需要的代码编写测试；例如，为对象访问器编写测试。测试应该经常运行，特别是通过测试运行器、构建工具或持续集成工具。不经常运行测试可能导致情况，即即使已经进行了更改并且组件可能失败，代码基地的真实状态也不为人所知。

# TDD 循环

TDD 技术遵循一个被称为红-绿-重构循环的原则，红色状态是初始状态，表示 TDD 循环的开始。在红色状态下，测试刚刚被编写，并且在运行时将失败。

下一个状态是绿色状态，它显示在实际应用代码编写后测试已通过。重构代码是确保代码完整性和健壮性的重要步骤。重构将反复进行，直到代码满足性能和需求期望为止。

![](img/ddddbd5c-0bb6-4cba-b577-c1f53eefe39b.png)

在周期开始时，尚未编写用于运行测试的生产代码，因此预计测试将失败。例如，在以下代码片段中，`IsServerOnline`方法尚未实现，当运行`Test_IsServerOnline_ShouldReturnTrue`单元测试方法时，它应该失败。

```cs
public bool IsServerOnline()
{
    return false;
}

 [Fact]
 public void Test_IsServerOnline_ShouldReturnTrue() 
 { 
    bool isOnline=IsServerOnline();   

    Assert.True(isOnline);
 }
```

为了使测试通过，您必须迭代实现生产代码。当实现以下`IsServerOnline`方法时，预期`Test_IsServerOnline_ShouldReturnTrue`测试方法将通过。

```cs
public bool IsServerOnline()
{
    string address="localhost";
    int port=8034;
    SmppManager smppManager= new SmppManager(address, port); 
    bool isOnline=smppManager.TestConnection();
    return isOnline;
}

 [Fact]
 public void Test_IsServerOnline_ShouldReturnTrue() 
 { 
    bool isOnline=IsServerOnline();   

    Assert.True(isOnline);
 }
```

当测试运行并通过时，根据您使用的测试运行器显示绿色，这会立即向您提供有关代码状态的反馈。这让您对代码的正确运行和预期行为感到自信和内心的喜悦。

重构是一个迭代的努力，您将不断修改先前编写的代码以通过测试，直到它达到了生产就绪状态，并且完全实现了需求，并且适用于所有可能的用例和场景。

# 总结

通过本章讨论的原则和编码模式，可以避免大多数潜在的软件项目维护瓶颈。成为专业人士需要保持一致性，要有纪律性，并坚持良好的编码习惯、实践，并对 TDD 持有专业态度。

编写易于维护的清晰代码将在长期内得到回报，因为将需要更少的工作量来进行用户请求的更改，并且当应用程序始终可供使用且几乎没有错误时，用户将感到满意。

在下一章中，我们将探索.NET Core 框架及其能力和局限性。此外，我们将在审查 C#编程语言的第 7 版中介绍的新功能之前，先了解 Microsoft Visual Studio Code。
