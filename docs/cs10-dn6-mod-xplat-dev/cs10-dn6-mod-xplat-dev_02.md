# 第二章：说 C#

本章主要介绍 C#编程语言的基础知识。在本章的过程中，您将学习如何使用 C#的语法编写语句，以及一些您每天都会使用的常见词汇。此外，在本章结束时，您将自信地知道如何在计算机内存中临时存储和处理信息。

本章涵盖了以下主题：

+   介绍 C#语言

+   理解 C#语法和词汇

+   使用变量

+   更多关于控制台应用程序的探索

# 介绍 C#语言

本书的这部分是关于 C#语言的——您每天都会用来为应用程序编写源代码的语法和词汇。

编程语言与人类语言有许多相似之处，只是在编程语言中，您可以编造自己的词，就像苏斯博士一样！

在 1950 年由苏斯博士撰写的一本书《如果我经营动物园》，他说：

> “然后，只是为了向他们展示，我将航行到卡特鲁，带回一个伊特库奇，一个普里普和一个普鲁，一个纳克尔，一个书呆子，还有一件粗花呢外套！”

## 了解语言版本和功能

本书的这部分涵盖了 C#编程语言，主要是为初学者编写的，因此涵盖了所有开发人员需要了解的基本主题，从声明变量到存储数据，再到如何定义自己的自定义数据类型。

本书涵盖了 C#语言从 1.0 版本到最新的 10.0 版本的特性。

如果您已经对旧版本的 C#有一定了解，并且对最新版本的 C#的新功能感到兴奋，我已经为您列出了语言版本及其重要的新功能，以及您可以了解它们的章节编号和主题标题，以便您更轻松地跳转。

### C# 1.0

C# 1.0 于 2002 年发布，包括了所有重要的静态类型面向对象的现代语言的特性，正如您将在*第 2*至*第 6*章中看到的。

### C# 2.0

C# 2.0 于 2005 年发布，重点是使用泛型实现强大的数据类型，以提高代码性能并减少类型错误，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 可空值类型 | 6 | 使值类型可为空 |
| 泛型 | 6 | 使用泛型使类型更可重用 |

### C# 3.0

C# 3.0 于 2007 年发布，重点是通过**语言集成查询**（**LINQ**）和相关功能，如匿名类型和 lambda 表达式，实现声明式编码，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 隐式类型的局部变量 | 2 | 推断局部变量的类型 |
| LINQ | 11 | *第十一章*中的所有主题，*使用 LINQ 查询和操作数据* |

### C# 4.0

C# 4.0 于 2010 年发布，重点是改进与 F#和 Python 等动态语言的互操作性，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 动态类型 | 2 | 存储动态类型 |
| 命名/可选参数 | 5 | 可选参数和命名参数 |

### C# 5.0

C# 5.0 于 2012 年发布，重点是通过自动实现复杂状态机来简化异步操作支持，同时编写看起来像同步语句的内容，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 简化的异步任务 | 12 | 理解 async 和 await |

### C# 6.0

C# 6.0 于 2015 年发布，重点是对语言进行微小的改进，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| `static`导入 | 2 | 简化控制台的使用 |
| 插值字符串 | 2 | 向用户显示输出 |
| 表达式主体成员 | 5 | 定义只读属性 |

### C# 7.0

C# 7.0 于 2017 年 3 月发布，重点是添加元组和模式匹配等功能语言特性，以及对语言的一些微小改进，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 二进制文字和数字分隔符 | 2 | 存储整数 |
| 模式匹配 | 3 | 使用`if`语句进行模式匹配 |
| `out`变量 | 5 | 控制参数传递方式 |
| 元组 | 5 | 使用元组组合多个值 |
| 本地函数 | 6 | 定义本地函数 |

### C# 7.1

C# 7.1 于 2017 年 8 月发布，重点是对语言进行微小改进，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 默认文字表达式 | 5 | 使用默认文字设置字段 |
| 推断元组元素名称 | 5 | 推断元组名称 |
| `async` Main | 12 | 改善控制台应用程序的响应性 |

### C# 7.2

C# 7.2 于 2017 年 11 月发布，重点是对语言进行微小改进，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 数字文字中的前导下划线 | 2 | 存储整数 |
| 非尾随命名参数 | 5 | 可选参数和命名参数 |
| `private protected`访问修饰符 | 5 | 理解访问修饰符 |
| 您可以使用元组类型测试`==`和`!=` | 5 | 比较元组 |

### C# 7.3

C# 7.3 于 2018 年 5 月发布，重点是性能导向的安全代码，改进了`ref`变量、指针和`stackalloc`。这些对大多数开发人员来说是高级且很少需要的，因此本书不涵盖它们。

### C# 8

C# 8 于 2019 年 9 月发布，重点是与空处理相关的语言的重大变化，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 可空引用类型 | 6 | 使引用类型可为空 |
| 开关表达式 | 3 | 使用开关表达式简化`switch`语句 |
| 默认接口方法 | 6 | 理解默认接口方法 |

### C# 9

C# 9 于 2020 年 11 月发布，重点是记录类型、模式匹配的改进以及最小代码控制台应用程序，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 最小代码控制台应用程序 | 1 | 顶级程序 |
| 目标类型的新 | 2 | 使用目标类型的新来实例化对象 |
| 增强模式匹配 | 5 | 对象的模式匹配 |
| 记录 | 5 | 使用记录 |

### C# 10

C# 10 于 2021 年 11 月发布，重点是在常见场景中最小化所需代码量的功能，包括以下表中列出的主题：

| 功能 | 章节 | 主题 |
| --- | --- | --- |
| 全局命名空间导入 | 2 | 导入命名空间 |
| 常量字符串文字 | 2 | 使用插值字符串进行格式化 |
| 文件范围命名空间 | 5 | 简化命名空间声明 |
| 必需属性 | 5 | 要求在实例化期间设置属性 |
| 记录结构 | 6 | 使用记录结构类型 |
| 空参数检查 | 6 | 检查方法参数是否为空 |

## 理解 C#标准

多年来，微软向标准机构提交了几个版本的 C#，如下表所示：

| C#版本 | ECMA 标准 | ISO/IEC 标准 |
| --- | --- | --- |
| 1.0 | ECMA-334:2003 | ISO/IEC 23270:2003 |
| 2.0 | ECMA-334:2006 | ISO/IEC 23270:2006 |
| 5.0 | ECMA-334:2017 | ISO/IEC 23270:2018 |

C# 6 的标准仍然是草案，正在进行添加 C# 7 功能的工作。微软于 2014 年将 C#开源。

目前有三个公共的 GitHub 存储库，使 C#和相关技术的工作尽可能地开放，如下表所示：

| 描述 | 链接 |
| --- | --- |
| C#语言设计 | [`github.com/dotnet/csharplang`](https://github.com/dotnet/csharplang) |
| 编译器实现 | [`github.com/dotnet/roslyn`](https://github.com/dotnet/roslyn) |
| 用于描述语言的标准 | [`github.com/dotnet/csharpstandard`](https://github.com/dotnet/csharpstandard) |

## 发现您的 C#编译器版本

.NET 语言编译器 C#和 Visual Basic，以及 F#的单独编译器，也称为 Roslyn，与.NET SDK 的一部分一起分发。要使用特定版本的 C#，您必须至少安装该版本的.NET SDK，如下表所示：

| .NET SDK | Roslyn 编译器 | 默认 C#语言 |
| --- | --- | --- |
| 1.0.4 | 2.0 - 2.2 | 7.0 |
| 1.1.4 | 2.3 - 2.4 | 7.1 |
| 2.1.2 | 2.6 - 2.7 | 7.2 |
| 2.1.200 | 2.8 - 2.10 | 7.3 |
| 3.0 | 3.0 - 3.4 | 8.0 |
| 5.0 | 3.8 | 9.0 |
| 6.0 | 3.9 - 3.10 | 10.0 |

当您创建类库时，您可以选择将其目标设置为.NET 标准以及现代.NET 的版本。它们具有默认的 C#语言版本，如下表所示：

| .NET 标准 | C# |
| --- | --- |
| 2.0 | 7.3 |
| 2.1 | 8.0 |

### 如何输出 SDK 版本

让我们看看您有哪些可用的.NET SDK 和 C#语言编译器版本：

1.  在 macOS 上，启动**Terminal**。在 Windows 上，启动**命令提示符**。

1.  要确定您有哪个版本的.NET SDK 可用，请输入以下命令：

```cs

dotnet --version

```

1.  请注意，撰写时的版本是 6.0.100，表明这是 SDK 的初始版本，尚未进行任何错误修复或新功能添加，如下面的输出所示：

```cs

6.0.100

```

### 启用特定版本的语言编译器

像 Visual Studio 和`dotnet`命令行界面这样的开发工具默认假定您想要使用最新的 C#语言编译器的主要版本。在 C# 8.0 发布之前，C# 7.0 是最新的主要版本，并且默认情况下使用。要使用 C# 7.1、7.2 或 7.3 这样的 C#点发布的改进，您必须向项目文件添加`<LangVersion>`配置元素，如下面的标记所示：

```cs

<LangVersion>7.3

</LangVersion>

```

在发布了带有.NET 6.0 的 C# 10.0 之后，如果微软发布了 C# 10.1 编译器，并且您想要使用其新的语言特性，那么您将不得不向项目文件添加一个配置元素，如下面的标记所示：

```cs

<LangVersion>10.1

</LangVersion>

```

`<LangVersion>`的潜在值如下表所示：

| LangVersion | 描述 |
| --- | --- |
| 7, 7.1, 7.2, 7.38, 9, 10 | 输入特定版本号将使用已安装的编译器。 |
| latestmajor | 使用最高主要号，例如，2019 年 8 月为 7.0，2019 年 10 月为 8.0，2020 年 11 月为 9.0，2021 年 11 月为 10.0。 |
| `latest` | 使用最高主要号和最高次要号，例如，2017 年为 7.2，2018 年为 7.3，2019 年为 8，也许 2022 年初为 10.1。 |
| `preview` | 使用最高可用的预览版本，例如，2021 年 7 月安装了.NET 6.0 预览 6 时的 10.0。 |

创建新项目后，您可以编辑`.csproj`文件并添加`<LangVersion>`元素，如下面标记中突出显示的那样：

```cs

<Project Sdk="Microsoft.NET.Sdk"

<PropertyGroup>

<OutputType>Exe</OutputType>

<TargetFramework>net6.0

</TargetFramework>

**<LangVersion>preview</LangVersion>**

</PropertyGroup>

</Project>

```

您的项目必须以`net6.0`为目标，才能使用 C# 10 的全部功能。

**良好实践**：如果您使用 Visual Studio Code，并且尚未这样做，请安装名为**MSBuild 项目工具**的 Visual Studio Code 扩展。这将在编辑`.csproj`文件时为您提供智能感知，包括轻松添加带有适当值的`<LangVersion>`元素。

# 理解 C#语法和词汇

要学习简单的 C#语言特性，您可以使用.NET 交互式笔记本，它消除了创建任何类型的应用程序的需要。

要了解其他 C#语言特性，您需要创建一个应用程序。最简单的应用程序类型是控制台应用程序。

让我们从基本的 C#语法和词汇开始。在本章中，您将创建多个控制台应用程序，每个应用程序显示 C#语言的相关特性。

## 显示编译器版本

我们将从编写显示编译器版本的代码开始：

1.  如果您已经完成了*第一章*，*你好，C#！欢迎，.NET！*，那么您已经有了一个`Code`文件夹。如果没有，那么您需要创建它。

1.  使用您喜欢的代码编辑器创建一个新的控制台应用程序，如下列表所示：

1.  项目模板：**控制台应用程序[C#]** / `控制台`

1.  工作区/解决方案文件和文件夹：`第二章`

1.  项目文件和文件夹：`词汇`

**良好实践**：如果您忘记了如何做，或者没有完成上一章，那么在*第一章*，*你好，C#！欢迎，.NET！*中提供了创建具有多个项目的工作区/解决方案的逐步说明。

1.  打开`Program.cs`文件，在文件顶部的注释下方，添加一个显示 C#版本的语句作为错误，如下面的代码所示：

```cs

#

错误

版本

```

1.  运行控制台应用程序：

1.  在 Visual Studio Code 中，在终端中输入命令`dotnet run`。

1.  在 Visual Studio 中，转到**调试** | **开始调试**。当提示继续并运行上次成功构建时，单击**否**。

1.  注意编译器版本和语言版本显示为编译器错误消息编号`CS8304`，如*图 2.1*所示：![](img/Image00030.jpg)

图 2.1：显示 C#语言版本的编译器错误

1.  Visual Studio Code 中的错误消息窗口或 Visual Studio 中的**错误列表**窗口显示错误消息`编译器版本：'4.0.0...'`，语言版本为`10.0`。

1.  注释掉导致错误的语句，如下面的代码所示：

```cs

// #error 版本

```

1.  请注意编译器错误消息消失了。

## 理解 C#语法

C#的语法包括语句和块。要记录您的代码，您可以使用注释。

**良好实践**：注释不应该是您记录代码的唯一方式。选择合理的变量和函数名称，编写单元测试，并创建实际文档是记录代码的其他方式。

## 语句

在英语中，我们用句号表示句子的结束。句子可以由多个单词和短语组成，单词的顺序是语法的一部分。例如，在英语中，我们说“the black cat.”

形容词*黑色*在名词*猫*之前。而法语语法的顺序不同；形容词在名词之后：“le chat noir.” 从中重要的是顺序很重要。

C#用分号表示**语句**的结束。语句可以由多个**变量**和**表达式**组成。例如，在下面的语句中，`totalPrice`是一个变量，`subtotal + salesTax`是一个表达式：

```cs

var

totalPrice = subtotal + salesTax;

```

表达式由名为`subtotal`的操作数、名为`+`的运算符和名为`salesTax`的另一个操作数组成。操作数和运算符的顺序很重要。

## 评论

在编写代码时，您可以使用双斜杠`//`添加注释来解释您的代码。通过插入`//`，编译器将忽略`//`之后的所有内容，直到行尾，如下面的代码所示：

```cs

//销售税必须添加到小计中

var

totalPrice = subtotal + salesTax;

```

要编写多行注释，请在注释开头使用`/*`，在注释结尾使用`*/`，如下面的代码所示：

```cs

/*

这是一个多行注释。

*/

```

**良好实践**：设计良好的代码，包括具有良好命名参数和类封装的函数签名，可以在一定程度上自我记录。当您发现自己在代码中放置了太多注释和解释时，请问自己：我能否重写，即重构，这段代码，使其更易理解而不需要长篇注释？

您的代码编辑器有命令可以更容易地添加和删除注释字符，如下列表所示：

+   **Visual Studio 2022 for Windows**：导航到**编辑** | **高级** | **注释选择**或**取消注释选择**

+   **Visual Studio Code**：导航到**编辑** | **切换行注释**或**切换块注释**

**良好的实践**：您可以通过在代码语句上方或下方添加描述性文本来**注释**代码。您可以通过在语句之前或周围添加注释字符来**注释掉**代码，使其无效。**取消注释**意味着删除注释字符。

## 块

在英语中，我们通过开始新的一行来表示新的段落。C#使用花括号`{}`来表示代码的**块**。

块以声明开始，以指示正在定义什么。例如，一个块可以定义许多语言结构的开始和结束，包括命名空间、类、方法或`foreach`等语句。

您将在本章和后续章节中更多地了解有关命名空间、类和方法的内容，但现在简要介绍一些概念：

+   **命名空间**包含类等类型，以将它们组合在一起。

+   一个**类**包含了对象的成员，包括方法。

+   一个**方法**包含了实现对象可以执行的动作的语句。

## 语句和块的示例

在针对.NET 5.0 的控制台应用程序项目模板中，注意 C#语法的示例已经由项目模板为您编写。我已经在语句和块中添加了一些注释，如下面的代码所示：

```cs

using

System; // 分号表示语句的结束

namespace

基础知识

{ // 开括号表示块的开始

类

Program

{

static

void

Main

(

string

[] args

)

{

Console.WriteLine("Hello World!"

); // 语句

}

}

} // 闭括号表示块的结束

```

## 了解 C#词汇

C#词汇由**关键字**，**符号字符**和**类型**组成。

在本书中，您将看到一些预定义的保留关键字，包括`using`,`namespace`,`class`,`static`,`int`,`string`,`double`,`bool`,`if`,`switch`,`break`,`while`,`do`,`for`,`foreach`,`and`,`or`,`not`,`record`和`init`。

您将看到的一些符号字符包括`"`,`'`,`+`,`-`,`*`,`/`,`%`,`@`和`$`。

还有一些上下文关键字，它们只在特定上下文中具有特殊含义。

然而，这意味着语言中实际上只有大约 100 个 C#关键字。

## 将编程语言与人类语言进行比较

英语语言有超过 25 万个不同的单词，那么为什么 C#只有大约 100 个关键字？此外，如果 C#只有英语语言中单词数量的 0.0416%，为什么学习起来如此困难？

人类语言和编程语言之间的一个关键区别是开发人员需要能够定义具有新含义的新“单词”。除了 C#语言中的大约 100 个关键字之外，本书还将教您一些其他开发人员定义的数十万个“单词”，但您还将学习如何定义自己的“单词”。

世界各地的程序员都必须学习英语，因为大多数编程语言使用英语单词，如 namespace 和 class。还有一些使用其他人类语言（如阿拉伯语）的编程语言，但它们很少见。如果您有兴趣了解更多，这个 YouTube 视频展示了阿拉伯编程语言的演示：[`youtu.be/dkO8cdwf6v8`](https://youtu.be/dkO8cdwf6v8)。

## 更改 C#语法的颜色方案

默认情况下，Visual Studio Code 和 Visual Studio 会以蓝色显示 C#关键字，以便更容易区分其他代码。这两个工具都允许您自定义颜色方案：

1.  在 Visual Studio Code 中，导航到**代码** | **首选项** | **颜色主题**（在 Windows 上是**文件**菜单）。

1.  选择一个颜色主题。作为参考，我将使用**Light+（默认浅色）**颜色主题，以便截图在印刷书籍中看起来好看。

1.  在 Visual Studio 中，导航到**工具** | **选项**。

1.  在**选项**对话框中，选择**字体和颜色**，然后选择要自定义的显示项。

## 帮助编写正确的代码

像记事本这样的纯文本编辑器无法帮助您编写正确的英语。同样，记事本也无法帮助您编写正确的 C#。

Microsoft Word 可以通过红色波浪线突出显示拼写错误来帮助您编写英语，Word 会说“icecream”应该是 ice-cream 或 ice cream，并通过蓝色波浪线突出显示语法错误，例如句子应以大写字母开头。

同样，Visual Studio Code 的 C#扩展和 Visual Studio 通过突出显示拼写错误（例如，方法名应为`WriteLine`，L 应大写）和语法错误（例如，语句必须以分号结尾）来帮助您编写 C#代码。

C#扩展不断监视您的输入，并通过突出显示有问题的地方以彩色波浪线的方式给出反馈，类似于 Microsoft Word。

让我们看看它的效果：

1.  在`Program.cs`中，将`WriteLine`方法中的`L`改为小写。

1.  删除语句末尾的分号。

1.  在 Visual Studio Code 中，导航到**视图** | **问题**，或在 Visual Studio 中导航到**视图** | **错误列表**，注意到代码错误下方出现了红色波浪线，并显示了详细信息，如*图 2.2*所示：![](img/Image00031.jpg)

图 2.2：错误列表窗口显示两个编译错误

1.  修复两个编码错误。

## 导入命名空间

`System`是一个命名空间，类似于类型的地址。要确切地指代某人的位置，您可能会使用`Oxford.HighStreet.BobSmith`，这告诉我们在牛津市的 High Street 上寻找一个名叫 Bob Smith 的人。

`System.Console.WriteLine`告诉编译器在名为`System`的命名空间中查找名为`Console`的类型中的名为`WriteLine`的方法。为了简化我们的代码，在.NET 6.0 之前的每个版本的**控制台应用程序**项目模板都会在代码文件顶部添加一条语句，告诉编译器始终在`System`命名空间中查找未加前缀的类型，如下面的代码所示：

```cs

使用

System; // 导入 System 命名空间

```

我们称之为*导入命名空间*。导入命名空间的效果是该命名空间中的所有可用类型都将在您的程序中可用，而无需输入命名空间前缀，并且在编写代码时将在 IntelliSense 中看到。

.NET 交互式笔记本自动导入大多数命名空间。

### 隐式和全局导入命名空间

传统上，每个需要导入命名空间的`.cs`文件都必须以`using`语句开头来导入这些命名空间。像`System`和`System.Linq`这样的命名空间几乎在所有`.cs`文件中都是必需的，因此每个`.cs`文件的前几行通常至少有几个`using`语句，如下面的代码所示：

```cs

使用

System;

使用

System.Linq;

使用

System.Collections.Generic;

```

在使用 ASP.NET Core 创建网站和服务时，通常会有几十个命名空间需要每个文件导入。

C# 10 引入了一些新功能，简化了导入命名空间。

首先，`global using`语句意味着您只需要在一个`.cs`文件中导入一个命名空间，它将在所有`.cs`文件中可用。您可以将`global using`语句放在`Program.cs`文件中，但我建议创建一个单独的文件来放置这些语句，命名为`GlobalUsings.cs`或`GlobalNamespaces.cs`，如下面的代码所示：

```cs

全局

使用

System;

全局

使用

System.Linq;

全局

使用

System.Collections.Generic;

```

**良好实践**：随着开发人员习惯于这一新的 C#功能，我期望这个文件的一种命名约定成为标准。

其次，任何针对.NET 6.0 的项目并因此使用 C# 10 编译器的项目都会在`obj`文件夹中生成一个`.cs`文件，以隐式全局导入一些常见的命名空间，如`System`。隐式导入的命名空间的具体列表取决于您的目标 SDK，如下表所示：

| SDK | 隐式导入的命名空间 |
| --- | --- |
| `Microsoft.NET.Sdk` | `System``System.Collections.Generic``System.IO``System.Linq``System.Net.Http``System.Threading``System.Threading.Tasks` |
| `Microsoft.NET.Sdk.Web` | 与`Microsoft.NET.Sdk`相同:`System.Net.Http.Json``Microsoft.AspNetCore.Builder``Microsoft.AspNetCore.Hosting``Microsoft.AspNetCore.Http``Microsoft.AspNetCore.Routing``Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging` |
| `Microsoft.NET.Sdk.Worker` | 与`Microsoft.NET.Sdk`相同:`Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging` |

让我们看看当前自动生成的隐式导入文件：

1.  在**解决方案资源管理器**中，选择`Vocabulary`项目，切换打开**显示所有文件**按钮，并注意编译器生成的`bin`和`obj`文件夹是可见的。

1.  展开`obj`文件夹，展开`Debug`文件夹，展开`net6.0`文件夹，并打开名为`Vocabulary.GlobalUsings.g.cs`的文件。

1.  请注意，此文件是由编译器自动生成的，用于针对.NET 6.0 的项目，并且它导入了一些常用的命名空间，包括`System.Threading`，如下代码所示：

```cs

// <autogenerated />

全球

使用

全球

:: System;

全球

使用

全局

:: System.Collections.Generic;

全球

使用

全球

:: System.IO;

全球

使用

全球

:: System.Linq;

全球

使用

全球

:: System.Net.Http;

全球

使用

全球

:: System.Threading;

全球

使用

全球

:: System.Threading.Tasks;

```

1.  关闭`Vocabulary.GlobalUsings.g.cs`文件。

1.  在**解决方案资源管理器**中，选择项目，然后向项目文件添加其他条目以控制隐式导入的命名空间，如下标记所示：

```cs

<Project Sdk="Microsoft.NET.Sdk"

<PropertyGroup>

<OutputType> Exe </ OutputType>

<TargetFramework>net6.0

</ TargetFramework>

<Nullable>启用</ Nullable>

<ImplicitUsings>启用</ImplicitUsings>

</ PropertyGroup>

**<ItemGroup>**

**<Using Remove=**

**"System.Threading"**

**/>**

**<Using Include=**

**"System.Numerics"**

**/>**

**</ ItemGroup>**

</ Project>

```

1.  保存对项目文件的更改。

1.  展开`obj`文件夹，展开`Debug`文件夹，展开`net6.0`文件夹，并打开名为`Vocabulary.GlobalUsings.g.cs`的文件。

1.  请注意，此文件现在导入`System.Numerics`而不是`System.Threading`，如下代码中所示：

```cs

// <autogenerated />

全球

使用

全局

:: System;

全球

使用

全局

:: System.Collections.Generic;

全球

使用

全球

:: System.IO;

全球

使用

全球

:: System.Linq;

全球

使用

全球

:: System.Net.Http;

全球

使用

全球

:: System.Threading.Tasks;

**全球**

**使用**

**全球**

**:: System.Numerics;**

```

1.  关闭`Vocabulary.GlobalUsings.g.cs`文件。

您可以通过从项目文件中删除条目来禁用所有 SDK 的隐式导入命名空间功能，如下标记所示：

```cs

<ImplicitUsings>启用</ImplicitUsings>

```

## 动词是方法

在英语中，动词是做或动作词，比如 run 和 jump。在 C#中，做或动作词称为**方法**。有数十万种方法可供 C#使用。在英语中，动词根据动作发生的时间而改变书写方式。例如，Amir *过去正在跳*，Beth *现在跳*，他们*过去跳*，Charlie *将来会跳*。

在 C#中，诸如`WriteLine`的方法根据具体的操作方式或执行方式而改变。这被称为重载，我们将在*第五章*，*使用面向对象编程构建自己的类型*中详细介绍。但现在，考虑以下示例：

```cs

// 输出当前行终止符字符串

// 默认情况下，这是回车和换行

Console.WriteLine();

// 输出问候语和当前行终止符字符串

Console.WriteLine("Hello Ahmed"

);

// 输出格式化的数字和日期以及当前行终止符字符串

Console.WriteLine("Temperature on {0:D} is {1}°C."

，

DateTime.Today, 23.4

）;

```

另一个类比是，有些单词拼写相同，但根据上下文有不同的含义。

## 名词是类型、变量、字段和属性

在英语中，名词是指代事物的名称。例如，Fido 是一只狗的名字。单词“狗”告诉我们 Fido 是什么类型的东西，所以为了让 Fido 去接球，我们会用他的名字。

在 C#中，它们的等价物是**类型**、**变量**、**字段**和**属性**。例如：

+   `Animal`和`Car`是类型；它们是用于对事物进行分类的名词。

+   `Head`和`Engine`可能是字段或属性；属于`Animal`和`Car`的名词。

+   `Fido`和`Bob`是变量；用于指代特定对象的名词。

C#中有数以万计的类型可用，尽管你是否注意到我没有说，“C#中有数以万计的类型？” 这种差异微妙但重要。C#语言只有少数关键字用于类型，例如`string`和`int`，严格来说，C#并没有定义任何类型。看起来像类型的关键字，如`string`，是**别名**，代表着 C#运行的平台提供的类型。

重要的是要知道，C#不能独立存在；毕竟，它是一种运行在.NET 变体上的语言。理论上，有人可以为 C#编写一个使用不同平台、具有不同底层类型的编译器。实际上，C#的平台是.NET，它为 C#提供了数以万计的类型，包括`System.Int32`，它是 C#关键字别名`int`映射到的类型，以及许多更复杂的类型，如`System.Xml.Linq.XDocument`。

值得注意的是，术语**类型**经常与**类**混淆。你玩过推理游戏*二十个问题*吗，也称为*动物、植物或矿物*？在这个游戏中，一切都可以归类为动物、植物或矿物。在 C#中，每个**类型**都可以归类为`class`、`struct`、`enum`、`interface`或`delegate`。你将在*第六章*，*实现接口和继承类*中学到这些含义。例如，C#关键字`string`是一个`class`，但`int`是一个`struct`。因此，最好使用术语**类型**来指代两者。

## 揭示 C#词汇的广度

我们知道 C#中有 100 多个关键字，但有多少种类型呢？让我们编写一些代码来找出我们简单控制台应用程序中有多少种类型（及其方法）可供 C#使用。

现在不用担心这段代码是如何工作的，但要知道它使用了一种叫做**反射**的技术：

1.  我们将从`Program.cs`文件的顶部导入`System.Reflection`命名空间，如下面的代码所示：

```cs

使用

System.Reflection;

```

1.  删除写入`Hello World!`的语句，并用以下代码替换它：

```cs

Assembly? assembly = Assembly.GetEntryAssembly();

if

（assembly == null

）返回

；

// 循环遍历此应用程序引用的程序集

foreach

（AssemblyName name in

assembly.GetReferencedAssemblies())

{

// 加载程序集以便读取其详细信息

Assembly a = Assembly.Load(name);

// 声明一个变量来计算方法的数量

int

methodCount = 0

;

// 遍历程序集中的所有类型

foreach

（TypeInfo t in

a.DefinedTypes)

{

//累加方法的计数

methodCount += t.GetMethods().Count();

}

//输出类型的计数和它们的方法

Console.WriteLine(

"{0:N0}个类型，{1:N0}个方法在{2}程序集中。"

，

arg0: a.DefinedTypes.Count(),

arg1: methodCount, arg2: name.Name);

}

```

1.  运行代码。当在您的操作系统上运行时，您将看到最简单应用程序中可用的类型和方法的实际数量。显示的类型和方法数量将取决于您使用的操作系统，如以下输出所示：

```cs

// Windows 上的输出

0 个类型，System.Runtime 程序集中有 0 个方法。

106 个类型，System.Linq 程序集中有 1,126 个方法。

44 个类型，System.Console 程序集中有 645 个方法。

// macOS 上的输出

0 个类型，System.Runtime 程序集中有 0 个方法。

103 个类型，System.Linq 程序集中有 1,094 个方法。

57 个类型，System.Console 程序集中有 701 个方法。

```

为什么`System.Runtime`程序集中不包含任何类型？这个程序集很特殊，因为它只包含**类型转发器**而不是实际类型。类型转发器表示已在.NET 之外或出于其他高级原因实现的类型。

1.  在导入命名空间后，向文件顶部添加语句以声明一些变量，如下面的代码中所突出显示的那样：

```cs

使用

System.Reflection;

**//使用类型声明一些未使用的变量**

**//在其他程序集中**

**System.Data.DataSet ds;**

**HttpClient client;**

```

通过声明使用其他程序集中的类型的变量，这些程序集将随我们的应用程序一起加载，从而使我们的代码能够看到其中的所有类型和方法。编译器会警告您有未使用的变量，但这不会阻止您的代码运行。

1.  再次运行控制台应用程序并查看结果，结果应该与以下输出类似：

```cs

// Windows 上的输出

0 个类型，System.Runtime 程序集中有 0 个方法。

383 个类型，System.Data.Common 程序集中有 6,854 个方法。

456 个类型，System.Net.Http 程序集中有 4,590 个方法。

106 个类型，System.Linq 程序集中有 1,126 个方法。

44 个类型，System.Console 程序集中有 645 个方法。

// macOS 上的输出

0 个类型，System.Runtime 程序集中有 0 个方法。

376 个类型，System.Data.Common 程序集中有 6,763 个方法。

522 个类型，System.Net.Http 程序集中有 5,141 个方法。

103 个类型，System.Linq 程序集中有 1,094 个方法。

57 个类型，System.Console 程序集中有 701 个方法。

```

现在，您更清楚地了解了为什么学习 C#是一项挑战，因为有太多类型和方法需要学习。方法只是类型可以拥有的成员的一类，您和其他程序员不断地定义新的类型和成员！

# 处理变量

所有应用程序都会处理数据。数据进入，数据被处理，然后数据输出。

数据通常从文件、数据库或用户输入中输入我们的程序，并且可以暂时放入变量中，这些变量将存储在运行程序的内存中。程序结束时，内存中的数据将丢失。数据通常输出到文件和数据库，或者输出到屏幕或打印机。在使用变量时，您应该首先考虑变量在内存中占用多少空间，其次是它可以被处理的速度。

我们通过选择适当的类型来控制这一点。您可以将简单的常见类型（如`int`和`double`）视为不同大小的存储盒，较小的盒子将占用更少的内存，但处理速度可能不如较快；例如，在 64 位操作系统上，添加 16 位数字的速度可能不如添加 64 位数字的速度快。其中一些盒子可能靠得很近，而另一些可能被扔到远处的大堆中。

## 命名事物和分配值

事物有命名约定，遵循它们是一个好习惯，如下表所示：

| 命名约定 | 示例 | 用途 |
| --- | --- | --- |
| Camel case | `cost` , `orderDetail` , `dateOfBirth` | 本地变量，私有字段 |
| Title case aka Pascal case | `String` , `Int32` , `Cost` , `DateOfBirth` , `Run` | 类型，非私有字段和其他成员，如方法 |

**良好的实践**：遵循一致的命名约定将使其他开发人员（以及将来的自己）能够轻松理解您的代码。

以下代码块显示了声明命名本地变量并使用`=`符号为其赋值的示例。您应该注意，您可以使用 C# 6.0 中引入的关键字`nameof`输出变量的名称：

```cs

// 让 heightInMetres 变量等于值 1.88

双

heightInMetres = 1.88

;

Console.WriteLine($"变量

{

nameof

(heightInMetres)}

具有值

{heightInMetres}

。"

);

```

在前面的代码中双引号中的消息换行到第二行，因为打印页面的宽度太窄。在代码编辑器中输入这样的语句时，将其全部输入单行。

## 文字值

当您为变量赋值时，通常但并非总是分配**文字**值。但是什么是文字值？文字是表示固定值的符号。数据类型有不同的符号表示它们的文字值，接下来的几节中，您将看到使用文字符号分配值给变量的示例。

## 存储文本

对于文本，如`A`这样的单个字母存储为`char`类型。

**良好的实践**：实际上，情况可能比这更复杂。埃及象形文字 A002（U+13001）需要两个`System.Char`值（称为代理对）来表示它：`\uD80C`和`\uDC01`。不要总是假设一个`char`等于一个字母，否则可能会在代码中引入奇怪的错误。

`char`使用单引号括起来的文字值进行分配，或者分配虚构函数调用的返回值，如下面的代码所示：

```cs

字符

letter = 'A'

; // 分配文字字符

字符

digit = '1'

;

字符

符号 = '$'

;

字符

userChoice = GetSomeKeystroke(); // 从一个虚构的函数赋值

```

对于文本，如`Bob`这样的多个字母存储为`string`类型，并使用双引号括起来的文字值或分配函数调用的返回值，如下面的代码所示：

```cs

字符串

firstName = "Bob"

; // 分配文字字符串

字符串

lastName = "Smith"

;

字符串

phoneNumber = "(215) 555-4256"

;

// 分配从虚构函数返回的字符串

字符串

address = GetAddressFromDatabase(id: 563

);

```

### 理解逐字字符串

当将文本存储在`string`变量中时，可以包含转义序列，这些序列代表特殊字符，如制表符和换行符，使用反斜杠，如下面的代码所示：

```cs```

字符串

fullNameWithTabSeparator = "Bob\tSmith"

;

```

但是，如果您要在 Windows 上存储文件的路径，并且其中一个文件夹名称以`T`开头，如下面的代码所示，会怎么样呢？

```cs

字符串

filePath = "C:\televisions\sony\bravia.txt"

;

```

编译器将`\t`转换为制表符，并且您将收到错误！

您必须使用`@`符号前缀来使用逐字文字`string`，如下面的代码所示：

```cs

字符串

filePath = @"C:\televisions\sony\bravia.txt"

;

```

总结：

+   **文字字符串**：用双引号括起来的字符。它们可以使用转义字符，如制表符`\t`。要表示反斜杠，请使用两个：`\\`。

+   **逐字字符串**：以`@`为前缀的文字字符串，以禁用转义字符，使反斜杠成为反斜杠。它还允许`string`值跨多行，因为空格字符被视为它们自己，而不是编译器的指令。

+   **插值字符串**：以`$`为前缀的文字字符串，以启用嵌入格式化变量。您将在本章后面学到更多关于这个的知识。

## 存储数字

数字是我们想要进行算术计算的数据，例如乘法。 电话号码不是一个数字。 要决定变量是否应存储为数字，请问自己是否需要对数字执行算术运算，或者数字是否包含非数字字符，例如括号或连字符，以格式化数字，例如(414) 555-1234。 在这种情况下，数字是一系列字符，因此应将其存储为`string`。

数字可以是自然数，例如 42，用于计数（也称为整数）；它们也可以是负数，例如-42（称为整数）；或者，它们可以是实数，例如 3.9（带有分数部分），在计算中称为单精度或双精度浮点数。

让我们探索数字：

1.  使用您喜欢的代码编辑器将新的**控制台应用程序**添加到名为`Numbers`的`Chapter02`工作区/解决方案中：

1.  在 Visual Studio Code 中，将`Numbers`选择为活动的 OmniSharp 项目。 当看到弹出的警告消息说缺少所需资产时，点击**是**以添加它们。

1.  在 Visual Studio 中，将启动项目设置为当前选择。

1.  在`Program.cs`中，删除现有代码，然后键入语句以使用各种数据类型声明一些数字变量，如下面的代码所示：

```cs

// 无符号整数表示正整数或 0

uint naturalNumber = 23

;

// 整数表示负整数或正整数或 0

int

integerNumber = -23

;

// 浮点数表示单精度浮点

// F 后缀使其成为浮点文字

float

realNumber = 2.3F

;

// double 表示双精度浮点

double

anotherRealNumber = 2.3

; // 双精度文字

```

### 存储整数

你可能知道计算机将所有内容都存储为位。 位的值要么是 0，要么是 1。 这称为**二进制数系统**。 人类使用**十进制数系统**。

十进制数系统，也称为基数 10，其**基数**为 10，意味着有十个数字，从 0 到 9。 尽管它是人类文明中最常用的数字基数，但其他数字基数系统在科学，工程和计算中也很受欢迎。 二进制数系统，也称为基数 2，其基数为 2，意味着有两个数字，0 和 1。

下表显示了计算机如何存储十进制数 10。 注意值为 1 的位在 8 和 2 列中； 8 + 2 = 10：

| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |

因此，十进制中的`10`在二进制中是`00001010`。

#### 通过使用数字分隔符来提高可读性

C# 7.0 及更高版本中看到的两项改进是使用下划线字符`_`作为数字分隔符，以及支持二进制文字。

您可以在数字文字的数字中的任何位置插入下划线，包括十进制，二进制或十六进制表示法，以提高可读性。

例如，您可以将 100 万的值用十进制表示法写成`1_000_000`。

您甚至可以使用印度常见的 2/3 分组：`10_00_000`。

#### 使用二进制表示法

要使用二进制表示法，即基数 2，只使用 1 和 0，从`0b`开始数字文字。 要使用十六进制表示法，即基数 16，使用 0 到 9 和 A 到 F，从`0x`开始数字文字。

### 探索整数

让我们输入一些代码来看一些例子：

1.  在`Program.cs`中，键入语句以使用下划线分隔符声明一些数字变量，如下面的代码所示：

```cs

// 存储数字 200 万的三个变量

int

decimalNotation = 2

_000_000;

int

binaryNotation = 0b

_0001_1110_1000_0100_1000_0000;

int

hexadecimalNotation = 0

x_001E_8480;

// 检查三个变量是否具有相同的值

// 两个语句都输出 true

Console.WriteLine($"

{decimalNotation == binaryNotation}

"

);

Console.WriteLine(

$"

{decimalNotation == hexadecimalNotation}

"

);

```

1.  运行代码并注意结果是所有三个数字都相同，如下面的输出所示：

```cs

True

True

```

计算机总是可以使用`int`类型或其兄弟类型（如`long`和`short`）精确表示整数。

## 存储实数

计算机不能总是精确地表示实数，也就是十进制或非整数。`float` 和 `double` 类型使用单精度和双精度浮点数存储实数。

大多数编程语言实现了 IEEE 浮点算术标准。IEEE 754 是 1985 年由**电气和电子工程师协会**（**IEEE**）制定的浮点算术技术标准。

下表显示了计算机如何以二进制表示数字`12.75`的简化。请注意，8、4、½和¼列中的值为`1`的位。

8 + 4 + ½ + ¼ = 12¾ = 12.75。

| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | . | 1 | 1 | 0 | 0 |

因此，十进制中的`12.75`是二进制中的`00001100.1100`。正如您所看到的，数字`12.75`可以用位数精确表示。然而，有些数字不能，这是我们将要探索的内容。

### 编写代码来探索数字大小

C#有一个名为`sizeof()`的运算符，它返回类型在内存中使用的字节数。一些类型有名为`MinValue`和`MaxValue`的成员，它们返回该类型的变量中可以存储的最小值和最大值。我们现在将使用这些特性创建一个控制台应用程序来探索数字类型：

1.  在`Program.cs`中，输入语句以显示三种数字数据类型的大小，如下面的代码所示：

```cs

Console.WriteLine($"int 使用

{

sizeof

(

int

)}

字节，并且可以存储范围内的数字

{

int

.MinValue:N0}

到

{

int

.MaxValue:N0}

。"

);

Console.WriteLine($"double 使用

{

sizeof

(

double

)}

字节，并且可以存储范围内的数字

{

double

.MinValue:N0}

到

{

double

.MaxValue:N0}

。"

);

Console.WriteLine($"decimal 使用

{

sizeof

(

decimal

)}

字节，并且可以存储范围内的数字

{

十进制

.MinValue:N0}

到

{

decimal

.MaxValue:N0}

。"

);

```

本书中打印页面的宽度使得`string`值（用双引号括起来）会跨越多行。您必须将它们输入到一行中，否则会出现编译错误。

1.  运行代码并查看输出，如*图 2.3*所示：![](img/Image00032.jpg)

图 2.3：常见数字数据类型的大小和范围信息

`int`变量使用四个字节的内存，可以存储正数或负数，最大约为 20 亿。`double`变量使用八个字节的内存，可以存储更大的值！`decimal`变量使用 16 个字节的内存，可以存储大数字，但不及`double`类型大。

但是你可能会问自己，为什么`double`变量能够存储比`decimal`变量更大的数字，但是它只使用了一半的内存空间？好吧，现在让我们找出答案！

### 比较 double 和 decimal 类型

现在，您将编写一些代码来比较`double`和`decimal`值。虽然不难理解，但现在不用担心理解语法：

1.  类型语句声明两个`double`变量，将它们相加并将结果与预期结果进行比较，并将结果写入控制台，如下面的代码所示：

```cs

Console.WriteLine("使用双精度："

);}

double

a = 0.1

;

double

b = 0.2

;

如果

(a + b == 0.3

)

{

Console.WriteLine($"

{a}

+

{b}

等于

{

0.3

}

"

);

}

else

{

Console.WriteLine($"

{a}

+

{b}

不等于

{

0.3

}

"

);

}

```

1.  运行代码并查看结果，如下面的输出所示：

```cs

使用双精度：

0.1 + 0.2 不等于 0.3

```

在使用逗号作为小数分隔符的区域，结果会略有不同，如下面的输出所示：

```cs

0,1 + 0,2 不等于 0,3

```

`double`类型不能保证精确，因为一些数字如`0.1`在浮点数值中无法准确表示。

作为一个经验法则，只有在精度不重要时才应该使用`double`。一个例子是当你测量一个人的身高，你只会使用大于或小于来比较值，但永远不会使用等于。

前面的代码问题在于计算机如何存储数字`0.1`或它的倍数。为了表示二进制中的`0.1`，计算机在 1/16 列中存储 1，在 1/32 列中存储 1，在 1/256 列中存储 1，在 1/512 列中存储 1，依此类推。

十进制中的数字`0.1`在二进制中是`0.00011001100110011`…一直重复下去：

| 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 | 1/32 | 1/64 | 1/128 | 1/256 | 1/512 | 1/1024 | 1/2048 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | . | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 |

**良好实践**：永远不要使用`==`来比较`double`值。在第一次海湾战争中，一支美国爱国者导弹连使用`double`值进行计算。这种不准确性导致它未能跟踪和拦截一枚来袭的伊拉克飞毛腿导弹，造成了 28 名士兵死亡；你可以在[`www.ima.umn.edu/~arnold/disasters/patriot.html`](https://www.ima.umn.edu/~arnold/disasters/patriot.html)上阅读相关内容。

1.  复制并粘贴之前写的使用`double`变量的语句。

1.  修改语句以使用`decimal`并将变量重命名为`c`和`d`，如下面的代码所示：

```cs

Console.WriteLine("使用小数："

);

decimal

c = 0.1

M; // M 后缀表示十进制字面值

decimal

d = 0.2

M;

如果

(c + d == 0.3

M)

{

Console.WriteLine($"

{c}

+

{d}

等于

{

0.3

M}

"

);

}

else

{

Console.WriteLine($"

{c}

+

{d}

不等于

{

0.3

M}

"

);

}

```

1.  运行代码并查看结果，如下面的输出所示：

```cs

使用小数：

0.1 + 0.2 等于 0.3

```

`decimal`类型是精确的，因为它将数字存储为一个大整数，并移动小数点。例如，`0.1`被存储为`1`，并注明将小数点向左移动一位。`12.75`被存储为`1275`，并注明将小数点向左移动两位。

**良好实践**：对于整数使用`int`。对于不需要与其他值相等比较的实数使用`double`；可以将`double`值进行小于或大于等比较。对于货币、CAD 图纸、一般工程等需要实数精度的地方使用`decimal`。

`double`类型有一些有用的特殊值：`double.NaN`表示非数字（例如除以零的结果），`double.Epsilon`表示可以存储在`double`中的最小正数，`double.PositiveInfinity`和`double.NegativeInfinity`表示无限大的正数和负数。

## 存储布尔值

布尔值只能包含两个字面值`true`或`false`，如下面的代码所示：

```cs

bool

happy = true

;

bool

sad = false

;

```

它们最常用于分支和循环。你现在不需要完全理解它们，因为它们在*第三章*，*控制流、类型转换和异常处理*中有更详细的介绍。

## 存储任何类型的对象

有一种特殊类型叫做`object`，它可以存储任何类型的数据，但它的灵活性是以代码混乱和可能的性能不佳为代价的。因为这两个原因，尽可能避免使用它。以下步骤展示了如何在需要时使用对象类型：

1.  使用你喜欢的代码编辑器向`Chapter02`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`Variables`。

1.  在 Visual Studio Code 中，将`Variables`作为活动的 OmniSharp 项目。当看到弹出的警告消息说缺少所需的资产时，点击**是**以添加它们。

1.  在`Program.cs`中，输入语句来声明和使用一些使用`object`类型的变量，如下面的代码所示：

```cs

object

height = 1.88

; // 在对象中存储一个双精度值

object

name = "Amir"

; // 在对象中存储一个字符串

Console.WriteLine($"

{name}

是

{height}

米高。"

);

int

length1 = name.Length; // 编译错误！

int

length2 = ((string

)name).Length; // 告诉编译器它是一个字符串

Console.WriteLine($"

{name}

有

{length2}

字符。"

);

```

1.  运行代码并注意第四个语句无法编译，因为编译器不知道`name`变量的数据类型，如*图 2.4*所示：![](img/Image00033.jpg)

图 2.4：对象类型没有 Length 属性

1.  在无法编译的语句开头添加双斜杠注释以"注释掉"该语句，使其无效。

1.  再次运行代码并注意，如果程序员显式告诉编译器`object`变量包含一个`string`，则编译器可以访问`string`的长度，方法是使用前缀为`(string)`的转换表达式，如下面的输出所示：

```cs

Amir 身高 1.88 米。

Amir 有 4 个字符。

```

`object`类型自第一个 C#版本以来就可用，但 C# 2.0 及更高版本有一个更好的替代方案，称为**泛型**，我们将在*第六章*，*实现接口和继承类*中介绍，这将为我们提供所需的灵活性，但没有性能开销。

## 存储动态类型

还有一种特殊类型叫做`dynamic`，它也可以存储任何类型的数据，但与`object`相比，它的灵活性更多，但性能更差。`dynamic`关键字是在 C# 4.0 中引入的。然而，与`object`不同，存储在变量中的值可以在没有显式转换的情况下调用其成员。让我们使用`dynamic`类型：

1.  添加语句来声明一个`dynamic`变量，然后分配一个`string`字面值，然后是一个整数值，然后是一个整数值数组，如下面的代码所示：

```cs

// 在动态对象中存储一个字符串

// string 有一个 Length 属性

dynamic

something = "Ahmed"

;

// int 没有 Length 属性

// something = 12;

// 任何类型的数组都有 Length 属性

// something = new[] { 3, 5, 7 };

```

1.  添加一个语句来输出`dynamic`变量的长度，如下面的代码所示：

```cs

// 这样编译，但会在运行时引发异常

// 如果以后存储了一个没有的数据类型

// 名为 Length 的属性

Console.WriteLine($"长度为

{something.Length}

"

);

```

1.  运行代码并注意它可以工作，因为`string`值确实有一个`Length`属性，如下面的输出所示：

```cs

长度为 5

```

1.  取消注释分配`int`值的语句。

1.  运行代码并注意运行时错误，因为`int`没有`Length`属性，如下面的输出所示：

```cs

未处理的异常。Microsoft.CSharp.RuntimeBinder.RuntimeBinderException: 'int'不包含'Length'的定义

```

1.  取消注释分配数组的语句。

1.  运行代码并注意输出，因为三个`int`值的数组确实有一个`Length`属性，如下面的输出所示：

```cs

长度为 3

```

`dynamic`的一个限制是代码编辑器无法显示智能感知以帮助您编写代码。这是因为编译器无法在构建时检查类型是什么。相反，CLR 在运行时检查成员并在缺失时引发异常。

异常是指示在运行时出现了问题的一种方式。您将在*第三章*，*控制流程，转换类型和处理异常*中学到更多关于它们以及如何处理它们。

## 声明局部变量

局部变量在方法内声明，它们只在该方法执行期间存在，一旦方法返回，为任何局部变量分配的内存将被释放。

严格来说，值类型会被释放，而引用类型必须等待垃圾回收。您将在*第六章*，*实现接口和继承类*中了解值类型和引用类型之间的区别。

### 指定本地变量的类型

让我们探索使用特定类型声明的本地变量和使用类型推断：

1.  使用特定类型的语句声明并为一些本地变量分配值，如下面的代码所示：

```cs

int

population = 66

_000_000; // 66 million in UK

double

weight = 1.88

; // in kilograms

decimal

price = 4.99

M; // in pounds sterling

string

fruit = "Apples"

; // strings use double-quotes

char

letter = 'Z'

; // chars use single-quotes

bool

happy = true

; // 布尔值为 true 或 false

```

根据您的代码编辑器和颜色方案，它将在每个变量名称下显示绿色波浪线，并将它们的文本颜色变浅，以警告您变量被赋值，但其值从未被使用。

### 推断本地变量的类型

您可以使用`var`关键字声明本地变量。编译器将从赋值运算符`=`后分配的值中推断类型。

没有小数点的文字数字被推断为`int`变量，也就是说，除非你添加一个后缀，如下面的列表所述：

+   `L`：推断`long`

+   `UL`：推断`ulong`

+   `M`：推断`decimal`

+   `D`：推断`double`

+   `F`：推断`float`

具有小数点的文字数字被推断为`double`，除非您添加`M`后缀，此时它推断为`decimal`变量，或者添加`F`后缀，此时它推断为`float`变量。

双引号表示`string`变量，单引号表示`char`变量，`true`和`false`值推断为`bool`类型：

1.  修改前面的语句以使用`var`，如下面的代码所示：

```cs

var

population = 66

_000_000; // 66 million in UK

var

weight = 1.88

; // in kilograms

var

price = 4.99

M; // in pounds sterling

var

fruit = "Apples"

; // strings use double-quotes

var

letter = 'Z'

; // chars use single-quotes

var

happy = true

; // 布尔值为 true 或 false

```

1.  将鼠标悬停在每个`var`关键字上，并注意您的代码编辑器显示了有关已推断类型的信息的工具提示。

1.  在类文件的顶部，导入用于处理 XML 的命名空间，以便我们可以使用该命名空间中的类型声明一些变量，如下面的代码所示：```

```cs

using

System.Xml;

```

**良好实践**：如果您正在使用.NET 交互式笔记本，则在您编写主要代码的代码单元格上方的单独代码单元格中添加`using`语句。然后单击**执行单元格**以确保导入了命名空间。然后它们将在随后的代码单元格中可用。

1.  在前面的语句下，添加语句以创建一些新对象，如下面的代码所示：

```cs

// 使用 var 的良好用法，因为它避免了重复的类型

// 如更冗长的第二个语句所示

var

xml1 = new

XmlDocument();

XmlDocument xml2 = new

XmlDocument();

// 使用 var 的不良用法，因为我们无法确定类型，所以我们

// 应该使用特定类型声明，如下所示

// 第二个语句

var

file1 = File.CreateText("something1.txt"

);

StreamWriter file2 = File.CreateText("something2.txt"

);

```

**良好实践**：虽然使用`var`很方便，但一些开发人员避免使用它，以使代码读者更容易理解所使用的类型。就个人而言，我只在类型明显时使用它。例如，在前面的代码语句中，第一个语句和第二个语句一样清楚地说明了`xml`变量的类型，但它更短。但是，第三个语句并没有清楚地显示`file`变量的类型，因此第四个语句更好，因为它显示了类型是`StreamWriter`。如果有疑问，就把它写出来！

### 使用目标类型的新实例化对象

使用 C# 9，Microsoft 引入了另一种用于实例化对象的语法，称为**目标类型的新功能**。在实例化对象时，您可以首先指定类型，然后使用`new`而不重复类型，如下所示：

```cs

XmlDocument xml3 = new

(); // C# 9 或更高版本中的目标类型的新功能

```

如果您有一个需要设置字段或属性的类型，则可以推断类型，如下所示：

```cs

类

Person

{

公共

DateTime BirthDate;

}

Person kim = new

();

kim.BirthDate = new

(1967

, 12

, 26

); // 而不是：new DateTime(1967, 12, 26)

```

**良好的实践**：除非必须使用早于版本 9 的 C#编译器，否则使用目标类型的新功能来实例化对象。我在本书的其余部分中都使用了目标类型的新功能。如果您发现我错过了任何情况，请告诉我！

## 获取和设置类型的默认值

除了`string`之外，大多数基本类型都是**值类型**，这意味着它们必须有一个值。您可以使用`default()`运算符并将类型作为参数来确定类型的默认值。您可以使用`default`关键字来分配类型的默认值。

`string`类型是**引用类型**。这意味着`string`变量包含值的内存地址，而不是值本身。引用类型变量可以有一个`null`值，这是一个字面量，表示变量尚未引用任何内容。`null`是所有引用类型的默认值。

您将在*第六章*，*实现接口和继承类*中更多地了解值类型和引用类型。

让我们探索默认值：

1.  添加语句以显示`int`，`bool`，`DateTime`和`string`的默认值，如下所示：

```cs

Console.WriteLine($"默认(int) =

{

默认值

(

int

)}

"

);

Console.WriteLine($"默认(bool) =

{

默认值

(

bool

)}

"

);

Console.WriteLine($"默认(DateTime) =

{

默认

(DateTime)}

"

);

Console.WriteLine($"默认(string) =

{

默认

(

string

)}

"

);

```

1.  运行代码并查看结果，注意如果您不是在英国运行代码，日期和时间的输出可能会有不同的格式，并且`null`值会输出为空字符串，如下所示：

```cs

默认(int) = 0

默认(bool) = False

默认(DateTime) = 01/01/0001 00:00:00

默认(string) =

```

1.  添加语句来声明一个数字，赋值，然后将其重置为默认值，如下所示：

```cs

int

number = 13

;

Console.WriteLine($"数字已设置为：

{number}

"

);

number = 默认值

;

Console.WriteLine($"数字已重置为默认值：

{number}

"

);

```

1.  运行代码并查看结果，如下所示：

```cs

数字已设置为：13

数字已重置为默认值：0

```

## 在数组中存储多个值

当您需要存储相同类型的多个值时，可以声明一个**数组**。例如，当您需要在`string`数组中存储四个名称时，可以这样做。

接下来要编写的代码将为存储四个`string`值的数组分配内存。然后，它将在索引位置 0 到 3 存储`string`值（数组通常具有零的下限，因此最后一项的索引比数组的长度少 1）。

**良好的实践**：不要假设所有数组都从零开始计数。.NET 中最常见的数组类型是**szArray**，即单维零索引数组，它们使用正常的`[]`语法。但.NET 还有**mdArray**，即多维数组，它们不必具有零的下限。这些很少使用，但您应该知道它们的存在。

最后，它将使用`for`语句循环遍历数组中的每个项目，这是我们将在*第三章*，*控制流，类型转换和处理异常*中更详细地介绍的内容。

让我们看看如何使用数组：

1.  声明和使用一个`string`值数组的类型语句，如下面的代码所示：

```cs

string

[] names; // 可引用任何大小的字符串数组

// 在数组中为四个字符串分配内存

names = new

string

[4

];

// 在索引位置存储项目

names[0

] = "Kate"

;

names[1

] = "Jack"

;

names[2

] = "Rebecca"

;

names[3

] = "Tom"

;

// 循环遍历名称

for

(int

i = 0

; i < names.Length; i++)

{

// 输出索引位置 i 处的项目

Console.WriteLine(names[i]);

}

```

1.  运行代码并注意结果，如下面的输出所示：

```cs

Kate

Jack

Rebecca

Tom

```

数组在内存分配时总是固定大小的，因此在实例化之前，您需要决定要存储多少项目。

与上面三个步骤定义数组的另一种选择是使用数组初始化程序语法，如下面的代码所示：

```cs

string

[] names2 = new

[] { "Kate"

, "Jack"

, "Rebecca"

, "Tom"

};

```

当您使用`new[]`语法为数组分配内存时，大括号中必须至少有一项，以便编译器可以推断数据类型。

数组用于临时存储多个项目，但在动态添加和删除项目时，集合是更灵活的选择。您现在不需要担心集合，因为我们将在*第八章* *使用常见的.NET 类型*中介绍它们。

# 更多关于控制台应用程序的探索

我们已经创建并使用了基本的控制台应用程序，但现在我们应该更深入地研究它们。

控制台应用程序是基于文本的，并在命令行上运行。它们通常执行需要脚本化的简单任务，例如编译文件或加密配置文件的一部分。

同样，它们也可以接受传递给它们的参数来控制它们的行为。

例如，使用指定的名称创建一个新的 F#语言控制台应用程序，而不是使用当前文件夹的名称，如下面的命令行所示：

```cs

dotnet new console -lang "F#" --name "ExploringConsole"

```

## 向用户显示输出

控制台应用程序执行的两个最常见任务是写入和读取数据。我们已经在使用`WriteLine`方法输出数据，但如果我们不希望在行末使用换行符，我们可以使用`Write`方法。

### 使用编号的位置参数进行格式化

生成格式化字符串的一种方法是使用编号的位置参数。

此功能由`Write`和`WriteLine`等方法支持，对于不支持该功能的方法，可以使用`string`的`Format`方法格式化`string`参数。

本节中的前几个代码示例将使用.NET 交互式笔记本，因为它们是关于向控制台输出。在本节的后面，您将学习通过控制台获取输入，遗憾的是笔记本不支持这一点。

让我们开始格式化：

1.  使用您喜欢的代码编辑器向`Chapter02`工作区/解决方案添加一个新的**控制台应用程序**，名称为`Formatting`。

1.  在 Visual Studio Code 中，选择`Formatting`作为活动的 OmniSharp 项目。

1.  在`Program.cs`中，输入语句来声明一些数字变量并将它们写入控制台，如下面的代码所示：

```cs

int

numberOfApples = 12

;

decimal

pricePerApple = 0.35

M;

Console.WriteLine(

format: "{0} apples costs {1:C}"

,

arg0: numberOfApples,

arg1: pricePerApple * numberOfApples);

string

formatted = string

.Format(

format: "{0} apples costs {1:C}"

,

arg0: numberOfApples,

arg1: pricePerApple * numberOfApples);

//WriteToFile(formatted); // 将字符串写入文件

```

`WriteToFile`方法是一个不存在的方法，用于说明这个想法。

**良好的实践**：一旦您对格式化字符串更加熟悉，您应该停止命名参数，例如，停止使用`format：`，`arg0：`和`arg1：`。上面的代码使用了一个非规范的样式来显示`0`和`1`来自于哪里，这样您在学习时就能知道。

### 使用插值字符串进行格式化

C# 6.0 及更高版本有一个方便的功能，名为**插值字符串**。以`$`为前缀的`string`可以使用大括号将变量或表达式的名称括起来，以在`string`中的该位置输出该变量或表达式的当前值，如下所示：

1.  在`Program.cs`文件的底部输入一条语句，如下面的代码所示：

```cs

Console.WriteLine($"

{苹果的数量}

苹果的成本

{pricePerApple * numberOfApples:C}

"

);

```

1.  运行代码并查看结果，如下面的部分输出所示：

```cs

12 个苹果的成本为 4.20 英镑

```

对于短的，格式化的`string`值，插值的`string`对于人们来说可能更容易阅读。但是对于书中需要跨越多行的代码示例来说，这可能有些棘手。对于本书中的许多代码示例，我将使用编号的位置参数。

避免插值字符串的另一个原因是它们无法从资源文件中读取以进行本地化。

在 C# 10 之前，只能通过连接来组合字符串常量，如下面的代码所示：

```cs

私有的

常量

字符串

firstname = "Omar"

;

私有的

常量

字符串

lastname = "Rudberg"

;

私有的

常量

字符串

fullname = firstname + " "

+ 姓;

```

使用 C# 10，可以使用插值字符串，如下面的代码所示：

```cs

私有的

常量

字符串

fullname = "{firstname} {lastname}"

;

```

这仅适用于组合字符串常量值。它无法处理其他类型，比如需要运行时数据类型转换的数字。

### 理解格式化字符串

变量或表达式可以在逗号或冒号后使用格式字符串进行格式化。

`N0`格式字符串表示带有千位分隔符且没有小数位的数字，而`C`格式字符串表示货币。货币格式将由当前线程确定。

例如，如果您在英国的 PC 上运行此代码，您将得到英镑和逗号作为千位分隔符，但如果您在德国的 PC 上运行此代码，您将得到欧元和点作为千位分隔符。

格式项的完整语法是：

```cs

{ index [, alignment ] [ : formatString ] }

```

每个格式项都可以有一个对齐，这在输出值的表格中非常有用，其中一些值可能需要在字符宽度内左对齐或右对齐。对齐值是整数。正整数表示右对齐，负整数表示左对齐。

例如，要输出一张水果表以及每种水果的数量，我们可能希望将名称左对齐到 10 个字符的列中，并将格式化为不带小数位的数字的计数右对齐到 6 个字符的列中：

1.  在`Program.cs`的底部，输入以下语句：

```cs

字符串

applesText = "苹果"

;

int

applesCount = 1234

;

字符串

bananasText = "香蕉"

;

int

bananasCount = 56789

;

Console.WriteLine(

格式："{0，-10} {1,6:N0}"

,

arg0："名字"

，

arg1："计数"

);

Console.WriteLine(

格式："{0，-10} {1,6:N0}"

,

arg0：applesText，

arg1：applesCount);

Console.WriteLine(

格式："{0，-10} {1,6:N0}"

,

arg0：bananasText，

arg1：bananasCount);

```

1.  运行代码并注意对齐和数字格式的效果，如下面的输出所示：

```cs

名字          计数

苹果        1,234

香蕉      56,789

```

## 从用户那里获取文本输入

我们可以使用`ReadLine`方法从用户那里获取文本输入。该方法等待用户输入一些文本，然后一旦用户按下 Enter 键，无论用户输入了什么都将作为`string`值返回。

**良好实践**：如果您在本节使用.NET 交互式笔记本，则请注意它不支持使用`Console.ReadLine()`从控制台读取输入。相反，您必须设置文字值，如下面的代码所示：`string? firstName = "Gary";`。这通常更快，因为您可以简单地更改文字`string`值并单击**执行单元格**按钮，而不必每次想要输入不同的`string`值时都必须重新启动控制台应用程序。

让我们从用户那里获取输入：

1.  输入语句以询问用户姓名和年龄，然后输出他们输入的内容，如下面的代码所示：

```cs

Console.Write("输入您的名字并按回车键："

）；

字符串

？firstName = Console.ReadLine();

Console.Write("输入您的年龄并按回车键："

）；

字符串

？age = Console.ReadLine();

Console.WriteLine(

$"你好

{firstName}

，你看起来很不错

{age}

。"

）；

```

1.  运行代码，然后输入姓名和年龄，如下面的输出所示：

```cs

输入您的姓名并按回车键：Gary

输入您的年龄并按回车键：34

你好 Gary，你看起来很不错，年龄为 34 岁。

```

`string?`数据类型声明末尾的问号表示我们承认从对`ReadLine`的调用中可能返回`null`（空）值。您将在*第六章*，*实现接口和继承类*中了解更多信息。

## 简化控制台的使用

在 C# 6.0 及更高版本中，`using`语句不仅可以用于导入命名空间，还可以通过导入静态类进一步简化我们的代码。然后，我们就不需要在整个代码中输入`Console`类型名称。您可以使用代码编辑器的查找和替换功能来删除我们以前写过的`Console`：

1.  在`Program.cs`文件的顶部，添加一个语句以**静态导入**`System.Console`类，如下面的代码所示：

```cs

使用

静态

系统。控制台；

```

1.  在代码中选择第一个`Console.`，确保您也选择了`Console`一词后面的句点。

1.  在 Visual Studio 中，导航到**编辑** | **查找和替换** | **快速替换**，或在 Visual Studio Code 中，导航到**编辑** | **替换**，注意到一个覆盖对话框已准备好让您输入您想要用什么替换**Console.**，如*图 2.5*所示：![](img/Image00034.jpg)

图 2.5：在 Visual Studio 中使用替换功能简化您的代码

1.  将替换框留空，单击“全部替换”按钮（替换框右侧的第二个按钮），然后单击替换框右上角的十字叉关闭替换框。

## 从用户那里获取按键输入

我们可以使用`ReadKey`方法从用户那里获取按键输入。该方法等待用户按下一个键或键组合，然后将其作为`ConsoleKeyInfo`值返回。

您将无法使用.NET 交互式笔记本执行对`ReadKey`方法的调用，但如果您创建了一个控制台应用程序，那么让我们来探索读取按键：

1.  输入语句以要求用户按任意键组合，然后输出有关它的信息，如下面的代码所示：

```cs

Write("按任意键组合："

);

ConsoleKeyInfo key = ReadKey();

WriteLine();

WriteLine("键：{0}，字符：{1}，修饰符：{2}"

，

arg0：key.Key，

arg1：key.KeyChar，

arg2：key.Modifiers);

```

1.  运行代码，按 K 键，然后注意结果，如下面的输出所示：

```cs

按任意键组合：k

键：K，字符：k，修饰符：0

```

1.  运行代码，按住 Shift 键并按下 K 键，然后注意结果，如下面的输出所示：

```cs

按任意键组合：K

键：K，字符：K，修饰符：Shift

```

1.  运行代码，按 F12 键，然后注意结果，如下面的输出所示：

```cs

按任意键组合：

键：F12，字符：，修饰符：0

```

在 Visual Studio Code 中，在终端中运行控制台应用程序时，某些键盘组合将在代码编辑器或操作系统之前被捕获，然后才能被您的应用程序处理。

## 向控制台应用程序传递参数

您可能一直在想如何获取可能传递给控制台应用程序的任何参数。

在.NET 6.0 之前的每个版本中，控制台应用程序项目模板都很明显，如下面的代码所示：

```cs

使用

系统；

命名空间

参数

{

类

Program

{

static

void

Main

(

字符串

[] args

)

{

Console.WriteLine("Hello World!"

);

}

}

}

```

`string[] args`参数在`Program`类的`Main`方法中声明和传递。它们是用于将参数传递到控制台应用程序中的数组。但在顶级程序中，即.NET 6.0 及以后版本中控制台应用程序项目模板使用的方式，`Program`类及其`Main`方法被隐藏，以及`args`字符串数组的声明。诀窍在于您必须知道它仍然存在。

命令行参数由空格分隔。连字符和冒号等其他字符被视为参数值的一部分。

要在参数值中包含空格，请将参数值括在单引号或双引号中。

假设我们希望能够在命令行中输入前景和背景的一些颜色名称，以及终端窗口的尺寸。我们可以通过从始终传递到`Main`方法（即控制台应用程序的入口点）的`args`数组中读取颜色和数字来实现。

1.  使用您喜欢的代码编辑器向`Chapter02`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`Arguments`。您将无法使用.NET 交互笔记本，因为您无法向笔记本传递参数。

1.  在 Visual Studio Code 中，选择`Arguments`作为活动的 OmniSharp 项目。

1.  添加一个语句来静态导入`System.Console`类型，并添加一个语句来输出传递给应用程序的参数数量，如下面的代码所示：

```cs

使用

static

System.Console;

WriteLine($"有

{args.Length}

参数。"

）；

```

**良好实践**：记住在所有未来的项目中静态导入`System.Console`类型，以简化您的代码，因为这些说明不会每次重复。

1.  运行代码并查看结果，如下面的输出所示：

```cs

没有参数。

```

1.  如果您正在使用 Visual Studio，则转到**项目** | **参数** **属性**，选择**调试**选项卡，在**应用程序参数**框中输入一些参数，保存更改，然后运行控制台应用程序，如*图 2.6*所示：![图形用户界面，文本，应用程序说明自动生成](img/Image00035.jpg)

图 2.6：在 Visual Studio 项目属性中输入应用程序参数

1.  如果您正在使用 Visual Studio Code，则在终端中，在`dotnet run`命令之后输入一些参数，如下所示：

```cs

dotnet run firstarg second-arg third:arg "fourth arg"

```

1.  注意结果显示了四个参数，如下面的输出所示：

```cs

有 4 个参数。

```

1.  要枚举或迭代（即循环）这四个参数的值，请在输出数组长度之后添加以下语句：

```cs

foreach

（字符串

arg in

args)

{

WriteLine(arg);

}

```

1.  再次运行代码，注意结果显示了四个参数的详细信息，如下所示：

```cs

有 4 个参数。

firstarg

second-arg

third:arg

第四个参数

```

## 使用参数设置选项

现在我们将使用这些参数，允许用户为输出窗口的背景、前景和光标大小选择颜色。光标大小可以是从 1 开始的整数值，表示光标单元底部的一条线，最大到 100，表示光标单元高度的百分比。

`System`命名空间已经导入，因此编译器知道`ConsoleColor`和`Enum`类型：

1.  添加语句以警告用户如果他们没有输入三个参数，然后解析这些参数并使用它们来设置控制台窗口的颜色和尺寸，如下代码所示：

```cs

if

(args.Length < 3

)

{

WriteLine("您必须指定两种颜色和光标大小，例如。"

);

WriteLine("dotnet run red yellow 50"

);

return

; // 停止运行

}

前景色 = (ConsoleColor)Enum.Parse(

enumType: typeof

(ConsoleColor),

value

: args[0

],

ignoreCase: true

);

BackgroundColor = (ConsoleColor)Enum.Parse(

enumType: typeof

(ConsoleColor),

value

: args[1

],

ignoreCase: true

);

CursorSize = int

.Parse(args[2

]);

```

设置`CursorSize`仅在 Windows 上受支持。

1.  在 Visual Studio 中，导航到**项目** | **参数属性**，并将参数更改为：`red yellow 50`，运行控制台应用程序，注意光标的大小减半，窗口中的颜色已更改，如*图 2.7*所示：![图形用户界面，应用程序，网站描述自动生成](img/Image00036.jpg)

图 2.7：在 Windows 上设置颜色和光标大小

1.  在 Visual Studio Code 中，使用参数运行代码，将前景色设置为红色，背景色设置为黄色，光标大小设置为 50%，如下命令所示：

```cs

dotnet run red yellow 50

```

在 macOS 上，您将看到一个未处理的异常，如*图 2.8*所示：

![图形用户界面，文本，应用程序描述自动生成](img/Image00037.jpg)

图 2.8：在不支持的 macOS 上发生未处理的异常

尽管编译器没有给出错误或警告，但在运行时，一些 API 调用可能在某些平台上失败。尽管在 Windows 上运行的控制台应用程序可以更改其光标大小，但在 macOS 上却不能，并且如果尝试，则会出现错误。

## 处理不支持 API 的平台

那么我们如何解决这个问题呢？我们可以通过使用异常处理程序来解决这个问题。您将在*第三章*，*控制流，类型转换和异常处理*中了解更多关于`try-catch`语句的细节，所以现在，只需输入以下代码：

1.  修改代码以在`try`语句中包装更改光标大小的行，如下代码所示：

```cs

try

{

CursorSize = int

.Parse(args[2

]);

}

catch (PlatformNotSupportedException)

{

WriteLine("当前平台不支持更改光标的大小。"

);

}

```

1.  如果您在 macOS 上运行代码，则会看到捕获到异常，并向用户显示更友好的消息。

处理操作系统差异的另一种方法是使用`System`命名空间中的`OperatingSystem`类，如下代码所示：

```cs

if

(OperatingSystem.IsWindows())

{

// 执行仅在 Windows 上有效的代码

}

else

if

(OperatingSystem.IsWindowsVersionAtLeast(major: 10

))

{

// 执行仅在 Windows 10 或更高版本上有效的代码

}

else

if

(OperatingSystem.IsIOSVersionAtLeast(major: 14

, minor: 5

))

{

// 执行仅在 iOS 14.5 或更高版本上有效的代码

}

else

if

(OperatingSystem.IsBrowser())

{

// 执行仅在具有 Blazor 的浏览器上有效的代码

}

```

`OperatingSystem`类还具有其他常见操作系统的等效方法，如 Android、iOS、Linux、macOS 甚至浏览器，这对于 Blazor 网络组件非常有用。

处理不同平台的第三种方法是使用条件编译语句。

有四个预处理指令来控制条件编译：`#if`，`#elif`，`#else`和`#endif`。

您可以使用`#define`来定义符号，如下代码所示：

```cs

#

define

MYSYMBOL

```

许多符号已经自动为您定义，如下表所示：

| 目标框架 | 符号 |
| --- | --- |
| .NET 标准 | `NETSTANDARD2_0`，`NETSTANDARD2_1`等 |
| 现代.NET | `NET6_0`，`NET6_0_ANDROID`，`NET6_0_IOS`，`NET6_0_WINDOWS`等 |

然后，你可以编写只在指定平台上编译的语句，就像下面的代码所示：

```cs

#

如果

NET6_0_ANDROID

// 编译语句仅适用于 Android

#

elif

NET6_0_IOS

// 编译语句仅适用于 iOS

#

else

// 编译语句适用于其他所有地方

#

endif

```

# 练习和探索

通过回答一些问题来测试你的知识和理解，进行一些实践，并深入研究本章涵盖的主题。

## 练习 2.1 – 测试你的知识

为了得到一些问题的最佳答案，你需要进行自己的研究。我希望你“超越书本”，所以我故意没有在书中提供所有答案。

我想鼓励你养成到其他地方寻求帮助的好习惯，遵循“授人以鱼不如授人以渔”的原则。

1.  你可以在 C#文件中输入什么语句来发现编译器和语言版本？

1.  C#中有哪两种类型的注释？

1.  逐字字符串和插值字符串之间有什么区别？

1.  为什么在使用`float`和`double`值时要小心？

1.  你如何确定像`double`这样的类型在内存中使用了多少字节？

1.  你什么时候应该使用`var`关键字？

1.  创建`XmlDocument`这样的类的实例的最新方法是什么？

1.  为什么在使用`dynamic`类型时要小心？

1.  如何使格式字符串右对齐？

1.  控制台应用程序的参数是由什么字符分隔的？

*附录*，*测试你的知识问题的答案* 可以从 GitHub 存储库的 README 中的链接下载：[`github.com/markjprice/cs10dotnet6`](https://github.com/markjprice/cs10dotnet6)。

## 练习 2.2 – 测试数字类型的知识

你会选择什么类型来表示以下的“数字”？

1.  一个人的电话号码

1.  一个人的身高

1.  一个人的年龄

1.  一个人的工资

1.  一本书的 ISBN

1.  一本书的价格

1.  一本书的运输重量

1.  一个国家的人口

1.  宇宙中的星星数量

1.  英国小型或中型企业中的员工人数（每家企业最多约 50,000 名员工）

## 练习 2.3 – 练习数字大小和范围

在`Chapter02`解决方案/工作区中，创建一个名为`Exercise02`的控制台应用程序项目，输出以下每种数字类型在内存中使用的字节数以及它们可以具有的最小和最大值：`sbyte`，`byte`，`short`，`ushort`，`int`，`uint`，`long`，`ulong`，`float`，`double`和`decimal`。

运行控制台应用程序的结果应该类似于*图 2.9*：

![自动生成的文本描述](img/Image00038.jpg)

图 2.9：输出数字类型大小的结果

所有练习的代码解决方案都可以从以下链接的 GitHub 存储库中下载或克隆：[`github.com/markjprice/cs10dotnet6`](https://github.com/markjprice/cs10dotnet6)。

## 练习 2.4 – 探索主题

使用以下页面上的链接，了解本章涵盖的主题的更多细节：

[`github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c`](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c)

# 摘要

在本章中，你学会了如何：

+   声明具有指定或推断类型的变量。

+   使用一些内置的类型来表示数字、文本和布尔值。

+   在数字类型之间进行选择。

+   控制控制台应用程序中的输出格式。

在下一章中，你将学习关于运算符、分支、循环、类型转换以及如何处理异常。
