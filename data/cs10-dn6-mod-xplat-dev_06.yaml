- en: '06'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '06'
- en: Implementing Interfaces and Inheriting Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口和继承类
- en: This chapter is about deriving new types from existing ones using **object-oriented
    programming** (**OOP**). You will learn about defining operators and local functions
    for performing simple actions and delegates and events for exchanging messages
    between types. You will implement interfaces for common functionality. You will
    learn about generics and the difference between reference and value types. You
    will create a derived class to inherit from a base class to reuse functionality,
    override an inherited type member, and use polymorphism. Finally, you will learn
    how to create extension methods and how to cast between classes in an inheritance
    hierarchy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于使用**面向对象编程**（**OOP**）从现有类型派生新类型的。你将学习定义运算符和局部函数以执行简单操作，以及委托和事件以在类型之间交换消息。你将实现接口以实现通用功能。你将了解泛型以及引用类型和值类型之间的区别。你将创建一个派生类以从基类继承功能，覆盖继承的类型成员，并使用多态性。最后，你将学习如何创建扩展方法以及如何在继承层次结构中的类之间进行类型转换。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Setting up a class library and console application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置类库和控制台应用程序
- en: More about methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于方法的内容
- en: Raising and handling events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发和处理事件
- en: Making types safely reusable with generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型安全地重用类型
- en: Implementing interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口
- en: Managing memory with reference and value types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引用和值类型管理内存
- en: Working with null values
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理空值
- en: Inheriting from classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类继承
- en: Casting within inheritance hierarchies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继承层次结构中进行类型转换
- en: Inheriting and extending .NET types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承和扩展.NET类型
- en: Using an analyzer to write better code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分析器编写更好的代码
- en: Setting up a class library and console application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置类库和控制台应用程序
- en: 'We will start by defining a workspace/solution with two projects like the one
    created in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*.
    Even if you completed all the exercises in that chapter, follow the instructions
    below because we will use C# 10 features in the class library, so it needs to
    target .NET 6.0 rather than .NET Standard 2.0:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个包含两个项目的工作区/解决方案，类似于在*第5章*，*使用面向对象编程构建自己的类型*中创建的那个。即使你完成了该章的所有练习，也要按照下面的说明操作，因为我们将在类库中使用C#
    10特性，因此它需要面向.NET 6.0而不是.NET Standard 2.0：
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter06`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编码工具创建一个名为`Chapter06`的新工作区/解决方案。
- en: 'Add a class library project, as defined in the following list:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类库项目，如下列表定义：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `PacktLibrary`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PacktLibrary`
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用程序项目，如下列表定义：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `PeopleApp`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PeopleApp`
- en: In the `PacktLibrary` project, rename the file named `Class1.cs` to `Person.cs`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，将名为`Class1.cs`的文件重命名为`Person.cs`。
- en: 'Modify the `Person.cs` file contents, as shown in the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Person.cs`文件内容，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `PeopleApp` project, add a project reference to `PacktLibrary`, as shown
    highlighted in the following markup:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中，添加对`PacktLibrary`的项目引用，如以下标记中突出显示的那样：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build the `PeopleApp` project and note the output indicating that both projects
    have been built successfully.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目并注意输出，表明两个项目都已成功构建。
- en: More about methods
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于方法的内容
- en: We might want two instances of `Person` to be able to procreate. We can implement
    this by writing methods. Instance methods are actions that an object does to itself;
    static methods are actions the type does.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望两个`Person`实例能够繁殖。我们可以通过编写方法来实现这一点。实例方法是对象对自己执行的操作；静态方法是类型执行的操作。
- en: Which you choose depends on what makes the most sense for the action.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪种方式取决于哪种对行动最有意义。
- en: '**Good Practice**: Having both static and instance methods to perform similar
    actions often makes sense. For example, `string` has both a `Compare` static method
    and a `CompareTo` instance method. This puts the choice of how to use the functionality
    in the hands of the programmers using your type, giving them more flexibility.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：同时拥有静态方法和实例方法来执行类似操作通常是有意义的。例如，`string`类型既有`Compare`静态方法，也有`CompareTo`实例方法。这使得使用你的类型的程序员能够选择如何使用这些功能，为他们提供了更多的灵活性。'
- en: Implementing functionality using methods
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过方法实现功能
- en: 'Let''s start by implementing some functionality by using both static and instance
    methods:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过使用静态和实例方法来实现一些功能：
- en: 'Add one instance method and one static method to the `Person` class that will
    allow two `Person` objects to procreate, as shown in the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Person`类添加一个实例方法和一个静态方法，这将允许两个`Person`对象繁衍后代，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the following:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: In the `static` method named `Procreate`, the `Person` objects to procreate
    are passed as parameters named `p1` and `p2`.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名为`Procreate`的`static`方法中，要繁衍后代的`Person`对象作为参数`p1`和`p2`传递。
- en: A new `Person` class named `baby` is created with a name composed of a combination
    of the two people who have procreated. This could be changed later by setting
    the returned `baby` variable's `Name` property.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的`Person`类名为`baby`，其名字由繁衍后代的两个人的名字组合而成。这可以通过设置返回的`baby`变量的`Name`属性来稍后更改。
- en: The `baby` object is added to the `Children` collection of both parents and
    then returned. Classes are reference types, meaning a reference to the `baby`
    object stored in memory is added, not a clone of the `baby` object. You will learn
    the difference between reference types and value types later in this chapter.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`baby`对象被添加到两个父母的`Children`集合中，然后返回。类是引用类型，意味着在内存中存储的`baby`对象的引用被添加，而不是`baby`对象的克隆。你将在本章后面学习引用类型和值类型之间的区别。'
- en: In the instance method named `ProcreateWith`, the `Person` object to procreate
    with is passed as a parameter named `partner`, and it, along with `this`, is passed
    to the static `Procreate` method to reuse the method implementation. `this` is
    a keyword that references the current instance of the class.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名为`ProcreateWith`的实例方法中，要与之繁衍后代的`Person`对象作为参数`partner`传递，它与`this`一起被传递给静态`Procreate`方法以重用方法实现。`this`是一个关键字，它引用当前类的实例。
- en: '**Good Practice**: A method that creates a new object, or modifies an existing
    object, should return a reference to that object so that the caller can access
    the results.'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：创建新对象或修改现有对象的方法应返回对该对象的引用，以便调用者可以访问结果。'
- en: 'In the `PeopleApp` project, at the top of the `Program.cs` file, delete the
    comment and import the namespace for our `Person` class and statically import
    the `Console` type, as shown in the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中，在`Program.cs`文件的顶部，删除注释并导入我们的`Person`类和静态导入`Console`类型，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `Program.cs`, create three people and have them procreate with each other,
    noting that to add a double-quote character into a `string`, you must prefix it
    with a backslash character like this, `\"`, as shown in the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建三个人并让他们相互繁衍后代，注意要在`string`中添加双引号字符，你必须在其前面加上反斜杠字符，如下所示，`\"`，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implementing functionality using operators
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过运算符实现功能
- en: 'The `System.String` class has a `static` method named `Concat` that concatenates
    two string values and returns the result, as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.String`类有一个名为`Concat`的`static`方法，它将两个字符串值连接起来并返回结果，如下面的代码所示：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Calling a method like `Concat` works, but it might be more natural for a programmer
    to use the `+` symbol operator to "add" two `string` values together, as shown
    in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 调用像`Concat`这样的方法是可以的，但对程序员来说，使用`+`符号运算符将两个`string`值“相加”可能更自然，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A well-known biblical phrase is *Go forth and multiply*, meaning to procreate.
    Let's write code so that the `*` (multiply) symbol will allow two `Person` objects
    to procreate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一句广为人知的圣经格言是*去繁衍后代*，意指生育。让我们编写代码，使得`*`（乘法）符号能让两个`Person`对象繁衍后代。
- en: We do this by defining a `static` operator for the `*` symbol. The syntax is
    rather like a method, because in effect, an operator *is* a method, but uses a
    symbol instead of a method name, which makes the syntax more concise.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为`*`符号定义一个`static`运算符来实现这一点。语法类似于方法，因为实际上，运算符*就是*一个方法，但使用符号代替方法名，使得语法更为简洁。
- en: 'In `Person.cs`, create a `static` operator for the `*` symbol, as shown in
    the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，创建一个`static`运算符用于`*`符号，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Good Practice**: Unlike methods, operators do not appear in IntelliSense
    lists for a type. For every operator that you define, make a method as well, because
    it may not be obvious to a programmer that the operator is available. The implementation
    of the operator can then call the method, reusing the code you have written. A
    second reason for providing a method is that operators are not supported by every
    language compiler; for example, although arithmetic operators like * are supported
    by Visual Basic and F#, there is no requirement that other languages support all
    operators supported by C#.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：与方法不同，运算符不会出现在类型的IntelliSense列表中。对于您定义的每个运算符，都应同时创建一个方法，因为程序员可能不清楚该运算符可用。运算符的实现可以调用该方法，重用您编写的代码。提供方法的第二个原因是并非所有语言编译器都支持运算符；例如，尽管Visual
    Basic和F#支持诸如*之类的算术运算符，但没有要求其他语言支持C#支持的所有运算符。'
- en: 'In `Program.cs`, after calling the `Procreate` method and before the statements
    that write to the console, use the `*` operator to make another baby, as shown
    highlighted in the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在调用`Procreate`方法和向控制台写入语句之前，使用`*`运算符再制造一个婴儿，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implementing functionality using local functions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用局部函数实现功能
- en: A language feature introduced in C# 7.0 is the ability to define a **local function**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0引入的一个语言特性是能够定义**局部函数**。
- en: Local functions are the method equivalent of local variables. In other words,
    they are methods that are only accessible from within the containing method in
    which they have been defined. In other languages, they are sometimes called **nested**
    or **inner functions**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数相当于方法中的局部变量。换句话说，它们是仅在其定义的包含方法内部可访问的方法。在其他语言中，它们有时被称为**嵌套**或**内部函数**。
- en: 'Local functions can be defined anywhere inside a method: the top, the bottom,
    or even somewhere in the middle!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 局部函数可以在方法内的任何位置定义：顶部、底部，甚至中间的某个位置！
- en: 'We will use a local function to implement a factorial calculation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用局部函数来实现阶乘计算：
- en: 'In `Person.cs`, add statements to define a `Factorial` function that uses a
    local function inside itself to calculate the result, as shown in the following
    code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义一个`Factorial`函数，该函数在其内部使用局部函数来计算结果，如下所示：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `Program.cs`, add a statement to call the `Factorial` function and write
    the return value to the console, as shown in the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句以调用`Factorial`函数并将返回值写入控制台，如下所示：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Raising and handling events
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引发和处理事件
- en: Methods are often described as *actions that an object can perform, either on
    itself or on related objects*. For example, `List<T>` can add an item to itself
    or clear itself, and `File` can create or delete a file in the filesystem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通常被描述为*对象可以执行的动作，无论是对自己还是对相关对象*。例如，`List<T>`可以向自身添加项目或清除自身，而`File`可以在文件系统中创建或删除文件。
- en: Events are often described as *actions that happen to an object*. For example,
    in a user interface, `Button` has a `Click` event, a click being something that
    happens to a button, and `FileSystemWatcher` listens to the filesystem for change
    notifications and raises events like `Created` and `Deleted` that are triggered
    when a directory or file changes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常被描述为*发生在对象上的动作*。例如，在用户界面中，`Button`有一个`Click`事件，点击是发生在按钮上的事情，而`FileSystemWatcher`监听文件系统的更改通知并引发`Created`和`Deleted`等事件，这些事件在目录或文件更改时触发。
- en: Another way of thinking of events is that they provide a way of exchanging messages
    between two objects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考事件的方式是，它们提供了一种在两个对象之间交换消息的方法。
- en: Events are built on **delegates**, so let's start by having a look at what delegates
    are and how they work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 事件基于**委托**构建，因此让我们先了解一下委托是什么以及它们如何工作。
- en: Calling methods using delegates
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用委托调用方法
- en: 'You have already seen the most common way to call or execute a method: use
    the `.` operator to access the method using its name. For example, `Console.WriteLine`
    tells the `Console` type to access its `WriteLine` method.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了调用或执行方法的最常见方式：使用 `.` 运算符通过其名称访问该方法。例如，`Console.WriteLine` 告诉 `Console`
    类型访问其 `WriteLine` 方法。
- en: The other way to call or execute a method is to use a delegate. If you have
    used languages that support **function pointers**, then think of a delegate as
    being a **type-safe method pointer**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调用或执行方法的另一种方式是使用委托。如果你使用过支持**函数指针**的语言，那么可以将委托视为**类型安全的方法指针**。
- en: In other words, a delegate contains the memory address of a method that matches
    the same signature as the delegate so that it can be called safely with the correct
    parameter types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，委托包含与委托具有相同签名的方法的内存地址，以便可以安全地使用正确的参数类型调用它。
- en: 'For example, imagine there is a method in the `Person` class that must have
    a `string` type passed as its only parameter, and it returns an `int` type, as
    shown in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 `Person` 类中有一个方法，它必须接受一个 `string` 类型的唯一参数，并返回一个 `int` 类型，如下所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I can call this method on an instance of `Person` named `p1` like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在名为 `p1` 的 `Person` 实例上调用此方法，如下所示：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, I can define a delegate with a matching signature to call the
    method indirectly. Note that the names of the parameters do not have to match.
    Only the types of parameters and return values must match, as shown in the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我可以定义一个与签名匹配的委托来间接调用该方法。请注意，参数的名称不必匹配。只有参数类型和返回值必须匹配，如下所示：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, I can create an instance of the delegate, point it at the method, and
    finally, call the delegate (which calls the method), as shown in the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以创建一个委托实例，将其指向该方法，最后，调用该委托（即调用该方法），如下所示：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You are probably thinking, "What's the point of that?" Well, it provides flexibility.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“这有什么意义？”嗯，它提供了灵活性。
- en: For example, we could use delegates to create a queue of methods that need to
    be called in order. Queuing actions that need to be performed is common in services
    to provide improved scalability.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用委托来创建一个方法队列，这些方法需要按顺序调用。在服务中排队执行操作以提供更好的可扩展性是很常见的。
- en: Another example is to allow multiple actions to perform in parallel. Delegates
    have built-in support for asynchronous operations that run on a different thread,
    and that can provide improved responsiveness. You will learn how to do this in
    *Chapter 12*, *Improving Performance and Scalability Using Multitasking*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是允许多个操作并行执行。委托内置支持异步操作，这些操作在不同的线程上运行，并且可以提供更好的响应性。你将在*第12章*，*使用多任务提高性能和可扩展性*中学习如何做到这一点。
- en: The most important example is that delegates allow us to implement events for
    sending messages between different objects that do not need to know about each
    other. Events are an example of loose coupling between components because the
    components do not need to know about each other, they just need to know the event
    signature.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的例子是，委托允许我们实现事件，以便在不需要相互了解的不同对象之间发送消息。事件是组件之间松散耦合的一个例子，因为组件不需要了解彼此，它们只需要知道事件签名。
- en: Delegates and events are two of the most confusing features of C# and can take
    a few attempts to understand, so don't worry if you feel lost!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 委托和事件是 C# 中最令人困惑的两个特性，可能需要几次尝试才能理解，所以如果你感到迷茫，不要担心！
- en: Defining and handling delegates
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和处理委托
- en: 'Microsoft has two predefined delegates for use as events. Their signatures
    are simple, yet flexible, as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 为事件提供了两个预定义的委托，其签名简单而灵活，如下所示：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Good Practice**: When you want to define an event in your own types, you
    should use one of these two predefined delegates.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：当你想在自己的类型中定义一个事件时，你应该使用这两个预定义委托之一。'
- en: 'Let''s explore delegates and events:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索委托和事件：
- en: 'Add statements to the `Person` class and note the following points, as shown
    in the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Person` 类添加语句，并注意以下几点，如下所示：
- en: It defines an `EventHandler` delegate field named `Shout`.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为 `Shout` 的 `EventHandler` 委托字段。
- en: It defines an `int` field to store `AngerLevel`.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个 `int` 字段来存储 `AngerLevel`。
- en: It defines a method named `Poke`.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为 `Poke` 的方法。
- en: 'Each time a person is poked, their `AngerLevel` increments. Once their `AngerLevel`
    reaches three, they raise the `Shout` event, but only if there is at least one
    event delegate pointing at a method defined somewhere else in the code; that is,
    it is not `null`:'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次有人被戳时，他们的`AngerLevel`都会增加。一旦他们的`AngerLevel`达到三，他们就会引发`Shout`事件，但前提是至少有一个事件委托指向代码中其他地方定义的方法；也就是说，它不是`null`：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Checking whether an object is not `null` before calling one of its methods
    is very common. C# 6.0 and later allows `null` checks to be simplified inline
    using a `?` symbol before the `.` operator, as shown in the following code:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用其方法之前检查对象是否不为`null`是非常常见的。C# 6.0及更高版本允许使用`?`符号在`.`运算符之前简化内联的`null`检查，如以下代码所示：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At the bottom of `Program.cs`, add a method with a matching signature that
    gets a reference to the `Person` object from the `sender` parameter and outputs
    some information about them, as shown in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，添加一个具有匹配签名的方法，该方法从`sender`参数获取`Person`对象的引用，并输出有关他们的信息，如以下代码所示：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Microsoft's convention for method names that handle events is `ObjectName_EventName`.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 微软对于处理事件的方法命名的约定是`对象名_事件名`。
- en: 'In `Program.cs`, add a statement to assign the method to the delegate field,
    as shown in the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句，将方法分配给委托字段，如以下代码所示：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add statements to call the `Poke` method four times, after assigning the method
    to the `Shout` event, as shown highlighted in the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将方法分配给`Shout`事件后，添加语句调用`Poke`方法四次，如以下突出显示的代码所示：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the code and view the result, and note that Harry says nothing the first
    two times he is poked, and only gets angry enough to shout once he''s been poked
    at least three times, as shown in the following output:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，注意哈利在前两次被戳时什么也没说，只有在被戳至少三次后才足够生气以至于大喊，如以下输出所示：
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Defining and handling events
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和处理事件
- en: 'You''ve now seen how delegates implement the most important functionality of
    events: the ability to define a signature for a method that can be implemented
    by a completely different piece of code, and then call that method and any others
    that are hooked up to the delegate field.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到了委托如何实现事件最重要的功能：定义一个方法签名，该签名可以由完全不同的代码块实现，然后调用该方法以及连接到委托字段的其他任何方法。
- en: But what about events? There is less to them than you might think.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 那么事件呢？它们可能比你想象的要简单。
- en: When assigning a method to a delegate field, you should not use the simple assignment
    operator as we did in the preceding example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在将方法分配给委托字段时，不应使用我们在前述示例中使用的简单赋值运算符。
- en: Delegates are multicast, meaning that you can assign multiple delegates to a
    single delegate field. Instead of the `=` assignment, we could have used the `+=`
    operator so we could add more methods to the same delegate field. When the delegate
    is called, all the assigned methods are called, although you have no control over
    the order in which they are called.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是多播的，这意味着你可以将多个委托分配给单个委托字段。我们本可以使用`+=`运算符而不是`=`赋值，这样我们就可以向同一个委托字段添加更多方法。当委托被调用时，所有分配的方法都会被调用，尽管你无法控制它们被调用的顺序。
- en: 'If the `Shout` delegate field was already referencing one or more methods,
    by assigning a method, it would replace all the others. With delegates that are
    used for events, we usually want to make sure that a programmer only ever uses
    either the `+=` operator or the `-=` operator to assign and remove methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Shout`委托字段已经引用了一个或多个方法，通过分配一个方法，它将替换所有其他方法。对于用于事件的委托，我们通常希望确保程序员仅使用`+=`运算符或`-=`运算符来分配和移除方法：
- en: 'To enforce this, in `Person.cs`, add the `event` keyword to the delegate field
    declaration, as shown highlighted in the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了强制执行这一点，在`Person.cs`中，将`event`关键字添加到委托字段声明中，如以下突出显示的代码所示：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Build the `PeopleApp` project and note the compiler error message, as shown
    in the following output:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目，并注意编译器错误消息，如以下输出所示：
- en: '[PRE26]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is (almost) all that the `event` keyword does! If you will never have more
    than one method assigned to a delegate field, then technically you do not need
    "events," but it is still good practice to indicate your meaning and that you
    expect a delegate field to be used as an event.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是`event`关键字所做的（几乎）所有事情！如果你永远不会将一个以上的方法分配给委托字段，那么从技术上讲，你不需要“事件”，但仍然是一种良好的实践，表明你的意图，并期望委托字段被用作事件。
- en: 'Modify the method assignment to use `+=`, as shown in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方法赋值修改为使用`+=`，如下列代码所示：
- en: '[PRE27]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the code and note that it has the same behavior as before.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它具有与之前相同的行为。
- en: Making types safely reusable with generics
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过泛型安全地重用类型
- en: In 2005, with C# 2.0 and .NET Framework 2.0, Microsoft introduced a feature
    named **generics**, which enables your types to be more safely reusable and more
    efficient. It does this by allowing a programmer to pass types as parameters,
    similar to how you can pass objects as parameters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，随着C# 2.0和.NET Framework 2.0的推出，微软引入了一项名为**泛型**的功能，它使你的类型能更安全地重用且更高效。它通过允许程序员传递类型作为参数来实现这一点，类似于你可以传递对象作为参数的方式。
- en: Working with non-generic types
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非泛型类型
- en: First, let's look at an example of working with a non-generic type so that you
    can understand the problem that generics are designed to solve, such as weakly
    typed parameters and values, and performance problems caused by using `System.Object`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个使用非泛型类型的例子，以便你能理解泛型旨在解决的问题，例如弱类型参数和值，以及使用`System.Object`导致性能问题。
- en: '`System.Collections.Hashtable` can be used to store multiple values each with
    a unique key that can later be used to quickly look up its value. Both the key
    and value can be any object because they are declared as `System.Object`. Although
    this provides flexibility when storing value types like integers, it is slow,
    and bugs are easier to introduce because no type checks are made when adding items.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Hashtable`可用于存储多个值，每个值都有一个唯一键，稍后可用于快速查找其值。键和值都可以是任何对象，因为它们被声明为`System.Object`。虽然这为存储整数等值类型提供了灵活性，但它速度慢，且更容易引入错误，因为添加项时不会进行类型检查。'
- en: 'Let''s write some code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码：
- en: 'In `Program.cs`, create an instance of the non-generic collection, `System.Collections.Hashtable`,
    and then add four items to it, as shown in the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个非泛型集合`System.Collections.Hashtable`的实例，然后添加四个项，如下列代码所示：
- en: '[PRE28]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add statements to define a `key` with the value of `2` and use it to look up
    its value in the hash table, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句定义一个值为`2`的`key`，并使用它在哈希表中查找其值，如下列代码所示：
- en: '[PRE29]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add statements to use the `harry` object to look up its value, as shown in
    the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句使用`harry`对象查找其值，如下列代码所示：
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the code and note that it works, as shown in the following output:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它按预期工作，如下列输出所示：
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Although the code works, there is potential for mistakes because literally any
    type can be used for the key or value. If another developer used your lookup object
    and expected all the items to be a certain type, they might cast them to that
    type and get exceptions because some values might be a different type. A lookup
    object with lots of items would also give poor performance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码能运行，但存在出错的可能性，因为实际上任何类型都可以用作键或值。如果其他开发人员使用了你的查找对象，并期望所有项都是特定类型，他们可能会将其强制转换为该类型，并因某些值可能为不同类型而引发异常。包含大量项的查找对象也会导致性能不佳。
- en: '**Good Practice**: Avoid types in the `System.Collections` namespace.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免使用`System.Collections`命名空间中的类型。'
- en: Working with generic types
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型类型
- en: '`System.Collections.Generic.Dictionary<TKey, TValue>` can be used to store
    multiple values each with a unique key that can later be used to quickly look
    up its value. Both the key and value can be any object, but you must tell the
    compiler what the types of the key and value will be when you first instantiate
    the collection. You do this by specifying types for the **generic parameters**
    in angle brackets `<>`, `TKey`, and `TValue`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Generic.Dictionary<TKey, TValue>`可用于存储多个值，每个值都有一个唯一键，稍后可用于快速查找其值。键和值可以是任何对象，但你必须在首次实例化集合时告诉编译器键和值的类型。你通过在尖括号`<>`中指定**泛型参数**的类型来实现这一点，即`TKey`和`TValue`。'
- en: '**Good Practice**: When a generic type has one definable type, it should be
    named `T`, for example, `List<T>`, where `T` is the type stored in the list. When
    a generic type has multiple definable types, they should use `T` as a name prefix
    and have a sensible name, for example, `Dictionary<TKey, TValue>`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当泛型类型有一个可定义的类型时，应将其命名为`T`，例如`List<T>`，其中`T`是列表中存储的类型。当泛型类型有多个可定义的类型时，应使用`T`作为名称前缀，并取一个合理的名称，例如`Dictionary<TKey,
    TValue>`。'
- en: This provides flexibility, it is faster, and bugs are easier to avoid because
    type checks are made when adding items.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了灵活性，速度更快，且更容易避免错误，因为添加项时会进行类型检查。
- en: 'Let''s write some code to solve the problem by using generics:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，使用泛型来解决问题：
- en: 'In `Program.cs`, create an instance of the generic lookup collection `Dictionary<TKey,
    TValue>` and then add four items to it, as shown in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建泛型查找集合`Dictionary<TKey, TValue>`的实例，然后添加四个项目，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note the compile error when using `harry` as a key, as shown in the following
    output:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意使用`harry`作为键时出现的编译错误，如下面的输出所示：
- en: '[PRE33]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Replace `harry` with `4`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`harry`替换为`4`。
- en: 'Add statements to set the `key` to `3` and use it to look up its value in the
    dictionary, as shown in the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句将`key`设置为`3`，并使用它在字典中查找其值，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the code and note that it works, as shown in the following output:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它按预期工作，如下面的输出所示：
- en: '[PRE35]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Implementing interfaces
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: Interfaces are a way of connecting different types to make new things. Think
    of them like the studs on top of LEGO™ bricks, which allow them to "stick" together,
    or electrical standards for plugs and sockets.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种将不同类型连接起来以创建新事物的方式。将它们想象成乐高™积木顶部的凸起，使它们能够“粘合”在一起，或者是插头和插座的电气标准。
- en: If a type implements an interface, then it is making a promise to the rest of
    .NET that it supports specific functionality. This is why they are sometimes described
    as being contracts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型实现了接口，那么它就是在向.NET的其余部分承诺它支持特定的功能。这就是为什么它们有时被描述为合同。
- en: Common interfaces
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见接口
- en: 'Here are some common interfaces that your types might need to implement:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您的类型可能需要实现的一些常见接口：
- en: '| Interface | Method(s) | Description |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 方法 | 描述 |'
- en: '| `IComparable` | `CompareTo(other)` | This defines a comparison method that
    a type implements to order or sort its instances. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `IComparable` | `CompareTo(other)` | 这定义了一个比较方法，类型通过该方法实现对其实例的排序。'
- en: '| `IComparer` | `Compare(first, second)` | This defines a comparison method
    that a secondary type implements to order or sort instances of a primary type.
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `IComparer` | `Compare(first, second)` | 这定义了一个比较方法，辅助类型通过该方法实现对主类型实例的排序。'
- en: '| `IDisposable` | `Dispose()` | This defines a disposal method to release unmanaged
    resources more efficiently than waiting for a finalizer (see the *Releasing unmanaged
    resources* section later in this chapter for more details. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `IDisposable` | `Dispose()` | 这定义了一个处置方法，以更有效地释放非托管资源，而不是等待终结器（有关详细信息，请参阅本章后面的*释放非托管资源*部分）。'
- en: '| `IFormattable` | `ToString(format, culture)` | This defines a culture-aware
    method to format the value of an object into a string representation. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `IFormattable` | `ToString(format, culture)` | 这定义了一个文化感知的方法，将对象的值格式化为字符串表示。'
- en: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | This defines
    methods to convert an object to and from a stream of bytes for storage or transfer.
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | 这定义了将对象转换为字节流以及从字节流转换回对象的方法，用于存储或传输。'
- en: '| `IFormatProvider` | `GetFormat(type)` | This defines a method to format inputs
    based on a language and region. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `IFormatProvider` | `GetFormat(type)` | 这定义了一个根据语言和区域格式化输入的方法。'
- en: Comparing objects when sorting
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序时比较对象
- en: 'One of the most common interfaces that you will want to implement is `IComparable`.
    It has one method named `CompareTo`. It has two variations, one that works with
    a nullable `object` type and one that works with a nullable generic type `T`,
    as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您最常想要实现的接口之一是`IComparable`。它有一个名为`CompareTo`的方法。它有两种变体，一种适用于可空`object`类型，另一种适用于可空泛型类型`T`，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For example, the `string` type implements `IComparable` by returning `-1` if
    the `string` is less than the `string` being compared to or `1` if it is greater.
    The `int` type implements `IComparable` by returning `-1` if the `int` is less
    than the `int` being compared to or `1` if it is greater.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`string`类型通过返回`-1`（如果`string`小于被比较的`string`）或`1`（如果它更大）来实现`IComparable`。`int`类型通过返回`-1`（如果`int`小于被比较的`int`）或`1`（如果它更大）来实现`IComparable`。
- en: If a type implements one of the `IComparable` interfaces, then arrays and collections
    can sort it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型实现了`IComparable`接口之一，那么数组和集合就可以对其进行排序。
- en: 'Before we implement the `IComparable` interface and its `CompareTo` method
    for the `Person` class, let''s see what happens when we try to sort an array of
    `Person` instances:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为`Person`类实现`IComparable`接口及其`CompareTo`方法之前，让我们看看当我们尝试对`Person`实例数组进行排序时会发生什么：
- en: 'In `Program.cs`, add statements that create an array of `Person` instances
    and write the items to the console, and then attempt to sort the array and write
    the items to the console again, as shown in the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以创建`Person`实例的数组，并将项目写入控制台，然后尝试对数组进行排序，并将项目再次写入控制台，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the code and an exception will be thrown. As the message explains, to fix
    the problem, our type must implement `IComparable`, as shown in the following
    output:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，将会抛出异常。正如消息所述，要解决问题，我们的类型必须实现`IComparable`，如下面的输出所示：
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `Person.cs`, after inheriting from `object`, add a comma and enter `IComparable<Person>`,
    as shown in the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，在继承自`object`之后，添加一个逗号并输入`IComparable<Person>`，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Your code editor will draw a red squiggle under the new code to warn you that
    you have not yet implemented the method you have promised to. Your code editor
    can write the skeleton implementation for you if you click on the light bulb and
    choose the **Implement interface** option.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的代码编辑器会在新代码下方画一条红色波浪线，警告你尚未实现承诺的方法。点击灯泡并选择**实现接口**选项，你的代码编辑器可以为你编写骨架实现。
- en: 'Scroll down to the bottom of the `Person` class to find the method that was
    written for you and delete the statement that throws the `NotImplementedException`
    error, as shown highlighted in the following code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动至`Person`类的底部，找到为你编写的方法，并删除抛出`NotImplementedException`错误的语句，如以下代码中突出显示的部分所示：
- en: '[PRE40]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a statement to call the `CompareTo` method of the `Name` field, which uses
    the `string` type''s implementation of `CompareTo` and return the result, as shown
    highlighted in the following code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一条语句以调用`Name`字段的`CompareTo`方法，该方法使用`string`类型的`CompareTo`实现并返回结果，如下面的代码中突出显示的部分所示：
- en: '[PRE41]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We have chosen to compare two `Person` instances by comparing their `Name` fields.
    `Person` instances will, therefore, be sorted alphabetically by their name. For
    simplicity, I have not added `null` checks throughout these examples.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们选择通过比较`Person`实例的`Name`字段来比较两个`Person`实例。因此，`Person`实例将按其名称的字母顺序排序。为简单起见，我没有在这些示例中添加`null`检查。
- en: 'Run the code and note that this time it works as it should, as shown in the
    following output:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意这次它按预期工作，如下面的输出所示：
- en: '[PRE42]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Good Practice**: If anyone will want to sort an array or collection of instances
    of your type, then implement the `IComparable` interface.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：如果有人想要对类型的数组或集合进行排序，那么请实现`IComparable`接口。'
- en: Comparing objects using a separate class
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单独的类比较对象
- en: 'Sometimes, you won''t have access to the source code for a type, and it might
    not implement the `IComparable` interface. Luckily, there is another way to sort
    instances of a type. You can create a separate type that implements a slightly
    different interface, named `IComparer`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能无法访问类型的源代码，并且它可能未实现`IComparable`接口。幸运的是，还有另一种方法可以对类型的实例进行排序。你可以创建一个单独的类型，该类型实现一个略有不同的接口，名为`IComparer`：
- en: 'In the `PacktLibrary` project, add a new class file named `PersonComparer.cs`
    containing a class that implements the `IComparer` interface that will compare
    two people, that is, two `Person` instances. Implement it by comparing the length
    of their `Name` field, or if the names are the same length, then by comparing
    the names alphabetically, as shown in the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`PersonComparer.cs`的新类文件，其中包含一个实现`IComparer`接口的类，该接口将比较两个人，即两个`Person`实例。通过比较他们的`Name`字段的长度来实现它，如果名称长度相同，则按字母顺序比较名称，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `Program.cs`, add statements to sort the array using this alternative implementation,
    as shown in the following code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以使用此替代实现对数组进行排序，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE45]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This time, when we sort the `people` array, we explicitly ask the sorting algorithm
    to use the `PersonComparer` type instead, so that the people are sorted with the
    shortest names first, like Adam, and the longest names last, like Richard; and
    when the lengths of two or more names are equal, to sort them alphabetically,
    like Jenny and Simon.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们对`people`数组进行排序时，我们明确要求排序算法使用`PersonComparer`类型，以便人们按名字最短的先排序，如Adam，名字最长的后排序，如Richard；当两个或多个名字长度相等时，按字母顺序排序，如Jenny和Simon。
- en: Implicit and explicit interface implementations
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式与显式接口实现
- en: Interfaces can be implemented implicitly and explicitly. Implicit implementations
    are simpler and more common. Explicit implementations are only necessary if a
    type must have multiple methods with the same name and signature.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以隐式和显式实现。隐式实现更简单、更常见。只有当类型必须具有具有相同名称和签名的多个方法时，才需要显式实现。
- en: 'For example, both `IGamePlayer` and `IKeyHolder` might have a method called
    `Lose` with the same parameters because both a game and a key can be lost. In
    a type that must implement both interfaces, only one implementation of `Lose`
    can be the implicit method. If both interfaces can share the same implementation,
    that works, but if not then the other `Lose` method will have to be implemented
    differently and called explicitly, as shown in the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`IGamePlayer`和`IKeyHolder`可能都有一个名为`Lose`的方法，参数相同，因为游戏和钥匙都可能丢失。在必须实现这两个接口的类型中，只能有一个`Lose`方法作为隐式方法。如果两个接口可以共享相同的实现，那很好，但如果不能，则另一个`Lose`方法必须以不同的方式实现并显式调用，如下所示：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Defining interfaces with default implementations
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义具有默认实现的接口
- en: 'A language feature introduced in C# 8.0 is **default implementations** for
    an interface. Let''s see it in action:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0引入的一项语言特性是接口的**默认实现**。让我们看看它的实际应用：
- en: In the `PacktLibrary` project, add a new file named `IPlayable.cs`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`IPlayable.cs`的新文件。
- en: 'Modify the statements to define a public `IPlayable` interface with two methods
    to `Play` and `Pause`, as shown in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改语句以定义一个具有两个方法`Play`和`Pause`的公共`IPlayable`接口，如下所示：
- en: '[PRE47]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the `PacktLibrary` project, add a new class file named `DvdPlayer.cs`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`DvdPlayer.cs`的新类文件。
- en: 'Modify the statements in the file to implement the `IPlayable` interface, as
    shown in the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件中的语句以实现`IPlayable`接口，如下所示：
- en: '[PRE48]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is useful, but what if we decide to add a third method named `Stop`? Before
    C# 8.0, this would be impossible once at least one type implements the original
    interface. One of the main points of an interface is that it is a fixed contract.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这很有用，但如果我们决定添加一个名为`Stop`的第三个方法呢？在C# 8.0之前，一旦至少有一个类型实现了原始接口，这是不可能的。接口的主要特点之一是它是一个固定的契约。
- en: C# 8.0 allows an interface to add new members after release as long as they
    have a default implementation. C# purists do not like the idea, but for practical
    reasons, such as avoiding breaking changes or having to define a whole new interface,
    it is useful, and other languages such as Java and Swift enable similar techniques.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C# 8.0允许接口在发布后添加新成员，只要它们具有默认实现。C#纯粹主义者可能不喜欢这个想法，但由于实用原因，例如避免破坏性更改或不得不定义一个全新的接口，它是有用的，其他语言如Java和Swift也启用了类似的技术。
- en: Support for default interface implementations requires some fundamental changes
    to the underlying platform, so they are only supported with C# if the target framework
    is .NET 5.0 or later, .NET Core 3.0 or later, or .NET Standard 2.1\. They are
    therefore not supported by .NET Framework.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认接口实现的支持需要对底层平台进行一些根本性的改变，因此只有在目标框架是.NET 5.0或更高版本、.NET Core 3.0或更高版本或.NET Standard
    2.1时，它们才受C#支持。因此，它们不受.NET Framework的支持。
- en: 'Modify the `IPlayable` interface to add a `Stop` method with a default implementation,
    as shown highlighted in the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`IPlayable`接口以添加具有默认实现的`Stop`方法，如下所示突出显示：
- en: '[PRE49]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Build the `PeopleApp` project and note that the projects compile successfully
    despite the `DvdPlayer` class not implementing `Stop`. In the future, we could
    override the default implementation of `Stop` by implementing it in the `DvdPlayer`
    class.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目并注意，尽管`DvdPlayer`类没有实现`Stop`，但项目仍能成功编译。将来，我们可以通过在`DvdPlayer`类中实现它来覆盖`Stop`的默认实现。
- en: Managing memory with reference and value types
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用引用类型和值类型管理内存
- en: I have mentioned reference types a couple of times. Let's look at them in more
    detail.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到引用类型。让我们更详细地了解一下它们。
- en: 'There are two categories of memory: **stack** memory and **heap** memory. With
    modern operating systems, the stack and heap can be anywhere in physical or virtual
    memory.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分为两类：**栈**内存和**堆**内存。在现代操作系统中，栈和堆可以在物理或虚拟内存的任何位置。
- en: Stack memory is faster to work with (because it is managed directly by the CPU
    and because it uses a last-in, first-out mechanism, it is more likely to have
    the data in its L1 or L2 cache) but limited in size, while heap memory is slower
    but much more plentiful.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 栈内存处理速度更快（因为它直接由CPU管理，并且采用后进先出机制，更有可能将数据保存在其L1或L2缓存中），但大小有限；而堆内存较慢，但资源丰富得多。
- en: For example, in a macOS terminal, I can enter the command `ulimit -a` to discover
    that the stack size is limited to 8,192 KB and that other memory is "unlimited."
    This limited amount of stack memory is why it is so easy to fill it up and get
    a "stack overflow."
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在macOS终端中，我可以输入命令`ulimit -a`来发现栈大小被限制为8192 KB，而其他内存则是“无限制”的。这种有限的栈内存量使得很容易填满它并导致“栈溢出”。
- en: Defining reference and value types
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义引用类型和值类型
- en: 'There are three C# keywords that you can use to define object types: `class`,
    `record`, and `struct`. All can have the same members, such as fields and methods.
    One difference between them is how memory is allocated.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 定义对象类型时，可以使用三个C#关键字：`class`、`record`和`struct`。它们都可以拥有相同的成员，如字段和方法。它们之间的一个区别在于内存分配方式。
- en: When you define a type using `record` or `class`, you are defining a **reference
    type**. This means that the memory for the object itself is allocated on the heap,
    and only the memory address of the object (and a little overhead) is stored on
    the stack.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`record`或`class`定义类型时，你定义的是**引用类型**。这意味着对象本身的内存是在堆上分配的，而只有对象的内存地址（以及少量开销）存储在栈上。
- en: When you define a type using `record struct` or `struct`, you are defining a
    **value type**. This means that the memory for the object itself is allocated
    on the stack.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`record struct`或`struct`定义类型时，你定义的是**值类型**。这意味着对象本身的内存是在栈上分配的。
- en: If a `struct` uses field types that are not of the `struct` type, then those
    fields will be stored on the heap, meaning the data for that object is stored
    in both the stack and the heap!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`struct`使用的字段类型不是`struct`类型，那么这些字段将存储在堆上，这意味着该对象的数据同时存储在栈和堆上！
- en: 'These are the most common struct types:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见的结构体类型：
- en: '**Number** `System` **types**: `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`,
    `long`, `ulong`, `float`, `double`, and `decimal`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字** `System` **类型**：`byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`、`double`和`decimal`'
- en: '**Other** `System` **types**: `char`, `DateTime`, and `bool`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他** `System` **类型**：`char`、`DateTime`和`bool`'
- en: '`System.Drawing` **types**: `Color`, `Point`, and `Rectangle`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Drawing` **类型**：`Color`、`Point`和`Rectangle`'
- en: Almost all the other types are `class` types, including `string`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有其他类型都是`class`类型，包括`string`。
- en: Apart from the difference in terms of where in memory the data for a type is
    stored, the other major difference is that you cannot inherit from a `struct`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型数据在内存中存储位置的差异外，另一个主要区别是`struct`不支持继承。
- en: How reference and value types are stored in memory
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型和值类型在内存中的存储方式
- en: 'Imagine that you have a console app that declares some variables, as shown
    in the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个控制台应用程序，它声明了一些变量，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s review what memory is allocated on the stack and heap when these statements
    execute, as shown in *Figure 6.1* and as described in the following list:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下执行这些语句时栈和堆上分配的内存，如*图6.1*所示，并按以下列表描述：
- en: The `number1` variable is a value type (also known as `struct`) so it is allocated
    on the stack and it uses 4 bytes of memory since it is a 32-bit integer. Its value,
    49, is stored directly in the variable.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number1`变量是值类型（也称为`struct`），因此它在栈上分配，由于它是32位整数，所以占用4字节内存。其值49直接存储在变量中。'
- en: The `number2` variable is also a value type so it is also allocated on the stack,
    and it uses 8 bytes since it is a 64-bit integer.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number2`变量也是值类型，因此它也在栈上分配，由于它是64位整数，所以占用8字节。'
- en: The `location` variable is also a value type so it is allocated on the stack
    and it uses 8 bytes since it is made up of two 32-bit integers, `x` and `y`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location`变量也是值类型，因此它在栈上分配，由于它由两个32位整数`x`和`y`组成，所以占用8字节。'
- en: The `kevin` variable is a reference type (also known as `class`) so 8 bytes
    for a 64-bit memory address (assuming a 64-bit operating system) is allocated
    on the stack and enough bytes on the heap to store an instance of a `Person`.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kevin`变量是引用类型（也称为`class`），因此在栈上分配了64位内存地址所需的8字节（假设是64位操作系统），并在堆上分配了足够字节来存储`Person`实例。'
- en: The `sally` variable is a reference type so 8 bytes for a 64-bit memory address
    is allocated on the stack. It is currently `null`, meaning no memory has yet been
    allocated for it on the heap.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sally`变量是引用类型，因此在64位内存地址的栈上分配了8字节。目前它为`null`，意味着堆上尚未为其分配内存。'
- en: '![](img/B17442_06_01.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17442_06_01.png)'
- en: 'Figure 6.1: How value and reference types are allocated in the stack and heap'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：值类型和引用类型在栈和堆上的分配方式
- en: All the allocated memory for a reference type is stored on the heap. If a value
    type such as `DateTime` is used for a field of a reference type like `Person`,
    then the `DateTime` value is stored on the heap.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的所有已分配内存都存储在堆上。如果值类型如`DateTime`被用作引用类型如`Person`的字段，那么`DateTime`值将存储在堆上。
- en: If a value type has a field that is a reference type, then that part of the
    value type is stored on the heap. `Point` is a value type that consists of two
    fields, both of which are themselves value types, so the entire object can be
    allocated on the stack. If the `Point` value type had a field that was a reference
    type, like `string`, then the `string` bytes would be stored on the heap.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值类型有一个引用类型的字段，那么该部分值类型将存储在堆上。`Point`是一个值类型，由两个字段组成，这两个字段本身也是值类型，因此整个对象可以在栈上分配。如果`Point`值类型有一个引用类型的字段，如`string`，那么`string`字节将存储在堆上。
- en: Equality of types
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型相等性
- en: It is common to compare two variables using the `==` and `!=` operators. The
    behavior of these two operators is different for reference types and value types.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用`==`和`!=`运算符比较两个变量。这两个运算符对于引用类型和值类型的行为是不同的。
- en: 'When you check the equality of two value type variables, .NET literally compares
    the values of those two variables on the stack and returns `true` if they are
    equal, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查两个值类型变量的相等性时，.NET会直接比较这两个变量在栈上的值，如果它们相等，则返回`true`，如下列代码所示：
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When you check the equality of two reference type variables, .NET compares
    the memory addresses of those two variables and returns `true` if they are equal,
    as shown in the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查两个引用类型变量的相等性时，.NET会比较这两个变量的内存地址，如果它们相等，则返回`true`，如下列代码所示：
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is because they are not the same object. If both variables literally point
    to the same object on the heap, then they would be equal, as shown in the following
    code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它们并非同一对象。如果两个变量确实指向堆上的同一对象，那么它们将被视为相等，如下列代码所示：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The one exception to this behavior is the `string` type. It is a reference
    type, but the equality operators have been overridden to make them behave as if
    they were value types, as shown in the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为的一个例外是`string`类型。它虽是引用类型，但其相等运算符已被重载，使其表现得如同值类型一般，如下列代码所示：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can do something similar with your classes to make the equality operators
    return `true` even if they are not the same object (same memory address on the
    heap) but instead if their fields have the same values, but that is beyond the
    scope of this book. Alternatively, use a `record class` because one of their benefits
    is that they implement this behavior for you.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对你的类进行类似操作，使相等运算符即使在它们不是同一对象（即堆上同一内存地址）时也返回`true`，只要它们的字段具有相同值即可，但这超出了本书的范围。或者，使用`record
    class`，因为它们的一个好处是为你实现了这种行为。
- en: Defining struct types
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义结构类型
- en: 'Let''s explore defining your own value types:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨如何定义自己的值类型：
- en: In the `PacktLibrary` project, add a file named `DisplacementVector.cs`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`DisplacementVector.cs`的文件。
- en: 'Modify the file, as shown in the following code, and note the following:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下列代码所示修改文件，并注意以下事项：
- en: The type is declared using `struct` instead of `class`.
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类型使用`struct`声明而非`class`。
- en: It has two `int` fields, named `X` and `Y`.
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有两个名为`X`和`Y`的`int`字段。
- en: It has a constructor for setting initial values for `X` and `Y`.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个构造函数，用于设置`X`和`Y`的初始值。
- en: It has an operator for adding two instances together that returns a new instance
    of the type with `X` added to `X`, and `Y` added to `Y`.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个运算符，用于将两个实例相加，返回一个新实例，其中`X`与`X`相加，`Y`与`Y`相加。
- en: '[PRE55]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In `Program.cs`, add statements to create two new instances of `DisplacementVector`,
    add them together, and output the result, as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加语句以创建两个新的`DisplacementVector`实例，将它们相加，并输出结果，如下列代码所示：
- en: '[PRE56]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE57]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Good Practice**: If the total bytes used by all the fields in your type is
    16 bytes or less, your type only uses value types for its fields, and you will
    never want to derive from your type, then Microsoft recommends that you use `struct`.
    If your type uses more than 16 bytes of stack memory, if it uses reference types
    for its fields, or if you might want to inherit from it, then use `class`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：如果类型中所有字段占用的总字节数不超过16字节，且仅使用值类型作为字段，并且你永远不希望从该类型派生，那么微软建议使用`struct`。如果你的类型使用的堆栈内存超过16字节，使用引用类型作为字段，或者可能希望继承它，那么应使用`class`。'
- en: Working with record struct types
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理记录结构类型
- en: C# 10 introduced the ability to use the `record` keyword with `struct` types
    as well as with class types.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10引入了使用`record`关键字与`struct`类型以及`class`类型一起使用的能力。
- en: 'We could define the `DisplacementVector` type, as shown in the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义`DisplacementVector`类型，如下列代码所示：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With this change, Microsoft recommends explicitly specifying `class` if you
    want to define a `record class` even though the `class` keyword is optional, as
    shown in the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`class`关键字可选，微软仍建议在定义`record class`时明确指定`class`，如下列代码所示：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Releasing unmanaged resources
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放非托管资源
- en: In the previous chapter, we saw that constructors can be used to initialize
    fields and that a type may have multiple constructors. Imagine that a constructor
    allocates an unmanaged resource; that is, anything that is not controlled by .NET,
    such as a file or mutex under the control of the operating system. The unmanaged
    resource must be manually released because .NET cannot do it for us using its
    automatic garbage collection feature.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们了解到构造器可用于初始化字段，且一个类型可以有多个构造器。设想一个构造器分配了一个非托管资源，即不由.NET控制的任何资源，如操作系统控制下的文件或互斥体。由于.NET无法使用其自动垃圾回收功能为我们释放这些资源，我们必须手动释放非托管资源。
- en: Garbage collection is an advanced topic, so for this topic, I will show some
    code examples, but you do not need to write the code yourself.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是一个高级话题，因此对于这个话题，我将展示一些代码示例，但你无需亲自编写代码。
- en: Each type can have a single **finalizer** that will be called by the .NET runtime
    when the resources need to be released. A finalizer has the same name as a constructor;
    that is, the type name, but it is prefixed with a tilde, `~`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型都可以有一个单一的**终结器**，当资源需要被释放时，.NET运行时会调用它。终结器的名称与构造器相同，即类型名称，但前面加了一个波浪线`~`。
- en: 'Do not confuse a finalizer (also known as a **destructor**) with a `Deconstruct`
    method. A destructor releases resources; that is, it destroys an object in memory.
    A `Deconstruct` method returns an object split up into its constituent parts and
    uses the C# deconstruction syntax, for example, when working with tuples:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将终结器（也称为**析构器**）与`Deconstruct`方法混淆。析构器释放资源，即它在内存中销毁一个对象。`Deconstruct`方法将对象分解为其组成部分，并使用C#解构语法，例如在处理元组时：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding code example is the minimum you should do when working with unmanaged
    resources. But the problem with only providing a finalizer is that the .NET garbage
    collector requires two garbage collections to completely release the allocated
    resources for this type.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例是在处理非托管资源时你应做的最低限度。但仅提供终结器的问题在于，.NET垃圾回收器需要两次垃圾回收才能完全释放该类型分配的资源。
- en: Though optional, it is recommended to also provide a method to allow a developer
    who uses your type to explicitly release resources so that the garbage collector
    can release managed parts of an unmanaged resource, such as a file, immediately
    and deterministically, and then release the managed memory part of the object
    in a single garbage collection instead of two rounds of garbage collection.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可选，但建议提供一个方法，让使用你类型的开发者能明确释放资源，以便垃圾回收器可以立即且确定性地释放非托管资源（如文件）的托管部分，并在一次垃圾回收中释放对象的托管内存部分，而不是经过两次垃圾回收。
- en: 'There is a standard mechanism for doing this by implementing the `IDisposable`
    interface, as shown in the following example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`IDisposable`接口，有一个标准机制可以做到这一点，如下例所示：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'There are two `Dispose` methods, one `public` and one `protected`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两个`Dispose`方法，一个`public`，一个`protected`：
- en: The `public void Dispose` method will be called by a developer using your type.
    When called, both unmanaged and managed resources need to be deallocated.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Dispose`方法将由使用你类型的开发者调用。当被调用时，无论是非托管资源还是托管资源都需要被释放。'
- en: The `protected virtual void Dispose` method with a `bool` parameter is used
    internally to implement the deallocation of resources. It needs to check the `disposing`
    parameter and `disposed` field because if the finalizer thread has already run
    and it called the `~Animal` method, then only unmanaged resources need to be deallocated.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected virtual void Dispose`方法带有一个`bool`参数，内部用于实现资源的释放。它需要检查`disposing`参数和`disposed`字段，因为如果终结器线程已经运行并调用了`~Animal`方法，那么只需要释放非托管资源。'
- en: The call to `GC.SuppressFinalize(this)` is what notifies the garbage collector
    that it no longer needs to run the finalizer, and removes the need for a second
    garbage collection.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`GC.SuppressFinalize(this)`是为了通知垃圾收集器不再需要运行终结器，从而消除了进行第二次垃圾收集的需求。
- en: Ensuring that Dispose is called
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保Dispose方法被调用
- en: 'When someone uses a type that implements `IDisposable`, they can ensure that
    the public `Dispose` method is called with the `using` statement, as shown in
    the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人使用实现了`IDisposable`的类型时，他们可以使用`using`语句确保调用公共`Dispose`方法，如下列代码所示：
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The compiler converts your code into something like the following, which guarantees
    that even if an exception occurs, the `Dispose` method will still be called:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将你的代码转换成类似下面的形式，这保证了即使发生异常，`Dispose`方法仍然会被调用：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You will see practical examples of releasing unmanaged resources with `IDisposable`,
    `using` statements, and `try`...`finally` blocks in *Chapter 9*, *Working with
    Files, Streams, and Serialization*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在*第9章*，*文件、流和序列化操作*中看到使用`IDisposable`、`using`语句以及`try`...`finally`块释放非托管资源的实际示例。
- en: Working with null values
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理null值
- en: You have seen how to store primitive values like numbers in `struct` variables.
    But what if a variable does not yet have a value? How can we indicate that? C#
    has the concept of a `null` value, which can be used to indicate that a variable
    has not been set.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何在`struct`变量中存储像数字这样的基本值。但如果一个变量还没有值呢？我们该如何表示这种情况？C#中有一个`null`值的概念，可以用来表示变量尚未被赋值。
- en: Making a value type nullable
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使值类型可空
- en: By default, value types like `int` and `DateTime` must always have a value,
    hence their name. Sometimes, for example, when reading values stored in a database
    that allows empty, missing, or null values, it is convenient to allow a value
    type to be `null`. We call this a **nullable value type**.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，像`int`和`DateTime`这样的值类型必须始终有值，因此得名。有时，例如在读取数据库中允许空、缺失或`null`值存储的值时，允许值类型为`null`会很方便。我们称这种类型为**可空值类型**。
- en: You can enable this by adding a question mark as a suffix to the type when declaring
    a variable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在声明变量时在类型后添加问号后缀来启用此功能。
- en: 'Let''s see an example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter06`
    workspace/solution named `NullHandling`. This section requires a full application
    with a project file, so you will not be able to use a .NET Interactive notebook.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的编程工具，在`Chapter06`工作区/解决方案中添加一个名为`NullHandling`的**控制台应用程序**。本节需要一个完整的应用程序，包含项目文件，因此你无法使用.NET
    Interactive笔记本。
- en: In Visual Studio Code, select `NullHandling` as the active OmniSharp project.
    In Visual Studio, set `NullHandling` as the startup project.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`NullHandling`作为活动的OmniSharp项目。在Visual Studio中，将`NullHandling`设置为启动项目。
- en: 'In `Program.cs`, type statements to declare and assign values, including `null`,
    to `int` variables, as shown in the following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入声明并赋值的语句，包括`null`，给`int`变量，如下列代码所示：
- en: '[PRE64]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Comment out the statement that gives a compile error.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉导致编译错误的语句。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE65]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first line is blank because it is outputting the `null` value!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是空白的，因为它输出了`null`值！
- en: Understanding nullable reference types
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解可空引用类型
- en: The use of the `null` value is so common, in so many languages, that many experienced
    programmers never question the need for its existence. But there are many scenarios
    where we could write better, simpler code if a variable is not allowed to have
    a `null` value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在众多语言中，`null`值的使用非常普遍，以至于许多经验丰富的程序员从未质疑过其存在的必要性。但在许多情况下，如果我们不允许变量具有`null`值，就能编写出更优、更简洁的代码。
- en: The most significant change to the language in C# 8 was the introduction of
    nullable and non- nullable reference types. "But wait!", you are probably thinking,
    "Reference types are already nullable!"
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8中最显著的语言变化是引入了可空和不可空的引用类型。“但是等等！”你可能会想，“引用类型不是已经可空了吗！”
- en: And you would be right, but in C# 8 and later, reference types can be configured
    to no longer allow the `null` value by setting a file- or project-level option
    to enable this useful new feature. Since this is a big change for C#, Microsoft
    decided to make the feature opt-in.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您说得没错，但在C# 8及更高版本中，引用类型可以通过设置文件级或项目级选项来配置，不再允许`null`值，从而启用这一有用的新特性。由于这对C#来说是一个重大变化，微软决定让该功能为可选。
- en: It will take multiple years for this new C# language feature to make an impact
    since thousands of existing library packages and apps will expect the old behavior.
    Even Microsoft did not have time to fully implement this new feature in all the
    main .NET packages until .NET 6.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成千上万的现有库包和应用程序期望旧的行为，这项新的C#语言特性需要多年时间才能产生影响。即使是微软，也直到.NET 6才在所有主要的.NET包中完全实现这一新特性。
- en: 'During the transition, you can choose between several approaches for your own
    projects:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡期间，您可以为您的项目选择几种方法之一：
- en: '**Default**: No changes are needed. Non-nullable reference types are not supported.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：无需更改。不支持不可空的引用类型。'
- en: '**Opt-in project, opt-out files**: Enable the feature at the project level
    and, for any files that need to remain compatible with old behavior, opt out.
    This is the approach Microsoft is using internally while it updates its own packages
    to use this new feature.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目级选择加入，文件级选择退出**：在项目级别启用该功能，并为需要与旧行为保持兼容的任何文件选择退出。这是微软在更新其自己的包以使用此新功能时内部采用的方法。'
- en: '**Opt-in files**: Only enable the feature for individual files.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件级选择加入**：仅对个别文件启用该功能。'
- en: Enabling nullable and non-nullable reference types
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用可空和不可空的引用类型
- en: 'To enable the feature at the project level, add the following to your project
    file:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目级别启用该功能，请在项目文件中添加以下内容：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is now done by default in project templates that target .NET 6.0.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这在面向.NET 6.0的项目模板中现已默认完成。
- en: 'To disable the feature at the file level, add the following to the top of a
    code file:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件级别禁用该功能，请在代码文件顶部添加以下内容：
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To enable the feature at the file level, add the following to the top of a
    code file:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件级别启用该功能，请在代码文件顶部添加以下内容：
- en: '[PRE68]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Declaring non-nullable variables and parameters
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明不可为空的变量和参数
- en: If you enable nullable reference types and you want a reference type to be assigned
    the `null` value, then you will have to use the same syntax as making a value
    type nullable, that is, adding a `?` symbol after the type declaration.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启用了可空引用类型，并且希望引用类型被赋予`null`值，那么您将不得不使用与使值类型可空相同的语法，即在类型声明后添加一个`?`符号。
- en: 'So, how do nullable reference types work? Let''s look at an example. When storing
    information about an address, you might want to force a value for the street,
    city, and region, but the building can be left blank, that is, `null`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，可空引用类型是如何工作的呢？让我们看一个例子。当存储地址信息时，您可能希望强制为街道、城市和地区提供值，但建筑可以留空，即`null`：
- en: 'In `NullHandling.csproj`, in `Program.cs`, at the bottom of the file, add statements
    to declare an `Address` class with four fields, as shown in the following code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NullHandling.csproj`中，在`Program.cs`文件底部，添加声明一个具有四个字段的`Address`类的语句，如下所示：
- en: '[PRE69]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After a few seconds, note the warnings about non-nullable fields, like `Street`
    not being initialized, as shown in *Figure 6.2*:![Graphical user interface, text,
    application, chat or text message  Description automatically generated](img/B17442_06_02.png)
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，注意关于不可为空的字段的警告，例如`Street`未初始化，如*图6.2*所示：![Graphical user interface, text,
    application, chat or text message  Description automatically generated](img/B17442_06_02.png)
- en: 'Figure 6.2: Warning messages about non-nullable fields in the PROBLEMS window'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.2：PROBLEMS窗口中关于不可为空的字段的警告信息
- en: 'Assign the empty `string` value to each of the three fields that are non-nullable,
    as shown in the following code:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将空`string`值分配给三个不可为空的字段中的每一个，如下所示：
- en: '[PRE70]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In `Program.cs`, at the top of the file, statically import `Console` and then
    add statements to instantiate an `Address` and set its properties, as shown in
    the following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在文件顶部，静态导入`Console`，然后添加语句来实例化一个`Address`并设置其属性，如下所示：
- en: '[PRE71]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note the warnings, as shown in *Figure 6.3*:![Graphical user interface, text,
    application, chat or text message, email  Description automatically generated](img/B17442_06_03.png)
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意警告，如*图6.3*所示：![图形用户界面，文本，应用程序，聊天或短信，电子邮件 自动生成描述](img/B17442_06_03.png)
- en: 'Figure 6.3: Warning message about assigning null to a non-nullable field'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3：关于将null分配给不可空字段的警告消息
- en: So, this is why the new language feature is named nullable reference types.
    Starting with C# 8.0, unadorned reference types can become non-nullable, and the
    same syntax is used to make a reference type nullable as is used for value types.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是为什么新语言特性被命名为可空引用类型。从C# 8.0开始，未修饰的引用类型可以变为不可空，并且用于使引用类型可空的语法与用于值类型的语法相同。
- en: Checking for null
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查是否为空
- en: 'Checking whether a nullable reference type or nullable value type variable
    currently contains `null` is important because if you do not, a `NullReferenceException`
    can be thrown, which results in an error. You should check for a `null` value
    before using a nullable variable, as shown in the following code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 检查可空引用类型或可空值类型变量当前是否包含`null`很重要，因为如果不这样做，可能会抛出`NullReferenceException`，导致错误。在使用可空变量之前，应检查其是否为`null`，如下所示：
- en: '[PRE72]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'C# 7 introduced `is` combined with the `!` (not) operator as an alternative
    to `!=`, as shown in the following code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7引入了`is`与`!`（非）运算符的组合作为`!=`的替代方案，如下所示：
- en: '[PRE73]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'C# 9 introduced `is not` as an even clearer alternative, as shown in the following
    code:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9引入了`is not`作为更清晰的替代方案，如下所示：
- en: '[PRE74]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If you are trying to use a member of a variable that might be `null`, use the
    null-conditional operator `?.`, as shown in the following code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用可能为`null`的变量的成员，请使用空条件运算符`?.`，如下所示：
- en: '[PRE75]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Sometimes you want to either assign a variable to a result or use an alternative
    value, such as `3`, if the variable is `null`. You do this using the null-coalescing
    operator, `??`, as shown in the following code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您希望将变量分配给结果，或者如果变量为`null`，则使用备用值，例如`3`。您可以使用空合并运算符`??`执行此操作，如下所示：
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '**Good Practice**: Even if you enable nullable reference types, you should
    still check non-nullable parameters for `null` and throw an `ArgumentNullException`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：即使启用了可空引用类型，您仍应检查不可空参数是否为`null`并抛出`ArgumentNullException`。'
- en: Checking for null in method parameters
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在方法参数中检查是否为空
- en: When defining methods with parameters, it is good practice to check for `null`
    values.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义带有参数的方法时，检查`null`值是良好的实践。
- en: 'In earlier versions of C#, you would have to write `if` statements to check
    for `null` parameter values and then throw an `ArgumentNullException` for any
    parameter that is `null`, as shown in the following code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的C#中，您需要编写`if`语句来检查`null`参数值，并对任何为`null`的参数抛出`ArgumentNullException`，如下所示：
- en: '[PRE77]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'C# 11 might introduce a new `!!` suffix that does this for you, as shown in
    the following code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: C# 11可能会引入一个新的`!!`后缀，为您执行此操作，如下所示：
- en: '[PRE78]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `if` statement and throwing of the exception are done for you.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句和抛出异常的操作已为您完成。'
- en: Inheriting from classes
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承自类
- en: 'The `Person` type we created earlier derived (inherited) from `object`, the
    alias for `System.Object`. Now, we will create a subclass that inherits from `Person`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的`Person`类型派生（继承）自`object`，即`System.Object`的别名。现在，我们将创建一个从`Person`继承的子类：
- en: In the `PacktLibrary` project, add a new class file named `Employee.cs`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`Employee.cs`的新类文件。
- en: 'Modify its contents to define a class named `Employee` that derives from `Person`,
    as shown in the following code:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容以定义一个名为`Employee`的类，该类派生自`Person`，如下所示：
- en: '[PRE79]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In `Program.cs`, add statements to create an instance of the `Employee` class,
    as shown in the following code:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以创建`Employee`类的一个实例，如下所示：
- en: '[PRE80]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE81]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note that the `Employee` class has inherited all the members of `Person`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Employee`类继承了`Person`类的所有成员。
- en: Extending classes to add functionality
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展类以添加功能
- en: Now, we will add some employee-specific members to extend the class.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一些特定于员工的成员以扩展该类。
- en: 'In `Employee.cs`, add statements to define two properties for an employee code
    and the date they were hired, as shown in the following code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Employee.cs`中，添加语句以定义员工代码和雇佣日期这两个属性，如下所示：
- en: '[PRE82]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In `Program.cs`, add statements to set John''s employee code and hire date,
    as shown in the following code:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以设置John的员工代码和雇佣日期，如下列代码所示：
- en: '[PRE83]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE84]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Hiding members
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏成员
- en: 'So far, the `WriteToConsole` method is inherited from `Person`, and it only
    outputs the employee''s name and date of birth. We might want to change what this
    method does for an employee:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`WriteToConsole`方法是从`Person`继承的，它仅输出员工的姓名和出生日期。我们可能希望为员工改变此方法的功能：
- en: 'In `Employee.cs`, add statements to redefine the `WriteToConsole` method, as
    shown highlighted in the following code:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Employee.cs`中，添加语句以重新定义`WriteToConsole`方法，如下列高亮代码所示：
- en: '[PRE85]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE86]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Your coding tool warns you that your method now hides the method from `Person`
    by drawing a squiggle under the method name, the **PROBLEMS**/**Error List** window
    includes more details, and the compiler will output the warning when you build
    and run the console application, as shown in *Figure 6.4*:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编码工具会警告你，你的方法现在通过在方法名下划波浪线来隐藏来自`Person`的方法，**问题**/**错误列表**窗口包含更多细节，编译器会在你构建并运行控制台应用程序时输出警告，如*图6.4*所示：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17442_06_04.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件 描述自动生成](img/B17442_06_04.png)'
- en: 'Figure 6.4: Hidden method warning'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：隐藏方法警告
- en: 'As the warning describes, you can hide this message by applying the `new` keyword
    to the method, to indicate that you are deliberately replacing the old method,
    as shown highlighted in the following code:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 正如警告所述，你可以通过将`new`关键字应用于该方法来隐藏此消息，以表明你是有意替换旧方法，如下列高亮代码所示：
- en: '[PRE87]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Overriding members
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖成员
- en: Rather than hiding a method, it is usually better to **override** it. You can
    only override if the base class chooses to allow overriding, by applying the `virtual`
    keyword to any methods that should allow overriding.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 与其隐藏一个方法，通常更好的做法是**覆盖**它。只有当基类选择允许覆盖时，你才能覆盖，这通过将`virtual`关键字应用于应允许覆盖的任何方法来实现。
- en: 'Let''s see an example:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 来看一个例子：
- en: 'In `Program.cs`, add a statement to write the value of the `john` variable
    to the console using its `string` representation, as shown in the following code:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句，使用其`string`表示形式将`john`变量的值写入控制台，如下列代码所示：
- en: '[PRE88]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Run the code and note that the `ToString` method is inherited from `System.Object`,
    so the implementation returns the namespace and type name, as shown in the following
    output:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意`ToString`方法是从`System.Object`继承的，因此实现返回命名空间和类型名称，如下列输出所示：
- en: '[PRE89]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In `Person.cs`, override this behavior by adding a `ToString` method to output
    the name of the person as well as the type name, as shown in the following code:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，通过添加一个`ToString`方法来覆盖此行为，该方法输出人的姓名以及类型名称，如下列代码所示：
- en: '[PRE90]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `base` keyword allows a subclass to access members of its superclass; that
    is, the **base class** that it inherits or derives from.
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`base`关键字允许子类访问其超类的成员；即它继承或派生自的**基类**。'
- en: 'Run the code and view the result. Now, when the `ToString` method is called,
    it outputs the person''s name, as well as returning the base class''s implementation
    of `ToString`, as shown in the following output:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果。现在，当调用`ToString`方法时，它输出人的姓名，并返回基类`ToString`的实现，如下列输出所示：
- en: '[PRE91]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '**Good Practice**: Many real-world APIs, for example, Microsoft''s Entity Framework
    Core, Castle''s DynamicProxy, and Episerver''s content models, require the properties
    that you define in your classes to be marked as `virtual` so that they can be
    overridden. Carefully decide which of your method and property members should
    be marked as `virtual`.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：许多现实世界的API，例如微软的Entity Framework Core、Castle的DynamicProxy和Episerver的内容模型，要求你在类中定义的属性标记为`virtual`，以便它们可以被覆盖。仔细决定你的哪些方法和属性成员应标记为`virtual`。'
- en: Inheriting from abstract classes
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承自抽象类
- en: Earlier in this chapter, you learned about interfaces that can define a set
    of members that a type must have to meet a basic level of functionality. These
    are very useful, but their main limitation is that until C# 8 they could not provide
    any implementation of their own.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 本章早些时候，你了解到接口可以定义一组成员，类型必须拥有这些成员才能达到基本的功能水平。这些接口非常有用，但主要局限在于，直到C# 8之前，它们无法提供任何自身的实现。
- en: This is a particular problem if you still need to create class libraries that
    will work with .NET Framework and other platforms that do not support .NET Standard
    2.1.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然需要创建与.NET Framework和其他不支持.NET Standard 2.1的平台兼容的类库，这将是一个特定问题。
- en: In those earlier platforms, you could use abstract classes as a sort of halfway
    house between a pure interface and a fully implemented class.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些早期平台中，你可以使用抽象类作为一种介于纯接口和完全实现类之间的半成品。
- en: When a class is marked as `abstract`, this means that it cannot be instantiated
    because you are indicating that the class is not complete. It needs more implementation
    before it can be instantiated.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类被标记为`abstract`时，这意味着它不能被实例化，因为你表明该类不完整。它需要更多的实现才能被实例化。
- en: For example, the `System.IO.Stream` class is abstract because it implements
    common functionality that all streams would need but is not complete, so you cannot
    instantiate it using `new Stream()`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`System.IO.Stream`类是抽象的，因为它实现了所有流都需要的一般功能，但并不完整，因此你不能使用`new Stream()`来实例化它。
- en: 'Let''s compare the two types of interface and two types of class, as shown
    in the following code:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较两种类型的接口和两种类型的类，如下代码所示：
- en: '[PRE92]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Preventing inheritance and overriding
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止继承和覆盖
- en: 'You can prevent another developer from inheriting from your class by applying
    the `sealed` keyword to its definition. No one can inherit from Scrooge McDuck,
    as shown in the following code:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在其定义中应用`sealed`关键字，你可以防止其他开发者继承你的类。没有人能继承史高治·麦克达克，如下代码所示：
- en: '[PRE93]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: An example of `sealed` in .NET is the `string` class. Microsoft has implemented
    some extreme optimizations inside the `string` class that could be negatively
    affected by your inheritance, so Microsoft prevents that.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中`sealed`的一个例子是`string`类。微软在`string`类内部实现了一些极端优化，这些优化可能会因你的继承而受到负面影响，因此微软阻止了这种情况。
- en: 'You can prevent someone from further overriding a `virtual` method in your
    class by applying the `sealed` keyword to the method. No one can change the way
    Lady Gaga sings, as shown in the following code:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方法上应用`sealed`关键字来防止某人进一步覆盖你类中的`virtual`方法。没有人能改变Lady Gaga的唱歌方式，如下代码所示：
- en: '[PRE94]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: You can only seal an overridden method.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能密封一个被覆盖的方法。
- en: Understanding polymorphism
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解多态性
- en: You have now seen two ways to change the behavior of an inherited method. We
    can *hide* it using the `new` keyword (known as **non-polymorphic inheritance**),
    or we can *override* it (known as **polymorphic inheritance**).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到了两种改变继承方法行为的方式。我们可以使用`new`关键字*隐藏*它（称为**非多态继承**），或者我们可以*覆盖*它（称为**多态继承**）。
- en: Both ways can access members of the base or superclass by using the `base` keyword,
    so what is the difference?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方式都可以使用`base`关键字访问基类或超类的成员，那么区别是什么呢？
- en: It all depends on the type of variable holding a reference to the object. For
    example, a variable of the `Person` type can hold a reference to a `Person` class,
    or any type that derives from `Person`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全取决于持有对象引用的变量类型。例如，类型为`Person`的变量可以持有`Person`类或任何派生自`Person`的类型的引用。
- en: 'Let''s see how this could affect your code:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何影响你的代码：
- en: 'In `Employee.cs`, add statements to override the `ToString` method so it writes
    the employee''s name and code to the console, as shown in the following code:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Employee.cs`中，添加语句以覆盖`ToString`方法，使其将员工的名字和代码写入控制台，如下代码所示：
- en: '[PRE95]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In `Program.cs`, write statements to create a new employee named Alice, store
    it in a variable of type `Person`, and call both variables'' `WriteToConsole`
    and `ToString` methods, as shown in the following code:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，编写语句以创建名为Alice的新员工，将其存储在类型为`Person`的变量中，并调用两个变量的`WriteToConsole`和`ToString`方法，如下代码所示：
- en: '[PRE96]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下输出所示：
- en: '[PRE97]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: When a method is hidden with `new`, the compiler is not smart enough to know
    that the object is an `Employee`, so it calls the `WriteToConsole` method in `Person`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被`new`隐藏时，编译器不够智能，无法知道该对象是`Employee`，因此它调用`Person`中的`WriteToConsole`方法。
- en: When a method is overridden with `virtual` and `override`, the compiler is smart
    enough to know that although the variable is declared as a `Person` class, the
    object itself is an `Employee` class and, therefore, the `Employee` implementation
    of `ToString` is called.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被`virtual`和`override`覆盖时，编译器足够智能，知道尽管变量声明为`Person`类，但对象本身是`Employee`类，因此调用`Employee`的`ToString`实现。
- en: 'The member modifiers and the effect they have are summarized in the following
    table:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 成员修饰符及其效果总结在下表中：
- en: '| Variable type | Member modifier | Method executed | In class |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| 变量类型 | 成员修饰符 | 执行的方法 | 所在类 |'
- en: '| `Person` |  | `WriteToConsole` | `Person` |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `Person` |  | `WriteToConsole` | `Person` |'
- en: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
- en: '| `Person` | `virtual` | `ToString` | `Employee` |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `Person` | `virtual` | `ToString` | `Employee` |'
- en: '| `Employee` | `override` | `ToString` | `Employee` |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `Employee` | `override` | `ToString` | `Employee` |'
- en: In my opinion, polymorphism is academic to most programmers. If you get the
    concept, that's cool; but, if not, I suggest that you don't worry about it. Some
    people like to make others feel inferior by saying understanding polymorphism
    is important for all C# programmers to learn, but IMHO it's not.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，多态性对大多数程序员来说是学术性的。如果你理解了这个概念，那很酷；但如果不理解，我建议你不必担心。有些人喜欢通过说理解多态性对所有C#程序员学习很重要来让别人感到自卑，但在我看来并非如此。
- en: You can have a successful career with C# and never need to be able to explain
    polymorphism, just as a racing car driver doesn't need to be able to explain the
    engineering behind fuel injection.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过C#拥有成功的职业生涯，而不必解释多态性，正如赛车手无需解释燃油喷射背后的工程原理一样。
- en: '**Good Practice**: You should use `virtual` and `override` rather than `new`
    to change the implementation of an inherited method whenever possible.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：应尽可能使用`virtual`和`override`而不是`new`来更改继承方法的实现。'
- en: Casting within inheritance hierarchies
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承层次结构内的强制转换
- en: Casting between types is subtly different from converting between types. Casting
    is between similar types, like between a 16-bit integer and a 32-bit integer,
    or between a superclass and one of its subclasses. Converting is between dissimilar
    types, such as between text and a number.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 类型之间的强制转换与类型转换略有不同。强制转换是在相似类型之间进行的，例如16位整数和32位整数之间，或者超类及其子类之间。转换是在不同类型之间进行的，例如文本和数字之间。
- en: Implicit casting
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式转换
- en: In the previous example, you saw how an instance of a derived type can be stored
    in a variable of its base type (or its base's base type, and so on). When we do
    this, it is called **implicit casting**.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你看到了如何将派生类型的实例存储在其基类型（或其基类型的基类型等）的变量中。当我们这样做时，称为**隐式转换**。
- en: Explicit casting
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式转换
- en: 'Going the other way is an explicit cast, and you must use parentheses around
    the type you want to cast into as a prefix to do it:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 反向操作是显式转换，你必须在要转换的类型周围使用括号作为前缀来执行此操作：
- en: 'In `Program.cs`, add a statement to assign the `aliceInPerson` variable to
    a new `Employee` variable, as shown in the following code:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个语句，将`aliceInPerson`变量赋值给一个新的`Employee`变量，如下所示：
- en: '[PRE98]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Your coding tool displays a red squiggle and a compile error, as shown in *Figure
    6.5*:![Graphical user interface, text, application, email, website  Description
    automatically generated](img/B17442_06_05.png)
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的编码工具会显示红色波浪线和编译错误，如*图6.5*所示：![图形用户界面，文本，应用程序，电子邮件，网站 自动生成描述](img/B17442_06_05.png)
- en: 'Figure 6.5: A missing explicit cast compile error'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.5：缺少显式转换的编译错误
- en: 'Change the statement to prefix the assigned variable named with a cast to the
    `Employee` type, as shown in the following code:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将语句更改为在赋值变量名前加上`Employee`类型的强制转换，如下所示：
- en: '[PRE99]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Avoiding casting exceptions
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免强制转换异常
- en: The compiler is now happy; but, because `aliceInPerson` might be a different
    derived type, like `Student` instead of `Employee`, we need to be careful. In
    a real application with more complex code, the current value of this variable
    could have been set to a `Student` instance, and then this statement would throw
    an `InvalidCastException` error.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器现在满意了；但是，因为`aliceInPerson`可能是不同的派生类型，比如`Student`而不是`Employee`，我们需要小心。在更复杂的代码的实际应用程序中，此变量的当前值可能已被设置为`Student`实例，然后此语句将抛出`InvalidCastException`错误。
- en: 'We can handle this by writing a `try` statement, but there is a better way.
    We can check the type of an object using the `is` keyword:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写`try`语句来处理这种情况，但还有更好的方法。我们可以使用`is`关键字检查对象的类型：
- en: 'Wrap the explicit cast statement in an `if` statement, as shown highlighted
    in the following code:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显式转换语句包裹在`if`语句中，如下所示突出显示：
- en: '[PRE100]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE101]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You can simplify the code further using a declaration pattern and this will
    avoid needing to perform an explicit cast, as shown in the following code:'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过使用声明模式进一步简化代码，这将避免需要执行显式转换，如下所示：
- en: '[PRE102]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Alternatively, you can use the `as` keyword to cast. Instead of throwing an
    exception, the `as` keyword returns `null` if the type cannot be cast.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你可以使用`as`关键字进行转换。如果无法进行类型转换，`as`关键字不会抛出异常，而是返回`null`。
- en: 'In `Main`, add the statements to cast Alice using the `as` keyword and then
    check whether the return value is not null, as shown in the following code:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`中，添加语句，使用`as`关键字转换Alice，然后检查返回值是否不为空，如下所示：
- en: '[PRE103]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Since accessing a member of a `null` variable will throw a `NullReferenceException`
    error, you should always check for `null` before using the result.
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于访问`null`变量的成员会抛出`NullReferenceException`错误，因此在使用结果之前应始终检查`null`。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE104]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: What if you want to execute a block of statements when Alice is not an employee?
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Alice不是员工时执行一组语句，该怎么办？
- en: 'In the past, you would have had to use the `!` (not) operator, as shown in
    the following code:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，你可能会使用`!`（非）运算符，如下所示：
- en: '[PRE105]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'With C# 9 and later, you can use the `not` keyword, as shown in the following
    code:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C# 9及更高版本，你可以使用`not`关键字，如下所示：
- en: '[PRE106]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '**Good Practice**: Use the `is` and `as` keywords to avoid throwing exceptions
    when casting between derived types. If you don''t do this, you must write `try`-`catch`
    statements for `InvalidCastException`.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：使用`is`和`as`关键字避免在派生类型之间转换时抛出异常。如果不这样做，你必须为`InvalidCastException`编写`try`-`catch`语句。'
- en: Inheriting and extending .NET types
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和扩展.NET类型
- en: .NET has prebuilt class libraries containing hundreds of thousands of types.
    Rather than creating your own completely new types, you can often get a head start
    by deriving from one of Microsoft's types to inherit some or all of its behavior
    and then overriding or extending it.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: .NET拥有预建的类库，包含数十万个类型。与其完全创建全新的类型，不如从微软的类型中派生，继承其部分或全部行为，然后覆盖或扩展它，从而获得先机。
- en: Inheriting exceptions
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承异常
- en: 'As an example of inheritance, we will derive a new type of exception:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 作为继承的一个例子，我们将派生一种新的异常类型：
- en: In the `PacktLibrary` project, add a new class file named `PersonException.cs`.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`PersonException.cs`的新类文件。
- en: 'Modify the contents of the file to define a class named `PersonException` with
    three constructors, as shown in the following code:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件内容，定义一个名为`PersonException`的类，包含三个构造函数，如下所示：
- en: '[PRE107]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Unlike ordinary methods, constructors are not inherited, so we must explicitly
    declare and explicitly call the base constructor implementations in `System.Exception`
    to make them available to programmers who might want to use those constructors
    with our custom exception.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与普通方法不同，构造函数不会被继承，因此我们必须显式声明并在`System.Exception`中显式调用基类构造函数实现，以便让可能希望使用这些构造函数的程序员能够使用我们自定义的异常。
- en: 'In `Person.cs`, add statements to define a method that throws an exception
    if a date/time parameter is earlier than a person''s date of birth, as shown in
    the following code:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义一个方法，如果日期/时间参数早于某人的出生日期，则抛出异常，如下所示：
- en: '[PRE108]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In `Program.cs`, add statements to test what happens when employee John Jones
    tries to time travel too far back, as shown in the following code:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以测试当员工John Jones试图穿越回太久远的时间时会发生什么，如下所示：
- en: '[PRE109]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE110]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '**Good Practice**: When defining your own exceptions, give them the same three
    constructors that explicitly call the built-in ones.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：在定义自己的异常时，应提供与内置异常相同的三个构造函数，并显式调用它们。'
- en: Extending types when you can't inherit
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当你无法继承时扩展类型
- en: Earlier, we saw how the `sealed` modifier can be used to prevent inheritance.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们了解到`sealed`修饰符可用于防止继承。
- en: Microsoft has applied the `sealed` keyword to the `System.String` class so that
    no one can inherit and potentially break the behavior of strings.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已将`sealed`关键字应用于`System.String`类，以确保无人能继承并可能破坏字符串的行为。
- en: Can we still add new methods to strings? Yes, if we use a language feature named
    **extension methods**, which was introduced with C# 3.0.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能给字符串添加新方法吗？可以，如果我们使用名为**扩展方法**的语言特性，该特性是在C# 3.0中引入的。
- en: Using static methods to reuse functionality
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用静态方法重用功能
- en: Since the first version of C#, we've been able to create `static` methods to
    reuse functionality, such as the ability to validate that a `string` contains
    an email address. The implementation will use a regular expression that you will
    learn more about in *Chapter 8*, *Working with Common .NET Types*.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 自C#的第一个版本以来，我们就能创建`static`方法来重用功能，例如验证`string`是否包含电子邮件地址的能力。其实现将使用正则表达式，你将在*第8章*，*使用常见的.NET类型*中了解更多相关内容。
- en: 'Let''s write some code:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来编写一些代码：
- en: 'In the `PacktLibrary` project, add a new class named `StringExtensions`, as
    shown in the following code, and note the following:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`StringExtensions`的新类，如下列代码所示，并注意以下事项：
- en: The class imports a namespace for handling regular expressions.
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类导入了一个用于处理正则表达式的命名空间。
- en: The `IsValidEmail` method is `static` and it uses the `Regex` type to check
    for matches against a simple email pattern that looks for valid characters before
    and after the `@` symbol.
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsValidEmail`方法是`static`的，它使用`Regex`类型来检查与一个简单的电子邮件模式匹配，该模式寻找`@`符号前后有效的字符。'
- en: '[PRE111]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'In `Program.cs`, add statements to validate two examples of email addresses,
    as shown in the following code:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以验证两个电子邮件地址示例，如下列代码所示：
- en: '[PRE112]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE113]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This works, but extension methods can reduce the amount of code we must type
    and simplify the usage of this function.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但扩展方法能减少我们必须输入的代码量并简化此功能的使用。
- en: Using extension methods to reuse functionality
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用扩展方法重用功能
- en: 'It is easy to make `static` methods into extension methods:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 将`static`方法转换为扩展方法很容易：
- en: 'In `StringExtensions.cs`, add the `static` modifier before the class, and add
    the `this` modifier before the `string` type, as highlighted in the following
    code:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StringExtensions.cs`中，在类前添加`static`修饰符，并在`string`类型前添加`this`修饰符，如下列代码中突出显示：
- en: '[PRE114]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: These two changes tell the compiler that it should treat the method as one that
    extends the `string` type.
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个改动告诉编译器，应将该方法视为扩展`string`类型的方法。
- en: 'In `Program.cs`, add statements to use the extension method for `string` values
    that need to be checked for valid email addresses, as shown in the following code:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以使用扩展方法检查需要验证的`string`值是否为有效电子邮件地址，如下列代码所示：
- en: '[PRE115]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note the subtle simplification in the syntax for calling the `IsValidEmail`
    method. The older, longer syntax still works too.
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意调用`IsValidEmail`方法的语法中微妙的简化。较旧、较长的语法仍然有效。
- en: The `IsValidEmail` extension method now appears to be a method just like all
    the actual instance methods of the `string` type, such as `IsNormalized` and `Insert`,
    as shown in *Figure 6.6*:![Graphical user interface, text, application  Description
    automatically generated](img/B17442_06_06.png)
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsValidEmail`扩展方法现在看起来就像是`string`类型的所有实际实例方法一样，例如`IsNormalized`和`Insert`，如*图6.6*所示：![图形用户界面，文本，应用程序
    自动生成的描述](img/B17442_06_06.png)'
- en: 'Figure 6.6: Extension methods appear in IntelliSense alongside instance methods'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.6：扩展方法在IntelliSense中与实例方法并列显示
- en: Run the code and view the result, which will be the same as before.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，其将与之前相同。
- en: '**Good Practice**: Extension methods cannot replace or override existing instance
    methods. You cannot, for example, redefine the `Insert` method. The extension
    method will appear as an overload in IntelliSense, but an instance method will
    be called in preference to an extension method with the same name and signature.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：扩展方法不能替换或覆盖现有实例方法。例如，你不能重新定义`Insert`方法。扩展方法会在IntelliSense中显示为重载，但具有相同名称和签名的实例方法会被优先调用。'
- en: Although extension methods might not seem to give a big benefit, in *Chapter
    11*, *Querying and Manipulating Data Using LINQ*, you will see some extremely
    powerful uses of extension methods.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管扩展方法可能看似没有带来巨大好处，但在*第11章*，*使用LINQ查询和操作数据*中，你将看到扩展方法的一些极其强大的用途。
- en: Using an analyzer to write better code
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分析器编写更优质的代码
- en: .NET analyzers find potential issues and suggest fixes for them. **StyleCop**
    is a commonly used analyzer for helping you write better C# code.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: .NET分析器能发现潜在问题并提出修复建议。**StyleCop**是一个常用的分析器，帮助你编写更优质的C#代码。
- en: 'Let''s see it in action, advising how to improve the code in the project template
    for a console app when targeting .NET 5.0 so that the console app already has
    a `Program` class with a `Main` method:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作，指导如何在面向.NET 5.0的控制台应用项目模板中改进代码，以便控制台应用已具备一个包含`Main`方法的`Program`类：
- en: 'Use your preferred code editor to add a console app project, as defined in
    the following list:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器添加一个控制台应用程序项目，如下表所定义：
- en: 'Project template: **Console Application** / `console -f net5.0`'
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console -f net5.0`
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-530
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `CodeAnalyzing`'
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`CodeAnalyzing`
- en: 'Target framework: **.NET 5.0 (Current)**'
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标框架：**.NET 5.0（当前）**
- en: In the `CodeAnalyzing` project, add a package reference for `StyleCop.Analyzers`.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CodeAnalyzing` 项目中，添加对 `StyleCop.Analyzers` 包的引用。
- en: Add a JSON file to your project named `stylecop.json` for controlling StyleCop
    settings.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的项目添加一个名为 `stylecop.json` 的 JSON 文件，以控制 StyleCop 设置。
- en: 'Modify its contents, as shown in the following markup:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容，如下面的标记所示：
- en: '[PRE116]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `$schema` entry enables IntelliSense while editing the `stylecop.json` file
    in your code editor.
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$schema` 条目在代码编辑器中编辑 `stylecop.json` 文件时启用 IntelliSense。'
- en: 'Edit the project file, change the target framework to `net6.0`, add entries
    to configure the file named `stylecop.json` to not be included in published deployments,
    and to enable it as an additional file for processing during development, as shown
    highlighted in the following markup:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑项目文件，将目标框架更改为 `net6.0`，添加条目以配置名为 `stylecop.json` 的文件，使其不在发布的部署中包含，并在开发期间作为附加文件进行处理，如下面的标记中突出显示的那样：
- en: '[PRE117]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Build your project.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建您的项目。
- en: You will see warnings for everything it thinks is wrong, as shown in *Figure
    6.7*:![](img/B17442_06_07.png)
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到它认为有问题的所有内容的警告，如图 *6.7* 所示：![](img/B17442_06_07.png)
- en: 'Figure 6.7: StyleCop code analyzer warnings'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.7：StyleCop 代码分析器警告
- en: 'For example, it wants `using` directives to be put within the namespace declaration,
    as shown in the following output:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，它希望 `using` 指令放在命名空间声明内，如下面的输出所示：
- en: '[PRE118]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Suppressing warnings
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抑制警告
- en: To suppress a warning, you have several options, including adding code and setting
    configuration.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 要抑制警告，您有几种选择，包括添加代码和设置配置。
- en: 'To suppress using an attribute, as shown in the following code:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 要抑制使用属性，如下面的代码所示：
- en: '[PRE119]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To suppress using a directive, as shown in the following code:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 要抑制使用指令，如下面的代码所示：
- en: '[PRE120]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Let''s suppress the warning by modifying the `stylecop.json` file:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改 `stylecop.json` 文件来抑制警告：
- en: 'In `stylecop.json`, add a configuration option to set `using` statements to
    be allowable outside a namespace, as shown highlighted in the following markup:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stylecop.json` 中，添加一个配置选项，将 `using` 语句设置为允许在命名空间外部使用，如下面的标记中突出显示的那样：
- en: '[PRE121]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Build the project and note that warning SA1200 has disappeared.
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意警告 SA1200 已消失。
- en: 'In `stylecop.json`, set the using directives placement to `preserve`, which
    allows `using` statements both inside and outside a namespace, as shown in the
    following markup:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stylecop.json` 中，将 using 指令的位置设置为 `preserve`，允许 `using` 语句在命名空间内部和外部使用，如下面的标记所示：
- en: '[PRE122]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Fixing the code
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复代码
- en: 'Now, let''s fix all the other warnings:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复所有其他警告：
- en: 'In `CodeAnalyzing.csproj`, add an element to automatically generate an XML
    file for documentation, as shown highlighted in the following markup:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CodeAnalyzing.csproj` 中，添加一个元素以自动生成文档的 XML 文件，如下面的标记中突出显示的那样：
- en: '[PRE123]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In `stylecop.json`, add a configuration option to provide values for documentation
    for the company name and copyright text, as shown highlighted in the following
    markup:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stylecop.json` 中，添加一个配置选项，为公司名称和版权文本的文档提供值，如下面的标记中突出显示的那样：
- en: '[PRE124]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'In `Program.cs`, add comments for a file header with company and copyright
    text, move the `using System;` declaration inside the namespace, and set explicit
    access modifiers and XML comments for the class and method, as shown in the following
    code:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，为文件头添加公司和版权文本的注释，将 `using System;` 声明移至命名空间内部，并为类和方法设置显式访问修饰符和
    XML 注释，如下面的代码所示：
- en: '[PRE125]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Build the project.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。
- en: 'Expand the `bin/Debug/net6.0` folder and note the autogenerated file named
    `CodeAnalyzing.xml`, as shown in the following markup:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 `bin/Debug/net6.0` 文件夹并注意名为 `CodeAnalyzing.xml` 的自动生成的文件，如下面的标记所示：
- en: '[PRE126]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Understanding common StyleCop recommendations
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解常见的 StyleCop 建议
- en: 'Inside a code file, you should order the contents, as shown in the following
    list:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码文件内部，应按以下列表所示顺序排列内容：
- en: External alias directives
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部别名指令
- en: Using directives
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指令
- en: Namespaces
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Delegates
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托
- en: Enums
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举
- en: Interfaces
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口
- en: Structs
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体
- en: Classes
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类
- en: 'Within a class, record, struct, or interface, you should order the contents,
    as shown in the following list:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在类、记录、结构或接口内部，应按以下列表所示顺序排列内容：
- en: Fields
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段
- en: Constructors
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Destructors (finalizers)
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数（终结器）
- en: Delegates
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托
- en: Events
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件
- en: Enums
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举
- en: Interfaces
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口
- en: Properties
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性
- en: Indexers
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引器
- en: Methods
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法
- en: Structs
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体
- en: Nested classes and records
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套类和记录
- en: '**Good Practice**: You can learn about all the StyleCop rules at the following
    link: [https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md).'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：你可以在以下链接了解所有StyleCop规则：[https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md)。'
- en: Practicing and exploring
  id: totrans-592
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践与探索
- en: Test your knowledge and understanding by answering some questions. Get some
    hands-on practice and explore this chapter's topics with more in-depth research.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试你的知识和理解。通过更深入的研究，获得一些实践经验并探索本章的主题。
- en: Exercise 6.1 – Test your knowledge
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What is a delegate?
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是委托？
- en: What is an event?
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事件？
- en: How are a base class and a derived class related, and how can the derived class
    access the base class?
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基类和派生类是如何关联的，派生类如何访问基类？
- en: What is the difference between `is` and `as` operators?
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`is`和`as`操作符之间有什么区别？'
- en: Which keyword is used to prevent a class from being derived from or a method
    from being further overridden?
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于防止一个类被派生或一个方法被进一步重写？
- en: Which keyword is used to prevent a class from being instantiated with the `new`
    keyword?
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于防止一个类通过`new`关键字实例化？
- en: Which keyword is used to allow a member to be overridden?
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于允许成员被重写？
- en: What's the difference between a destructor and a deconstruct method?
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数和解构方法之间有什么区别？
- en: What are the signatures of the constructors that all exceptions should have?
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有异常应具有的构造函数的签名是什么？
- en: What is an extension method, and how do you define one?
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是扩展方法，如何定义一个？
- en: Exercise 6.2 – Practice creating an inheritance hierarchy
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.2 – 实践创建继承层次结构
- en: 'Explore inheritance hierarchies by following these steps:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤探索继承层次结构：
- en: Add a new console application named `Exercise02` to your `Chapter06` solution/workspace.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向你的`Chapter06`解决方案/工作区中添加一个名为`Exercise02`的新控制台应用程序。
- en: Create a class named `Shape` with properties named `Height`, `Width`, and `Area`.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Shape`的类，其属性名为`Height`、`Width`和`Area`。
- en: Add three classes that derive from it—`Rectangle`, `Square`, and `Circle`—with
    any additional members you feel are appropriate and that override and implement
    the `Area` property correctly.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个从它派生的类——`Rectangle`、`Square`和`Circle`——根据你认为合适的任何额外成员，并正确地重写和实现`Area`属性。
- en: 'In `Main`, add statements to create one instance of each shape, as shown in
    the following code:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`中，添加语句以创建每种形状的一个实例，如下列代码所示：
- en: '[PRE127]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Run the console application and ensure that the result looks like the following
    output:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并确保结果与以下输出相符：
- en: '[PRE128]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Exercise 6.3 – Explore topics
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.3 – 探索主题
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接来了解更多关于本章涵盖的主题：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
- en: Summary
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about local functions and operators, delegates
    and events, implementing interfaces, generics, and deriving types using inheritance
    and OOP. You also learned about base and derived classes, and how to override
    a type member, use polymorphism, and cast between types.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了局部函数和操作符、委托和事件、实现接口、泛型以及使用继承和OOP派生类型。你还学习了基类和派生类，以及如何重写类型成员、使用多态性以及在类型之间进行转换。
- en: In the next chapter, you will learn how .NET is packaged and deployed, and,
    in subsequent chapters, the types that it provides you with to implement common
    functionality such as file handling, database access, encryption, and multitasking.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习.NET是如何打包和部署的，以及在后续章节中，它为你提供的实现常见功能（如文件处理、数据库访问、加密和多任务处理）的类型。
