- en: '04'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '04'
- en: Writing, Debugging, and Testing Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写、调试和测试函数
- en: This chapter is about writing functions to reuse code, debugging logic errors
    during development, logging exceptions during runtime, unit testing your code
    to remove bugs, and ensuring stability and reliability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于编写可重用代码的函数，开发过程中调试逻辑错误，运行时记录异常，单元测试代码以消除错误，并确保稳定性和可靠性。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Writing functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数
- en: Debugging during development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发过程中的调试
- en: Logging during runtime
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时日志记录
- en: Unit testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Throwing and catching exceptions in functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中抛出和捕获异常
- en: Writing functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写函数
- en: A fundamental principle of programming is **Don't Repeat Yourself** (**DRY**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一个基本原则是 **不要重复自己** (**DRY**)。
- en: While programming, if you find yourself writing the same statements over and
    over again, then turn those statements into a function. Functions are like tiny
    programs that complete one small task. For example, you might write a function
    to calculate sales tax and then reuse that function in many places in a financial
    application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编程时，如果你发现自己一遍又一遍地写相同的语句，那么将这些语句转换成一个函数。函数就像完成一项小任务的小程序。例如，你可能会编写一个计算销售税的函数，然后在财务应用程序的许多地方重用该函数。
- en: Like programs, functions usually have inputs and outputs. They are sometimes
    described as black boxes, where you feed some raw materials in one end, and a
    manufactured item emerges at the other. Once created, you don't need to think
    about how they work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序一样，函数通常有输入和输出。它们有时被描述为黑盒子，你在一端输入一些原材料，另一端就会产生成品。一旦创建，你不需要考虑它们是如何工作的。
- en: Times table example
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘法表示例
- en: 'Let''s say that you want to help your child learn their times tables, so you
    want to make it easy to generate a times table for a number, such as the 12 times
    table:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想帮助你的孩子学习乘法表，因此你希望轻松生成任意数字的乘法表，例如 12 的乘法表：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You previously learned about the `for` statement earlier in this book, so you
    know that it can be used to generate repeated lines of output when there is a
    regular pattern, such as the 12 times table, as shown in the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前在这本书中学过 `for` 语句，因此你知道它可以用来生成重复的输出行，当存在规律模式时，例如 12 的乘法表，如下列代码所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, instead of outputting the 12 times table, we want to make this more
    flexible, so it could output the times table for any number. We can do this by
    creating a function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不想只输出 12 的乘法表，而是希望使其更灵活，以便它可以输出任意数字的乘法表。我们可以通过创建一个函数来实现这一点。
- en: Writing a times table function
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写乘法表函数
- en: 'Let''s explore functions by creating one to output any times table for numbers
    0 to 255 multiplied by 1 to 12:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个输出 0 到 255 的任意数字乘以 1 到 12 的乘法表的函数来探索函数：
- en: 'Use your preferred coding tool to create a new console app, as defined in the
    following list:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编程工具创建一个新的控制台应用程序，如下表所定义：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter04`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter04`
- en: 'Project file and folder: `WritingFunctions`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WritingFunctions`
- en: Statically import `System.Console`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态导入 `System.Console`。
- en: 'In `Program.cs`, write statements to define a function named `TimesTable`,
    as shown in the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，编写语句以定义名为 `TimesTable` 的函数，如下列代码所示：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, note the following:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意以下几点：
- en: '`TimesTable` must have a `byte` value passed to it as a parameter named `number`.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable` 方法必须接收一个名为 `number` 的 `byte` 类型参数。'
- en: '`TimesTable` is a `static` method because it will be called by the `static`
    method `Main`.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable` 是一个 `static` 方法，因为它将由 `static` 方法 `Main` 调用。'
- en: '`TimesTable` does not return a value to the caller, so it is declared with
    the `void` keyword before its name.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable` 不向调用者返回值，因此它在其名称前声明了 `void` 关键字。'
- en: '`TimesTable` uses a `for` statement to output the times table for the `number`
    passed to it.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimesTable` 使用一个 `for` 语句来输出传入的 `number` 的乘法表。'
- en: 'After the statement that statically imports the `Console` class and before
    the `TimesTable` function, call the function and pass in a `byte` value for the
    `number` parameter, for example, `6`, as shown highlighted in the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在静态导入 `Console` 类和 `TimesTable` 函数之前，调用该函数并传入一个 `byte` 类型的 `number` 参数值，例如 `6`，如下列代码中突出显示的那样：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Good Practice**: If a function has one or more parameters where just passing
    the values may not provide enough meaning, then you can optionally specify the
    name of the parameter as well as its value, as shown in the following code: `TimesTable(number:
    6)`.'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：如果一个函数有一个或多个参数，仅传递值可能不足以表达其含义，那么你可以选择性地指定参数的名称及其值，如下所示：`TimesTable(number:
    6)`。'
- en: 'Run the code and then view the result, as shown in the following output:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，然后查看结果，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Change the number passed into the `TimesTable` function to other `byte` values
    between `0` and `255` and confirm that the output times tables are correct.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传递给`TimesTable`函数的数字更改为其他`byte`值，范围在`0`到`255`之间，并确认输出乘法表是否正确。
- en: 'Note that if you try to pass a non-`byte` number, for example, an `int` or
    `double` or `string`, an error is returned, as shown in the following output:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，如果你尝试传递一个非`byte`类型的数字，例如`int`、`double`或`string`，将会返回一个错误，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Writing a function that returns a value
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个返回值的函数
- en: The previous function performed actions (looping and writing to the console),
    but it did not return a value. Let's say that you need to calculate sales or value-added
    tax (VAT). In Europe, VAT rates can range from 8% in Switzerland to 27% in Hungary.
    In the United States, state sales taxes can range from 0% in Oregon to 8.25% in
    California.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的函数执行了操作（循环和写入控制台），但没有返回值。假设你需要计算销售税或增值税（VAT）。在欧洲，VAT税率可以从瑞士的8%到匈牙利的27%不等。在美国，州销售税率可以从俄勒冈州的0%到加利福尼亚州的8.25%不等。
- en: Tax rates change all the time, and they vary based on many factors. You do not
    need to contact me to tell me that the tax rate in Virginia is 6%. Thank you.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 税率随时在变化，且受多种因素影响。无需联系我告知弗吉尼亚州的税率是6%，谢谢。
- en: 'Let''s implement a function to calculate taxes in various regions around the
    world:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个计算全球各地税收的函数：
- en: 'Add a function named `CalculateTax`, as shown in the following code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`CalculateTax`的函数，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, note the following:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前述代码中，请注意以下几点：
- en: '`CalculateTax` has two inputs: a parameter named `amount` that will be the
    amount of money spent, and a parameter named `twoLetterRegionCode` that will be
    the region the amount is spent in.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculateTax`有两个输入：一个名为`amount`的参数，表示花费的金额，以及一个名为`twoLetterRegionCode`的参数，表示花费金额的地区。'
- en: '`CalculateTax` will perform a calculation using a `switch` statement and then
    return the sales tax or VAT owed on the amount as a `decimal` value; so, before
    the name of the function, we have declared the data type of the return value to
    be `decimal`.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculateTax`将使用`switch`语句进行计算，并返回该金额应缴纳的销售税或增值税作为`decimal`值；因此，在函数名前，我们声明了返回值的数据类型为`decimal`。'
- en: 'Comment out the `TimesTable` method call and call the `CalculateTax` method,
    passing values for the amount such as `149` and a valid region code such as `FR`,
    as shown in the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉`TimesTable`方法的调用，并调用`CalculateTax`方法，传入金额值如`149`和有效的地区代码如`FR`，如下所示：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We could format the `taxToPay` output as currency by using `{taxToPay:C}` but
    it will use your local culture to decide how to format the currency symbol and
    decimals. For example, for me in the UK, I would see `£29.80`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`{taxToPay:C}`将`taxToPay`的输出格式化为货币，但它会根据您的本地文化来决定如何格式化货币符号和小数。例如，在英国的我，会看到`£29.80`。
- en: Can you think of any problems with the `CalculateTax` function as written? What
    would happen if the user enters a code such as `fr` or `UK`? How could you rewrite
    the function to improve it? Would using a `switch` *expression* instead of a `switch`
    *statement* be clearer?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到`CalculateTax`函数按原样编写可能存在的问题吗？如果用户输入一个代码如`fr`或`UK`会发生什么？如何重写该函数以改进它？使用`switch`*表达式*而不是`switch`*语句*是否会更为清晰？
- en: Converting numbers from cardinal to ordinal
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数字从基数转换为序数
- en: 'Numbers that are used to count are called **cardinal** numbers, for example,
    1, 2, and 3, whereas numbers used to order are **ordinal** numbers, for example,
    1st, 2nd, and 3rd. Let''s create a function to convert cardinals to ordinals:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计数的数字称为**基数**数字，例如1、2和3，而用于排序的数字称为**序数**数字，例如1st、2nd和3rd。让我们创建一个将基数转换为序数的函数：
- en: 'Write a function named `CardinalToOrdinal` that converts a cardinal `int` value
    into an ordinal `string` value; for example, it converts 1 into 1st, 2 into 2nd,
    and so on, as shown in the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`CardinalToOrdinal`的函数，该函数将基数`int`值转换为序数`string`值；例如，它将1转换为1st，2转换为2nd，依此类推，如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From the preceding code, note the following:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从前面的代码中，请注意以下内容：
- en: '`CardinalToOrdinal` has one input: a parameter of the `int` type named `number`,
    and one output: a return value of the `string` type.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CardinalToOrdinal`有一个输入：名为`number`的`int`类型参数，一个输出：`string`类型的返回值。'
- en: A `switch` *statement* is used to handle the special cases of 11, 12, and 13.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`switch`*语句*来处理11、12和13的特殊情况。
- en: 'A `switch` *expression* then handles all other cases: if the last digit is
    1, then use `st` as the suffix; if the last digit is 2, then use `nd` as the suffix;
    if the last digit is 3, then use `rd` as the suffix; and if the last digit is
    anything else, then use `th` as the suffix.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后使用`switch`*表达式*处理所有其他情况：如果最后一个数字是1，则使用`st`作为后缀；如果最后一个数字是2，则使用`nd`作为后缀；如果最后一个数字是3，则使用`rd`作为后缀；如果最后一个数字是其他任何数字，则使用`th`作为后缀。
- en: 'Write a function named `RunCardinalToOrdinal` that uses a `for` statement to
    loop from 1 to 40, calling the `CardinalToOrdinal` function for each number and
    writing the returned `string` to the console, separated by a space character,
    as shown in the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`RunCardinalToOrdinal`的函数，该函数使用`for`语句从1循环到40，对每个数字调用`CardinalToOrdinal`函数，并将返回的`字符串`写入控制台，以空格字符分隔，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Comment out the `CalculateTax` statements, and call the `RunCardinalToOrdinal`
    method, as shown in the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉`CalculateTax`语句，并调用`RunCardinalToOrdinal`方法，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Calculating factorials with recursion
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用递归计算阶乘
- en: 'The factorial of 5 is 120, because factorials are calculated by multiplying
    the starting number by one less than itself, and then by one less again, and so
    on, until the number is reduced to 1\. An example can be seen here: 5 x 4 x 3
    x 2 x 1 = 120.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 5的阶乘是120，因为阶乘是通过将起始数乘以比自身小1的数，然后再乘以小1的数，依此类推，直到数减至1来计算的。一个例子可以在这里看到：5 x 4 x
    3 x 2 x 1 = 120。
- en: 'Factorials are written like this: 5!, where the exclamation mark is read as
    bang, so 5! = 120, that is, *five bang equals one hundred and twenty*. Bang is
    a good name for factorials because they increase in size very rapidly, just like
    an explosion.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘这样表示：5!，其中感叹号读作bang，所以5! = 120，即*五bang等于一百二十*。Bang是阶乘的好名字，因为它们的大小增长非常迅速，就像爆炸一样。
- en: 'We will write a function named `Factorial`; this will calculate the factorial
    for an `int` passed to it as a parameter. We will use a clever technique called
    **recursion**, which means a function that calls itself within its implementation,
    either directly or indirectly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为`Factorial`的函数；这将计算传递给它的`int`参数的阶乘。我们将使用一种称为**递归**的巧妙技术，这意味着一个函数在其实现中调用自身，无论是直接还是间接：
- en: 'Add a function named `Factorial`, and a function to call it, as shown in the
    following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Factorial`的函数，以及一个调用它的函数，如下所示：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As before, there are several noteworthy elements of the preceding code, including
    the following:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，前面的代码中有几个值得注意的元素，包括以下内容：
- en: If the input parameter `number` is zero or negative, `Factorial` returns `0`.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数`number`为零或负数，`Factorial`返回`0`。
- en: If the input parameter `number` is `1`, `Factorial` returns `1`, and therefore
    stops calling itself.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数`number`为`1`，`Factorial`返回`1`，因此停止调用自身。
- en: If the input parameter `number` is larger than one, which it will be in all
    other cases, `Factorial` multiplies the number by the result of calling itself
    and passing one less than `number`. This makes the function recursive.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数`number`大于1，在所有其他情况下都会如此，`Factorial`函数会将该数乘以调用自身并传递比`number`小1的结果。这使得函数具有递归性。
- en: '**More Information**: Recursion is clever, but it can lead to problems, such
    as a stack overflow due to too many function calls because memory is used to store
    data on every function call, and it eventually uses too much. Iteration is a more
    practical, if less succinct, solution in languages such as C#. You can read more
    about this at the following link: [https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration](https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration).'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**更多信息**：递归虽然巧妙，但可能导致问题，如因函数调用过多而导致的栈溢出，因为每次函数调用都会占用内存来存储数据，最终会消耗过多内存。在C#等语言中，迭代是一种更实用（尽管不那么简洁）的解决方案。您可以在以下链接了解更多信息：[https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration](https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration)。'
- en: 'Add a function named `RunFactorial` that uses a `for` statement to output the
    factorials of numbers from 1 to 14, calls the `Factorial` function inside its
    loop, and then outputs the result, formatted using the code `N0`, which means
    number format uses thousand separators with zero decimal places, as shown in the
    following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`RunFactorial`的函数，该函数使用`for`语句输出1到14的阶乘，在循环内部调用`Factorial`函数，然后使用代码`N0`格式化输出结果，这意味着数字格式使用千位分隔符且无小数位，如下所示：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Comment out the `RunCardinalToOrdinal` method call and call the `RunFactorial`
    method.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉`RunCardinalToOrdinal`方法调用，并调用`RunFactorial`方法。
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is not immediately obvious in the previous output, but factorials of 13 and
    higher overflow the `int` type because they are so big. 12! is 479,001,600, which
    is about half a billion. The maximum positive value that can be stored in an `int`
    variable is about two billion. 13! is 6,227,020,800, which is about six billion
    and when stored in a 32-bit integer it overflows silently without showing any
    problems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中并不立即明显，但13及以上的阶乘会溢出`int`类型，因为它们太大了。12!是479,001,600，大约是半十亿。`int`变量能存储的最大正数值大约是二十亿。13!是6,227,020,800，大约是六十亿，当存储在32位整数中时，它会无声地溢出，不会显示任何问题。
- en: Do you remember what we can do to be notified of a numeric overflow?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们可以做什么来获知数值溢出吗？
- en: What should you do to get notified when an overflow happens? Of course, we could
    solve the problem for 13! and 14! by using a `long` (64-bit integer) instead of
    an `int` (32-bit integer), but we will quickly hit the overflow limit again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生溢出时，你应该怎么做才能得到通知？当然，我们可以通过使用`long`（64位整数）而不是`int`（32位整数）来解决13!和14!的问题，但我们很快会再次遇到溢出限制。
- en: The point of this section is to understand that numbers can overflow and how
    to show that rather than ignore it, not specifically how to calculate factorials
    higher than 12!.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的重点是理解数字可能溢出以及如何显示溢出而非忽略它，并非特定于如何计算高于12的阶乘。
- en: 'Modify the `Factorial` function to check for overflows, as shown highlighted
    in the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Factorial`函数以检查溢出，如下所示高亮显示：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Modify the `RunFactorial` function to handle overflow exceptions when calling
    the `Factorial` function, as shown highlighted in the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`RunFactorial`函数以处理在调用`Factorial`函数时发生的溢出异常，如下所示高亮显示：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Documenting functions with XML comments
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XML注释记录函数
- en: 'By default, when calling a function such as `CardinalToOrdinal`, code editors
    will show a tooltip with basic information, as shown in *Figure 4.1*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当调用如`CardinalToOrdinal`这样的函数时，代码编辑器会显示一个包含基本信息的工具提示，如*图4.1*所示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17442_04_01.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序 描述自动生成](img/B17442_04_01.png)'
- en: 'Figure 4.1: A tooltip showing the default simple method signature'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：显示默认简单方法签名的工具提示
- en: 'Let''s improve the tooltip by adding extra information:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加额外信息来改进工具提示：
- en: 'If you are using Visual Studio Code with the **C#** extension, you should navigate
    to **View** | **Command Palette** | **Preferences: Open Settings (UI)**, and then
    search for `formatOnType` and make sure that is enabled. C# XML documentation
    comments are a built-in feature of Visual Studio 2022.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是带有**C#**扩展的Visual Studio Code，你应该导航到**视图** | **命令面板** | **首选项：打开设置（UI）**，然后搜索`formatOnType`并确保其已启用。C#
    XML文档注释是Visual Studio 2022的内置功能。
- en: On the line above the `CardinalToOrdinal` function, type three forward slashes
    `///`, and note that they are expanded into an XML comment that recognizes that
    the function has a single parameter named `number`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CardinalToOrdinal`函数上方的一行中，键入三个正斜杠`///`，并注意它们扩展成一个XML注释，该注释识别到函数有一个名为`number`的单个参数。
- en: 'Enter suitable information for the XML documentation comment for a summary
    and to describe the input parameter and the return value for the `CardinalToOrdinal`
    function, as shown in the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`CardinalToOrdinal`函数的XML文档注释输入合适的信息，以总结并描述输入参数和返回值，如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when calling the function, you will see more details, as shown in *Figure
    4.2*:![Graphical user interface, text, application, chat or text message, email  Description
    automatically generated](img/B17442_04_03.png)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在调用函数时，您将看到更多细节，如*图4.2*所示：![图形用户界面，文本，应用程序，聊天或短信，电子邮件 自动生成描述](img/B17442_04_03.png)
- en: 'Figure 4.2: A tooltip showing the more detailed method signature'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：显示更详细方法签名的工具提示
- en: At the time of writing the sixth edition, C# XML documentation comments do not
    work in .NET Interactive notebooks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写第六版时，C# XML文档注释在.NET Interactive笔记本中不起作用。
- en: '**Good Practice**: Add XML documentation comments to all your functions.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：为所有函数添加XML文档注释。'
- en: Using lambdas in function implementations
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数实现中使用lambda表达式
- en: F# is Microsoft's strongly typed functional-first programming language that,
    like C#, compiles to IL to be executed by .NET. Functional languages evolved from
    lambda calculus; a computational system based only on functions. The code looks
    more like mathematical functions than steps in a recipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: F#是微软的强类型函数优先编程语言，与C#一样，它编译为IL，由.NET执行。函数式语言从lambda演算演变而来；一个仅基于函数的计算系统。代码看起来更像数学函数，而不是食谱中的步骤。
- en: 'Some of the important attributes of functional languages are defined in the
    following list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言的一些重要属性定义如下：
- en: '**Modularity**: The same benefit of defining functions in C# applies to functional
    languages. Break up a large complex code base into smaller pieces.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：在C#中定义函数的相同好处也适用于函数式语言。将大型复杂代码库分解为较小的部分。'
- en: '**Immutability**: Variables in the C# sense do not exist. Any data value inside
    a function cannot change. Instead, a new data value can be created from an existing
    one. This reduces bugs.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：C#意义上的变量不存在。函数内部的任何数据值都不能更改。相反，可以从现有数据值创建新的数据值。这减少了错误。'
- en: '**Maintainability**: Code is cleaner and clearer (for mathematically inclined
    programmers!).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：代码更简洁明了（对于数学倾向的程序员而言！）。'
- en: Since C# 6, Microsoft has worked to add features to the language to support
    a more functional approach. For example, adding **tuples** and **pattern matching**
    in C# 7, **non-null reference types** in C# 8, and improving pattern matching
    and adding records, that is, **immutable objects** in C# 9.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 自C# 6以来，微软一直致力于为该语言添加功能，以支持更函数化的方法。例如，在C# 7中添加**元组**和**模式匹配**，在C# 8中添加**非空引用类型**，以及改进模式匹配并添加记录，即C#
    9中的**不可变对象**。
- en: In C# 6, Microsoft added support for **expression-bodied function members**.
    We will look at an example of this now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6中，微软增加了对**表达式体函数成员**的支持。我们现在来看一个例子。
- en: 'The **Fibonacci sequence** of numbers always starts with 0 and 1\. Then the
    rest of the sequence is generated using the rule of adding together the previous
    two numbers, as shown in the following sequence of numbers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数字序列的**斐波那契数列**总是以0和1开始。然后，序列的其余部分按照前两个数字相加的规则生成，如下列数字序列所示：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The next term in the sequence would be 34 + 55, which is 89.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 序列中的下一个项将是34 + 55，即89。
- en: 'We will use the Fibonacci sequence to illustrate the difference between an
    imperative and declarative function implementation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用斐波那契数列来说明命令式和声明式函数实现之间的区别：
- en: 'Add a function named `FibImperative` that will be written in an imperative
    style, as shown in the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`FibImperative`的函数，该函数将以命令式风格编写，如下所示：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a function named `RunFibImperative` that calls `FibImperative` inside a
    `for` statement that loops from 1 to 30, as shown in the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`RunFibImperative`的函数，该函数在从1到30的`for`循环中调用`FibImperative`，如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Comment out the other method calls and call the `RunFibImperative` method.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉其他方法调用，并调用`RunFibImperative`方法。
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE23]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a function named `FibFunctional` written in a declarative style, as shown
    in the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`FibFunctional`的函数，采用声明式风格编写，如下列代码所示：
- en: '[PRE24]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add a function to call it inside a `for` statement that loops from 1 to 30,
    as shown in the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`语句中添加一个调用它的函数，该语句从1循环到30，如下列代码所示：
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Comment out the `RunFibImperative` method call, and call the `RunFibFunctional`
    method.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉`RunFibImperative`方法调用，并调用`RunFibFunctional`方法。
- en: Run the code and view the results (which will be the same as before).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果（与之前相同）。
- en: Debugging during development
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发过程中的调试
- en: In this section, you will learn how to debug problems at development time. You
    must use a code editor that has debugging tools such as Visual Studio or Visual
    Studio Code. At the time of writing, you cannot use .NET Interactive Notebooks
    to debug code, but this is expected to be added in the future.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何在开发时调试问题。你必须使用具有调试工具的代码编辑器，如Visual Studio或Visual Studio Code。在撰写本文时，你不能使用.NET
    Interactive Notebooks来调试代码，但预计未来会添加此功能。
- en: '**More Information**: Some people find it tricky setting up the OmniSharp debugger
    for Visual Studio Code. I have included instructions for the most common issues,
    but if you still have trouble, try reading the information at the following link:
    [https://github.com/OmniSharp/omnisharp-vscode/blob/master/debugger.md](https://github.com/OmniSharp/omnisharp-vscode/blob/master/debugger.md)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：有些人发现为Visual Studio Code设置OmniSharp调试器很棘手。我已包含最常见问题的解决方法，但如果你仍有困难，尝试阅读以下链接中的信息：[https://github.com/OmniSharp/omnisharp-vscode/blob/master/debugger.md](https://github.com/OmniSharp/omnisharp-vscode/blob/master/debugger.md)'
- en: Creating code with a deliberate bug
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建带有故意错误的代码
- en: 'Let''s explore debugging by creating a console app with a deliberate bug that
    we will then use the debugger tools in your code editor to track down and fix:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个带有故意错误的控制台应用程序来探索调试，然后我们将使用代码编辑器中的调试工具来追踪并修复它：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter04`
    workspace/solution named `Debugging`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的编程工具，在`Chapter04`工作区/解决方案中添加一个名为`Debugging`的**控制台应用程序**。
- en: In Visual Studio Code, select `Debugging` as the active OmniSharp project. When
    you see the pop-up warning message saying that required assets are missing, click
    **Yes** to add them.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Debugging`作为活动OmniSharp项目。当看到提示缺少必需资产的弹出警告消息时，点击**是**以添加它们。
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，将解决方案的启动项目设置为当前选择。
- en: 'In `Program.cs`, add a function with a deliberate bug, as shown in the following
    code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个带有故意错误的函数，如下列代码所示：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Below the `Add` function, write statements to declare and set some variables
    and then add them together using the buggy function, as shown in the following
    code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Add`函数下方，编写语句以声明并设置一些变量，然后使用有缺陷的函数将它们相加，如下列代码所示：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the console application and view the result, as shown in the following
    partial output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并查看结果，如下列部分输出所示：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: But wait, there's a bug! 4.5 added to 2.5 should be 7, not 11.25!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，有个错误！4.5加上2.5应该是7，而不是11.25！
- en: We will use the debugging tools to hunt for and squash the bug.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用调试工具来追踪并消除这个错误。
- en: Setting a breakpoint and start debugging
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置断点并开始调试
- en: Breakpoints allow us to mark a line of code that we want to pause at to inspect
    the program state and find bugs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 断点允许我们在想要暂停以检查程序状态和查找错误的代码行上做标记。
- en: Using Visual Studio 2022
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Visual Studio 2022
- en: 'Let''s set a breakpoint and then start debugging using Visual Studio 2022:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个断点，然后使用Visual Studio 2022开始调试：
- en: Click in the statement that declares the variable named `a`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击声明名为`a`的变量的语句。
- en: Navigate to **Debug** | **Toggle Breakpoint** or press F9\. A red circle will
    then appear in the margin bar on the left-hand side and the statement will be
    highlighted in red to indicate that a breakpoint has been set, as shown in *Figure
    4.3*:![](img/B17442_04_04.png)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**调试** | **切换断点**或按F9。随后，左侧边距栏中将出现一个红色圆圈，语句将以红色高亮显示，表明已设置断点，如*图4.3*所示：![](img/B17442_04_04.png)
- en: 'Figure 4.3: Toggling breakpoints using Visual Studio 2022'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图4.3*：使用Visual Studio 2022切换断点'
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off, or right-click a breakpoint to
    see more options, such as delete, disable, or edit conditions or actions for an
    existing breakpoint.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断点可以通过相同的操作关闭。你也可以在边距处左键点击来切换断点的开启和关闭，或者右键点击断点以查看更多选项，例如删除、禁用或编辑现有断点的条件或操作。
- en: Navigate to **Debug** | **Start Debugging** or press F5\. Visual Studio starts
    the console application and then pauses when it hits the breakpoint. This is known
    as break mode. Extra windows titled **Locals** (showing current values of local
    variables), **Watch 1** (showing any watch expressions you have defined), **Call
    Stack**, **Exception Settings**, and **Immediate Window** appear. The **Debugging**
    toolbar appears. The line that will be executed next is highlighted in yellow,
    and a yellow arrow points at the line from the margin bar, as shown in *Figure
    4.4*:![](img/B17442_04_05.png)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**调试** | **开始调试**或按F5。Visual Studio启动控制台应用程序，并在遇到断点时暂停。这称为中断模式。额外的窗口标题为**局部变量**（显示当前局部变量的值），**监视1**（显示你定义的任何监视表达式），**调用堆栈**，**异常设置**和**即时窗口**出现。**调试**工具栏出现。下一条将要执行的行以黄色高亮显示，黄色箭头从边距栏指向该行，如图*4.4*所示：![](img/B17442_04_05.png)
- en: 'Figure 4.4: Break mode in Visual Studio 2022'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：Visual Studio 2022中的中断模式
- en: If you do not want to see how to use Visual Studio Code to start debugging then
    you can skip the next section and continue to the section titled *Navigating with
    the debugging toolbar*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想了解如何使用Visual Studio Code开始调试，则可以跳过下一节，继续阅读标题为*使用调试工具栏导航*的部分。
- en: Using Visual Studio Code
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code
- en: 'Let''s set a breakpoint and then start debugging using Visual Studio Code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个断点，然后使用Visual Studio Code开始调试：
- en: Click in the statement that declares the variable named `a`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击声明名为`a`的变量的语句。
- en: Navigate to **Run** | **Toggle Breakpoint** or press F9\. A red circle will
    appear in the margin bar on the left-hand side to indicate that a breakpoint has
    been set, as shown in *Figure 4.5*:![](img/B17442_04_06.png)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**运行** | **切换断点**或按F9。边距栏左侧将出现一个红色圆圈，表示已设置断点，如图*4.5*所示：![](img/B17442_04_06.png)
- en: 'Figure 4.5: Toggling breakpoints using Visual Studio Code'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.5：使用Visual Studio Code切换断点
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off, or right-click to see more options,
    such as remove, edit, or disable an existing breakpoint; or adding a breakpoint,
    conditional breakpoint, or logpoint when a breakpoint does not yet exist.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断点可以通过相同的操作关闭。你也可以在边距处左键点击来切换断点的开启和关闭，或者右键点击断点以查看更多选项，例如删除、禁用或编辑现有断点的条件或操作；或者在没有断点时添加断点、条件断点或日志点。
- en: Logpoints, also known as tracepoints, indicate that you want to record some
    information without having to actually stop executing the code at that point.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 日志点，也称为跟踪点，表示你希望记录某些信息而不必实际停止在该点执行代码。
- en: Navigate to **View** | **Run**, or in the left navigation bar you can click
    the **Run and Debug** icon (the triangle "play" button and "bug"), as shown in
    *Figure 4.5*.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**视图** | **运行**，或在左侧导航栏中点击**运行和调试**图标（三角形“播放”按钮和“错误”），如图*4.5*所示。
- en: At the top of the **DEBUG** window, click on the dropdown to the right of the
    **Start Debugging** button (green triangular "play" button), and select **.NET
    Core Launch (console) (Debugging)**, as shown in *Figure 4.6*:![](img/B17442_04_07.png)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**调试**窗口顶部，点击**开始调试**按钮（绿色三角形“播放”按钮）右侧的下拉菜单，并选择**.NET Core启动（控制台）（调试）**，如图*4.6*所示：![](img/B17442_04_07.png)
- en: 'Figure 4.6: Selecting the project to debug using Visual Studio Code'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.6：使用Visual Studio Code选择要调试的项目
- en: '**Good Practice**: If you do not see a choice in the dropdown list for the
    **Debugging** project, it is because that project does not have the assets needed
    to debug. Those assets are stored in the `.vscode` folder. To create the `.vscode`
    folder for a project, navigate to **View** | **Command Palette**, select **OmniSharp:
    Select Project**, and then select the **Debugging** project. After a few seconds,
    when prompted, **Required assets to build and debug are missing from ''Debugging''.
    Add them?**, click **Yes** to add the missing assets.'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：如果在**调试**项目的下拉列表中没有看到选项，那是因为该项目没有所需的调试资产。这些资产存储在 `.vscode` 文件夹中。要为项目创建
    `.vscode` 文件夹，请导航至**视图** | **命令面板**，选择 **OmniSharp: 选择项目**，然后选择**调试**项目。几秒钟后，当提示**调试中缺少构建和调试所需的资产。添加它们？**时，点击**是**以添加缺失的资产。'
- en: At the top of the **DEBUG** window, click the **Start Debugging** button (green
    triangular "play" button), or navigate to **Run** | **Start Debugging**, or press
    F5\. Visual Studio Code starts the console application and then pauses when it
    hits the breakpoint. This is known as break mode. The line that will be executed
    next is highlighted in yellow, and a yellow block points at the line from the
    margin bar, as shown in *Figure 4.7*:![](img/B17442_04_08.png)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**调试**窗口顶部，点击**开始调试**按钮（绿色三角形“播放”按钮），或导航至**运行** | **开始调试**，或按 F5。Visual Studio
    Code 启动控制台应用程序，并在遇到断点时暂停。这称为断点模式。接下来要执行的行以黄色高亮显示，黄色方块从边距栏指向该行，如*图 4.7* 所示：![](img/B17442_04_08.png)
- en: 'Figure 4.7: Break mode in Visual Studio Code'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4.7*：Visual Studio Code 中的断点模式'
- en: Navigating with the debugging toolbar
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调试工具栏导航
- en: Visual Studio Code shows a floating toolbar with buttons to make it easy to
    access debugging features. Visual Studio 2022 has one button in its **Standard**
    toolbar to start or continue debugging and a separate **Debugging** toolbar for
    the rest of the tools.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 显示一个浮动工具栏，上面有按钮，方便访问调试功能。Visual Studio 2022 在**标准**工具栏上有一个按钮用于开始或继续调试，另外还有一个单独的**调试**工具栏用于其他工具。
- en: 'Both are shown in *Figure 4.8* and as described in the following list:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 两者均在*图 4.8* 中展示，并按以下列表描述：
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B17442_04_09.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 描述自动生成，中等置信度](img/B17442_04_09.png)'
- en: 'Figure 4.8: Debugging toolbars in Visual Studio 2022 and Visual Studio Code'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.8*：Visual Studio 2022 和 Visual Studio Code 中的调试工具栏'
- en: '**Continue**/F5: This button will continue running the program from the current
    position until it ends or hits another breakpoint.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继续** / F5：此按钮将从当前位置继续运行程序，直到程序结束或遇到另一个断点。'
- en: '**Step Over**/F10, **Step Into**/F11, and **Step Out**/Shift + F11 (blue arrows
    over dots): These buttons step through the code statements in various ways, as
    you will see in a moment.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单步执行** / F10，**单步进入** / F11，**单步退出** / Shift + F11（蓝色箭头在点上）：这些按钮以不同方式逐条执行代码语句，稍后你将看到。'
- en: '**Restart**/Ctrl or Cmd + Shift + F5 (circular arrow): This button will stop
    and then immediately restart the program with the debugger attached again.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新启动** / Ctrl 或 Cmd + Shift + F5（圆形箭头）：此按钮将停止程序，然后立即重新启动，同时再次附加调试器。'
- en: '**Stop**/Shift + F5 (red square): This button will stop the debugging session.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止** / Shift + F5（红色方块）：此按钮将停止调试会话。'
- en: Debugging windows
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试窗口
- en: While debugging, both Visual Studio Code and Visual Studio show extra windows
    that allow you to monitor useful information, such as variables, while you step
    through your code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，Visual Studio Code 和 Visual Studio 都会显示额外的窗口，以便你在逐步执行代码时监控诸如变量等有用信息。
- en: 'The most useful windows are described in the following list:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了最有用的窗口：
- en: '**VARIABLES**, including **Locals**, which shows the name, value, and type
    for any local variables automatically. Keep an eye on this window while you step
    through your code.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**，包括**局部变量**，自动显示任何局部变量的名称、值和类型。在逐步执行代码时，请留意此窗口。'
- en: '**WATCH**, or **Watch 1**, which shows the value of variables and expressions
    that you manually enter.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视**，或**监视 1**，显示你手动输入的变量和表达式的值。'
- en: '**CALL STACK**, which shows the stack of function calls.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用堆栈**，显示函数调用堆栈。'
- en: '**BREAKPOINTS**, which shows all your breakpoints and allows finer control
    over them.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点**，显示所有断点并允许对其进行更精细的控制。'
- en: 'When in break mode, there is also a useful window at the bottom of the edit
    area:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在断点模式下，编辑区域底部还有一个有用的窗口：
- en: '**DEBUG CONSOLE** or **Immediate Window** enables live interaction with your
    code. You can interrogate the program state, for example, by entering the name
    of a variable. For example, you can ask a question such as, "What is 1+2?" by
    typing `1+2` and pressing Enter, as shown in *Figure 4.9*:![](img/B17442_04_10.png)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DEBUG CONSOLE**或**即时窗口**使您能够与代码实时交互。您可以查询程序状态，例如，通过输入变量名。例如，您可以通过输入`1+2`并按Enter键来提问“1+2等于多少？”，如图*4.9*所示：![](img/B17442_04_10.png)'
- en: 'Figure 4.9: Interrogating the program state'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：查询程序状态
- en: Stepping through code
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐行执行代码
- en: 'Let''s explore some ways to step through the code using either Visual Studio
    or Visual Studio Code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些使用Visual Studio或Visual Studio Code逐行执行代码的方法：
- en: Navigate to **Run/Debug** | **Step Into**, or click on the **Step Into** button
    in the toolbar, or press F11\. The yellow highlight steps forward one line.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**运行/调试** | **逐语句**，或点击工具栏中的**逐语句**按钮，或按F11。黄色高亮将前进一行。
- en: Navigate to **Run/Debug** | **Step Over**, or click on the **Step Over** button
    in the toolbar, or press F10\. The yellow highlight steps forward one line. At
    the moment, you can see that there is no difference between using **Step Into**
    or **Step Over**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**运行/调试** | **逐过程**，或点击工具栏中的**逐过程**按钮，或按F10。黄色高亮将前进一行。目前，您可以看到使用**逐语句**或**逐过程**没有区别。
- en: You should now be on the line that calls the `Add` method, as shown in *Figure
    4.10*:![](img/B17442_04_11.png)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在应该位于调用`Add`方法的行上，如图*4.10*所示：![](img/B17442_04_11.png)
- en: 'Figure 4.10: Stepping into and over code'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.10：逐语句进入和跳过代码
- en: 'The difference between **Step Into** and **Step Over** can be seen when you
    are about to execute a method call:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**逐语句**与**逐过程**的区别在于即将执行方法调用时：'
- en: If you click on **Step Into**, the debugger steps *into* the method so that
    you can step through every line in that method.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击**逐语句**，调试器将进入方法内部，以便您可以逐行执行该方法。
- en: If you click on **Step Over**, the whole method is executed in one go; it does
    not skip over the method without executing it.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果点击**逐过程**，整个方法将一次性执行；它不会跳过该方法而不执行。
- en: Click on **Step Into** to step inside the method.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**逐语句**以进入方法内部。
- en: Hover your mouse pointer over the `a` or `b` parameters in the code editing
    window and note that a tooltip appears showing their current value.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在代码编辑窗口中的`a`或`b`参数上，注意会出现一个工具提示，显示它们的当前值。
- en: Select the expression `a * b`, right-click the expression, and select **Add
    to Watch** or **Add Watch**. The expression is added to the **WATCH** window,
    showing that this operator is multiplying `a` by `b` to give the result `11.25`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中表达式`a * b`，右键点击表达式，并选择**添加到监视**或**添加监视**。该表达式被添加到**监视**窗口，显示此运算符正在将`a`乘以`b`以得到结果`11.25`。
- en: In the **WATCH** or **Watch 1** window, right-click the expression and choose
    **Remove Expression** or **Delete Watch**.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**监视**或**监视1**窗口中，右键点击表达式并选择**删除表达式**或**删除监视**。
- en: Fix the bug by changing `*` to `+` in the `Add` function.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`Add`函数中将`*`更改为`+`来修复错误。
- en: Stop debugging, recompile, and restart debugging by clicking the circular arrow
    **Restart** button or pressing Ctrl or Cmd + Shift + F5.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止调试，重新编译，并通过点击圆形箭头**重新启动**按钮或按Ctrl或Cmd + Shift + F5重新开始调试。
- en: Step over the function, take a minute to note how it now calculates correctly,
    and click the **Continue** button or press **F5**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过该函数，花一分钟注意它现在如何正确计算，然后点击**继续**按钮或按**F5**。
- en: With Visual Studio Code, note that when writing to the console during debugging,
    the output appears in the **DEBUG CONSOLE** window instead of the **TERMINAL**
    window, as shown in *Figure 4.11*:![](img/B17442_04_13.png)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code时，请注意，在调试期间向控制台写入内容时，输出显示在**DEBUG CONSOLE**窗口中，而不是**TERMINAL**窗口中，如图*4.11*所示：![](img/B17442_04_13.png)
- en: 'Figure 4.11: Writing to the DEBUG CONSOLE during debugging'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.11：调试期间向DEBUG CONSOLE写入内容
- en: Customizing breakpoints
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义断点
- en: 'It is easy to make more complex breakpoints:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建更复杂的断点很容易：
- en: If you are still debugging, click the **Stop** button in the debugging toolbar,
    or navigate to **Run/Debug** | **Stop Debugging**, or press Shift + F5.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 若仍在调试中，点击调试工具栏中的**停止**按钮，或导航至**运行/调试** | **停止调试**，或按Shift + F5。
- en: Navigate to **Run** | **Remove All Breakpoints** or **Debug** | **Delete All
    Breakpoints**.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**运行** | **删除所有断点**或**调试** | **删除所有断点**。
- en: Click on the `WriteLine` statement that outputs the answer.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击输出答案的`WriteLine`语句。
- en: Set a breakpoint by pressing F9 or navigating to **Run/Debug** | **Toggle Breakpoint**.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按F9或导航至**运行/调试** | **切换断点**来设置断点。
- en: In Visual Studio Code, right-click the breakpoint and choose **Edit Breakpoint...**,
    and then enter an expression, such as the `answer` variable must be greater than
    9, and note the expression must evaluate to true for the breakpoint to activate,
    as shown in *Figure 4.12*:![](img/B17442_04_14.png)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，右键点击断点并选择**编辑断点...**，然后输入一个表达式，例如`answer`变量必须大于9，注意表达式必须计算为真才能激活断点，如图*4.12*所示：![](img/B17442_04_14.png)
- en: 'Figure 4.12: Customizing a breakpoint with an expression using Visual Studio
    Code'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.12：使用Visual Studio Code通过表达式自定义断点
- en: In Visual Studio, right-click the breakpoint and choose **Conditions...**, and
    then enter an expression, such as the `answer` variable must be greater than 9,
    and note the expression must evaluate to true for the breakpoint to activate.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，右键点击断点并选择**条件...**，然后输入一个表达式，例如`answer`变量必须大于9，注意表达式必须计算为真才能激活断点。
- en: Start debugging and note the breakpoint is not hit.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试并注意断点未被命中。
- en: Stop debugging.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止调试。
- en: Edit the breakpoint or its conditions and change its expression to less than
    9.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑断点或其条件，并将其表达式更改为小于9。
- en: Start debugging and note the breakpoint is hit.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试并注意断点被命中。
- en: Stop debugging.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止调试。
- en: Edit the breakpoint or its conditions, (in Visual Studio click **Add condition**)
    and select **Hit Count**, then enter a number such as `3`, meaning that you would
    have to hit the breakpoint three times before it activates, as shown in *Figure
    4.13*:![Graphical user interface, text, application  Description automatically
    generated](img/B17442_04_15.png)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑断点或其条件，（在Visual Studio中点击**添加条件**）并选择**命中计数**，然后输入一个数字，如`3`，意味着断点需被命中三次才会激活，如图*4.13*所示：![图形用户界面，文本，应用程序
    自动生成描述](img/B17442_04_15.png)
- en: 'Figure 4.13: Customizing a breakpoint with an expression and hot count using
    Visual Studio 2022'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.13：使用Visual Studio 2022通过表达式和热计数自定义断点
- en: Hover your mouse over the breakpoint's red circle to see a summary, as shown
    in *Figure 4.14*:![Graphical user interface, text, application  Description automatically
    generated](img/B17442_04_16.png)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在断点的红色圆圈上以查看摘要，如图*4.14*所示：![图形用户界面，文本，应用程序 自动生成描述](img/B17442_04_16.png)
- en: 'Figure 4.14: A summary of a customized breakpoint in Visual Studio Code'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.14：Visual Studio Code中自定义断点的摘要
- en: You have now fixed a bug using some debugging tools and seen some advanced possibilities
    for setting breakpoints.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已使用一些调试工具修复了一个错误，并看到了设置断点的一些高级可能性。
- en: Logging during development and runtime
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和运行时日志记录
- en: Once you believe that all the bugs have been removed from your code, you would
    then compile a release version and deploy the application, so that people can
    use it. But no code is ever bug free, and during runtime unexpected errors can
    occur.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您认为代码中的所有错误都已被移除，您将编译发布版本并部署应用程序，以便人们可以使用它。但没有任何代码是完全无错误的，运行时可能会发生意外错误。
- en: End users are notoriously bad at remembering, admitting to, and then accurately
    describing what they were doing when an error occurred, so you should not rely
    on them accurately providing useful information to reproduce the problem to understand
    what caused the problem and then fix it. Instead, you can **instrument your code**,
    which means logging events of interest.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户通常不擅长记忆、承认，然后准确描述他们在错误发生时正在做什么，因此您不应依赖他们准确提供有用信息来重现问题以理解问题原因并进行修复。相反，您可以**检测您的代码**，这意味着记录感兴趣的事件。
- en: '**Good Practice**: Add code throughout your application to log what is happening,
    and especially when exceptions occur, so that you can review the logs and use
    them to trace the issue and fix the problem. Although we will see logging again
    in *Chapter 10*, *Working with Data Using Entity Framework Core*, and in *Chapter
    15*, *Building Websites Using the Model-View-Controller Pattern*, logging is a
    huge topic, so we can only cover the basics in this book.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：在应用程序中添加代码以记录正在发生的事情，特别是在异常发生时，以便您可以审查日志并使用它们来追踪问题并修复问题。虽然我们将在*第10章*，*使用Entity
    Framework Core处理数据*，以及*第15章*，*使用模型-视图-控制器模式构建网站*中再次看到日志记录，但日志记录是一个庞大的主题，因此本书只能涵盖基础知识。'
- en: Understanding logging options
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解日志记录选项
- en: '.NET includes some built-in ways to instrument your code by adding logging
    capabilities. We will cover the basics in this book. But logging is an area where
    third parties have created a rich ecosystem of powerful solutions that extend
    what Microsoft provides. I cannot make specific recommendations because the best
    logging framework depends on your needs. But I include some common ones in the
    following list:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: .NET包含一些内置方法，通过添加日志记录功能来检测您的代码。本书将介绍基础知识。但日志记录是一个领域，第三方已经创建了一个丰富的生态系统，提供了超越微软所提供的强大解决方案。我无法做出具体推荐，因为最佳日志记录框架取决于您的需求。但我在此列出了一些常见选项：
- en: Apache log4net
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache log4net
- en: NLog
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NLog
- en: Serilog
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serilog
- en: Instrumenting with Debug and Trace
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调试和跟踪进行检测
- en: 'There are two types that can be used to add simple logging to your code: `Debug`
    and `Trace`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型可用于向代码添加简单日志记录：`Debug`和`Trace`。
- en: 'Before we delve into them in more detail, let''s look at a quick overview of
    each one:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨它们之前，让我们先快速概览一下每个：
- en: The `Debug` class is used to add logging that gets written only during development.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug`类用于添加仅在开发期间写入的日志记录。'
- en: The `Trace` class is used to add logging that gets written during both development
    and runtime.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trace`类用于添加在开发和运行时都会写入的日志记录。'
- en: You have seen the use of the `Console` type and its `WriteLine` method write
    out to the console window. There is also a pair of types named `Debug` and `Trace`
    that have more flexibility in where they write out to.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您已见过`Console`类型的使用及其`WriteLine`方法向控制台窗口输出的情况。还有一对名为`Debug`和`Trace`的类型，它们在输出位置上更具灵活性。
- en: The `Debug` and `Trace` classes write to any trace listener. A trace listener
    is a type that can be configured to write output anywhere you like when the `WriteLine`
    method is called. There are several trace listeners provided by .NET, including
    one that outputs to the console, and you can even make your own by inheriting
    from the `TraceListener` type.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug`和`Trace`类向任何跟踪监听器写入。跟踪监听器是一种类型，可以配置为在调用`WriteLine`方法时将输出写入您喜欢的任何位置。.NET提供了几种跟踪监听器，包括一个输出到控制台的监听器，您甚至可以通过继承`TraceListener`类型来创建自己的监听器。'
- en: Writing to the default trace listener
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入默认跟踪监听器
- en: One trace listener, the `DefaultTraceListener` class, is configured automatically
    and writes to Visual Studio Code's **DEBUG CONSOLE** window or Visual Studio's
    **Debug** window. You can configure other trace listeners using code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个跟踪监听器，即`DefaultTraceListener`类，是自动配置的，并写入Visual Studio Code的**DEBUG CONSOLE**窗口或Visual
    Studio的**Debug**窗口。您可以通过代码配置其他跟踪监听器。
- en: 'Let''s see trace listeners in action:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看跟踪监听器的作用：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter04`
    workspace/solution named `Instrumenting`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的编码工具，在`Chapter04`工作区/解决方案中添加一个名为`Instrumenting`的新**控制台应用程序**。
- en: In Visual Studio Code, select `Instrumenting` as the active OmniSharp project.
    When you see the pop-up warning message saying that required assets are missing,
    click **Yes** to add them.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Instrumenting`作为活动OmniSharp项目。当您看到弹出警告消息提示所需资产缺失时，点击**是**以添加它们。
- en: In `Program.cs`, import the `System.Diagnostics` namespace.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入`System.Diagnostics`命名空间。
- en: 'Write a message from the `Debug` and `Trace` classes, as shown in the following
    code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码所示，从`Debug`和`Trace`类中写入一条消息：
- en: '[PRE29]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In Visual Studio, navigate to **View** | **Output** and make sure **Show output
    from:** **Debug** is selected.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航至**视图** | **输出**，并确保**显示输出自：** **调试**被选中。
- en: Start debugging the `Instrumenting` console application, and note that **DEBUG
    CONSOLE** in Visual Studio Code or the **Output** window in Visual Studio 2022
    shows the two messages, mixed with other debugging information, such as loaded
    assembly DLLs, as shown in *Figures 4.15* and *4.16*:![Graphical user interface,
    text, website  Description automatically generated](img/B17442_04_17.png)
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试`Instrumenting`控制台应用程序，并注意Visual Studio Code中的**DEBUG CONSOLE**或Visual Studio
    2022中的**Output**窗口显示了这两条消息，以及其他调试信息，如加载的程序集DLL，如*图4.15*和*4.16*所示：![图形用户界面，文本，网站
    描述自动生成](img/B17442_04_17.png)
- en: 'Figure 4.15: Visual Studio Code DEBUG CONSOLE shows the two messages in blue'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图4.15*：Visual Studio Code DEBUG CONSOLE以蓝色显示两条消息'
- en: '![](img/B17442_04_18.png)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17442_04_18.png)'
- en: 'Figure 4.16: Visual Studio 2022 Output window shows Debug output including
    the two messages'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图4.16*：Visual Studio 2022 Output窗口显示包括两条消息在内的调试输出'
- en: Configuring trace listeners
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置跟踪监听器
- en: 'Now, we will configure another trace listener that will write to a text file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将配置另一个将写入文本文件的跟踪监听器：
- en: 'Before the `Debug` and `Trace` calls to `WriteLine`, add a statement to create
    a new text file on the desktop and pass it into a new trace listener that knows
    how to write to a text file, and enable automatic flushing for its buffer, as
    shown highlighted in the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Debug`和`Trace`的`WriteLine`调用之前，添加一个语句以在桌面上创建一个新的文本文件，并将其传递给一个新的跟踪监听器，该监听器知道如何写入文本文件，并为缓冲区启用自动刷新，如下面的代码中突出显示的那样：
- en: '[PRE30]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Good Practice**: Any type that represents a file usually implements a buffer
    to improve performance. Instead of writing immediately to the file, data is written
    to an in-memory buffer and only once the buffer is full will it be written in
    one chunk to the file. This behavior can be confusing while debugging because
    we do not immediately see the results! Enabling `AutoFlush` means it calls the
    `Flush` method automatically after every write.'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：任何表示文件的类型通常都会实现一个缓冲区以提高性能。数据不是立即写入文件，而是写入内存缓冲区，只有当缓冲区满时，数据才会一次性写入文件。这种行为在调试时可能会令人困惑，因为我们不会立即看到结果！启用`AutoFlush`意味着在每次写入后自动调用`Flush`方法。'
- en: 'In Visual Studio Code, run the release configuration of the console app by
    entering the following command in the **TERMINAL** window for the `Instrumenting`
    project and note that nothing will appear to have happened:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，通过在`Instrumenting`项目的**TERMINAL**窗口中输入以下命令来运行控制台应用的发布配置，并注意到似乎没有任何事情发生：
- en: '[PRE31]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In Visual Studio 2022, in the standard toolbar, select **Release** in the **Solution
    Configurations** dropdown list, as shown in *Figure 4.17*:![](img/B17442_04_19.png)
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，在标准工具栏上，从**解决方案配置**下拉列表中选择**Release**，如图*4.17*所示：![](img/B17442_04_19.png)
- en: 'Figure 4.17: Selecting the Release configuration in Visual Studio'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.17：在Visual Studio中选择Release配置
- en: In Visual Studio 2022, run the release configuration of the console app by navigating
    to **Debug** | **Start Without Debugging**.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，通过导航到**Debug** | **开始不调试**来运行控制台应用的发布配置。
- en: On your desktop, open the file named `log.txt` and note that it contains the
    message `Trace says, I am watching!`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的桌面上，打开名为`log.txt`的文件，并注意到它包含消息`Trace says, I am watching!`。
- en: 'In Visual Studio Code, run the debug configuration of the console app by entering
    the following command in the **TERMINAL** window for the `Instrumenting` project:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，通过在`Instrumenting`项目的**TERMINAL**窗口中输入以下命令来运行控制台应用的调试配置：
- en: '[PRE32]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In Visual Studio, in the standard toolbar, select **Debug** in the **Solution
    Configurations** dropdown list and then run the console app by navigating to **Debug**
    | **Start Debugging**.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，在标准工具栏上，从**解决方案配置**下拉列表中选择**Debug**，然后通过导航到**Debug** | **开始调试**来运行控制台应用。
- en: On your desktop, open the file named `log.txt` and note that it contains both
    the message, `Debug says, I am watching!` and `Trace says, I am watching!`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的桌面上，打开名为`log.txt`的文件，并注意到它包含了消息`Debug says, I am watching!`和`Trace says,
    I am watching!`。
- en: '**Good Practice**: When running with the `Debug` configuration, both `Debug`
    and `Trace` are active and will write to any trace listeners. When running with
    the `Release` configuration, only `Trace` will write to any trace listeners. You
    can therefore use `Debug.WriteLine` calls liberally throughout your code, knowing
    they will be stripped out automatically when you build the release version of
    your application and will therefore not affect performance.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当使用`Debug`配置运行时，`Debug`和`Trace`均处于激活状态，并将写入任何跟踪监听器。当使用`Release`配置运行时，只有`Trace`会写入任何跟踪监听器。因此，您可以在代码中自由使用`Debug.WriteLine`调用，知道在构建应用程序的发布版本时它们会自动被移除，从而不会影响性能。'
- en: Switching trace levels
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换跟踪级别
- en: The `Trace.WriteLine` calls are left in your code even after release. So, it
    would be great to have fine control over when they are output. This is something
    we can do with a **trace switch**.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trace.WriteLine`调用即使在发布后仍保留在代码中。因此，能够精细控制它们的输出时机将非常有益。这可以通过**跟踪开关**实现。'
- en: 'The value of a trace switch can be set using a number or a word. For example,
    the number `3` can be replaced with the word `Info`, as shown in the following
    table:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪开关的值可以使用数字或单词设置。例如，数字`3`可以替换为单词`Info`，如下表所示：
- en: '| Number | Word | Description |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 编号 | 单词 | 描述 |'
- en: '| 0 | Off | This will output nothing. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Off | 这将不输出任何内容。 |'
- en: '| 1 | Error | This will output only errors. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Error | 这将仅输出错误。 |'
- en: '| 2 | Warning | This will output errors and warnings. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Warning | 这将输出错误和警告。 |'
- en: '| 3 | Info | This will output errors, warnings, and information. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 信息 | 这将输出错误、警告和信息。 |'
- en: '| 4 | Verbose | This will output all levels. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 详细 | 这将输出所有级别。 |'
- en: Let's explore using trace switches. First, we will add some NuGet packages to
    our project to enable loading configuration settings from a JSON `appsettings`
    file.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用跟踪开关。首先，我们将向项目添加一些NuGet包，以启用从JSON `appsettings`文件加载配置设置。
- en: Adding packages to a project in Visual Studio Code
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中向项目添加包
- en: 'Visual Studio Code does not have a mechanism to add NuGet packages to a project,
    so we will use the command-line tool:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code没有向项目添加NuGet包的机制，因此我们将使用命令行工具：
- en: Navigate to the **TERMINAL** window for the `Instrumenting` project.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Instrumenting`项目的**终端**窗口。
- en: 'Enter the following command:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE33]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Enter the following command:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE34]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Enter the following command:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE35]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Enter the following command:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE36]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`dotnet add package` adds a reference to a NuGet package to your project file.
    It will be downloaded during the build process. `dotnet add reference` adds a
    project-to-project reference to your project file. The referenced project will
    be compiled if needed during the build process.'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`dotnet add package`向项目文件添加对NuGet包的引用。它将在构建过程中下载。`dotnet add reference`向项目文件添加项目到项目的引用。如果需要，将在构建过程中编译引用的项目。'
- en: Adding packages to a project in Visual Studio 2022
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中向项目添加包
- en: Visual Studio has a graphical user interface for adding packages.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio具有添加包的图形用户界面。
- en: In **Solution Explorer**, right-click the **Instrumenting** project and select
    **Manage NuGet Packages**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，右键单击**Instrumenting**项目并选择**管理NuGet包**。
- en: Select the **Browse** tab.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**浏览**选项卡。
- en: In the search box, enter `Microsoft.Extensions.Configuration`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中，输入`Microsoft.Extensions.Configuration`。
- en: 'Select each of these NuGet packages and click the **Install** button, as shown
    in *Figure 4.18*:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这些NuGet包中的每一个，然后点击**安装**按钮，如图*4.18*所示：
- en: '`Microsoft.Extensions.Configuration`'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration`'
- en: '`Microsoft.Extensions.Configuration.Binder`'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.Binder`'
- en: '`Microsoft.Extensions.Configuration.Json`'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.Json`'
- en: '`Microsoft.Extensions.Configuration.FileExtensions`![Graphical user interface,
    text, application  Description automatically generated](img/B17442_04_20.png)'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Configuration.FileExtensions`![图形用户界面，文本，应用程序 描述自动生成](img/B17442_04_20.png)'
- en: 'Figure 4.18: Installing NuGet packages using Visual Studio 2022'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.18：使用Visual Studio 2022安装NuGet包
- en: '**Good Practice**: There are also packages for loading configuration from XML
    files, INI files, environment variables, and the command line. Use the most appropriate
    technique for setting configuration in your projects.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：还有用于从XML文件、INI文件、环境变量和命令行加载配置的包。为项目设置配置选择最合适的技术。'
- en: Reviewing project packages
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审查项目包
- en: 'After adding the NuGet packages, we can see the references in the project file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 添加NuGet包后，我们可以在项目文件中看到引用：
- en: 'Open `Instrumenting.csproj` (double-click the **Instrumenting** project in
    Visual Studio''s **Solution Explorer**) and note the `<ItemGroup>` section with
    the added NuGet packages, as shown highlighted in the following markup:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Instrumenting.csproj`（在Visual Studio的**解决方案资源管理器**中双击**Instrumenting**项目），并注意添加了NuGet包的`<ItemGroup>`部分，如下所示高亮显示：
- en: '[PRE37]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add a file named `appsettings.json` to the `Instrumenting` project folder.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Instrumenting`项目文件夹添加一个名为`appsettings.json`的文件。
- en: 'Modify `appsettings.json` to define a setting named `PacktSwitch` with a `Level`
    value, as shown in the following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`appsettings.json`以定义一个名为`PacktSwitch`的设置，其`Level`值如下所示：
- en: '[PRE38]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In Visual Studio 2022, in **Solution Explorer**, right-click `appsettings.json`,
    select **Properties**, and then in the **Properties** window, change **Copy to
    Output Directory** to **Copy if newer**. This is necessary because unlike Visual
    Studio Code, which runs the console app in the project folder, Visual Studio runs
    the console app in `Instrumenting\bin\Debug\net6.0` or `Instrumenting\bin\Release\net6.0`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，在**解决方案资源管理器**中右键单击`appsettings.json`，选择**属性**，然后在**属性**窗口中，将**复制到输出目录**更改为**如果较新则复制**。这是必要的，因为与在项目文件夹中运行控制台应用程序的Visual
    Studio Code不同，Visual Studio在`Instrumenting\bin\Debug\net6.0`或`Instrumenting\bin\Release\net6.0`中运行控制台应用程序。
- en: At the top of `Program.cs`, import the `Microsoft.Extensions.Configuration`
    namespace.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，导入`Microsoft.Extensions.Configuration`命名空间。
- en: 'Add some statements to the end of `Program.cs` to create a configuration builder
    that looks in the current folder for a file named `appsettings.json`, build the
    configuration, create a trace switch, set its level by binding to the configuration,
    and then output the four trace switch levels, as shown in the following code:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`末尾添加一些语句，以创建一个配置构建器，该构建器会在当前文件夹中查找名为`appsettings.json`的文件，构建配置，创建跟踪开关，通过绑定到配置来设置其级别，然后输出四个跟踪开关级别，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Set a breakpoint on the `Bind` statement.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Bind`语句上设置断点。
- en: Start debugging the `Instrumenting` console app.In the **VARIABLES** or **Locals**
    window, expand the `ts` variable expression, and note that its `Level` is `Off`
    and its `TraceError`, `TraceWarning`, and so on are all `false`, as shown in *Figure
    4.19*:![Graphical user interface, text, application  Description automatically
    generated](img/B17442_04_21.png)
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试`Instrumenting`控制台应用。在**变量**或**局部变量**窗口中，展开`ts`变量表达式，并注意其`级别`为`Off`，其`TraceError`、`TraceWarning`等均为`false`，如图
    *4.19* 所示：![图形用户界面，文本，应用程序 自动生成的描述](img/B17442_04_21.png)
- en: 'Figure 4.19: Watching the trace switch variable properties in Visual Studio
    2022'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.19：在 Visual Studio 2022 中观察跟踪开关变量属性
- en: Step into the call to the `Bind` method by clicking the **Step Into** or **Step
    Over** buttons or pressing F11 or F10, and note the `ts` variable watch expression
    updates to the `Info` level.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**步入**或**步过**按钮，或按 F11 或 F10，步入对`Bind`方法的调用，并注意`ts`变量监视表达式更新至`Info`级别。
- en: Step into or over the four calls to `Trace.WriteLineIf` and note that all levels
    up to `Info` are written to the **DEBUG CONSOLE** or **Output - Debug** window,
    but not `Verbose`, as shown in *Figure 4.20*:![Graphical user interface, text,
    application  Description automatically generated](img/B17442_04_22.png)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步入或步过对`Trace.WriteLineIf`的四次调用，并注意所有级别直至`Info`都被写入到**DEBUG CONSOLE**或**输出 -
    调试**窗口，但不包括`Verbose`，如图 *4.20* 所示：![图形用户界面，文本，应用程序 自动生成的描述](img/B17442_04_22.png)
- en: 'Figure 4.20: Different trace levels shown in the DEBUG CONSOLE in Visual Studio
    Code'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.20：在 Visual Studio Code 的 DEBUG CONSOLE 中显示的不同跟踪级别
- en: Stop debugging.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止调试。
- en: 'Modify `appsettings.json` to set a level of `2`, which means warning, as shown
    in the following JSON file:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`appsettings.json`，将其级别设置为`2`，即警告，如下面的 JSON 文件所示：
- en: '[PRE40]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Save the changes.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改。
- en: 'In Visual Studio Code, run the console application by entering the following
    command in the **TERMINAL** window for the `Instrumenting` project:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，通过在`Instrumenting`项目的**TERMINAL**窗口中输入以下命令来运行控制台应用程序：
- en: '[PRE41]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In Visual Studio, in the standard toolbar, select **Release** in the **Solution
    Configurations** dropdown list and then run the console app by navigating to **Debug**
    | **Start Without Debugging**.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 的标准工具栏中，从**解决方案配置**下拉列表中选择**发布**，然后通过导航到**调试** | **启动而不调试**来运行控制台应用。
- en: 'Open the file named `log.txt` and note that this time, only trace error and
    warning levels are the output of the four potential trace levels, as shown in
    the following text file:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开名为`log.txt`的文件，并注意这次只有跟踪错误和警告级别是四个潜在跟踪级别的输出，如下面的文本文件所示：
- en: '[PRE42]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If no argument is passed, the default trace switch level is `Off` (0), so none
    of the switch levels are output.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递参数，默认的跟踪开关级别为`Off`（0），因此不会输出任何开关级别。
- en: Unit testing
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Fixing bugs in code is expensive. The earlier that a bug is discovered in the
    development process, the less expensive it will be to fix.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 修复代码中的 bug 成本高昂。在开发过程中越早发现 bug，修复它的成本就越低。
- en: Unit testing is a good way to find bugs early in the development process. Some
    developers even follow the principle that programmers should create unit tests
    before they write code, and this is called **Test-Driven Development** (**TDD**).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是早期开发过程中发现 bug 的好方法。一些开发者甚至遵循程序员应在编写代码之前创建单元测试的原则，这称为**测试驱动开发**（**TDD**）。
- en: Microsoft has a proprietary unit testing framework known as **MS Test**. There
    is also a framework named **NUnit**. However, we will use the free and open-source
    third-party framework **xUnit.net**. xUnit was created by the same team that built
    NUnit but they fixed the mistakes they felt they made previously. xUnit is more
    extensible and has better community support.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 微软有一个专有的单元测试框架，称为**MS Test**。还有一个名为**NUnit**的框架。然而，我们将使用免费且开源的第三方框架**xUnit.net**。xUnit
    是由构建 NUnit 的同一团队创建的，但他们修正了之前感觉错误的方面。xUnit 更具扩展性，并拥有更好的社区支持。
- en: Understanding types of testing
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解测试类型
- en: 'Unit testing is just one of many types of testing, as described in the following
    table:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试只是众多测试类型中的一种，如下表所述：
- en: '| Type of testing | Description |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 测试类型 | 描述 |'
- en: '| Unit | Tests the smallest unit of code, typically a method or function. Unit
    testing is performed on a unit of code isolated from its dependencies by mocking
    them if needed. Each unit should have multiple tests: some with typical inputs
    and expected outputs, some with extreme input values to test boundaries, and some
    with deliberately wrong inputs to test exception handling. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 单元 | 测试代码的最小单元，通常是一个方法或函数。单元测试是通过模拟其依赖项（如果需要）来隔离代码单元进行的。每个单元应该有多个测试：一些使用典型输入和预期输出，一些使用极端输入值来测试边界，还有一些使用故意错误的输入来测试异常处理。
    |'
- en: '| Integration | Tests if the smaller units and larger components work together
    as a single piece of software. Sometimes involves integrating with external components
    that you do not have source code for. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 集成 | 测试较小的单元和较大的组件是否能作为一个软件整体协同工作。有时涉及与没有源代码的外部组件的集成。 |'
- en: '| System | Tests the whole system environment in which your software will run.
    |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | 测试你的软件将运行的整个系统环境。 |'
- en: '| Performance | Tests the performance of your software; for example, your code
    must return a web page full of data to a visitor in under 20 milliseconds. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 测试你的软件性能；例如，你的代码必须在20毫秒内向访问者返回一个充满数据的网页。 |'
- en: '| Load | Tests how many requests your software can handle simultaneously while
    maintaining required performance, for example, 10,000 concurrent visitors to a
    website. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 负载 | 测试你的软件在保持所需性能的同时可以处理多少请求，例如，一个网站可以同时容纳10,000名访问者。 |'
- en: '| User Acceptance | Tests if users can happily complete their work using your
    software. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 用户接受度 | 测试用户是否能愉快地使用你的软件完成他们的工作。 |'
- en: Creating a class library that needs testing
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个需要测试的类库
- en: 'First, we will create a function that needs testing. We will create it in a
    class library project. A class library is a package of code that can be distributed
    and referenced by other .NET applications:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个需要测试的函数。我们将在类库项目中创建它。类库是一个可以被其他.NET应用程序分发和引用的代码包：
- en: Use your preferred coding tool to add a new **Class Library** to the `Chapter04`
    workspace/solution named `CalculatorLib`. The `dotnet new` template is named `classlib`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的编码工具，在`Chapter04`工作区/解决方案中添加一个新的**类库**，命名为`CalculatorLib`。`dotnet new`模板名为`classlib`。
- en: Rename the file named `Class1.cs` to `Calculator.cs`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件名为`Class1.cs`重命名为`Calculator.cs`。
- en: 'Modify the file to define a `Calculator` class (with a deliberate bug!), as
    shown in the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件以定义一个`Calculator`类（故意包含一个错误！），如下所示的代码：
- en: '[PRE43]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Compile your class library project:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的类库项目：
- en: In Visual Studio 2022, navigate to **Build** | **Build CalculatorLib**.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，导航到**构建** | **构建CalculatorLib**。
- en: In Visual Studio Code, in **TERMINAL**, enter the command `dotnet build`.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在**终端**中输入命令`dotnet build`。
- en: Use your preferred coding tool to add a new **xUnit Test Project [C#]** to the
    `Chapter04` workspace/solution named `CalculatorLibUnitTests`. The `dotnet new`
    template is named `xunit`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的编码工具，在`Chapter04`工作区/解决方案中添加一个新的**xUnit测试项目[C#]**，命名为`CalculatorLibUnitTests`。`dotnet
    new`模板名为`xunit`。
- en: If you are using Visual Studio, in **Solution Explorer**, select the `CalculatorLibUnitTests`
    project, navigate to **Project** | **Add Project Reference…**, check the box to
    select the `CalculatorLib` project, and then click **OK**.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是Visual Studio，在**解决方案资源管理器**中，选择`CalculatorLibUnitTests`项目，导航到**项目**
    | **添加项目引用…**，勾选框选择`CalculatorLib`项目，然后点击**确定**。
- en: 'If you are using Visual Studio Code, use the `dotnet add reference` command
    or click on the file named `CalculatorLibUnitTests.csproj`, and modify the configuration
    to add an item group with a project reference to the `CalculatorLib` project,
    as shown highlighted in the following markup:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是Visual Studio Code，使用`dotnet add reference`命令或点击名为`CalculatorLibUnitTests.csproj`的文件，并修改配置以添加一个项目参考到`CalculatorLib`项目，如下所示的高亮标记：
- en: '[PRE44]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Build the `CalculatorLibUnitTests` project.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`CalculatorLibUnitTests`项目。
- en: Writing unit tests
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'A well-written unit test will have three parts:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一个编写良好的单元测试将包含三个部分：
- en: '**Arrange**: This part will declare and instantiate variables for input and
    output.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**: 这一部分将声明并实例化输入和输出的变量。'
- en: '**Act**: This part will execute the unit that you are testing. In our case,
    that means calling the method that we want to test.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**: 这一部分将执行你正在测试的单元。在我们的例子中，这意味着调用我们想要测试的方法。'
- en: '**Assert**: This part will make one or more assertions about the output. An
    assertion is a belief that, if not true, indicates a failed test. For example,
    when adding 2 and 2, we would expect the result to be 4.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：这一部分将做出一个或多个关于输出的断言。断言是一种信念，如果它不成立，则表明测试失败。例如，当加2和2时，我们期望结果是4。'
- en: 'Now, we will write some unit tests for the `Calculator` class:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为`Calculator`类编写一些单元测试：
- en: Rename the file `UnitTest1.cs` to `CalculatorUnitTests.cs` and then open it.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件`UnitTest1.cs`重命名为`CalculatorUnitTests.cs`，然后打开它。
- en: In Visual Studio Code, rename the class to `CalculatorUnitTests`. (Visual Studio
    prompts you to rename the class when you rename the file.)
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将类重命名为`CalculatorUnitTests`。（当你重命名文件时，Visual Studio会提示你重命名类。）
- en: Import the `Packt` namespace.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Packt`命名空间。
- en: 'Modify the `CalculatorUnitTests` class to have two test methods for adding
    2 and 2, and adding 2 and 3, as shown in the following code:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`CalculatorUnitTests`类，使其有两个测试方法，分别用于加2和2，以及加2和3，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Running unit tests using Visual Studio Code
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code运行单元测试
- en: 'Now we are ready to run the unit tests and see the results:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好运行单元测试并查看结果：
- en: 'In the `CalculatorLibUnitTest` project''s **TERMINAL** window, run the tests,
    as shown in the following command:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CalculatorLibUnitTest`项目的**终端**窗口中运行测试，如下面的命令所示：
- en: '[PRE46]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that the results indicate that two tests ran, one test passed, and one
    test failed, as shown in *Figure 4.21*:![](img/B17442_04_23.png)
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意结果显示两个测试运行，一个测试通过，一个测试失败，如图*4.21*所示：![](img/B17442_04_23.png)
- en: 'Figure 4.21: The unit test results in Visual Studio Code''s TERMINAL'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图4.21*：Visual Studio Code的终端中的单元测试结果'
- en: Running unit tests using Visual Studio
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Visual Studio运行单元测试
- en: 'Now we are ready to run the unit tests and see the results:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好运行单元测试并查看结果：
- en: Navigate to **Test** | **Run All Tests**.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**测试** | **运行所有测试**。
- en: In **Test Explorer**, note that the results indicate that two tests ran, one
    test passed, and one test failed, as shown in *Figure 4.22*:![Graphical user interface,
    text, application, email  Description automatically generated](img/B17442_04_24.png)
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**测试资源管理器**中，注意结果显示两个测试运行，一个测试通过，一个测试失败，如图*4.22*所示：![图形用户界面，文本，应用程序，电子邮件 描述自动生成](img/B17442_04_24.png)
- en: 'Figure 4.22: The unit test results in Visual Studio 2022''s Test Explorer'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.22*：Visual Studio 2022的测试资源管理器中的单元测试结果'
- en: Fix the bug
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复错误
- en: 'Now you can fix the bug:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以修复错误：
- en: Fix the bug in the `Add` method.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复`Add`方法中的错误。
- en: Run the unit tests again to see that the bug has now been fixed and both tests
    pass.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行单元测试，看看错误现在是否已被修复，两个测试都通过。
- en: Throwing and catching exceptions in functions
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数中抛出和捕获异常
- en: In *Chapter 3*, *Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to exceptions and how to use a `try-catch` statement to handle
    them. But you should only catch and handle an exception if you have enough information
    to mitigate the issue. If you do not, then you should allow the exception to pass
    up through the call stack to a higher level.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*控制流程、转换类型和处理异常*中，你被介绍了异常以及如何使用`try-catch`语句来处理它们。但你应该只在有足够信息来缓解问题时才捕获和处理异常。如果没有，那么你应该允许异常通过调用堆栈传递到更高级别。
- en: Understanding usage errors and execution errors
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解使用错误和执行错误
- en: '**Usage errors** are when a programmer misuses a function, typically by passing
    invalid values as parameters. They could be avoided by that programmer changing
    their code to pass valid values. When some programmers first learn C# and .NET,
    they sometimes think exceptions can always be avoided because they assume all
    errors are usage errors. Usage errors should all be fixed before production runtime.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用错误**是指程序员错误地使用了一个函数，通常是通过传递无效的参数值。这些错误可以通过程序员修改代码以传递有效值来避免。一些初学C#和.NET的程序员有时认为异常总是可以避免的，因为他们假设所有错误都是使用错误。使用错误应在生产运行时之前全部修复。'
- en: '**Execution errors** are when something happens at runtime that cannot be fixed
    by writing "better" code. Execution errors can be split into **program errors**
    and **system errors**. If you attempt to access a network resource but the network
    is down, you need to be able to handle that system error by logging an exception,
    and possibly backing off for a time and trying again. But some system errors,
    such as running out of memory, simply cannot be handled. If you attempt to open
    a file that does not exist, you might be able to catch that error and handle it
    programmatically by creating a new file. Program errors can be programmatically
    fixed by writing smart code. System errors often cannot be fixed programmatically.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行错误**是指在运行时发生的事情，无法通过编写“更好”的代码来修复。执行错误可分为**程序错误**和**系统错误**。如果您尝试访问网络资源但网络已关闭，您需要能够通过记录异常来处理该系统错误，并可能暂时退避并尝试再次访问。但某些系统错误，如内存耗尽，根本无法处理。如果您尝试打开一个不存在的文件，您可能能够捕获该错误并通过编程方式处理它，即创建一个新文件。程序错误可以通过编写智能代码来编程修复。系统错误通常无法通过编程方式修复。'
- en: Commonly thrown exceptions in functions
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数中常见的抛出异常
- en: Very rarely should you define new types of exceptions to indicate usage errors.
    .NET already defines many that you should use.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 您很少应该定义新的异常类型来指示使用错误。.NET 已经定义了许多您应该使用的异常。
- en: When defining your own functions with parameters, your code should check the
    parameter values and throw exceptions if they have values that will prevent your
    function from properly functioning.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义带有参数的自己的函数时，您的代码应检查参数值，并在它们具有阻止您的函数正常工作的值时抛出异常。
- en: 'For example, if a parameter should not be `null`, throw `ArgumentNullException`.
    For other problems, throw `ArgumentException`, `NotSupportedException`, or `InvalidOperationException`.
    For any exception, include a message that describes the problem for whoever will
    have to read it (typically a developer audience for class libraries and functions,
    or end users if it is at the highest level of a GUI app), as shown in the following
    code:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个参数不应为 `null`，则抛出 `ArgumentNullException`。对于其他问题，抛出 `ArgumentException`、`NotSupportedException`
    或 `InvalidOperationException`。对于任何异常，都应包含一条消息，描述问题所在，以便需要阅读它的人（通常是类库和函数的开发者受众，或如果是
    GUI 应用的最高级别，则为最终用户），如下列代码所示：
- en: '[PRE47]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Good Practice**: If a function cannot successfully perform its operation,
    you should consider that a function failure and report it by throwing an exception.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：如果一个函数无法成功执行其操作，应将其视为函数失败，并通过抛出异常来报告。'
- en: You should never need to write a `try-catch` statement to catch these usage
    type errors. You want the application to terminate. These exceptions should cause
    the programmer who is calling the function to fix their code to prevent the problem.
    They should be fixed before production deployment. That does not mean that your
    code does not need to throw usage error type exceptions. You should—to force other
    programmers to call your functions correctly!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不需要编写 `try-catch` 语句来捕获这些使用类型的错误。您希望应用程序终止。这些异常应促使调用函数的程序员修复其代码以防止问题。它们应在生产部署之前修复。这并不意味着您的代码不需要抛出使用错误类型的异常。您应该这样做——以强制其他程序员正确调用您的函数！
- en: Understanding the call stack
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解调用栈
- en: The entry point for a .NET console application is the `Main` method of the `Program`
    class, regardless of if you have explicitly defined this class and method or if
    it was created for you by the top-level program feature.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 控制台应用程序的入口点是 `Program` 类的 `Main` 方法，无论您是否明确定义了这个类和方法，或者它是否由顶级程序功能为您创建。
- en: 'The `Main` method will call other methods, that call other methods, and so
    on, and these methods could be in the current project or in referenced projects
    and NuGet packages, as shown in *Figure 4.23*:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法会调用其他方法，这些方法又会调用其他方法，依此类推，这些方法可能位于当前项目或引用的项目和 NuGet 包中，如*图 4.23*所示：'
- en: '![](img/B17442_04_25.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17442_04_25.png)'
- en: 'Figure 4.23: A chain of method calls that create a call stack'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.23*：创建调用栈的方法调用链'
- en: 'Let''s create a similar chain of methods to explore where we could catch and
    handle exceptions:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类似的方法链，以探索我们可以在哪里捕获和处理异常：
- en: Use your preferred coding tool to add a new **Class Library** to the `Chapter04`
    workspace/solution named `CallStackExceptionHandlingLib`.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的编程工具，在 `Chapter04` 工作区/解决方案中添加一个名为 `CallStackExceptionHandlingLib` 的**类库**。
- en: Rename the `Class1.cs` file to `Calculator.cs`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Class1.cs` 文件重命名为 `Calculator.cs`。
- en: 'Open `Calculator.cs` and modify its contents, as shown in the following code:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Calculator.cs`并修改其内容，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter04`
    workspace/solution named `CallStackExceptionHandling`.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编码工具，在`Chapter04`工作区/解决方案中添加一个名为`CallStackExceptionHandling`的新**控制台应用程序**。
- en: In Visual Studio Code, select `CallStackExceptionHandling` as the active OmniSharp
    project. When you see the pop-up warning message saying that required assets are
    missing, click **Yes** to add them.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`CallStackExceptionHandling`作为活动OmniSharp项目。当看到弹出警告消息提示缺少必需资产时，点击**是**以添加它们。
- en: In the `CallStackExceptionHandling` project, add a reference to the `CallStackExceptionHandlingLib`
    project.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CallStackExceptionHandling`项目中，添加对`CallStackExceptionHandlingLib`项目的引用。
- en: 'In `Program.cs`, add statements to define two methods and chain calls to them,
    and the methods in the class library, as shown in the following code:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以定义两个方法并链接调用它们，以及类库中的方法，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the console app, and note the results, as shown in the following partial
    output:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意结果，如下面的部分输出所示：
- en: '[PRE50]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note the following:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下几点：
- en: 'The call stack is upside-down. Starting from the bottom, you see:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用堆栈是颠倒的。从底部开始，你会看到：
- en: The first call is to the `Main` entry point function in the auto-generated `Program`
    class. This is where arguments are passed in as a `string` array.
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次调用是调用自动生成的`Program`类中的`Main`入口点函数。这是将参数作为`string`数组传递的地方。
- en: The second call is to the `Alpha` function.
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次调用是调用`Alpha`函数。
- en: The third call is to the `Beta` function.
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次调用是调用`Beta`函数。
- en: The fourth call is to the `Gamma` function.
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四次调用是调用`Gamma`函数。
- en: The fifth call is to the `Delta` function. This function attempts to open a
    file by passing a bad file path. This causes an exception to be thrown. Any function
    with a `try-catch` statement could catch this exception. If they do not, it is
    automatically passed up the call stack until it reaches the top, where .NET outputs
    the exception (and the details of this call stack).
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五次调用是调用`Delta`函数。该函数试图通过传递错误的文件路径来打开文件。这会导致抛出异常。任何具有`try-catch`语句的函数都可以捕获此异常。如果它们没有捕获，异常会自动向上传递到调用堆栈的顶部，在那里.NET输出异常（以及此调用堆栈的详细信息）。
- en: Where to catch exceptions
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在哪里捕获异常
- en: Programmers can decide if they want to catch an exception near the failure point,
    or centralized higher up the call stack. This allows your code to be simplified
    and standardized. You might know that calling an exception could throw one or
    more types of exception, but you do not need to handle any of them at the current
    point in the call stack.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以选择在故障点附近捕获异常，或者在调用堆栈的更高层集中处理。这使得代码更简化、标准化。你可能知道调用异常可能会抛出一种或多种类型的异常，但在当前调用堆栈点无需处理任何异常。
- en: Rethrowing exceptions
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新抛出异常
- en: 'Sometimes you want to catch an exception, log it, and then rethrow it. There
    are three ways to rethrow an exception inside a `catch` block, as shown in the
    following list:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想要捕获异常，记录它，然后重新抛出它。在`catch`块内重新抛出异常有三种方法，如下表所示：
- en: To throw the caught exception with its original call stack, call `throw`.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用其原始调用堆栈抛出捕获的异常，请调用`throw`。
- en: To throw the caught exception as if it was thrown at the current level in the
    call stack, call `throw` with the caught exception, for example, `throw ex`. This
    is usually poor practice because you have lost some potentially useful information
    for debugging.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将捕获的异常抛出，就像它在当前调用堆栈级别抛出一样，调用`throw`并传入捕获的异常，例如`throw ex`。这通常是不良实践，因为你丢失了一些可能对调试有用的信息。
- en: To wrap the caught exception in another exception that can include more information
    in a message that might help the caller understand the problem, throw a new exception
    and pass the caught exception as the `innerException` parameter.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将捕获的异常包装在另一个异常中，该异常可以在消息中包含更多信息，这可能有助于调用者理解问题，抛出一个新异常，并将捕获的异常作为`innerException`参数传递。
- en: 'If an error could occur when we call the `Gamma` function then we could catch
    the exception and then perform one of the three techniques of rethrowing an exception,
    as shown in the following code:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用`Gamma`函数时可能发生错误，那么我们可以捕获异常，然后执行三种重新抛出异常技术中的一种，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s see this in action with our call stack example:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用堆栈示例来看看这一操作：
- en: 'In the `CallStackExceptionHandling` project, in `Program.cs`, in the `Beta`
    function, add a `try-catch` statement around the call to the `Gamma` function,
    as shown highlighted in the following code:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CallStackExceptionHandling`项目中，在`Program.cs`文件的`Beta`函数中，围绕对`Gamma`函数的调用添加一个`try-catch`语句，如下所示：
- en: '[PRE52]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note the green squiggle under the `ex` to warn you that you will lose call stack
    information.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意`ex`下面的绿色波浪线，它会警告你将丢失调用堆栈信息。
- en: 'Run the console app and note the output excludes some details of the call stack,
    as shown in the following output:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用并注意输出排除了调用堆栈的一些细节，如下所示：
- en: '[PRE53]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Delete the `ex` when rethrowing.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重新抛出异常时删除`ex`。
- en: Run the console app and note the output includes all the details of the call
    stack.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用并注意输出包括了调用堆栈的所有细节。
- en: Implementing the tester-doer pattern
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现测试者-执行者模式
- en: 'The **tester-doer pattern** can avoid some thrown exceptions (but not eliminate
    them completely). This pattern uses pairs of functions: one to perform a test,
    the other to perform an action that would fail if the test is not passed.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试者-执行者模式**可以避免一些抛出的异常（但不能完全消除它们）。此模式使用一对函数：一个执行测试，另一个执行如果测试未通过则会失败的操作。'
- en: .NET implements this pattern itself. For example, before adding an item to a
    collection by calling the `Add` method, you can test to see if it is read-only,
    which would cause `Add` to fail and therefore throw an exception.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: .NET本身实现了这种模式。例如，在通过调用`Add`方法向集合添加项之前，你可以测试它是否为只读，这会导致`Add`失败并因此抛出异常。
- en: 'For example, before withdrawing money from a bank account, you might test that
    the account is not overdrawn, as shown in the following code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在从银行账户取款前，你可能会测试账户是否透支，如下所示：
- en: '[PRE54]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Problems with the tester-doer pattern
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试者-执行者模式的问题
- en: The tester-doer pattern can add performance overhead, so you can also implement
    the **try pattern**, which in effect combines the test and do parts into a single
    function, as we saw with `TryParse`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 测试者-执行者模式可能会增加性能开销，因此你也可以实现**try模式**，它实际上将测试和执行部分合并为一个函数，正如我们在`TryParse`中看到的那样。
- en: Another problem with the tester-doer pattern occurs when you are using multiple
    threads. In this scenario, one thread could call the test function and it returns
    okay. But then another thread executes that changes the state. Then the original
    thread continues executing assuming everything is fine, but it is not fine. This
    is called a race condition. We will see how we could handle it in *Chapter 12*,
    *Improving Performance and Scalability Using Multitasking*.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 测试者-执行者模式的另一个问题出现在使用多线程时。在这种情况下，一个线程可能调用测试函数并返回正常。但随后另一个线程执行改变了状态。然后原始线程继续执行，假设一切正常，但实际上并非如此。这称为竞态条件。我们将在*第12章*，*使用多任务提高性能和可扩展性*中看到如何处理它。
- en: 'If you implement your own try pattern function and it fails, remember to set
    the `out` parameter to the default value of its type and then return `false`,
    as shown in the following code:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现自己的try模式函数且失败了，记得将`out`参数设置为其类型的默认值，然后返回`false`，如下所示：
- en: '[PRE55]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Practicing and exploring
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践和探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics covered in
    this chapter.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试你的知识和理解，进行一些实践操作，并深入研究本章涵盖的主题。
- en: Exercise 4.1 – Test your knowledge
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.1 – 测试你的知识
- en: 'Answer the following questions. If you get stuck, try Googling the answers
    if necessary, while remembering that if you get totally stuck, the answers are
    in the Appendix:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题。如果你卡住了，必要时尝试通过谷歌搜索答案，同时记住如果你完全卡住了，答案在附录中：
- en: What does the C# keyword `void` mean?
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#关键字`void`是什么意思？
- en: What are some differences between imperative and functional programming styles?
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令式和函数式编程风格之间有哪些区别？
- en: In Visual Studio Code or Visual Studio, what is the difference between pressing
    F5, Ctrl or Cmd + F5, Shift + F5, and Ctrl or Cmd + Shift + F5?
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code或Visual Studio中，按F5、Ctrl或Cmd + F5、Shift + F5以及Ctrl或Cmd +
    Shift + F5之间有何区别？
- en: Where does the `Trace.WriteLine` method write its output to?
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Trace.WriteLine`方法将输出写入到哪里？'
- en: What are the five trace levels?
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 五个跟踪级别是什么？
- en: What is the difference between the `Debug` and `Trace` classes?
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Debug`类和`Trace`类之间有何区别？'
- en: When writing a unit test, what are the three "A"s?
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写单元测试时，三个“A”是什么？
- en: When writing a unit test using xUnit, what attribute must you decorate the test
    methods with?
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用xUnit编写单元测试时，你必须用什么属性来装饰测试方法？
- en: What `dotnet` command executes xUnit tests?
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行xUnit测试的`dotnet`命令是什么？
- en: What statement should you use to rethrow a caught exception named `ex` without
    losing the stack trace?
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重新抛出名为`ex`的捕获异常而不丢失堆栈跟踪，应使用什么语句？
- en: Exercise 4.2 – Practice writing functions with debugging and unit testing
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.2 – 实践编写带有调试和单元测试的函数
- en: 'Prime factors are the combination of the smallest prime numbers that, when
    multiplied together, will produce the original number. Consider the following
    example:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 质因数是能乘积得到原数的最小质数的组合。考虑以下示例：
- en: 'Prime factors of 4 are: 2 x 2'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4的质因数是：2 x 2
- en: 'Prime factors of 7 are: 7'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7的质因数是：7
- en: 'Prime factors of 30 are: 5 x 3 x 2'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 30的质因数是：5 x 3 x 2
- en: 'Prime factors of 40 are: 5 x 2 x 2 x 2'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 40的质因数是：5 x 2 x 2 x 2
- en: 'Prime factors of 50 are: 5 x 5 x 2'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50的质因数是：5 x 5 x 2
- en: 'Create a workspace/solution named `PrimeFactors` to contain three projects:
    a class library with a method named `PrimeFactors` that, when passed an `int`
    variable as a parameter, returns a `string` showing its prime factors; a unit
    tests project; and a console application to use it.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`PrimeFactors`的工作区/解决方案，包含三个项目：一个类库，其中有一个名为`PrimeFactors`的方法，当传入一个`int`变量作为参数时，返回一个显示其质因数的`string`；一个单元测试项目；以及一个控制台应用程序来使用它。
- en: To keep it simple, you can assume that the largest number entered will be 1,000.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 为简化起见，你可以假设输入的最大数字将是1,000。
- en: Use the debugging tools and write unit tests to ensure that your function works
    correctly with multiple inputs and returns the correct output.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试工具并编写单元测试，以确保你的函数能正确处理多个输入并返回正确的输出。
- en: Exercise 4.3 – Explore topics
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.3 – 探索主题
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接来了解更多关于本章涵盖主题的详细信息：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-4---writing-debugging-and-testing-functions](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-4---writing-debugging-and-testing-functions)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章 - 编写、调试和测试函数](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-4---writing-debugging-and-testing-functions)'
- en: Summary
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to write reusable functions with input parameters
    and return values, in both an imperative and functional style, and then how to
    use the Visual Studio and Visual Studio Code debugging and diagnostic features
    to fix any bugs in them. Finally, you learned how to throw and catch exceptions
    in functions and understand the call stack.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写可重用的函数，这些函数具有输入参数和返回值，既采用命令式风格也采用函数式风格，然后如何使用Visual Studio和Visual
    Studio Code的调试和诊断功能来修复其中的任何错误。最后，你学习了如何在函数中抛出和捕获异常，并理解调用堆栈。
- en: In the next chapter, you will learn how to build your own types using object-oriented
    programming techniques.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用面向对象编程技术构建自己的类型。
