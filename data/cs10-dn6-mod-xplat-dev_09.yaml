- en: 09
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 09
- en: Working with Files, Streams, and Serialization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件、流和序列化
- en: This chapter is about reading and writing to files and streams, text encoding,
    and serialization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于读写文件和流、文本编码和序列化的。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Managing the filesystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理文件系统
- en: Reading and writing with streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流进行读写
- en: Encoding and decoding text
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码和解码文本
- en: Serializing object graphs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化对象图
- en: Controlling JSON processing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制JSON处理
- en: Managing the filesystem
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件系统
- en: Your applications will often need to perform input and output operations with
    files and directories in different environments. The `System` and `System.IO`
    namespaces contain classes for this purpose.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序通常需要在不同的环境中对文件和目录执行输入和输出操作。`System`和`System.IO`命名空间包含为此目的的类。
- en: Handling cross-platform environments and filesystems
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理跨平台环境和文件系统
- en: 'Let''s explore how to handle cross-platform environments like the differences
    between Windows and Linux or macOS. Paths are different for Windows, macOS, and
    Linux, so we will start by exploring how .NET handles this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何处理跨平台环境，例如Windows与Linux或macOS之间的差异。Windows、macOS和Linux的路径不同，因此我们将从探索.NET如何处理这一点开始：
- en: Use your preferred code editor to create a new solution/workspace named `Chapter09`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器创建一个名为`Chapter09`的新解决方案/工作区。
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用程序项目，如下表所定义：
- en: 'Project template: **Console Application**/`console`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序**/`console`
- en: 'Workspace/solution file and folder: `Chapter09`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter09`
- en: 'Project file and folder: `WorkingWithFileSystems`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WorkingWithFileSystems`
- en: 'In `Program.cs`, add statements to statically import the `System.Console`,
    `System.IO.Directory`, `System.Environment`, and `System.IO.Path` types, as shown
    in the following code:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以静态导入`System.Console`、`System.IO.Directory`、`System.Environment`和`System.IO.Path`类型，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `Program.cs`, create a static `OutputFileSystemInfo` method, and write statements
    in it to do the following:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个静态`OutputFileSystemInfo`方法，并在其中编写语句以执行以下操作：
- en: Output the path and directory separation characters.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出路径和目录分隔符字符。
- en: Output the path of the current directory.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出当前目录的路径。
- en: Output some special paths for system files, temporary files, and documents.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出一些特殊路径，用于系统文件、临时文件和文档。
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Environment` type has many other useful members that we did not use in
    this code, including the `GetEnvironmentVariables` method and the `OSVersion`
    and `ProcessorCount` properties.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Environment`类型有许多其他有用的成员，我们在此代码中未使用，包括`GetEnvironmentVariables`方法以及`OSVersion`和`ProcessorCount`属性。'
- en: 'In `Program.cs`, above the function, call the `OutputFileSystemInfo` method,
    as shown in the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在函数上方调用`OutputFileSystemInfo`方法，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the code and view the result, as shown in *Figure 9.1*:![Text  Description
    automatically generated](img/B17442_09_01.png)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如图*9.1*所示：![文本描述自动生成](img/B17442_09_01.png)
- en: 'Figure 9.1: Running your application to show filesystem information on Windows'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.1：运行应用程序以在Windows上显示文件系统信息
- en: When running the console app using `dotnet run` with Visual Studio Code, the
    `CurrentDirectory` will be the project folder, not a folder inside `bin`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Visual Studio Code中的`dotnet run`运行控制台应用程序时，`CurrentDirectory`将是项目文件夹，而不是`bin`内的文件夹。
- en: '**Good Practice**: Windows uses a backslash `\` for the directory separator
    character. macOS and Linux use a forward slash `/` for the directory separator
    character. Do not assume what character is used in your code when combining paths.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：Windows使用反斜杠`\`作为目录分隔符。macOS和Linux使用正斜杠`/`作为目录分隔符。在组合路径时，不要假设代码中使用的是哪种字符。'
- en: Managing drives
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理驱动器
- en: To manage drives, use the `DriveInfo` type, which has a static method that returns
    information about all the drives connected to your computer. Each drive has a
    drive type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理驱动器，请使用`DriveInfo`类型，该类型有一个静态方法，返回有关连接到计算机的所有驱动器的信息。每个驱动器都有一个驱动器类型。
- en: 'Let''s explore drives:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索驱动器：
- en: 'Create a `WorkWithDrives` method, and write statements to get all the drives
    and output their name, type, size, available free space, and format, but only
    if the drive is ready, as shown in the following code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`WorkWithDrives`方法，并编写语句以获取所有驱动器并输出其名称、类型、大小、可用自由空间和格式，但仅当驱动器就绪时，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Good Practice**: Check that a drive is ready before reading properties such
    as `TotalSize` or you will see an exception thrown with removable drives.'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：在读取`TotalSize`等属性之前，检查驱动器是否就绪，否则对于可移动驱动器，您将看到抛出的异常。'
- en: 'In `Program.cs`, comment out the previous method call and add a call to `WorkWithDrives`,
    as shown highlighted in the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的方法调用，并添加对`WorkWithDrives`的调用，如下面的代码中突出显示的那样：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the code and view the result, as shown in *Figure 9.2*:![](img/B17442_09_02.png)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如*图9.2*所示：![](img/B17442_09_02.png)
- en: 'Figure 9.2: Showing drive information on Windows'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.2：在Windows上显示驱动器信息
- en: Managing directories
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理目录
- en: To manage directories, use the `Directory`, `Path`, and `Environment` static
    classes. These types include many members for working with the filesystem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理目录，请使用`Directory`、`Path`和`Environment`静态类。这些类型包含许多用于处理文件系统的成员。
- en: 'When constructing custom paths, you must be careful to write your code so that
    it makes no assumptions about the platform, for example, what to use for the directory
    separator character:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自定义路径时，必须小心编写代码，使其不依赖于平台，例如，不假设使用哪种目录分隔符字符。
- en: 'Create a `WorkWithDirectories` method, and write statements to do the following:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`WorkWithDirectories`方法，并编写语句以执行以下操作：
- en: Define a custom path under the user's home directory by creating an array of
    strings for the directory names, and then properly combining them with the `Path`
    type's `Combine` method.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为用户的主目录下创建一个字符串数组来定义自定义路径，然后使用`Path`类型的`Combine`方法正确组合它们。
- en: Check for the existence of the custom directory path using the `Exists` method
    of the `Directory` class.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Directory`类的`Exists`方法检查自定义目录路径是否存在。
- en: 'Create and then delete the directory, including files and subdirectories within
    it, using the `CreateDirectory` and `Delete` methods of the `Directory` class:'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Directory`类的`CreateDirectory`和`Delete`方法创建然后删除目录，包括其中的文件和子目录：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `Program.cs`, comment out the previous method call, and add a call to `WorkWithDirectories`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的方法调用，并添加对`WorkWithDirectories`的调用。
- en: 'Run the code and view the result, and use your favorite file management tool
    to confirm that the directory has been created before pressing Enter to delete
    it, as shown in the following output:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，并使用您喜欢的文件管理工具确认目录已创建，然后按Enter键删除它，如下面的输出所示：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Managing files
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理文件
- en: 'When working with files, you could statically import the file type, just as
    we did for the directory type, but, for the next example, we will not, because
    it has some of the same methods as the directory type and they would conflict.
    The file type has a short enough name not to matter in this case. The steps are
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件时，可以像我们为目录类型所做的那样静态导入文件类型，但对于下一个示例，我们将不会这样做，因为它与目录类型有一些相同的方法，并且它们会发生冲突。文件类型的名称足够短，在这种情况下不会造成影响。步骤如下：
- en: 'Create a `WorkWithFiles` method, and write statements to do the following:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`WorkWithFiles`方法，并编写语句以执行以下操作：
- en: Check for the existence of a file.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件是否存在。
- en: Create a text file.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文本文件。
- en: Write a line of text to the file.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向文件写入一行文本。
- en: Close the file to release system resources and file locks (this would normally
    be done inside a `try-finally` statement block to ensure that the file is closed
    even if an exception occurs when writing to it).
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件以释放系统资源和文件锁（这通常在`try-finally`语句块内部完成，以确保即使写入文件时发生异常，文件也会关闭）。
- en: Copy the file to a backup.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件复制到备份。
- en: Delete the original file.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始文件。
- en: 'Read the backup file''s contents and then close it:'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取备份文件的内容，然后关闭它：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In `Program.cs`, comment out the previous method call, and add a call to `WorkWithFiles`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的方法调用，并添加对`WorkWithFiles`的调用。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Managing paths
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理路径
- en: 'Sometimes, you need to work with parts of a path; for example, you might want
    to extract just the folder name, the filename, or the extension. Sometimes, you
    need to generate temporary folders and filenames. You can do this with static
    methods of the `Path` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要处理路径的一部分；例如，您可能只想提取文件夹名称、文件名或扩展名。有时，您需要生成临时文件夹和文件名。您可以使用`Path`类的静态方法来完成此操作：
- en: 'Add the following statements to the end of the `WorkWithFiles` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkWithFiles`方法的末尾添加以下语句：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`GetTempFileName` creates a zero-byte file and returns its name, ready for
    you to use. `GetRandomFileName` just returns a filename; it doesn''t create the
    file.'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GetTempFileName`创建一个零字节文件并返回其名称，供你使用。`GetRandomFileName`仅返回一个文件名；它不创建文件。'
- en: Getting file information
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取文件信息
- en: To get more information about a file or directory, for example, its size or
    when it was last accessed, you can create an instance of the `FileInfo` or `DirectoryInfo`
    class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关文件或目录的更多信息，例如其大小或上次访问时间，你可以创建`FileInfo`或`DirectoryInfo`类的实例。
- en: '`FileInfo` and `DirectoryInfo` both inherit from `FileSystemInfo`, so they
    both have members such as `LastAccessTime` and `Delete`, as well as extra members
    specific to themselves, as shown in the following table:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileInfo`和`DirectoryInfo`都继承自`FileSystemInfo`，因此它们都具有`LastAccessTime`和`Delete`等成员，以及它们自己的特定成员，如下表所示：'
- en: '| Class | Members |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 成员 |'
- en: '| `FileSystemInfo` | Fields: `FullPath`, `OriginalPath`Properties: `Attributes`,
    `CreationTime`, `CreationTimeUtc`, `Exists`, `Extension`, `FullName`, `LastAccessTime`,
    `LastAccessTimeUtc`, `LastWriteTime`, `LastWriteTimeUtc`, `Name`Methods: `Delete`,
    `GetObjectData`, `Refresh` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `FileSystemInfo` | 字段：`FullPath`、`OriginalPath`属性：`Attributes`、`CreationTime`、`CreationTimeUtc`、`Exists`、`Extension`、`FullName`、`LastAccessTime`、`LastAccessTimeUtc`、`LastWriteTime`、`LastWriteTimeUtc`、`Name`方法：`Delete`、`GetObjectData`、`Refresh`
    |'
- en: '| `DirectoryInfo` | Properties: `Parent`, `Root`Methods: `Create`, `CreateSubdirectory`,
    `EnumerateDirectories`, `EnumerateFiles`, `EnumerateFileSystemInfos`, `GetAccessControl`,
    `GetDirectories`, `GetFiles`, `GetFileSystemInfos`, `MoveTo`, `SetAccessControl`
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `DirectoryInfo` | 属性：`Parent`、`Root`方法：`Create`、`CreateSubdirectory`、`EnumerateDirectories`、`EnumerateFiles`、`EnumerateFileSystemInfos`、`GetAccessControl`、`GetDirectories`、`GetFiles`、`GetFileSystemInfos`、`MoveTo`、`SetAccessControl`
    |'
- en: '| `FileInfo` | Properties: `Directory`, `DirectoryName`, `IsReadOnly`, `Length`Methods:
    `AppendText`, `CopyTo`, `Create`, `CreateText`, `Decrypt`, `Encrypt`, `GetAccessControl`,
    `MoveTo`, `Open`, `OpenRead`, `OpenText`, `OpenWrite`, `Replace`, `SetAccessControl`
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `FileInfo` | 属性：`Directory`、`DirectoryName`、`IsReadOnly`、`Length`方法：`AppendText`、`CopyTo`、`Create`、`CreateText`、`Decrypt`、`Encrypt`、`GetAccessControl`、`MoveTo`、`Open`、`OpenRead`、`OpenText`、`OpenWrite`、`Replace`、`SetAccessControl`
    |'
- en: 'Let''s write some code that uses a `FileInfo` instance for efficiently performing
    multiple actions on a file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，使用`FileInfo`实例高效地对文件执行多项操作：
- en: 'Add statements to the end of the `WorkWithFiles` method to create an instance
    of `FileInfo` for the backup file and write information about it to the console,
    as shown in the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkWithFiles`方法末尾添加语句，为备份文件创建一个`FileInfo`实例，并将有关它的信息写入控制台，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The number of bytes might be different on your operating system because operating
    systems can use different line endings.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 字节数可能因操作系统而异，因为操作系统可以使用不同的行结束符。
- en: Controlling how you work with files
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制你处理文件的方式
- en: When working with files, you often need to control how they are opened. The
    `File.Open` method has overloads to specify additional options using `enum` values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件时，你经常需要控制它们的打开方式。`File.Open`方法有重载，可以使用`enum`值指定额外的选项。
- en: 'The `enum` types are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型如下：'
- en: '`FileMode`: This controls what you want to do with the file, like `CreateNew`,
    `OpenOrCreate`, or `Truncate`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileMode`：这控制你想要对文件执行的操作，例如`CreateNew`、`OpenOrCreate`或`Truncate`。'
- en: '`FileAccess`: This controls what level of access you need, like `ReadWrite`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileAccess`：这控制你需要什么级别的访问权限，例如`ReadWrite`。'
- en: '`FileShare`: This controls locks on the file to allow other processes the specified
    level of access, like `Read`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileShare`：这控制文件上的锁定，以允许其他进程指定级别的访问权限，例如`Read`。'
- en: 'You might want to open a file and read from it, and allow other processes to
    read it too, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要打开一个文件并从中读取，并允许其他进程也读取它，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is also an `enum` for attributes of a file as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文件属性也有一个`enum`，如下所示：
- en: '`FileAttributes`: This is to check a `FileSystemInfo`-derived types'' `Attributes`
    property for values like `Archive` and `Encrypted`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileAttributes`：这是为了检查`FileSystemInfo`派生类型的`Attributes`属性，例如`Archive`和`Encrypted`。'
- en: 'You could check a file or directory''s attributes, as shown in the following
    code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查文件或目录的属性，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Reading and writing with streams
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流进行读写
- en: A **stream** is a sequence of bytes that can be read from and written to. Although
    files can be processed rather like arrays, with random access provided by knowing
    the position of a byte within the file, it can be useful to process files as a
    stream in which the bytes can be accessed in sequential order.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**流**是一系列字节，可以从中读取和写入。尽管文件可以像数组一样处理，通过知道文件中字节的位置提供随机访问，但将文件作为流处理，其中字节可以按顺序访问，可能会有用。
- en: Streams can also be used to process terminal input and output and networking
    resources such as sockets and ports that do not provide random access and cannot
    seek (that is, move) to a position. You can write code to process some arbitrary
    bytes without knowing or caring where it comes from. Your code simply reads or
    writes to a stream, and another piece of code handles where the bytes are actually
    stored.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 流还可用于处理终端输入输出和网络资源，如套接字和端口，这些资源不提供随机访问，也不能查找（即移动）到某个位置。您可以编写代码来处理一些任意字节，而无需知道或关心它来自哪里。您的代码只是读取或写入流，而另一段代码处理字节实际存储的位置。
- en: Understanding abstract and concrete streams
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解抽象流和具体流
- en: There is an `abstract` class named `Stream` that represents any type of stream.
    Remember that an `abstract` class cannot be instantiated using `new`; they can
    only be inherited.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个名为`Stream`的`抽象`类，它代表任何类型的流。记住，`抽象`类不能使用`new`实例化；它们只能被继承。
- en: There are many concrete classes that inherit from this base class, including
    `FileStream`, `MemoryStream`, `BufferedStream`, `GZipStream`, and `SslStream`,
    so they all work the same way. All streams implement `IDisposable`, so they have
    a `Dispose` method to release unmanaged resources.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多具体类继承自这个基类，包括`FileStream`、`MemoryStream`、`BufferedStream`、`GZipStream`和`SslStream`，因此它们都以相同的方式工作。所有流都实现`IDisposable`，因此它们有一个`Dispose`方法来释放非托管资源。
- en: 'Some of the common members of the `Stream` class are described in the following
    table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了`Stream`类的一些常见成员：
- en: '| Member | Description |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| `CanRead`, `CanWrite` | These properties determine if you can read from and
    write to the stream. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `CanRead`, `CanWrite` | 这些属性确定是否可以从流中读取和写入。 |'
- en: '| `Length`, `Position` | These properties determine the total number of bytes
    and the current position within the stream. These properties may throw an exception
    for some types of streams. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `Length`, `Position` | 这些属性确定流中的总字节数和当前位置。对于某些类型的流，这些属性可能会引发异常。 |'
- en: '| `Dispose` | This method closes the stream and releases its resources. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Dispose` | 此方法关闭流并释放其资源。 |'
- en: '| `Flush` | If the stream has a buffer, then this method writes the bytes in
    the buffer to the stream and the buffer is cleared. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `Flush` | 如果流有缓冲区，则此方法将缓冲区中的字节写入流，并清除缓冲区。 |'
- en: '| `CanSeek` | This property determines if the `Seek` method can be used. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `CanSeek` | 此属性确定是否可以使用`Seek`方法。 |'
- en: '| `Seek` | This method moves the current position to the one specified in its
    parameter. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `Seek` | 此方法将其参数指定的新位置移动当前位置。 |'
- en: '| `Read`, `ReadAsync` | These methods read a specified number of bytes from
    the stream into a byte array and advance the position. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `Read`, `ReadAsync` | 这些方法从流中读取指定数量的字节到字节数组中，并推进位置。 |'
- en: '| `ReadByte` | This method reads the next byte from the stream and advances
    the position. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `ReadByte` | 此方法从流中读取下一个字节并推进位置。 |'
- en: '| `Write`, `WriteAsync` | These methods write the contents of a byte array
    into the stream. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Write`, `WriteAsync` | 这些方法将字节数组的内容写入流中。 |'
- en: '| `WriteByte` | This method writes a byte to the stream. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `WriteByte` | 此方法将一个字节写入流中。 |'
- en: Understanding storage streams
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解存储流
- en: 'Some storage streams that represent a location where the bytes will be stored
    are described in the following table:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了一些代表字节存储位置的存储流：
- en: '| Namespace | Class | Description |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 类 | 描述 |'
- en: '| `System.IO` | `FileStream` | Bytes stored in the filesystem. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `FileStream` | 文件系统中存储的字节。 |'
- en: '| `System.IO` | `MemoryStream` | Bytes stored in memory in the current process.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `MemoryStream` | 当前进程内存中存储的字节。 |'
- en: '| `System.Net.Sockets` | `NetworkStream` | Bytes stored at a network location.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.Sockets` | `NetworkStream` | 网络位置存储的字节。 |'
- en: '`FileStream` has been re-written in .NET 6 to have much higher performance
    and reliability on Windows.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream` 在 .NET 6 中被重写，以在 Windows 上具有更高的性能和可靠性。'
- en: Understanding function streams
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解功能流
- en: 'Some function streams that cannot exist on their own, but can only be "plugged
    onto" other streams to add functionality, are described in the following table:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 某些功能流无法独立存在，只能“附加到”其他流以添加功能，如下表所述：
- en: '| Namespace | Class | Description |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 类 | 描述 |'
- en: '| `System.Security.Cryptography` | `CryptoStream` | This encrypts and decrypts
    the stream. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `System.Security.Cryptography` | `CryptoStream` | 此流用于加密和解密。'
- en: '| `System.IO.Compression` | `GZipStream`, `DeflateStream` | These compress
    and decompress the stream. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO.Compression` | `GZipStream`, `DeflateStream` | 这些类用于压缩和解压缩流。'
- en: '| `System.Net.Security` | `AuthenticatedStream` | This sends credentials across
    the stream. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.Security` | `AuthenticatedStream` | 此流用于跨流发送凭据。'
- en: Understanding stream helpers
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解流辅助类
- en: Although there will be occasions where you need to work with streams at a low
    level, most often, you can plug helper classes into the chain to make things easier.
    All the helper types for streams implement `IDisposable`, so they have a `Dispose`
    method to release unmanaged resources.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有时您需要以低级别处理流，但大多数情况下，您可以将辅助类插入链中以简化操作。所有流辅助类型均实现 `IDisposable`，因此它们具有 `Dispose`
    方法以释放非托管资源。
- en: 'Some helper classes to handle common scenarios are described in the following
    table:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 处理常见场景的一些辅助类如下表所述：
- en: '| Namespace | Class | Description |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 类 | 描述 |'
- en: '| `System.IO` | `StreamReader` | This reads from the underlying stream as plain
    text. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `StreamReader` | 此读取器以纯文本形式从底层流读取数据。'
- en: '| `System.IO` | `StreamWriter` | This writes to the underlying stream as plain
    text. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `StreamWriter` | 此写入器以纯文本形式向底层流写入数据。'
- en: '| `System.IO` | `BinaryReader` | This reads from streams as .NET types. For
    example, the `ReadDecimal` method reads the next 16 bytes from the underlying
    stream as a `decimal` value and the `ReadInt32` method reads the next 4 bytes
    as an `int` value. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `BinaryReader` | 此读取器以 .NET 类型从流中读取数据。例如，`ReadDecimal` 方法从底层流读取接下来的
    16 字节作为 `decimal` 值，而 `ReadInt32` 方法读取接下来的 4 字节作为 `int` 值。'
- en: '| `System.IO` | `BinaryWriter` | This writes to streams as .NET types. For
    example, the `Write` method with a `decimal` parameter writes 16 bytes to the
    underlying stream and the `Write` method with an `int` parameter writes 4 bytes.
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO` | `BinaryWriter` | 此写入器以 .NET 类型向流写入数据。例如，带有 `decimal` 参数的 `Write`
    方法向底层流写入 16 字节，而带有 `int` 参数的 `Write` 方法写入 4 字节。'
- en: '| `System.Xml` | `XmlReader` | This reads from the underlying stream using
    XML format. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `System.Xml` | `XmlReader` | 此读取器使用 XML 格式从底层流读取数据。'
- en: '| `System.Xml` | `XmlWriter` | This writes to the underlying stream using XML
    format. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `System.Xml` | `XmlWriter` | 此写入器使用 XML 格式向底层流写入数据。'
- en: Writing to text streams
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文本流
- en: 'Let''s type some code to write text to a stream:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码将文本写入流：
- en: 'Use your preferred code editor to add a new console app named `WorkingWithStreams`
    to the `Chapter09` solution/workspace:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，在 `Chapter09` 解决方案/工作区中添加一个名为 `WorkingWithStreams` 的新控制台应用：
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，将解决方案的启动项目设置为当前选定项。
- en: In Visual Studio Code, select `WorkingWithStreams` as the active OmniSharp project.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，选择 `WorkingWithStreams` 作为活动 OmniSharp 项目。
- en: In the `WorkingWithStreams` project, in `Program.cs`, import the `System.Xml`
    namespace and statically import the `System.Console`, `System.Environment`, and
    `System.IO.Path` types.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WorkingWithStreams` 项目中，在 `Program.cs` 中，导入 `System.Xml` 命名空间并静态导入 `System.Console`、`System.Environment`
    和 `System.IO.Path` 类型。
- en: 'At the bottom of `Program.cs`, define a static class named `Viper` with a static
    array of `string` values named `Callsigns`, as shown in the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 底部，定义一个名为 `Viper` 的静态类，其中包含一个名为 `Callsigns` 的静态 `string` 数组，如下所示：
- en: '[PRE15]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Above the `Viper` class, define a `WorkWithText` method that enumerates the
    Viper call signs, writing each one on its own line in a single text file, as shown
    in the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Viper` 类上方，定义一个名为 `WorkWithText` 的方法，该方法枚举 Viper 呼号，将每个呼号写入单个文本文件中的一行，如下所示：
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Below the namespace imports, call the `WorkWithText` method.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命名空间导入下方，调用 `WorkWithText` 方法。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open the file that was created and check that it contains the list of call signs.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开创建的文件并检查其是否包含呼号列表。
- en: Writing to XML streams
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入 XML 流
- en: 'There are two ways to write an XML element, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 XML 元素有两种方式，如下所示：
- en: '`WriteStartElement` and `WriteEndElement`: Use this pair when an element might
    have child elements.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteStartElement`和`WriteEndElement`：当元素可能有子元素时使用这一对方法。'
- en: '`WriteElementString`: Use this when an element does not have children.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteElementString`：当元素没有子元素时使用此方法。'
- en: 'Now, let''s try storing the Viper pilot call signs array of `string` values
    in an XML file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试将Viper飞行员呼号数组`string`值存储在XML文件中：
- en: 'Create a `WorkWithXml` method that enumerates the call signs, writing each
    one as an element in a single XML file, as shown in the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`WorkWithXml`方法，该方法枚举呼号，并将每个呼号作为单个XML文件中的元素写入，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `Program.cs`, comment out the previous method call, and add a call to the
    `WorkWithXml` method.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的方法调用，并添加对`WorkWithXml`方法的调用。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE19]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Disposing of file resources
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放文件资源
- en: When you open a file to read or write to it, you are using resources outside
    of .NET. These are called **unmanaged resources** and must be disposed of when
    you are done working with them. To deterministically control when they are disposed
    of, we can call the `Dispose` method inside of a `finally` block.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开一个文件进行读取或写入时，你正在使用.NET之外的资源。这些被称为**非托管资源**，并且在完成与它们的工作后必须被释放。为了确定性地控制何时释放它们，我们可以在`finally`块中调用`Dispose`方法。
- en: 'Let''s improve our previous code that works with XML to properly dispose of
    its unmanaged resources:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进之前处理XML的代码，以正确释放其非托管资源：
- en: 'Modify the `WorkWithXml` method, as shown highlighted in the following code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`WorkWithXml`方法，如下面的代码中突出显示的那样：
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You could also go back and modify the other methods you previously created but
    I will leave that as an optional exercise for you.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以回去修改你之前创建的其他方法，但我会将其留作可选练习。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE21]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Good Practice**: Before calling the `Dispose` method, check that the object
    is not null.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：在调用`Dispose`方法之前，检查对象是否不为null。'
- en: Simplifying disposal by using the using statement
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过使用`using`语句简化释放
- en: You can simplify the code that needs to check for a `null` object and then call
    its `Dispose` method by using the `using` statement. Generally, I would recommend
    using `using` rather than manually calling `Dispose` unless you need a greater
    level of control.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`using`语句简化需要检查`null`对象然后调用其`Dispose`方法的代码。一般来说，我建议使用`using`而不是手动调用`Dispose`，除非你需要更高级别的控制。
- en: 'Confusingly, there are two uses for the `using` keyword: importing a namespace
    and generating a `finally` statement that calls `Dispose` on an object that implements
    `IDisposable`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，`using`关键字有两种用途：导入命名空间和生成一个`finally`语句，该语句在实现`IDisposable`接口的对象上调用`Dispose`。
- en: 'The compiler changes a `using` statement block into a `try`-`finally` statement
    without a `catch` statement. You can use nested `try` statements; so, if you do
    want to catch any exceptions, you can, as shown in the following code example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将`using`语句块转换为没有`catch`语句的`try`-`finally`语句。你可以使用嵌套的`try`语句；因此，如果你确实想要捕获任何异常，你可以这样做，如下面的代码示例所示：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can even simplify the code further by not explicitly specifying the braces
    and indentation for the `using` statements, as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过不明确指定`using`语句的大括号和缩进来进一步简化代码，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compressing streams
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩流
- en: 'XML is relatively verbose, so it takes up more space in bytes than plain text.
    Let''s see how we can squeeze the XML using a common compression algorithm known
    as GZIP:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: XML相对冗长，因此在字节中占用的空间比纯文本多。让我们看看如何使用称为GZIP的常见压缩算法来压缩XML：
- en: 'At the top of `Program.cs`, import the namespace for working with compression,
    as shown in the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，导入用于处理压缩的命名空间，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add a `WorkWithCompression` method, which uses instances of `GZipStream` to
    create a compressed file containing the same XML elements as before and then decompresses
    it while reading it and outputting to the console, as shown in the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`WorkWithCompression`方法，该方法使用`GZipStream`实例创建一个包含与之前相同XML元素的压缩文件，然后在读取时解压缩并输出到控制台，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `Program.cs`, leave the call to `WorkWithXml`, and add a call to `WorkWithCompression`,
    as shown highlighted in the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，保留对`WorkWithXml`的调用，并添加对`WorkWithCompression`的调用，如下面的代码中突出显示的那样：
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the code and compare the sizes of the XML file and the compressed XML file.
    It is less than half the size of the same XML without compression, as shown in
    the following edited output:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并比较XML文件和压缩后的XML文件的大小。如以下编辑后的输出所示，压缩后的文件大小不到未压缩XML文件的一半。
- en: '[PRE27]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compressing with the Brotli algorithm
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Brotli算法压缩
- en: 'In .NET Core 2.1, Microsoft introduced an implementation of the Brotli compression
    algorithm. In performance, Brotli is like the algorithm used in DEFLATE and GZIP,
    but the output is about 20% denser. The steps are as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core 2.1中，微软引入了Brotli压缩算法的实现。在性能上，Brotli类似于DEFLATE和GZIP中使用的算法，但输出密度大约高出20%。步骤如下：
- en: 'Modify the `WorkWithCompression` method to have an optional parameter to indicate
    if Brotli should be used and to use Brotli by default, as shown highlighted in
    the following code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`WorkWithCompression`方法，使其具有一个可选参数来指示是否应使用Brotli，并默认使用Brotli，如下面的代码中突出显示的那样：
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Near the top of `Program.cs`, call `WorkWithCompression` twice, once with the
    default using Brotli and once with GZIP, as shown in the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部附近，调用`WorkWithCompression`两次，一次使用默认的Brotli，一次使用GZIP，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the code and compare the sizes of the two compressed XML files. Brotli
    is more than 21% denser, as shown in the following edited output:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并比较两个压缩后的XML文件的大小。如以下编辑后的输出所示，Brotli的密度高出21%以上。
- en: '[PRE30]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Encoding and decoding text
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码和解码文本
- en: Text characters can be represented in different ways. For example, the alphabet
    can be encoded using Morse code into a series of dots and dashes for transmission
    over a telegraph line.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字符可以用不同的方式表示。例如，字母表可以用摩尔斯电码编码成一系列点和划，以便通过电报线路传输。
- en: In a similar way, text inside a computer is stored as bits (ones and zeros)
    representing a code point within a code space. Most code points represent a single
    character, but they can also have other meanings like formatting.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，计算机内部的文本以位（1和0）的形式存储，代表代码空间内的一个码位。大多数码位代表一个字符，但它们也可以有其他含义，如格式化。
- en: For example, ASCII has a code space with 128 code points. .NET uses a standard
    called **Unicode** to encode text internally. Unicode has more than one million
    code points.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ASCII有一个包含128个码位的代码空间。.NET使用名为**Unicode**的标准来内部编码文本。Unicode拥有超过一百万个码位。
- en: Sometimes, you will need to move text outside .NET for use by systems that do
    not use Unicode or use a variation of Unicode, so it is important to learn how
    to convert between encodings.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要将文本移出.NET，以便在不使用Unicode或使用Unicode变体的系统中使用，因此学习如何在编码之间转换非常重要。
- en: 'The following table lists some alternative text encodings commonly used by
    computers:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了计算机常用的一些替代文本编码：
- en: '| Encoding | Description |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 编码方式 | 描述 |'
- en: '| ASCII | This encodes a limited range of characters using the lower seven
    bits of a byte. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| ASCII | 此编码使用字节的低七位对有限范围的字符进行编码。 |'
- en: '| UTF-8 | This represents each Unicode code point as a sequence of one to four
    bytes. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| UTF-8 | 此方式将每个Unicode码位表示为一个至四个字节的序列。 |'
- en: '| UTF-7 | This is designed to be more efficient over 7-bit channels than UTF-8
    but it has security and robustness issues, so UTF-8 is recommended over UTF-7.
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| UTF-7 | 与UTF-8相比，此方式在7位通道上更高效，但它存在安全性和健壮性问题，因此建议使用UTF-8而非UTF-7。 |'
- en: '| UTF-16 | This represents each Unicode code point as a sequence of one or
    two 16-bit integers. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16 | 此方式将每个Unicode码位表示为一个或两个16位整数的序列。 |'
- en: '| UTF-32 | This represents each Unicode code point as a 32-bit integer and
    is therefore a fixed-length encoding unlike the other Unicode encodings, which
    are all variable-length encodings. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32 | 此方式将每个Unicode码位表示为一个32位整数，因此是一种固定长度编码，与其他所有变长Unicode编码不同。 |'
- en: '| ANSI/ISO encodings | This provides support for a variety of code pages that
    are used to support a specific language or group of languages. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| ANSI/ISO编码 | 这提供了对各种代码页的支持，这些代码页用于支持特定的语言或一组语言。 |'
- en: '**Good Practice**: In most cases today, UTF-8 is a good default, which is why
    it is literally the default encoding, that is, `Encoding.Default`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：在当今大多数情况下，UTF-8是一个好的默认选择，这也是它实际上是默认编码的原因，即`Encoding.Default`。'
- en: Encoding strings as byte arrays
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字符串编码为字节数组
- en: 'Let''s explore text encodings:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨文本编码：
- en: Use your preferred code editor to add a new console app named `WorkingWithEncodings`
    to the `Chapter09` solution/workspace.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，在`Chapter09`解决方案/工作区中添加一个名为`WorkingWithEncodings`的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithEncodings` as the active OmniSharp
    project.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithEncodings`作为活动OmniSharp项目。
- en: In `Program.cs`, import the `System.Text` namespace and statically import the
    `Console` class.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入`System.Text`命名空间并静态导入`Console`类。
- en: 'Add statements to encode a `string` using an encoding chosen by the user, loop
    through each byte, and then decode it back into a `string` and output it, as shown
    in the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以使用用户选择的编码对`string`进行编码，循环遍历每个字节，然后将其解码回`string`并输出，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the code and note the warning to avoid using `Encoding.UTF7` because it
    is insecure. Of course, if you need to generate text using that encoding for compatibility
    with another system, it needs to remain an option in .NET.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意避免使用`Encoding.UTF7`的警告，因为它不安全。当然，如果您需要使用该编码生成文本以与其他系统兼容，它需要在.NET中保持为选项。
- en: Press 1 to choose ASCII and note that when outputting the bytes, the pound sign
    (£) and accented e (é) cannot be represented in ASCII, so it uses a question mark
    instead.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按1选择ASCII，并注意当输出字节时，英镑符号（£）和带重音的e（é）无法在ASCII中表示，因此它使用问号代替。
- en: '[PRE32]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Rerun the code and press 3 to choose UTF-8 and note that UTF-8 requires two
    extra bytes for the two characters that need 2 bytes each (18 bytes instead of
    16 bytes total) but it can encode and decode the é and £ characters.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并按3选择UTF-8，注意UTF-8为需要两个字节的两个字符额外需要两个字节（总共18字节而不是16字节），但它可以编码和解码é和£字符。
- en: '[PRE33]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Rerun the code and press 4 to choose Unicode (UTF-16) and note that UTF-16 requires
    two bytes for every character, so 32 bytes in total, and it can encode and decode
    the é and £ characters. This encoding is used internally by .NET to store `char`
    and `string` values.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并按4选择Unicode（UTF-16），注意UTF-16为每个字符需要两个字节，总共32字节，并且能够编码和解码é和£字符。这种编码被.NET内部用于存储`char`和`string`值。
- en: Encoding and decoding text in files
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件中的文本编码和解码
- en: When using stream helper classes, such as `StreamReader` and `StreamWriter`,
    you can specify the encoding you want to use. As you write to the helper, the
    text will automatically be encoded, and as you read from the helper, the bytes
    will be automatically decoded.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用流辅助类，如`StreamReader`和`StreamWriter`时，您可以指定要使用的编码。当您向辅助类写入时，文本将自动编码，当您从辅助类读取时，字节将自动解码。
- en: 'To specify an encoding, pass the encoding as a second parameter to the helper
    type''s constructor, as shown in the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定编码，请将编码作为第二个参数传递给辅助类型的构造函数，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Good Practice**: Often, you won''t have the choice of which encoding to use,
    because you will be generating a file for use by another system. However, if you
    do, pick one that uses the least number of bytes, but can store every character
    you need.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：通常，您无法选择使用哪种编码，因为您将生成的文件供另一个系统使用。但是，如果可以，请选择使用最少字节数但能存储您所需所有字符的编码。'
- en: Serializing object graphs
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化对象图
- en: '**Serialization** is the process of converting a live object into a sequence
    of bytes using a specified format. **Deserialization** is the reverse process.
    You would do this to save the current state of a live object so that you can recreate
    it in the future. For example, saving the current state of a game so that you
    can continue at the same place tomorrow. Serialized objects are usually stored
    in a file or database.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**是将活动对象转换为使用指定格式的字节序列的过程。**反序列化**则是其逆过程。这样做是为了保存活动对象的当前状态，以便将来可以重新创建它。例如，保存游戏的当前状态，以便明天可以从同一位置继续。序列化的对象通常存储在文件或数据库中。'
- en: There are dozens of formats you can specify, but the two most common ones are
    **eXtensible Markup Language** (**XML**) and **JavaScript Object Notation** (**JSON**).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种格式可供指定，但最常见的两种是**可扩展标记语言**（**XML**）和**JavaScript对象表示法**（**JSON**）。
- en: '**Good Practice**: JSON is more compact and is best for web and mobile applications.
    XML is more verbose but is better supported in more legacy systems. Use JSON to
    minimize the size of serialized object graphs. JSON is also a good choice when
    sending object graphs to web applications and mobile applications because JSON
    is the native serialization format for JavaScript and mobile apps often make calls
    over limited bandwidth, so the number of bytes is important.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：JSON更紧凑，最适合Web和移动应用程序。XML更冗长，但在更多遗留系统中得到更好的支持。使用JSON来最小化序列化对象图的大小。当向Web应用程序和移动应用程序发送对象图时，JSON也是一个不错的选择，因为JSON是JavaScript的原生序列化格式，而移动应用程序通常通过有限的带宽进行调用，因此字节数很重要。'
- en: .NET has multiple classes that will serialize to and from XML and JSON. We will
    start by looking at `XmlSerializer` and `JsonSerializer`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: .NET有多个类可以序列化和反序列化为XML和JSON。我们将从`XmlSerializer`和`JsonSerializer`开始。
- en: Serializing as XML
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化为XML
- en: 'Let''s start by looking at XML, probably the world''s most used serialization
    format (for now). To show a typical example, we will define a custom class to
    store information about a person and then create an object graph using a list
    of `Person` instances with nesting:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从XML开始，这可能是目前世界上最常用的序列化格式。为了展示一个典型的例子，我们将定义一个自定义类来存储有关人员的信息，然后使用嵌套的`Person`实例列表创建一个对象图：
- en: Use your preferred code editor to add a new console app named `WorkingWithSerialization`
    to the `Chapter09` solution/workspace.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，在`Chapter09`解决方案/工作区中添加一个名为`WorkingWithSerialization`的新控制台应用程序。
- en: In Visual Studio Code, select `WorkingWithSerialization` as the active OmniSharp
    project.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithSerialization`作为活动OmniSharp项目。
- en: 'Add a class named `Person` with a `Salary` property that is `protected`, meaning
    it is only accessible to itself and derived classes. To populate the salary, the
    class has a constructor with a single parameter to set the initial salary, as
    shown in the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Person`的类，其中包含一个`protected`的`Salary`属性，这意味着它只能由自身和派生类访问。为了填充薪水，该类有一个构造函数，它有一个参数来设置初始薪水，如下所示：
- en: '[PRE35]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In `Program.cs`, import namespaces for working with XML serialization and statically
    import the `Console`, `Environment`, and `Path` classes, as shown in the following
    code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入用于XML序列化的命名空间，并静态导入`Console`、`Environment`和`Path`类，如下所示：
- en: '[PRE36]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add statements to create an object graph of `Person` instances, as shown in
    the following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以创建`Person`实例的对象图，如下所示：
- en: '[PRE37]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the code, view the result, and note that an exception is thrown, as shown
    in the following output:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意抛出了一个异常，如下所示：
- en: '[PRE38]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `Person`, add a statement to define a parameterless constructor, as shown
    in the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`中，添加一个语句来定义一个无参数构造函数，如下所示：
- en: '[PRE39]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The constructor does not need to do anything, but it must exist so that the
    `XmlSerializer` can call it to instantiate new `Person` instances during the deserialization
    process.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数无需执行任何操作，但它必须存在，以便`XmlSerializer`在反序列化过程中调用它来实例化新的`Person`实例。
- en: 'Rerun the code and view the result, and note that the object graph is serialized
    as XML elements like `<FirstName>Bob</FirstName>` and that the `Salary` property
    is not included because it is not a `public` property, as shown in the following
    output:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并查看结果，并注意对象图被序列化为XML元素，如`<FirstName>Bob</FirstName>`，并且`Salary`属性未被包含，因为它不是`public`属性，如下所示：
- en: '[PRE40]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Generating compact XML
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成紧凑的XML
- en: 'We could make the XML more compact using attributes instead of elements for
    some fields:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用属性而不是元素来使XML更紧凑：
- en: In `Person`, import the `System.Xml.Serialization` namespace so that you can
    decorate some properties with the `[XmlAttribute]` attribute.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`中，导入`System.Xml.Serialization`命名空间，以便您可以为某些属性装饰`[XmlAttribute]`属性。
- en: 'Decorate the first name, last name, and date of birth properties with the `[XmlAttribute]`
    attribute, and set a short name for each property, as shown highlighted in the
    following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`[XmlAttribute]`属性修饰名字、姓氏和出生日期属性，并为每个属性设置一个简短名称，如下所示：
- en: '[PRE41]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the code and note that the size of the file has been reduced from 752 to
    462 bytes, a space-saving of more than a third, by outputting property values
    as XML attributes, as shown in the following output:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意文件大小已从752字节减少到462字节，通过将属性值输出为XML属性，节省了超过三分之一的存储空间，如下所示：
- en: '[PRE42]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Deserializing XML files
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反序列化XML文件
- en: 'Now let''s try deserializing the XML file back into live objects in memory:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试将XML文件反序列化回内存中的活动对象：
- en: 'Add statements to open the XML file and then deserialize it, as shown in the
    following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以打开XML文件，然后对其进行反序列化，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the code and note that the people are loaded successfully from the XML
    file and then enumerated, as shown in the following output:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意，人员成功地从XML文件加载并进行了枚举，如下面的输出所示：
- en: '[PRE44]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There are many other attributes that can be used to control the XML generated.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他属性可用于控制生成的XML。
- en: If you don't use any annotations, `XmlSerializer` performs a case-insensitive
    match using the property name when deserializing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用任何注解，`XmlSerializer`在反序列化时会使用属性名称进行大小写不敏感匹配。
- en: '**Good Practice**: When using `XmlSerializer`, remember that only the public
    fields and properties are included, and the type must have a parameterless constructor.
    You can customize the output with attributes.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用`XmlSerializer`时，请记住只有公共字段和属性会被包含，且类型必须有一个无参构造函数。你可以通过属性来自定义输出。'
- en: Serializing with JSON
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSON进行序列化
- en: 'One of the most popular .NET libraries for working with the JSON serialization
    format is Newtonsoft.Json, known as Json.NET. It is mature and powerful. Let''s
    see it in action:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 处理JSON序列化格式的最流行的.NET库之一是Newtonsoft.Json，也称为Json.NET。它成熟且功能强大。让我们看看它的实际应用：
- en: 'In the `WorkingWithSerialization` project, add a package reference for the
    latest version of `Newtonsoft.Json`, as shown in the following markup:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithSerialization`项目中，添加对`Newtonsoft.Json`最新版本的包引用，如下面的标记所示：
- en: '[PRE45]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Build the `WorkingWithSerialization` project to restore packages.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`WorkingWithSerialization`项目以恢复包。
- en: 'In `Program.cs`, add statements to create a text file and then serialize the
    people into the file as JSON, as shown in the following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以创建一个文本文件，然后将人员序列化为JSON文件，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the code and note that JSON requires less than half the number of bytes
    compared to XML with elements. It''s even smaller than the XML file, which uses
    attributes, as shown in the following output:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意，与包含元素的XML相比，JSON所需的字节数不到一半。它甚至比使用属性的XML文件还要小，如下面的输出所示：
- en: '[PRE47]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: High-performance JSON processing
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高性能的JSON处理
- en: .NET Core 3.0 introduced a new namespace for working with JSON, `System.Text.Json`,
    which is optimized for performance by leveraging APIs like `Span<T>`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 3.0引入了一个新的命名空间来处理JSON，`System.Text.Json`，它通过利用`Span<T>`等API优化了性能。
- en: Also, older libraries like Json.NET are implemented by reading UTF-16\. It would
    be more performant to read and write JSON documents using UTF-8 because most network
    protocols, including HTTP, use UTF-8 and you can avoid transcoding UTF-8 to and
    from Json.NET's Unicode `string` values.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像Json.NET这样的旧库是基于读取UTF-16实现的。使用UTF-8读写JSON文档将更高效，因为大多数网络协议，包括HTTP，都使用UTF-8，你可以避免将UTF-8从Json.NET的Unicode
    `string`值进行转码。
- en: With the new API, Microsoft achieved between 1.3x and 5x improvement, depending
    on the scenario.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同场景，微软通过新API实现了1.3倍至5倍的性能提升。
- en: 'The original author of Json.NET, James Newton-King, joined Microsoft and has
    been working with them to develop their new JSON types. As he says in a comment
    discussing the new JSON APIs, "Json.NET isn''t going away," as shown in *Figure
    9.3*:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Json.NET的原作者James Newton-King加入了微软，并与他们合作开发了新的JSON类型。正如他在讨论新JSON API的评论中所说，“Json.NET不会消失”，如图*9.3*所示：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17442_09_03.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件 描述自动生成](img/B17442_09_03.png)'
- en: 'Figure 9.3: A comment by the original author of Json.NET'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：Json.NET原作者的一条评论
- en: 'Let''s see how to use the new JSON APIs to deserialize a JSON file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用新的JSON API来反序列化JSON文件：
- en: 'In the `WorkingWithSerialization` project, in `Program.cs`, import the new
    JSON class for performing serialization using an alias to avoid conflicting names
    with the Json.NET one we used before, as shown in the following code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithSerialization`项目中，在`Program.cs`中，导入新的JSON类以进行序列化，使用别名以避免与我们之前使用的Json.NET名称冲突，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add statements to open the JSON file, deserialize it, and output the names
    and counts of the children of the people, as shown in the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以打开JSON文件，反序列化它，并输出人员的姓名和子女数量，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE50]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Good Practice**: Choose Json.NET for developer productivity and a large feature
    set or `System.Text.Json` for performance.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：为提高开发效率和丰富功能集选择Json.NET，或为性能选择`System.Text.Json`。'
- en: Controlling JSON processing
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制JSON处理
- en: 'There are many options for taking control of how JSON is processed, as shown
    in the following list:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 控制JSON处理的方式有很多选项，如下所示：
- en: Including and excluding fields.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括与排除字段。
- en: Setting a casing policy.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置大小写策略。
- en: Selecting a case-sensitivity policy.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择大小写敏感策略。
- en: Choosing between compact and prettified whitespace.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择紧凑与美化空白。
- en: 'Let''s see some in action:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些实际操作：
- en: Use your preferred code editor to add a new console app named `WorkingWithJson`
    to the `Chapter09` solution/workspace.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，在`Chapter09`解决方案/工作区中添加一个名为`WorkingWithJson`的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithJson` as the active OmniSharp project.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithJson`作为活动OmniSharp项目。
- en: 'In the `WorkingWithJson` project, in `Program.cs`, delete the existing code,
    import the two main namespaces for working with JSON, and then statically import
    the `System.Console`, `System.Environment`, and `System.IO.Path` types, as shown
    in the following code:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithJson`项目中，在`Program.cs`中，删除现有代码，导入用于处理JSON的两个主要命名空间，然后静态导入`System.Console`、`System.Environment`和`System.IO.Path`类型，如下所示：
- en: '[PRE51]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'At the bottom of `Program.cs`, define a class named `Book`, as shown in the
    following code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，定义一个名为`Book`的类，如下所示：
- en: '[PRE52]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Above the `Book` class, add statements to create an instance of the `Book`
    class and serialize it to JSON, as shown in the following code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Book`类上方，添加语句以创建`Book`类的一个实例并将其序列化为JSON，如下所示：
- en: '[PRE53]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE54]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note the following:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下事项：
- en: The JSON file is 315 bytes.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON文件大小为315字节。
- en: The member names use camelCasing, for example, `publishDate`. This is best for
    subsequent processing in a browser with JavaScript.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员名称使用驼峰式大小写，例如`publishDate`。这对后续在JavaScript浏览器中处理最为有利。
- en: All fields are included due to the options set, including `pages`.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于设置的选项，所有字段均被包含，包括`pages`。
- en: JSON is prettified for easier human legibility.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON被美化以提高人类可读性。
- en: '`DateTimeOffset` values are stored as a single standard string format.'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTimeOffset`值以单一标准字符串格式存储。'
- en: '`DateOnly` values are stored as an object with sub-properties for date parts
    like `year` and `month`.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateOnly`值存储为具有`year`和`month`等日期部分的子属性的对象。'
- en: In `Program.cs`, when setting the `JsonSerializerOptions`, comment out the setting
    of casing policy, write indented, and include fields.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，设置`JsonSerializerOptions`时，注释掉大小写策略设置，写入缩进，并包含字段。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE55]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note the following:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下事项：
- en: The JSON file is 230 bytes, a more than 25% reduction.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON文件大小为230字节，减少了超过25%。
- en: The member names use normal casing, for example, `PublishDate`.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员名称使用正常大小写，例如`PublishDate`。
- en: The `Pages` field is missing. The other fields are included due to the `[JsonInclude]`
    attribute on `PublishDate` and `Created` field.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pages`字段缺失。其他字段因`PublishDate`和`Created`字段上的`[JsonInclude]`属性而被包含。'
- en: JSON is compact with minimal whitespace to save bandwidth for transmission or
    storage.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON紧凑，空白字符最少，以节省传输或存储的带宽。
- en: New JSON extension methods for working with HTTP responses
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于处理HTTP响应的新JSON扩展方法
- en: In .NET 5, Microsoft added refinements to the types in the `System.Text.Json`
    namespace like extension methods for `HttpResponse`, which you will see in *Chapter
    16*, *Building and Consuming Web Services*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 5中，微软对`System.Text.Json`命名空间中的类型进行了改进，例如为`HttpResponse`添加了扩展方法，您将在*第16章*，*构建和消费Web服务*中看到。
- en: Migrating from Newtonsoft to new JSON
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Newtonsoft迁移到新JSON
- en: 'If you have existing code that uses the Newtonsoft Json.NET library and you
    want to migrate to the new `System.Text.Json` namespace, then Microsoft has specific
    documentation for that, which you will find at the following link:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现有的代码使用了Newtonsoft Json.NET库，并希望迁移到新的`System.Text.Json`命名空间，那么微软有专门的文档指导，您可以在以下链接找到：
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)'
- en: Practicing and exploring
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践与探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with more in-depth research.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答问题、进行实践操作并深入研究本章主题，测试你的知识和理解。
- en: Exercise 9.1 – Test your knowledge
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What is the difference between using the `File` class and the `FileInfo` class?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`File`类和`FileInfo`类有何不同？
- en: What is the difference between the `ReadByte` method and the `Read` method of
    a stream?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流（stream）的`ReadByte`方法与`Read`方法有何区别？
- en: When would you use the `StringReader`, `TextReader`, and `StreamReader` classes?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时使用`StringReader`、`TextReader`和`StreamReader`类？
- en: What does the `DeflateStream` type do?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DeflateStream`类型有何作用？'
- en: How many bytes per character does UTF-8 encoding use?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: UTF-8编码每个字符使用多少字节？
- en: What is an object graph?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象图（object graph）是什么？
- en: What is the best serialization format to choose for minimizing space requirements?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种序列化格式最适合用于最小化空间需求？
- en: What is the best serialization format to choose for cross-platform compatibility?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种序列化格式最适合用于跨平台兼容性？
- en: Why is it bad to use a `string` value like `"\Code\Chapter01"` to represent
    a path, and what should you do instead?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为何使用`string`值如`"\Code\Chapter01"`来表示路径是不妥的，应如何替代？
- en: Where can you find information about NuGet packages and their dependencies?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于NuGet包及其依赖关系的信息在哪里可以找到？
- en: Exercise 9.2 – Practice serializing as XML
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.2 – 实践XML序列化
- en: 'In the `Chapter09` solution/workspace, create a console application named `Exercise02`
    that creates a list of shapes, uses serialization to save it to the filesystem
    using XML, and then deserializes it back:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter09`解决方案/工作区中，创建一个名为`Exercise02`的控制台应用程序，该程序创建一个形状列表，使用序列化将其保存到文件系统中（使用XML格式），然后进行反序列化：
- en: '[PRE56]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Shapes should have a read-only property named `Area` so that when you deserialize,
    you can output a list of shapes, including their areas, as shown here:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 形状（Shapes）应有一个名为`Area`的只读属性，以便在反序列化时，能输出包含面积的形状列表，如下所示：
- en: '[PRE57]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is what your output should look like when you run your console application:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序时，输出应如下所示：
- en: '[PRE58]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Exercise 9.3 – Explore topics
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.3 – 探索主题
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 利用以下页面上的链接，深入了解本章涉及的主题：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-9---working-with-files-streams-and-serialization](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-9---working-with-files-streams-and-serialization)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章 - 文件、流和序列化](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-9---working-with-files-streams-and-serialization)'
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to read from and write to text files and XML
    files, how to compress and decompress files, how to encode and decode text, and
    how to serialize an object into JSON and XML (and deserialize it back again).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你学习了如何读写文本文件和XML文件，如何压缩和解压缩文件，如何编码和解码文本，以及如何将对象序列化为JSON和XML（并反序列化回来）。
- en: In the next chapter, you will learn how to work with databases using Entity
    Framework Core.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，你将学习如何使用Entity Framework Core操作数据库。
