- en: '07'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '07'
- en: Packaging and Distributing .NET Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和分发 .NET 类型
- en: This chapter is about how C# keywords are related to .NET types, and about the
    relationship between namespaces and assemblies. You'll also become familiar with
    how to package and publish your .NET apps and libraries for cross-platform use,
    how to use legacy .NET Framework libraries in .NET libraries, and the possibility
    of porting legacy .NET Framework code bases to modern .NET.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨 C# 关键字与 .NET 类型之间的关系，以及命名空间与程序集之间的关系。你还将熟悉如何打包和发布你的 .NET 应用和库以供跨平台使用，如何在
    .NET 库中使用遗留的 .NET Framework 库，以及将遗留的 .NET Framework 代码库移植到现代 .NET 的可能性。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: The road to .NET 6
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通往 .NET 6 之路
- en: Understanding .NET components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 .NET 组件
- en: Publishing your applications for deployment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布应用程序以供部署
- en: Decompiling .NET assemblies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反编译 .NET 程序集
- en: Packaging your libraries for NuGet distribution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 NuGet 分发打包你的库
- en: Porting from .NET Framework to modern .NET
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 .NET Framework 迁移到现代 .NET
- en: Working with preview features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预览功能
- en: The road to .NET 6
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通往 .NET 6 之路
- en: This part of the book is about the functionality in the **Base Class Library**
    (**BCL**) APIs provided by .NET and how to reuse functionality across all the
    different .NET platforms using .NET Standard.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分关于 **基类库** (**BCL**) API 提供的功能，以及如何使用 .NET Standard 在所有不同的 .NET 平台上重用功能。
- en: First, we will review the route to this point and why it is important to understand
    the past.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回顾到达此点的路径，并理解过去为何重要。
- en: .NET Core 2.0 and later's support for a minimum of .NET Standard 2.0 is important
    because it provides many of the APIs that were missing from the first version
    of .NET Core. The 15 years' worth of libraries and applications that .NET Framework
    developers had available to them that are relevant for modern development have
    now been migrated to .NET and can run cross-platform on macOS and Linux variants,
    as well as on Windows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 2.0 及更高版本对 .NET Standard 2.0 的最小支持至关重要，因为它提供了 .NET Core 初版中缺失的许多 API。.NET
    Framework 开发者过去 15 年可用的、与现代开发相关的库和应用程序现已迁移至 .NET，并能在 macOS、Linux 变种以及 Windows
    上跨平台运行。
- en: .NET Standard 2.1 added about 3,000 new APIs. Some of those APIs need runtime
    changes that would break backward compatibility, so .NET Framework 4.8 only implements
    .NET Standard 2.0\. .NET Core 3.0, Xamarin, Mono, and Unity implement .NET Standard
    2.1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard 2.1 新增约 3,000 个新 API。其中一些 API 需要运行时变更，这会破坏向后兼容性，因此 .NET Framework
    4.8 仅实现 .NET Standard 2.0。.NET Core 3.0、Xamarin、Mono 和 Unity 实现 .NET Standard
    2.1。
- en: .NET 6 removes the need for .NET Standard if all your projects can use .NET
    6\. Since you might still need to create class libraries for legacy .NET Framework
    projects or legacy Xamarin mobile apps, there is still a need to create .NET Standard
    2.0 and 2.1 class libraries. In March 2021, I surveyed professional developers,
    and half still needed to create .NET Standard 2.0 compliant class libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 消除了对 .NET Standard 的需求，前提是所有项目都能使用 .NET 6。由于你可能仍需为遗留的 .NET Framework
    项目或遗留的 Xamarin 移动应用创建类库，因此仍需创建 .NET Standard 2.0 和 2.1 类库。2021 年 3 月，我调查了专业开发者，其中一半仍需创建符合
    .NET Standard 2.0 的类库。
- en: Now that .NET 6 has been released with preview support for mobile and desktop
    apps built using .NET MAUI, the need for .NET Standard has been further reduced.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 .NET 6 的发布，预览支持使用 .NET MAUI 构建的移动和桌面应用，对 .NET Standard 的需求进一步减少。
- en: 'To summarize the progress that .NET has made over the past five years, I have
    compared the major .NET Core and modern .NET versions with the equivalent .NET
    Framework versions in the following list:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结 .NET 在过去五年中的进展，我已将主要的 .NET Core 和现代 .NET 版本与相应的 .NET Framework 版本进行了比较，如下所示：
- en: '**.NET Core 1.x**: much smaller API compared to .NET Framework 4.6.1, which
    was the current version in March 2016.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core 1.x**：相较于 2016 年 3 月当时的当前版本 .NET Framework 4.6.1，API 规模小得多。'
- en: '**.NET Core 2.x**: reached API parity with .NET Framework 4.7.1 for modern
    APIs because they both implement .NET Standard 2.0.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core 2.x**：与 .NET Framework 4.7.1 实现了现代 API 的 API 对等，因为它们都实现了 .NET Standard
    2.0。'
- en: '**.NET Core 3.x**: larger API compared to .NET Framework for modern APIs because.NET Framework
    4.8 does not implement .NET Standard 2.1.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET Core 3.x**：相较于 .NET Framework，提供了更大的现代 API 集合，因为 .NET Framework 4.8
    不实现 .NET Standard 2.1。'
- en: '**.NET 5**: even larger API compared to .NET Framework 4.8 for modern APIs,
    with much-improved performance.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 5**：相较于 .NET Framework 4.8，提供了更大的现代 API 集合，性能显著提升。'
- en: '**.NET 6**: final unification with the support for mobile apps in .NET MAUI,
    expected by May 2022.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 6**：最终统一，支持.NET MAUI中的移动应用，预计于2022年5月实现。'
- en: .NET Core 1.0
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Core 1.0
- en: .NET Core 1.0 was released in June 2016 and focused on implementing an API suitable
    for building modern cross-platform apps, including web and cloud applications
    and services for Linux using ASP.NET Core.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 1.0 于2016年6月发布，重点在于实现适合构建现代跨平台应用的API，包括为Linux使用ASP.NET Core构建的Web和云应用及服务。
- en: .NET Core 1.1
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Core 1.1
- en: .NET Core 1.1 was released in November 2016 and focused on fixing bugs, increasing
    the number of Linux distributions supported, supporting .NET Standard 1.6, and
    improving performance, especially with ASP.NET Core for web apps and services.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 1.1 于2016年11月发布，主要关注于修复错误、增加支持的Linux发行版数量、支持.NET Standard 1.6，以及提升性能，特别是在使用ASP.NET
    Core构建的Web应用和服务方面。
- en: .NET Core 2.0
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Core 2.0
- en: .NET Core 2.0 was released in August 2017 and focused on implementing .NET Standard
    2.0, the ability to reference .NET Framework libraries, and more performance improvements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 2.0 于2017年8月发布，重点在于实现.NET Standard 2.0，能够引用.NET Framework库，以及更多的性能改进。
- en: The third edition of this book was published in November 2017, so it covered
    up to .NET Core 2.0 and .NET Core for **Universal Windows Platform** (**UWP**)
    apps.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: （本书）第三版于2017年11月出版，涵盖至.NET Core 2.0及用于**通用Windows平台** (**UWP**) 应用的.NET Core。
- en: .NET Core 2.1
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Core 2.1
- en: '.NET Core 2.1 was released in May 2018 and focused on an extendable tooling
    system, adding new types like `Span<T>`, new APIs for cryptography and compression,
    a Windows Compatibility Pack with an additional 20,000 APIs to help port old Windows
    applications, Entity Framework Core value conversions, LINQ `GroupBy` conversions,
    data seeding, query types, and even more performance improvements, including the
    topics listed in the following table:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 2.1 于2018年5月发布，重点在于可扩展的工具系统，新增类型如`Span<T>`，加密和压缩的新API，包含额外20,000个API的Windows兼容包以帮助移植旧Windows应用，Entity
    Framework Core值转换，LINQ `GroupBy` 转换，数据播种，查询类型，以及更多的性能改进，包括下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Spans | 8 | Working with spans, indexes, and ranges |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 跨度 | 8 | 处理跨度、索引和范围 |'
- en: '| Brotli compression | 9 | Compressing with the Brotli algorithm |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Brotli压缩 | 9 | 使用Brotli算法进行压缩 |'
- en: '| Cryptography | 20 | What''s new in cryptography? |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 加密学 | 20 | 加密学有哪些新内容？ |'
- en: '| EF Core Lazy loading | 10 | Enabling lazy loading |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| EF Core 延迟加载 | 10 | 启用延迟加载 |'
- en: '| EF Core Data seeding | 10 | Understanding data seeding |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| EF Core 数据播种 | 10 | 理解数据播种 |'
- en: .NET Core 2.2
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Core 2.2
- en: .NET Core 2.2 was released in December 2018 and focused on diagnostic improvements
    for the runtime, optional tiered compilation, and adding new features to ASP.NET
    Core and Entity Framework Core like spatial data support using types from the
    **NetTopologySuite** (**NTS**) library, query tags, and collections of owned entities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 2.2 于2018年12月发布，重点在于运行时诊断改进、可选的分层编译，以及为ASP.NET Core和Entity Framework
    Core添加新功能，如使用**NetTopologySuite** (**NTS**) 库类型的空间数据支持、查询标签和拥有的实体集合。
- en: .NET Core 3.0
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Core 3.0
- en: '.NET Core 3.0 was released in September 2019 and focused on adding support
    for building Windows desktop applications using Windows Forms (2001), **Windows
    Presentation Foundation** (**WPF**; 2006), and Entity Framework 6.3, side-by-side
    and app-local deployments, a fast JSON reader, serial port access and other pinout
    access for **Internet of Things** (**IoT**) solutions, and tiered compilation
    by default, including the topics listed in the following table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 3.0 于2019年9月发布，重点在于增加对使用Windows Forms (2001)、**Windows Presentation
    Foundation** (**WPF**; 2006) 和Entity Framework 6.3构建Windows桌面应用的支持，支持并行和应用本地部署，快速的JSON阅读器，串口访问和其他引脚访问，用于**物联网**
    (**IoT**) 解决方案，以及默认的分层编译，包括下表中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Embedding .NET in-app | 7 | Publishing your applications for deployment |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 应用内嵌.NET | 7 | 发布您的应用程序以供部署 |'
- en: '| `Index` and `Range` | 8 | Working with spans, indexes, and ranges |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `Index` 和 `Range` | 8 | 处理跨度、索引和范围 |'
- en: '| `System.Text.Json` | 9 | High-performance JSON processing |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `System.Text.Json` | 9 | 高性能JSON处理 |'
- en: '| Async streams | 12 | Working with async streams |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 异步流 | 12 | 处理异步流 |'
- en: The fourth edition of this book was published in October 2019, so it covered
    some of the new APIs added in later versions up to .NET Core 3.0.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: （本书）第四版于2019年10月出版，因此涵盖了后续版本中添加的一些新API，直至.NET Core 3.0。
- en: .NET Core 3.1
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Core 3.1
- en: .NET Core 3.1 was released in December 2019 and focused on bug fixes and refinements
    so that it could be a **Long Term Support** (**LTS**) release, not losing support
    until December 2022.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 3.1 于 2019 年 12 月发布，专注于 bug 修复和优化，以便成为 **长期支持** (**LTS**) 版本，直至 2022
    年 12 月才停止支持。
- en: .NET 5.0
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 5.0
- en: '.NET 5.0 was released in November 2020 and focused on unifying the various
    .NET platforms except mobile, refining the platform, and improving performance,
    including the topics listed in the following table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5.0 于 2020 年 11 月发布，专注于统一除移动平台外的各种 .NET 平台，优化平台，并提升性能，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| `Half` type | 8 | Working with numbers |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Half` 类型 | 8 | 数值操作 |'
- en: '| Regular expression performance improvements | 8 | Regular expression performance
    improvements |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式性能提升 | 8 | 正则表达式性能提升 |'
- en: '| `System.Text.Json` improvements | 9 | High-performance JSON processing |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `System.Text.Json` 性能改进 | 9 | 高效处理 JSON |'
- en: '| EF Core generated SQL | 10 | Getting the generated SQL |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| EF Core 生成的 SQL | 10 | 获取生成的 SQL |'
- en: '| EF Core Filtered Include | 10 | Filtering included entities |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| EF Core 筛选包含 | 10 | 筛选包含的实体 |'
- en: '| EF Core Scaffold-DbContext now singularizes using Humanizer | 10 | Scaffolding
    models using an existing database |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| EF Core Scaffold-DbContext 现使用 Humanizer 进行单数化 | 10 | 基于现有数据库生成模型 |'
- en: .NET 6.0
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 6.0
- en: '.NET 6.0 was released in November 2021 and focused on unifying with the mobile
    platform, adding more features to EF Core for data management, and improving performance,
    including the topics listed in the following table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6.0 于 2021 年 11 月发布，重点在于与移动平台统一，为 EF Core 的数据管理添加更多功能，并提升性能，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Check .NET SDK status | 7 | Checking your .NET SDKs for updates |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 检查 .NET SDK 状态 | 7 | 检查 .NET SDK 更新 |'
- en: '| Support for Apple Silicon | 7 | Creating a console application to publish
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 对 Apple Silicon 的支持 | 7 | 创建控制台应用程序发布 |'
- en: '| Link trim mode as default | 7 | Reducing the size of apps using app trimming
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 默认链接修剪模式 | 7 | 使用应用修剪减小应用大小 |'
- en: '| `DateOnly` and `TimeOnly` | 8 | Specifying date and time values |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `DateOnly` 和 `TimeOnly` | 8 | 指定日期和时间值 |'
- en: '| `EnsureCapacity` for `List<T>` | 8 | Improving performance by ensuring the
    capacity of a collection |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `List<T>` 的 `EnsureCapacity` | 8 | 通过确保集合容量提升性能 |'
- en: '| EF Core configure conventions | 10 | Configuring preconvention models |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| EF Core 配置约定 | 10 | 配置预约定模型 |'
- en: '| New LINQ methods | 11 | Building LINQ expressions with the Enumerable class
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 新增 LINQ 方法 | 11 | 使用 Enumerable 类构建 LINQ 表达式 |'
- en: Improving performance from .NET Core 2.0 to .NET 5
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 .NET Core 2.0 到 .NET 5 的性能提升
- en: 'Microsoft has made significant improvements to performance in the past few
    years. You can read a detailed blog post at the following link: [https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在过去几年中对性能进行了重大改进。您可以在以下链接阅读详细博客文章：[https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-5/)。
- en: Checking your .NET SDKs for updates
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 .NET SDK 更新
- en: 'With .NET 6, Microsoft added a command to check the versions of .NET SDKs and
    runtimes that you have installed and warn you if any need updating. For example,
    you enter the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .NET 6，微软添加了一个命令来检查已安装的 .NET SDK 和运行时版本，并在需要更新时发出警告。例如，您输入以下命令：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will then see results, including the status of available updates, as shown
    in the following partial output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，您将看到包括可用更新状态在内的结果，如下所示的部分输出：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Understanding .NET components
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 .NET 组件
- en: '.NET is made up of several pieces, which are shown in the following list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 由多个部分组成，如下所示：
- en: '**Language compilers**: These turn your source code written with languages
    such as C#, F#, and Visual Basic into **intermediate language** (**IL**) code
    stored in assemblies. With C# 6.0 and later, Microsoft switched to an open-source
    rewritten compiler known as Roslyn that is also used by Visual Basic.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言编译器**：这些编译器将使用 C#、F# 和 Visual Basic 等语言编写的源代码转换为 **中间语言** (**IL**) 代码，存储在程序集中。使用
    C# 6.0 及更高版本，微软转向了名为 Roslyn 的开源重写编译器，该编译器也用于 Visual Basic。'
- en: '**Common Language Runtime (CoreCLR)**: This runtime loads assemblies, compiles
    the IL code stored in them into native code instructions for your computer''s
    CPU, and executes the code within an environment that manages resources such as
    threads and memory.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共语言运行时（CoreCLR）**：此运行时加载程序集，将存储在其中的IL代码编译为计算机CPU的本地代码指令，并在管理线程和内存等资源的环境中执行代码。'
- en: '**Base Class Libraries (BCL or CoreFX)**: These are prebuilt assemblies of
    types packaged and distributed using NuGet for performing common tasks when building
    applications. You can use them to quickly build anything you want, rather like
    combining LEGO™ pieces. .NET Core 2.0 implemented .NET Standard 2.0, which is
    a superset of all previous versions of .NET Standard, and lifted .NET Core up
    to parity with .NET Framework and Xamarin. .NET Core 3.0 implemented .NET Standard
    2.1, which added new capabilities and enables performance improvements beyond
    those available in .NET Framework. .NET 6 implements a unified BCL across all
    types of apps, including mobile.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基类库（BCL或CoreFX）**：这些是预构建的类型集合，通过NuGet打包和分发，用于在构建应用程序时执行常见任务。你可以使用它们快速构建任何你想要的东西，就像组合乐高™积木一样。.NET
    Core 2.0实现了.NET标准2.0，它是所有先前版本的.NET标准的超集，并将.NET Core提升到与.NET Framework和Xamarin平齐。.NET
    Core 3.0实现了.NET标准2.1，增加了新的功能，并实现了在.NET Framework中不可用的性能改进。.NET 6在所有类型的应用程序中实现了一个统一的BCL，包括移动应用。'
- en: Understanding assemblies, NuGet packages, and namespaces
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解程序集、NuGet包和命名空间
- en: An **assembly** is where a type is stored in the filesystem. Assemblies are
    a mechanism for deploying code. For example, the `System.Data.dll` assembly contains
    types for managing data. To use types in other assemblies, they must be referenced.
    Assemblies can be static (pre-created) or dynamic (generated at runtime). Dynamic
    assemblies are an advanced feature that we will not cover in this book. Assemblies
    can be compiled into a single file as a DLL (class library) or an EXE (console
    app).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序集**是类型在文件系统中存储的位置。程序集是一种部署代码的机制。例如，`System.Data.dll`程序集包含管理数据的类型。要使用其他程序集中的类型，必须引用它们。程序集可以是静态的（预先创建的）或动态的（在运行时生成的）。动态程序集是一个高级特性，本书中不会涉及。程序集可以编译成单个文件，作为DLL（类库）或EXE（控制台应用）。'
- en: Assemblies are distributed as **NuGet packages**, which are files downloadable
    from public online feeds and can contain multiple assemblies and other resources.
    You will also hear about **project SDKs**, **workloads**, and **platforms**, which
    are combinations of NuGet packages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集作为**NuGet包**分发，这些是可以从公共在线源下载的文件，可以包含多个程序集和其他资源。你还会听到关于**项目SDK**、**工作负载**和**平台**的说法，这些都是NuGet包的组合。
- en: 'Microsoft''s NuGet feed is found here: [https://www.nuget.org/](https://www.nuget.org/).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft的NuGet源在这里：[https://www.nuget.org/](https://www.nuget.org/)。
- en: What is a namespace?
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是命名空间？
- en: A namespace is the address of a type. Namespaces are a mechanism to uniquely
    identify a type by requiring a full address rather than just a short name. In
    the real world, *Bob of 34 Sycamore Street* is different from *Bob of 12 Willow
    Drive*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是类型的地址。命名空间是一种机制，通过要求完整的地址而不是简短的名称来唯一标识类型。在现实世界中，*34号梧桐街的鲍勃*与*12号柳树道的鲍勃*是不同的。
- en: In .NET, the `IActionFilter` interface of the `System.Web.Mvc` namespace is
    different from the `IActionFilter` interface of the `System.Web.Http.Filters`
    namespace.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，`System.Web.Mvc`命名空间中的`IActionFilter`接口与`System.Web.Http.Filters`命名空间中的`IActionFilter`接口不同。
- en: Understanding dependent assemblies
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解依赖的程序集
- en: If an assembly is compiled as a class library and provides types for other assemblies
    to use, then it has the file extension `.dll` (**dynamic link library**), and
    it cannot be executed standalone.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序集被编译为类库并提供类型供其他程序集使用，那么它具有文件扩展名`.dll`（**动态链接库**），并且不能独立执行。
- en: Likewise, if an assembly is compiled as an application, then it has the file
    extension `.exe` (**executable**) and can be executed standalone. Before .NET
    Core 3.0, console apps were compiled to `.dll` files and had to be executed by
    the `dotnet run` command or a host executable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果一个程序集被编译为应用程序，那么它具有文件扩展名`.exe`（**可执行文件**），并且可以独立执行。在.NET Core 3.0之前，控制台应用被编译为`.dll`文件，必须通过`dotnet
    run`命令或宿主可执行文件来执行。
- en: Any assembly can reference one or more class library assemblies as dependencies,
    but you cannot have circular references. So, assembly *B* cannot reference assembly
    *A* if assembly *A* already references assembly *B*. The compiler will warn you
    if you attempt to add a dependency reference that would cause a circular reference.
    Circular references are often a warning sign of poor code design. If you are sure
    that you need a circular reference, then use an interface to solve it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序集都可以引用一个或多个类库程序集作为依赖项，但不能有循环引用。因此，如果程序集*A*已经引用程序集*B*，则程序集*B*不能引用程序集*A*。如果您尝试添加会导致循环引用的依赖项引用，编译器会警告您。循环引用通常是代码设计不良的警告信号。如果您确定需要循环引用，则使用接口来解决它。
- en: Understanding the Microsoft .NET project SDKs
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Microsoft .NET项目SDKs
- en: By default, console applications have a dependency reference on the Microsoft
    .NET project SDK. This platform contains thousands of types in NuGet packages
    that almost all applications would need, such as the `System.Int32` and `System.String`
    types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控制台应用程序对Microsoft .NET项目SDK有依赖引用。该平台包含数千种类型，几乎所有应用程序都需要这些类型，例如`System.Int32`和`System.String`类型。
- en: When using .NET, you reference the dependency assemblies, NuGet packages, and
    platforms that your application needs in a project file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用.NET时，您在项目文件中引用应用程序所需的依赖程序集、NuGet包和平台。
- en: 'Let''s explore the relationship between assemblies and namespaces:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨程序集和命名空间之间的关系：
- en: Use your preferred code editor to create a new solution/workspace named `Chapter07`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器创建一个名为`Chapter07`的新解决方案/工作区。
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用项目，如下表所定义：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter07`'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter07`
- en: 'Project file and folder: `AssembliesAndNamespaces`'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`AssembliesAndNamespaces`
- en: 'Open `AssembliesAndNamespaces.csproj` and note that it is a typical project
    file for a .NET 6 application, as shown in the following markup:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AssembliesAndNamespaces.csproj`并注意，它是一个典型的.NET 6应用程序项目文件，如下所示：
- en: '[PRE2]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Understanding namespaces and types in assemblies
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解程序集中的命名空间和类型
- en: 'Many common .NET types are in the `System.Runtime.dll` assembly. There is not
    always a one-to-one mapping between assemblies and namespaces. A single assembly
    can contain many namespaces and a namespace can be defined in many assemblies.
    You can see the relationship between some assemblies and the namespaces that they
    supply types for, as shown in the following table:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的.NET类型位于`System.Runtime.dll`程序集中。程序集和命名空间之间并不总是存在一对一的映射。单个程序集可以包含多个命名空间，一个命名空间也可以在多个程序集中定义。您可以查看一些程序集与其提供的类型的命名空间之间的关系，如下表所示：
- en: '| Assembly | Example namespaces | Example types |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 程序集 | 示例命名空间 | 示例类型 |'
- en: '| `System.Runtime.dll` | `System`, `System.Collections`, `System.Collections.Generic`
    | `Int32`, `String`, `IEnumerable<T>` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `System.Runtime.dll` | `System`, `System.Collections`, `System.Collections.Generic`
    | `Int32`, `String`, `IEnumerable<T>` |'
- en: '| `System.Console.dll` | `System` | `Console` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `System.Console.dll` | `System` | `Console` |'
- en: '| `System.Threading.dll` | `System.Threading` | `Interlocked`, `Monitor`, `Mutex`
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `System.Threading.dll` | `System.Threading` | `Interlocked`, `Monitor`, `Mutex`
    |'
- en: '| `System.Xml.XDocument.dll` | `System.Xml.Linq` | `XDocument`, `XElement`,
    `XNode` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `System.Xml.XDocument.dll` | `System.Xml.Linq` | `XDocument`, `XElement`,
    `XNode` |'
- en: Understanding NuGet packages
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解NuGet包
- en: .NET is split into a set of packages, distributed using a Microsoft-supported
    package management technology named NuGet. Each of these packages represents a
    single assembly of the same name. For example, the `System.Collections` package
    contains the `System.Collections.dll` assembly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: .NET被拆分为一组包，使用名为NuGet的微软支持的包管理技术进行分发。这些包中的每一个都代表一个同名的单一程序集。例如，`System.Collections`包包含`System.Collections.dll`程序集。
- en: 'The following are the benefits of packages:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包的好处：
- en: Packages can be easily distributed on public feeds.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以轻松地在公共源中分发。
- en: Packages can be reused.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以重复使用。
- en: Packages can ship on their own schedule.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以按照自己的时间表发货。
- en: Packages can be tested independently of other packages.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以独立于其他包进行测试。
- en: Packages can support different OSes and CPUs by including multiple versions
    of the same assembly built for different OSes and CPUs.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过包含为不同操作系统和CPU构建的同一程序集的多个版本，包可以支持不同的操作系统（OSes）和CPU。
- en: Packages can have dependencies specific to only one library.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包可以有仅针对一个库的特定依赖项。
- en: 'Apps are smaller because unreferenced packages aren''t part of the distribution.
    The following table lists some of the more important packages and their important
    types:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用体积更小，因为未引用的包不包含在分发中。下表列出了一些较重要的包及其重要类型：
- en: '| Package | Important types |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 包 | 重要类型 |'
- en: '| `System.Runtime` | `Object`, `String`, `Int32`, `Array` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `System.Runtime` | `Object`，`String`，`Int32`，`Array` |'
- en: '| `System.Collections` | `List<T>`, `Dictionary<TKey, TValue>` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections` | `List<T>`，`Dictionary<TKey, TValue>` |'
- en: '| `System.Net.Http` | `HttpClient`, `HttpResponseMessage` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.Http` | `HttpClient`，`HttpResponseMessage` |'
- en: '| `System.IO.FileSystem` | `File`, `Directory` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `System.IO.FileSystem` | `File`，`Directory` |'
- en: '| `System.Reflection` | `Assembly`, `TypeInfo`, `MethodInfo` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `System.Reflection` | `Assembly`，`TypeInfo`，`MethodInfo` |'
- en: Understanding frameworks
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解框架
- en: There is a two-way relationship between frameworks and packages. Packages define
    the APIs, while frameworks group packages. A framework without any packages would
    not define any APIs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 框架与包之间存在双向关系。包定义API，而框架则整合包。一个没有任何包的框架不会定义任何API。
- en: '.NET packages each support a set of frameworks. For example, the `System.IO.FileSystem`
    package version 4.3.0 supports the following frameworks:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: .NET包各自支持一组框架。例如，`System.IO.FileSystem`包版本4.3.0支持以下框架：
- en: .NET Standard, version 1.3 or later.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Standard，版本1.3或更高。
- en: .NET Framework, version 4.6 or later.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Framework，版本4.6或更高。
- en: Six Mono and Xamarin platforms (for example, Xamarin.iOS 1.0).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个Mono和Xamarin平台（例如，Xamarin.iOS 1.0）。
- en: '**More Information**: You can read the details at the following link: [https://www.nuget.org/packages/System.IO.FileSystem/](https://www.nuget.org/packages/System.IO.FileSystem/).'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**更多信息**：你可以在以下链接阅读详细信息：[https://www.nuget.org/packages/System.IO.FileSystem/](https://www.nuget.org/packages/System.IO.FileSystem/)。'
- en: Importing a namespace to use a type
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命名空间以使用类型
- en: 'Let''s explore how namespaces are related to assemblies and types:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨命名空间与程序集和类型之间的关系：
- en: 'In the `AssembliesAndNamespaces` project, in `Program.cs`, enter the following
    code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AssembliesAndNamespaces`项目中，在`Program.cs`文件里，输入以下代码：
- en: '[PRE3]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Build the project and note the compiler error message, as shown in the following
    output:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意编译器错误信息，如下所示：
- en: '[PRE4]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `XDocument` type is not recognized because we have not told the compiler
    what the namespace of the type is. Although this project already has a reference
    to the assembly that contains the type, we also need to either prefix the type
    name with its namespace or import the namespace.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`XDocument`类型未被识别，因为我们没有告诉编译器该类型的命名空间是什么。尽管此项目已有一个指向包含该类型的程序集的引用，我们还需通过在其类型名前加上命名空间或导入命名空间来解决。'
- en: Click inside the `XDocument` class name. Your code editor displays a light bulb,
    showing that it recognizes the type and can automatically fix the problem for
    you.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`XDocument`类名内部。你的代码编辑器会显示一个灯泡图标，表明它识别了该类型，并能自动为你修复问题。
- en: Click the light bulb, and select `using System.Xml.Linq;` from the menu.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击灯泡图标，并从菜单中选择`using System.Xml.Linq;`。
- en: This will *import the namespace* by adding a `using` statement to the top of
    the file. Once a namespace is imported at the top of a code file, then all the
    types within the namespace are available for use in that code file by just typing
    their name without the type name needing to be fully qualified by prefixing it
    with its namespace.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将*通过在文件顶部添加`using`语句来导入命名空间*。一旦在代码文件顶部导入了命名空间，那么该命名空间内的所有类型在该代码文件中只需输入其名称即可使用，无需通过在其名称前加上命名空间来完全限定类型名。
- en: 'Sometimes I like to add a comment with a type name after importing a namespace
    to remind me why I need to import that namespace, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我喜欢在导入命名空间后添加一个带有类型名的注释，以提醒我为何需要导入该命名空间，如下所示：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Relating C# keywords to .NET types
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将C#关键字关联到.NET类型
- en: One of the common questions I get from new C# programmers is, "What is the difference
    between `string` with a lowercase s and `String` with an uppercase S?"
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我常从初学C#的程序员那里得到的一个常见问题是：“`string`（小写s）和`String`（大写S）之间有什么区别？”
- en: 'The short answer is easy: none. The long answer is that all C# type keywords
    like `string` or `int` are aliases for a .NET type in a class library assembly.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案是：没有区别。详细的答案是，所有C#类型关键字，如`string`或`int`，都是.NET类库程序集中某个类型的别名。
- en: When you use the `string` keyword, the compiler recognizes it as a `System.String`
    type. When you use the `int` type, the compiler recognizes it as a `System.Int32`
    type.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`string`关键字时，编译器将其识别为`System.String`类型。当你使用`int`类型时，编译器将其识别为`System.Int32`类型。
- en: 'Let''s see this in action with some code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码来实际看看：
- en: 'In `Program.cs`, declare two variables to hold `string` values, one using lowercase
    `string` and one using uppercase `String`, as shown in the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，声明两个变量以保存`string`值，一个使用小写的`string`，另一个使用大写的`String`，如下列代码所示：
- en: '[PRE6]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the code, and note that at the moment, they both work equally well, and
    literally mean the same thing.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意目前它们两者工作效果相同，实际上意味着相同的事情。
- en: 'In `AssembliesAndNamespaces.csproj`, add entries to prevent the `System` namespace
    from being globally imported, as shown in the following markup:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AssembliesAndNamespaces.csproj`中，添加条目以防止全局导入`System`命名空间，如下列标记所示：
- en: '[PRE7]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `Program.cs` note the compiler error message, as shown in the following
    output:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中注意编译器错误消息，如下列输出所示：
- en: '[PRE8]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the top of `Program.cs`, import the `System` namespace with a `using` statement
    that will fix the error, as shown in the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，使用`using`语句导入`System`命名空间以修复错误，如下列代码所示：
- en: '[PRE9]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Good Practice**: When you have a choice, use the C# keyword instead of the
    actual type because the keywords do not need the namespace imported.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：当有选择时，使用 C# 关键字而非实际类型，因为关键字不需要导入命名空间。'
- en: Mapping C# aliases to .NET types
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 别名映射到 .NET 类型
- en: 'The following table shows the 18 C# type keywords along with their actual .NET
    types:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了 18 个 C# 类型关键字及其对应的实际 .NET 类型：
- en: '| Keyword | .NET type | Keyword | .NET type |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | .NET 类型 | 关键字 | .NET 类型 |'
- en: '| `string` | `System.String` | `char` | `System.Char` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `System.String` | `char` | `System.Char` |'
- en: '| `sbyte` | `System.SByte` | `byte` | `System.Byte` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | `System.SByte` | `byte` | `System.Byte` |'
- en: '| `short` | `System.Int16` | `ushort` | `System.UInt16` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `System.Int16` | `ushort` | `System.UInt16` |'
- en: '| `int` | `System.Int32` | `uint` | `System.UInt32` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `System.Int32` | `uint` | `System.UInt32` |'
- en: '| `long` | `System.Int64` | `ulong` | `System.UInt64` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `System.Int64` | `ulong` | `System.UInt64` |'
- en: '| `nint` | `System.IntPtr` | `nuint` | `System.UIntPtr` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `nint` | `System.IntPtr` | `nuint` | `System.UIntPtr` |'
- en: '| `float` | `System.Single` | `double` | `System.Double` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `System.Single` | `double` | `System.Double` |'
- en: '| `decimal` | `System.Decimal` | `bool` | `System.Boolean` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | `System.Decimal` | `bool` | `System.Boolean` |'
- en: '| `object` | `System.Object` | `dynamic` | `System.Dynamic.DynamicObject` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `object` | `System.Object` | `dynamic` | `System.Dynamic.DynamicObject` |'
- en: Other .NET programming language compilers can do the same thing. For example,
    the Visual Basic .NET language has a type named `Integer` that is its alias for
    `System.Int32`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 .NET 编程语言编译器也能做到同样的事情。例如，Visual Basic .NET 语言有一个名为`Integer`的类型，它是`System.Int32`的别名。
- en: Understanding native-sized integers
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解原生大小整数
- en: C# 9 introduced `nint` and `nuint` keyword alias for **native-sized integers**,
    meaning that the storage size for the integer value is platform specific. They
    store a 32-bit integer in a 32-bit process and `sizeof()` returns 4 bytes; they
    store a 64-bit integer in a 64-bit process and `sizeof()` returns 8 bytes. The
    aliases represent pointers to the integer value in memory, which is why their
    .NET names are `IntPtr` and `UIntPtr`. The actual storage type will be either
    `System.Int32` or `System.Int64` depending on the process.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9 引入了`nint`和`nuint`关键字别名，用于**原生大小整数**，意味着整数值的存储大小是平台特定的。它们在 32 位进程中存储 32
    位整数，`sizeof()`返回 4 字节；在 64 位进程中存储 64 位整数，`sizeof()`返回 8 字节。这些别名代表内存中整数值的指针，这就是为什么它们的
    .NET 名称是`IntPtr`和`UIntPtr`。实际存储类型将根据进程是`System.Int32`还是`System.Int64`。
- en: 'In a 64-bit process, the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位进程中，下列代码：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'produces this output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 产生此输出：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Revealing the location of a type
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 揭示类型的位置
- en: 'Code editors provide built-in documentation for .NET types. Let''s explore:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑器为 .NET 类型提供内置文档。我们来探索一下：
- en: Right-click inside `XDocument` and choose **Go to Definition**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`XDocument`内部右键单击并选择**转到定义**。
- en: Navigate to the top of the code file and note the assembly filename is `System.Xml.XDocument.dll`,
    but the class is in the `System.Xml.Linq` namespace, as shown in *Figure 7.1*:![Graphical
    user interface, text, application, email  Description automatically generated](img/B17442_07_01.png)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到代码文件顶部，并注意程序集文件名为`System.Xml.XDocument.dll`，但类位于`System.Xml.Linq`命名空间中，如*图
    7.1*所示：![图形用户界面，文本，应用程序，电子邮件 描述自动生成](img/B17442_07_01.png)
- en: 'Figure 7.1: Assembly and namespace that contains the XDocument type'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.1：包含 XDocument 类型的程序集和命名空间
- en: Close the **XDocument [from metadata]** tab.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**XDocument [来自元数据]**选项卡。
- en: Right-click inside `string` or `String` and choose **Go to Definition**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`string`或`String`内部右键单击并选择**转到定义**。
- en: Navigate to the top of the code file and note the assembly filename is `System.Runtime.dll`
    but the class is in the `System` namespace.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至代码文件顶部，注意程序集文件名为`System.Runtime.dll`，但类位于`System`命名空间中。
- en: Actually, your code editor is technically lying to you. If you remember when
    we wrote code in *Chapter 2*, *Speaking C#*, when we revealed the extent of the
    C# vocabulary, we discovered that the `System.Runtime.dll` assembly contains zero
    types.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你的代码编辑器在技术上对你撒了谎。如果你还记得我们在*第2章*，*讲C#*中编写代码时，当我们揭示C#词汇的范围时，我们发现`System.Runtime.dll`程序集中不包含任何类型。
- en: What it does contain are type-forwarders. These are special types that appear
    to exist in an assembly but actually are implemented elsewhere. In this case,
    they are implemented deep inside the .NET runtime using highly optimized code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含的是类型转发器。这些特殊类型看似存在于一个程序集中，但实际上在别处实现。在这种情况下，它们在.NET运行时内部深处使用高度优化的代码实现。
- en: Sharing code with legacy platforms using .NET Standard
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET Standard与遗留平台共享代码
- en: Before .NET Standard, there were **Portable Class Libraries** (**PCLs**). With
    PCLs, you could create a library of code and explicitly specify which platforms
    you want the library to support, such as Xamarin, Silverlight, and Windows 8\.
    Your library could then use the intersection of APIs that are supported by the
    specified platforms.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard出现之前，有**便携式类库**（**PCLs**）。使用PCLs，你可以创建一个代码库，并明确指定希望该库支持的平台，如Xamarin、Silverlight和Windows
    8。你的库随后可以使用这些指定平台所支持的API交集。
- en: Microsoft realized that this is unsustainable, so they created .NET Standard—a
    single API that all future .NET platforms would support. There are older versions
    of .NET Standard, but .NET Standard 2.0 was an attempt to unify all important
    recent .NET platforms. .NET Standard 2.1 was released in late 2019 but only .NET
    Core 3.0 and that year's version of Xamarin support its new features. For the
    rest of this book, I will use the term .NET Standard to mean .NET Standard 2.0.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 微软意识到这是不可持续的，因此他们创建了.NET Standard——一个所有未来.NET平台都将支持的单一API。有较早版本的.NET Standard，但.NET
    Standard 2.0试图统一所有重要的近期.NET平台。.NET Standard 2.1于2019年底发布，但只有.NET Core 3.0和当年版本的Xamarin支持其新特性。在本书的其余部分，我将使用.NET
    Standard来指代.NET Standard 2.0。
- en: .NET Standard is similar to HTML5 in that they are both standards that a platform
    should support. Just as Google's Chrome browser and Microsoft's Edge browser implement
    the HTML5 standard, .NET Core, .NET Framework, and Xamarin all implement .NET
    Standard. If you want to create a library of types that will work across variants
    of legacy .NET, you can do so most easily with .NET Standard.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Standard类似于HTML5，它们都是平台应支持的标准。正如谷歌的Chrome浏览器和微软的Edge浏览器实现HTML5标准一样，.NET
    Core、.NET Framework和Xamarin都实现.NET Standard。如果你想创建一个能在遗留.NET各变体间工作的类型库，最简便的方法就是使用.NET
    Standard。
- en: '**Good Practice**: Since many of the API additions in .NET Standard 2.1 required
    runtime changes, and .NET Framework is Microsoft''s legacy platform that needs
    to remain as unchanging as possible, .NET Framework 4.8 remained on .NET Standard
    2.0 rather than implementing .NET Standard 2.1\. If you need to support .NET Framework
    customers, then you should create class libraries on .NET Standard 2.0 even though
    it is not the latest and does not support all the recent language and BCL new
    features.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：由于.NET Standard 2.1中的许多API新增内容需要运行时变更，而.NET Framework作为微软的遗留平台，需要尽可能保持不变，因此.NET
    Framework 4.8仍停留在.NET Standard 2.0，并未实现.NET Standard 2.1。若需支持.NET Framework用户，则应基于.NET
    Standard 2.0创建类库，尽管它不是最新版本，也不支持所有近期的语言和BCL新特性。'
- en: Your choice of which .NET Standard version to target comes down to a balance
    between maximizing platform support and available functionality. A lower version
    supports more platforms but has a smaller set of APIs. A higher version supports
    fewer platforms but has a larger set of APIs. Generally, you should choose the
    lowest version that supports all the APIs that you need.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 选择针对哪个.NET Standard版本，取决于在最大化平台支持和可用功能之间的权衡。较低版本支持更多平台，但API集较小；较高版本支持的平台较少，但API集更大。通常，应选择支持所需所有API的最低版本。
- en: Understanding defaults for class libraries with different SDKs
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解不同SDK下类库的默认设置
- en: 'When using the `dotnet` SDK tool to create a class library it might be useful
    to know which target framework will be used by default, as shown in the following
    table:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`dotnet` SDK工具创建类库时，了解默认使用的目标框架可能会有所帮助，如下表所示：
- en: '| SDK | Default target framework for new class libraries |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| SDK | 新类库的默认目标框架 |'
- en: '| .NET Core 3.1 | `netstandard2.0` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| .NET Core 3.1 | `netstandard2.0` |'
- en: '| .NET 5 | `net5.0` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| .NET 5 | `net5.0` |'
- en: '| .NET 6 | `net6.0` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| .NET 6 | `net6.0` |'
- en: Of course, just because a class library targets a specific version of .NET by
    default does not mean you cannot change it after creating a class library project
    using the default template.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅因为类库默认面向特定版本的 .NET，并不意味着在创建使用默认模板的类库项目后不能更改它。
- en: 'You can manually set the target framework to a value that supports the projects
    that need to reference that library, as shown in the following table:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动将目标框架设置为支持需要引用该库的项目的值，如下表所示：
- en: '| Class library target framework | Can be used by projects that target |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 类库目标框架 | 可用于面向以下版本的项目 |'
- en: '| `netstandard2.0` | .NET Framework 4.6.1 or later, .NET Core 2.0 or later,
    .NET 5.0 or later, Mono 5.4 or later, Xamarin.Android 8.0 or later, Xamarin.iOS
    10.14 or later |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `netstandard2.0` | .NET Framework 4.6.1 或更高版本，.NET Core 2.0 或更高版本，.NET 5.0
    或更高版本，Mono 5.4 或更高版本，Xamarin.Android 8.0 或更高版本，Xamarin.iOS 10.14 或更高版本 |'
- en: '| `netstandard2.1` | .NET Core 3.0 or later, .NET 5.0 or later, Mono 6.4 or
    later, Xamarin.Android 10.0 or later, Xamarin.iOS 12.16 or later |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `netstandard2.1` | .NET Core 3.0 或更高版本，.NET 5.0 或更高版本，Mono 6.4 或更高版本，Xamarin.Android
    10.0 或更高版本，Xamarin.iOS 12.16 或更高版本 |'
- en: '| `net5.0` | .NET 5.0 or later |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `net5.0` | .NET 5.0 或更高版本 |'
- en: '| `net6.0` | .NET 6.0 or later |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `net6.0` | .NET 6.0 或更高版本 |'
- en: '**Good Practice**: Always check the target framework of a class library and
    then manually change it to something more appropriate if necessary. Make a conscious
    decision about what it should be rather than accept the default.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：始终检查类库的目标框架，并在必要时手动将其更改为更合适的选项。要有意识地决定它应该是什么，而不是接受默认值。'
- en: Creating a .NET Standard 2.0 class library
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 .NET Standard 2.0 类库
- en: 'We will create a class library using .NET Standard 2.0 so that it can be used
    across all important .NET legacy platforms and cross-platform on Windows, macOS,
    and Linux operating systems, while also having access to a wide set of .NET APIs:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个使用 .NET Standard 2.0 的类库，以便它可以在所有重要的 .NET 遗留平台上以及在 Windows、macOS 和 Linux
    操作系统上跨平台使用，同时还可以访问广泛的 .NET API 集：
- en: Use your preferred code editor to add a new class library named `SharedLibrary`
    to the `Chapter07` solution/workspace.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向 `Chapter07` 解决方案/工作区添加一个名为 `SharedLibrary` 的新类库。
- en: If you use Visual Studio 2022, when prompted for the **Target Framework**, select
    **.NET Standard 2.0**, and then set the startup project for the solution to the
    current selection.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是 Visual Studio 2022，当提示选择**目标框架**时，请选择 **.NET Standard 2.0**，然后将解决方案的启动项目设置为当前选择。
- en: 'If you use Visual Studio Code, include a switch to target .NET Standard 2.0,
    as shown in the following command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是 Visual Studio Code，请包含一个目标为 .NET Standard 2.0 的开关，如下面的命令所示：
- en: '[PRE12]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you use Visual Studio Code, select `SharedLibrary` as the active OmniSharp
    project.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是 Visual Studio Code，请选择 `SharedLibrary` 作为活动的 OmniSharp 项目。
- en: '**Good Practice**: If you need to create types that use new features in .NET
    6.0, as well as types that only use .NET Standard 2.0 features, then you can create
    two separate class libraries: one targeting .NET Standard 2.0 and one targeting
    .NET 6.0\. You will see this in action in *Chapter 10*, *Working with Data Using
    Entity Framework Core*.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：如果您需要创建使用 .NET 6.0 新功能的类型，以及仅使用 .NET Standard 2.0 功能的类型，那么您可以创建两个单独的类库：一个面向
    .NET Standard 2.0，另一个面向 .NET 6.0。您将在*第 10 章*，*使用 Entity Framework Core 处理数据*中看到这一操作。'
- en: 'An alternative to manually creating two class libraries is to create one that
    supports multi-targeting. If you would like me to add a section about multi-targeting
    to the next edition, please let me know. You can read about multi-targeting here:
    [https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建两个类库的替代方法是创建一个支持多目标的类库。如果您希望我在下一版中添加关于多目标的章节，请告诉我。您可以在这里阅读关于多目标的信息：[https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting#multi-targeting)。
- en: Controlling the .NET SDK
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制 .NET SDK
- en: By default, executing `dotnet` commands uses the most recent installed .NET
    SDK. There may be times when you want to control which SDK is used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，执行 `dotnet` 命令使用最新安装的 .NET SDK。有时您可能希望控制使用哪个 SDK。
- en: For example, one reader of the fourth edition wanted their experience to match
    the book steps that use the .NET Core 3.1 SDK. But they had installed the .NET
    5.0 SDK as well and that was being used by default. As described in the previous
    section, the behavior when creating new class libraries changed to target .NET
    5.0 instead of .NET Standard 2.0, and that confused the reader.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第四版的某位读者希望其体验与书中使用.NET Core 3.1 SDK的步骤相匹配。但他们也安装了.NET 5.0 SDK，并且默认使用的是这个版本。如前一节所述，创建新类库时的行为已更改为针对.NET
    5.0而非.NET Standard 2.0，这让读者感到困惑。
- en: You can control the .NET SDK used by default by using a `global.json` file.
    The `dotnet` command searches the current folder and ancestor folders for a `global.json`
    file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`global.json`文件，你可以控制默认使用的.NET SDK。`dotnet`命令会在当前文件夹及其祖先文件夹中搜索`global.json`文件。
- en: Create a subdirectory/folder in the `Chapter07` folder named `ControlSDK`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter07`文件夹中创建一个名为`ControlSDK`的子目录/文件夹。
- en: On Windows, start **Command Prompt** or **Windows Terminal**. On macOS, start
    **Terminal**. If you are using Visual Studio Code, then you can use the integrated
    terminal.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，启动**命令提示符**或**Windows终端**。在macOS上，启动**终端**。如果你使用的是Visual Studio Code，则可以使用集成终端。
- en: 'In the `ControlSDK` folder, at the command prompt or terminal, enter a command
    to create a `global.json` file that forces the use of the latest .NET Core 3.1
    SDK, as shown in the following command:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ControlSDK`文件夹中，在命令提示符或终端下，输入创建强制使用最新.NET Core 3.1 SDK的`global.json`文件的命令，如下所示：
- en: '[PRE13]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Open the `global.json` file and review its contents, as shown in the following
    markup:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`global.json`文件并审查其内容，如下所示：
- en: '[PRE14]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can discover the version numbers of the latest .NET SDKs in the table at
    the following link: [https://dotnet.microsoft.com/download/visual-studio-sdks](https://dotnet.microsoft.com/download/visual-studio-sdks)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在以下链接的表格中找到最新.NET SDK的版本号：[https://dotnet.microsoft.com/download/visual-studio-sdks](https://dotnet.microsoft.com/download/visual-studio-sdks)
- en: 'In the `ControlSDK` folder, at the command prompt or terminal, enter a command
    to create a class library project, as shown in the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ControlSDK`文件夹中，在命令提示符或终端下，输入创建类库项目的命令，如下所示：
- en: '[PRE15]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you do not have the .NET Core 3.1 SDK installed then you will see an error,
    as shown in the following output:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你未安装.NET Core 3.1 SDK，则会看到如下所示的错误：
- en: '[PRE16]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you do have the .NET Core 3.1 SDK installed, then a class library project
    will be created that targets .NET Standard 2.0 by default.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已安装.NET Core 3.1 SDK，则默认将创建一个针对.NET Standard 2.0的类库项目。
- en: 'You do not need to complete the above steps, but if you want to try and do
    not already have .NET Core 3.1 SDK installed then you can install it from the
    following link:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需完成上述步骤，但如果你想尝试且尚未安装.NET Core 3.1 SDK，则可以从以下链接安装：
- en: '[https://dotnet.microsoft.com/download/dotnet/3.1](https://dotnet.microsoft.com/download/dotnet/3.1)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://dotnet.microsoft.com/download/dotnet/3.1](https://dotnet.microsoft.com/download/dotnet/3.1)'
- en: Publishing your code for deployment
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布你的代码以供部署
- en: If you write a novel and you want other people to read it, you must publish
    it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写了一部小说并希望其他人阅读，你必须将其出版。
- en: Most developers write code for other developers to use in their own code, or
    for users to run as an app. To do so, you must publish your code as packaged class
    libraries or executable applications.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者编写代码供其他开发者在他们的代码中使用，或者供用户作为应用程序运行。为此，你必须将你的代码发布为打包的类库或可执行应用程序。
- en: 'There are three ways to publish and deploy a .NET application. They are:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 发布和部署.NET应用程序有三种方式，它们是：
- en: '**Framework-dependent deployment** (**FDD**).'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖框架的部署**（**FDD**）。'
- en: '**Framework-dependent executables** (**FDEs**).'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖框架的可执行文件**（**FDEs**）。'
- en: Self-contained.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自包含。
- en: If you choose to deploy your application and its package dependencies, but not
    .NET itself, then you rely on .NET already being on the target computer. This
    works well for web applications deployed to a server because .NET and lots of
    other web applications are likely already on the server.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择部署应用程序及其包依赖项，但不包括.NET本身，那么你依赖于目标计算机上已有的.NET。这对于部署到服务器的Web应用程序非常有效，因为.NET和其他许多Web应用程序可能已经在服务器上。
- en: '**Framework-dependent deployment** (**FDD**) means you deploy a DLL that must
    be executed by the `dotnet` command-line tool. **Framework-dependent executables**
    (**FDE**) means you deploy an EXE that can be run directly from the command line.
    Both require .NET to be already installed on the system.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架依赖部署**（**FDD**）意味着您部署的是必须由`dotnet`命令行工具执行的DLL。**框架依赖可执行文件**（**FDE**）意味着您部署的是可以直接从命令行运行的EXE。两者都要求系统上已安装.NET。'
- en: Sometimes, you want to be able to give someone a USB stick containing your application
    and know that it can execute on their computer. You want to perform a self-contained
    deployment. While the size of the deployment files will be larger, you'll know
    that it will work.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望能够在USB闪存驱动器上提供您的应用程序，并确保它能在他人的计算机上执行。您希望进行自包含部署。虽然部署文件的大小会更大，但您可以确信它将能够运行。
- en: Creating a console application to publish
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序以发布
- en: 'Let''s explore how to publish a console application:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何发布一个控制台应用程序：
- en: Use your preferred code editor to add a new console app named `DotNetEverywhere`
    to the `Chapter07` solution/workspace.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，在`Chapter07`解决方案/工作区中添加一个名为`DotNetEverywhere`的新控制台应用。
- en: In Visual Studio Code, select `DotNetEverywhere` as the active OmniSharp project.
    When you see the pop-up warning message saying that required assets are missing,
    click **Yes** to add them.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`DotNetEverywhere`作为活动的OmniSharp项目。当看到弹出警告消息提示缺少必需资产时，点击**是**以添加它们。
- en: In `Program.cs`, delete the comment and statically import the `Console` class.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除注释并静态导入`Console`类。
- en: 'In `Program.cs`, add a statement to output a message saying the console app
    can run everywhere and some information about the operating system, as shown in
    the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句，输出一条消息，表明控制台应用可在任何地方运行，并提供一些关于操作系统的信息，如下所示：
- en: '[PRE17]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open `DotNetEverywhere.csproj` and add the runtime identifiers to target three
    operating systems inside the `<PropertyGroup>` element, as shown highlighted in
    the following markup:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DotNetEverywhere.csproj`文件，并在`<PropertyGroup>`元素内添加运行时标识符，以针对三个操作系统进行目标设定，如下所示的高亮标记：
- en: '[PRE18]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `win10-x64` RID value means Windows 10 or Windows Server 2016 64-bit. You
    could also use the `win10-arm64` RID value to deploy to a Microsoft Surface Pro
    X.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`win10-x64` RID值表示Windows 10或Windows Server 2016的64位版本。您也可以使用`win10-arm64`
    RID值来部署到Microsoft Surface Pro X。'
- en: The `osx-x64` RID value means macOS Sierra 10.12 or later. You can also specify
    version-specific RID values like `osx.10.15-x64` (Catalina), `osx.11.0-x64` (Big
    Sur on Intel), or `osx.11.0-arm64` (Big Sur on Apple Silicon).
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`osx-x64` RID值表示macOS Sierra 10.12或更高版本。您也可以指定特定版本的RID值，如`osx.10.15-x64`（Catalina）、`osx.11.0-x64`（Intel上的Big
    Sur）或`osx.11.0-arm64`（Apple Silicon上的Big Sur）。'
- en: The `linux-x64` RID value means most desktop distributions of Linux like Ubuntu,
    CentOS, Debian, or Fedora. Use `linux-arm` for Raspbian or Raspberry Pi OS 32-bit.
    Use `linux-arm64` for a Raspberry Pi running Ubuntu 64-bit.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linux-x64` RID值适用于大多数桌面Linux发行版，如Ubuntu、CentOS、Debian或Fedora。使用`linux-arm`适用于Raspbian或Raspberry
    Pi OS的32位版本。使用`linux-arm64`适用于运行Ubuntu 64位的Raspberry Pi。'
- en: Understanding dotnet commands
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解dotnet命令
- en: When you install the .NET SDK, it includes a **command-line interface (CLI)**
    named `dotnet`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 安装.NET SDK时，它会包含一个名为`dotnet`的**命令行界面(CLI)**。
- en: Creating new projects
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'The .NET CLI has commands that work on the current folder to create a new project
    using templates:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI拥有在当前文件夹上工作的命令，用于使用模板创建新项目：
- en: On Windows, start **Command Prompt** or **Windows Terminal**. On macOS, start
    **Terminal**. If you are using Visual Studio Code, then you can use the integrated
    terminal.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，启动**命令提示符**或**Windows终端**。在macOS上，启动**终端**。如果您使用的是Visual Studio Code，则可以使用集成终端。
- en: Enter the `dotnet new --list` or `dotnet new -l` command to list your currently
    installed templates, as shown in *Figure 7.2*:![A picture containing text  Description
    automatically generated](img/B17442_07_02.png)
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`dotnet new --list`或`dotnet new -l`命令，列出您当前安装的模板，如*图7.2*所示：![图7.2：已安装的dotnet
    new项目模板列表](img/B17442_07_02.png)
- en: 'Figure 7.2: A list of installed dotnet new project templates'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.2：已安装的dotnet new项目模板列表*'
- en: Most `dotnet` command-line switches have a long and a short version. For example,
    `--list` or `-l`. The short ones are quicker to type but more likely to be misinterpreted
    by you or other humans. Sometimes more typing is clearer.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`dotnet`命令行开关都有长版和短版。例如，`--list`或`-l`。短版输入更快，但更容易被您或其他人类误解。有时，多输入一些字符会更清晰。
- en: Getting information about .NET and its environment
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取有关.NET及其环境的信息
- en: 'It is useful to see what .NET SDKs and runtimes are currently installed, alongside
    information about the operating system, as shown in the following command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当前安装的 .NET SDK 和运行时以及操作系统信息非常有用，如下所示：
- en: '[PRE19]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note the results, as shown in the following partial output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结果，如下所示：
- en: '[PRE20]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Managing projects
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目管理
- en: 'The .NET CLI has the following commands that work on the project in the current
    folder, to manage the project:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI 提供了以下命令，用于管理当前文件夹中的项目：
- en: '`dotnet restore`: This downloads dependencies for the project.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet restore`: 此命令下载项目的依赖项。'
- en: '`dotnet build`: This builds, aka compiles, the project.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet build`: 此命令构建（即编译）项目。'
- en: '`dotnet test`: This builds and then runs unit tests for the project.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet test`: 此命令构建项目并随后运行单元测试。'
- en: '`dotnet run`: This builds and then runs the project.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet run`: 此命令构建项目并随后运行。'
- en: '`dotnet pack`: This creates a NuGet package for the project.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet pack`: 此命令为项目创建 NuGet 包。'
- en: '`dotnet publish`: This builds and then publishes the project, either with dependencies
    or as a self-contained application.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet publish`: 此命令构建并发布项目，无论是包含依赖项还是作为自包含应用程序。'
- en: '`dotnet add`: This adds a reference to a package or class library to the project.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet add`: 此命令向项目添加对包或类库的引用。'
- en: '`dotnet remove`: This removes a reference to a package or class library from
    the project.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet remove`: 此命令从项目中移除对包或类库的引用。'
- en: '`dotnet list`: This lists the package or class library references for the project.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet list`: 此命令列出项目对包或类库的引用。'
- en: Publishing a self-contained app
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布自包含应用
- en: 'Now that you have seen some example `dotnet` tool commands, we can publish
    our cross-platform console app:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经看到了一些 `dotnet` 工具命令的示例，我们可以发布我们的跨平台控制台应用：
- en: At the command line, make sure that you are in the `DotNetEverywhere` folder.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，确保你位于 `DotNetEverywhere` 文件夹中。
- en: 'Enter a command to build and publish the release version of the console application
    for Windows 10, as shown in the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以构建并发布适用于 Windows 10 的控制台应用程序的发布版本：
- en: '[PRE21]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note the build engine restores any needed packages, compiles the project source
    code into an assembly DLL, and creates a `publish` folder, as shown in the following
    output:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，构建引擎会恢复任何需要的包，将项目源代码编译成程序集 DLL，并创建一个 `publish` 文件夹，如下所示：
- en: '[PRE22]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Enter the commands to build and publish the release versions for macOS and
    Linux variants, as shown in the following commands:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以构建并发布适用于 macOS 和 Linux 变体的发布版本：
- en: '[PRE23]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Good Practice**: You could automate these commands by using a scripting language
    like PowerShell and execute it on any operating system using the cross-platform
    PowerShell Core. Just create a file with the extension `.ps1` with the five commands
    on it. Then execute the file. Learn more about PowerShell at the following link:
    [https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell](https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell)'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：你可以使用 PowerShell 等脚本语言自动化这些命令，并通过跨平台的 PowerShell Core 在任何操作系统上执行。只需创建一个扩展名为
    `.ps1` 的文件，其中包含这五个命令。然后执行该文件。更多关于 PowerShell 的信息，请访问以下链接：[https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell](https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell)'
- en: Open a macOS **Finder** window or Windows **File Explorer**, navigate to `DotNetEverywhere\bin\Release\net6.0`,
    and note the output folders for the various operating systems.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 macOS **Finder** 窗口或 Windows **文件资源管理器**，导航至 `DotNetEverywhere\bin\Release\net6.0`，并注意针对不同操作系统的输出文件夹。
- en: In the `win10-x64` folder, select the `publish` folder, note all the supporting
    assemblies like `Microsoft.CSharp.dll`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `win10-x64` 文件夹中，选择 `publish` 文件夹，注意所有支持程序集，如 `Microsoft.CSharp.dll`。
- en: Select the `DotNetEverywhere` executable file, and note it is 161 KB, as shown
    in *Figure 7.3*:![Graphical user interface  Description automatically generated](img/B17442_07_03.png)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `DotNetEverywhere` 可执行文件，并注意其大小为 161 KB，如图 *7.3* 所示：![图形用户界面 自动生成的描述](img/B17442_07_03.png)
- en: 'Figure 7.3: The DotNetEverywhere executable file for Windows 10 64-bit'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.3：适用于 Windows 10 64 位的 DotNetEverywhere 可执行文件
- en: 'If you are on Windows, then double-click to execute the program and note the
    result, as shown in the following output:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，则双击执行程序并注意结果，如下所示：
- en: '[PRE24]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the total size of the `publish` folder and all its files is 64.8 MB.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`publish` 文件夹及其所有文件的总大小为 64.8 MB。
- en: In the `osx.11.0-arm64` folder, select the `publish` folder, note all the supporting
    assemblies, and then select the `DotNetEverywhere` executable file, and note the
    executable is 126 KB, and the `publish` folder is 71.8 MB.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`osx.11.0-arm64`文件夹中，选择`publish`文件夹，注意所有支持的程序集，然后选择`DotNetEverywhere`可执行文件，并注意可执行文件为126
    KB，而`publish`文件夹为71.8 MB。
- en: 'If you copy any of those `publish` folders to the appropriate operating system,
    the console application will run; this is because it is a self-contained deployable
    .NET application. For example, on macOS with Intel, as shown in the following
    output:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将任何`publish`文件夹复制到相应的操作系统，控制台应用程序将运行；这是因为它是自包含的可部署.NET应用程序。例如，在配备Intel芯片的macOS上，如下所示：
- en: '[PRE25]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example used a console app, but you could just as easily create an ASP.NET
    Core website or web service, or a Windows Forms or WPF app. Of course, you can
    only deploy Windows desktop apps to Windows computers, not Linux or macOS.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用的是控制台应用程序，但你同样可以轻松创建一个ASP.NET Core网站或Web服务，或是Windows Forms或WPF应用程序。当然，你只能将Windows桌面应用程序部署到Windows计算机上，不能部署到Linux或macOS。
- en: Publishing a single-file app
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布单文件应用程序
- en: To publish as a "single" file, you can specify flags when publishing. With .NET
    5, single-file apps were primarily focused on Linux because there are limitations
    in both Windows and macOS that mean true single-file publishing is not technically
    possible. With .NET 6, you can now create proper single-file apps on Windows.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布为“单个”文件，你可以在发布时指定标志。在.NET 5中，单文件应用程序主要关注Linux，因为Windows和macOS都存在限制，这意味着真正的单文件发布在技术上是不可能的。在.NET
    6中，你现在可以在Windows上创建真正的单文件应用程序。
- en: 'If you can assume that .NET 6 is already installed on the computer on which
    you want to run your app, then you can use the extra flags when you publish your
    app for release to say that it does not need to be self-contained and that you
    want to publish it as a single file (if possible), as shown in the following command
    (that must be entered on a single line):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能假设目标计算机上已安装.NET 6，那么在发布应用程序时，你可以使用额外的标志来表明它不需要自包含，并且你希望将其发布为单个文件（如果可能），如下所示（该命令必须在一行内输入）：
- en: '[PRE26]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will generate two files: `DotNetEverywhere.exe` and `DotNetEverywhere.pdb`.
    The `.exe` is the executable. The `.pdb` file is a **program debug database**
    file that stores debugging information.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个文件：`DotNetEverywhere.exe`和`DotNetEverywhere.pdb`。`.exe`是可执行文件，而`.pdb`文件是**程序调试数据库**文件，存储调试信息。
- en: There is no `.exe` file extension for published applications on macOS, so if
    you use `osx-x64` in the command above, the filename will not have an extension.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: macOS上发布的应用程序没有`.exe`文件扩展名，因此如果你在上面的命令中使用`osx-x64`，文件名将不会有扩展名。
- en: 'If you prefer the `.pdb` file to be embedded in the `.exe` file, then add a
    `<DebugType>` element to the `<PropertyGroup>` element in your `.csproj` file
    and set it to `embedded`, as shown highlighted in the following markup:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将`.pdb`文件嵌入到`.exe`文件中，那么请在你的`.csproj`文件中的`<PropertyGroup>`元素内添加一个`<DebugType>`元素，并将其设置为`embedded`，如下所示：
- en: '[PRE27]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you cannot assume that .NET 6 is already installed on a computer, then although
    Linux also only generates the two files, expect the following additional files
    for Windows: `coreclr.dll`, `clrjit.dll`, `clrcompression.dll`, and `mscordaccore.dll`.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能假设目标计算机上已安装.NET 6，那么在Linux上虽然也只生成两个文件，但Windows上还需额外生成以下文件：`coreclr.dll`、`clrjit.dll`、`clrcompression.dll`和`mscordaccore.dll`。
- en: 'Let''s see an example for Windows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个Windows的示例：
- en: 'At the command line, enter the command to build the release version of the
    console application for Windows 10, as shown in the following command:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入构建Windows 10控制台应用程序的发布版本的命令，如下所示：
- en: '[PRE28]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Navigate to the `DotNetEverywhere\bin\Release\net6.0\win10-x64\publish` folder,
    select the `DotNetEverywhere` executable file, and note the executable is now
    58.3 MB, and there is also a `.pdb` file that is 10 KB. The sizes on your system
    will vary.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`DotNetEverywhere\bin\Release\net6.0\win10-x64\publish`文件夹，选择`DotNetEverywhere`可执行文件，并注意可执行文件现在为58.3
    MB，还有一个10 KB的`.pdb`文件。你系统上的大小可能会有所不同。
- en: Reducing the size of apps using app trimming
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过应用程序修剪减小应用程序大小
- en: One of the problems with deploying a .NET app as a self-contained app is that
    the .NET libraries take up a lot of space. One of the biggest needs for reduced
    size is Blazor WebAssembly components because all the .NET libraries need to be
    downloaded to the browser.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 将.NET应用程序部署为自包含应用程序的一个问题是.NET库占用了大量空间。其中，对减小体积需求最大的就是Blazor WebAssembly组件，因为所有.NET库都需要下载到浏览器中。
- en: Luckily, you can reduce this size by not packaging unused assemblies with your
    deployments. Introduced with .NET Core 3.0, the app trimming system can identify
    the assemblies needed by your code and remove those that are not needed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您可以通过不在部署中打包未使用的程序集来减少此大小。随着.NET Core 3.0的引入，应用修剪系统可以识别您的代码所需的程序集并移除不需要的那些。
- en: With .NET 5, the trimming went further by removing individual types, and even
    members like methods from within an assembly if they are not used. For example,
    with a Hello World console app, the `System.Console.dll` assembly is trimmed from
    61.5 KB to 31.5 KB. For .NET 5, this is an experimental feature so it is disabled
    by default.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 随着.NET 5，修剪更进一步，通过移除单个类型，甚至是程序集内未使用的方法等成员。例如，使用Hello World控制台应用，`System.Console.dll`程序集从61.5
    KB修剪到31.5 KB。对于.NET 5，这是一个实验性功能，因此默认情况下是禁用的。
- en: With .NET 6, Microsoft added annotations to their libraries to indicate how
    they can be safely trimmed so the trimming of types and members was made the default.
    This is known as **link trim mode**.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 随着.NET 6，微软在其库中添加了注解，以指示它们如何可以安全地修剪，因此类型和成员的修剪被设为默认。这被称为**链接修剪模式**。
- en: The catch is how well the trimming identifies unused assemblies, types, and
    members. If your code is dynamic, perhaps using reflection, then it might not
    work correctly, so Microsoft also allows manual control.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于修剪如何准确识别未使用的程序集、类型和成员。如果您的代码是动态的，可能使用反射，那么它可能无法正常工作，因此微软也允许手动控制。
- en: Enabling assembly-level trimming
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用程序集级别修剪
- en: There are two ways to enable assembly-level trimming.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以启用程序集级别修剪。
- en: 'The first way is to add an element in the project file, as shown in the following
    markup:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是在项目文件中添加一个元素，如下面的标记所示：
- en: '[PRE29]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The second way is to add a flag when publishing, as shown highlighted in the
    following command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是在发布时添加一个标志，如下面的命令中突出显示的那样：
- en: '[PRE30]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Enabling type-level and member-level trimming
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用类型级别和成员级别修剪
- en: There are two ways to enable type-level and member-level trimming.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以启用类型级别和成员级别修剪。
- en: 'The first way is to add two elements in the project file, as shown in the following
    markup:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是在项目文件中添加两个元素，如下面的标记所示：
- en: '[PRE31]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second way is to add two flags when publishing, as shown highlighted in
    the following command:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是在发布时添加两个标志，如下面的命令中突出显示的那样：
- en: '[PRE32]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For .NET 6, link trim mode is the default, so you only need to specify the switch
    if you want to set an alternative trim mode like `copyused`, which means assembly-level
    trimming.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于.NET 6，链接修剪模式是默认的，因此您只需在想要设置如`copyused`等替代修剪模式时指定开关，这意味着程序集级别修剪。
- en: Decompiling .NET assemblies
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反编译.NET程序集
- en: One of the best ways to learn how to code for .NET is to see how professionals
    do it.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何为.NET编码的最佳方法之一是观察专业人士如何操作。
- en: '**Good Practice**: You could decompile someone else''s assemblies for non-learning
    purposes like copying their code for use in your own production library or application,
    but remember that you are viewing their intellectual property, so please respect
    that.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：您可以出于非学习目的反编译他人的程序集，例如复制他们的代码以用于您自己的生产库或应用程序，但请记住您正在查看他们的知识产权，因此请予以尊重。'
- en: Decompiling using the ILSpy extension for Visual Studio 2022
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Visual Studio 2022的ILSpy扩展进行反编译
- en: For learning purposes, you can decompile any .NET assembly with a tool like
    ILSpy.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 出于学习目的，您可以使用ILSpy等工具反编译任何.NET程序集。
- en: In Visual Studio 2022 for Windows, navigate to **Extensions** | **Manage Extensions**.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上的Visual Studio 2022中，导航至**扩展** | **管理扩展**。
- en: In the search box, enter `ilspy`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`ilspy`。
- en: For the **ILSpy** extension, click **Download**.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**ILSpy**扩展，点击**下载**。
- en: Click **Close**.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**关闭**。
- en: Close Visual Studio to allow the extension to install.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭Visual Studio以允许扩展安装。
- en: Restart Visual Studio and reopen the `Chapter07` solution.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启Visual Studio并重新打开`Chapter07`解决方案。
- en: In **Solution Explorer**, right-click the **DotNetEverywhere** project and select
    **Open output in ILSpy**.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，右键点击**DotNetEverywhere**项目并选择**在ILSpy中打开输出**。
- en: Navigate to **File** | **Open…**.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**文件** | **打开…**。
- en: 'Navigate to the following folder:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至以下文件夹：
- en: '[PRE33]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Select the `System.IO.FileSystem.dll` assembly and click **Open**.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`System.IO.FileSystem.dll`程序集并点击**打开**。
- en: In the **Assemblies** tree, expand the **System.IO.FileSystem** assembly, expand
    the **System.IO** namespace, select the **Directory** class, and wait for it to
    decompile.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**程序集**树中，展开**System.IO.FileSystem**程序集，展开**System.IO**命名空间，选择**Directory**类，并等待其反编译。
- en: In the `Directory` class, click the **[+]** to expand the `GetParent` method,
    as shown in *Figure 7.4*:![Graphical user interface, text, application  Description
    automatically generated](img/B17442_07_04.png)
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Directory` 类中，点击 **[+]** 展开 `GetParent` 方法，如图 *7.4* 所示：![图形用户界面，文本，应用程序 自动生成的描述](img/B17442_07_04.png)
- en: 'Figure 7.4: Decompiled GetParent method of Directory class on Windows'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.4：Windows 上 Directory 类的反编译 GetParent 方法
- en: Note the good practice of checking the `path` parameter and throwing an `ArgumentNullException`
    if it is `null` or an `ArgumentException` if it is zero length.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意检查 `path` 参数的良好实践，如果为 `null` 则抛出 `ArgumentNullException`，如果长度为零则抛出 `ArgumentException`。
- en: Close ILSpy.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 ILSpy。
- en: Decompiling using the ILSpy extension for Visual Studio Code
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ILSpy 扩展进行反编译
- en: A similar capability is available cross-platform as an extension for Visual
    Studio Code.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的功能作为 Visual Studio Code 的扩展在跨平台上可用。
- en: If you have not already installed the **ILSpy .NET Decompiler** extension for
    Visual Studio Code, then search for it and install it now.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未安装 **ILSpy .NET Decompiler** 扩展，请搜索并安装它。
- en: 'On macOS or Linux the extension has a dependency on Mono so you will also need
    to install Mono from the following link: [https://www.mono-project.com/download/stable/](https://www.mono-project.com/download/stable/).'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 macOS 或 Linux 上，该扩展依赖于 Mono，因此您还需要从以下链接安装 Mono：[https://www.mono-project.com/download/stable/](https://www.mono-project.com/download/stable/)。
- en: In Visual Studio Code, navigate to **View** | **Command Palette…**.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，导航到 **View** | **Command Palette…**。
- en: 'Type `ilspy` and then select **ILSpy: Decompile IL Assembly (pick file)**.'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '输入 `ilspy` 然后选择 **ILSpy: Decompile IL Assembly (pick file)**。'
- en: 'Navigate to the following folder:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到以下文件夹：
- en: '[PRE34]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Select the `System.IO.FileSystem.dll` assembly and click **Select assembly**.
    Nothing will appear to happen, but you can confirm that ILSpy is working by viewing
    the **Output** window, selecting **ilspy-vscode** in the dropdown list, and seeing
    the processing, as shown in *Figure 7.5*:![Graphical user interface, text, application,
    email  Description automatically generated](img/B17442_07_05.png)
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `System.IO.FileSystem.dll` 程序集并点击 **Select assembly**。看似无事发生，但您可以通过查看 **Output**
    窗口，在下拉列表中选择 **ilspy-vscode**，并查看处理过程来确认 ILSpy 是否在工作，如图 *7.5* 所示：![图形用户界面，文本，应用程序，电子邮件
    自动生成的描述](img/B17442_07_05.png)
- en: 'Figure 7.5: ILSpy extension output when selecting an assembly to decompile'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.5：选择要反编译的程序集时 ILSpy 扩展的输出
- en: In **EXPLORER**, expand **ILSPY DECOMPILED MEMBERS**, select the assembly, close
    the **Output** window, and note the two edit windows that open showing assembly
    attributes using C# code and external DLL and assembly references using IL code,
    as shown in *Figure 7.6*:![Graphical user interface, text, application  Description
    automatically generated](img/B17442_07_06.png)
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EXPLORER** 中，展开 **ILSPY DECOMPILED MEMBERS**，选择程序集，关闭 **Output** 窗口，并注意打开的两个编辑窗口，它们显示使用
    C# 代码的程序集属性和使用 IL 代码的外部 DLL 和程序集引用，如图 *7.6* 所示：![图形用户界面，文本，应用程序 自动生成的描述](img/B17442_07_06.png)
- en: 'Figure 7.6: Expanding ILSPY DECOMPILED MEMBERS'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.6：展开 ILSPY DECOMPILED MEMBERS
- en: 'In the IL code on the right side, note the reference to the `System.Runtime`
    assembly, including the version number, as shown in the following code:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的 IL 代码中，注意对 `System.Runtime` 程序集的引用，包括版本号，如下所示：
- en: '[PRE35]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`.module extern libSystem.Native` means this assembly makes function calls
    to Linux system APIs as you would expect from code that interacts with the filesystem.
    If we had decompiled the Windows equivalent of this assembly, it would use `.module
    extern kernel32.dll` instead, which is a Win32 API.'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.module extern libSystem.Native` 表示此程序集像预期那样调用了 Linux 系统 API，这些代码与文件系统交互。如果我们反编译此程序集的
    Windows 版本，它将使用 `.module extern kernel32.dll` 代替，这是一个 Win32 API。'
- en: In **EXPLORER**, in **ILSPY DECOMPILED MEMBERS**, expand the assembly, expand
    the **System.IO** namespace, select **Directory**, and note the two edit windows
    that open showing the decompiled `Directory` class using C# code on the left and
    IL code on the right, as shown in *Figure 7.7*:![](img/B17442_07_07.png)
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **EXPLORER** 中，在 **ILSPY DECOMPILED MEMBERS** 中，展开程序集，展开 **System.IO** 命名空间，选择
    **Directory**，并注意打开的两个编辑窗口，它们显示使用 C# 代码的反编译 `Directory` 类在左侧，IL 代码在右侧，如图 *7.7*
    所示：![](img/B17442_07_07.png)
- en: 'Figure 7.7: The decompiled Directory class in C# and IL code'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.7：C# 和 IL 代码中的反编译 Directory 类
- en: 'Compare the C# source code for the `GetParent` method, shown in the following
    code:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较以下代码中 `GetParent` 方法的 C# 源代码：
- en: '[PRE36]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the equivalent IL source code of the `GetParent` method, as shown in the
    following code:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `GetParent` 方法的等效 IL 源代码，如下所示：
- en: '[PRE37]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Good Practice**: The IL code edit windows are not especially useful unless
    you get very advanced with C# and .NET development when knowing how the C# compiler
    translates your source code into IL code can be important. The much more useful
    edit windows contain the equivalent C# source code written by Microsoft experts.
    You can learn a lot of good practices from seeing how professionals implement
    types. For example, the `GetParent` method shows how to check arguments for `null`
    and other argument exceptions.'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：IL 代码编辑窗口在深入了解 C# 和 .NET 开发之前并不是特别有用，此时了解 C# 编译器如何将源代码转换为 IL 代码非常重要。更有用的编辑窗口包含由微软专家编写的等效
    C# 源代码。通过观察专业人士如何实现类型，你可以学到很多好的做法。例如，`GetParent` 方法展示了如何检查参数是否为 `null` 及其他参数异常。'
- en: Close the edit windows without saving changes.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑窗口而不保存更改。
- en: In **EXPLORER**, in **ILSPY DECOMPILED MEMBERS**, right-click the assembly and
    choose **Unload Assembly**.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**资源管理器**中，在**ILSPY 反编译成员**中，右键单击程序集并选择**卸载程序集**。
- en: No, you cannot technically prevent decompilation
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**不**，从技术上讲，你无法阻止反编译。'
- en: I sometimes get asked if there is a way to protect compiled code to prevent
    decompilation. The quick answer is no, and if you think about it, you'll see why
    this has to be the case. You can make it harder using obfuscation tools like **Dotfuscator**,
    but ultimately you cannot completely prevent it.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会有人问我是否有办法保护编译后的代码以防止反编译。简短的回答是**没有**，如果你仔细想想，就会明白为什么必须如此。你可以使用**Dotfuscator**等混淆工具使其变得更难，但最终你无法完全阻止反编译。
- en: All compiled applications contain instructions to the platform, operating system,
    and hardware on which it runs. Those instructions have to be functionally the
    same as the original source code but are just harder for a human to read. Those
    instructions must be readable to execute your code; they therefore must be readable
    to be decompiled. If you protect your code from decompilation using some custom
    technique, then you would also prevent your code from running!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编译后的应用程序都包含针对运行平台的指令、操作系统和硬件。这些指令必须与原始源代码功能相同，只是对人类来说更难阅读。这些指令必须可读才能执行你的代码；因此，它们必须可读才能被反编译。如果你使用某种自定义技术保护代码免受反编译，那么你也会阻止代码运行！
- en: Virtual machines simulate hardware and so can capture all interaction between
    your running application and the software and hardware that it thinks it is running
    on.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机模拟硬件，因此可以捕获运行应用程序与它认为正在运行的软件和硬件之间的所有交互。
- en: If you could protect your code, then you would also prevent attaching to it
    with a debugger and stepping through it. If the compiled application has a `pdb`
    file, then you can attach a debugger and step through the statements line-by-line.
    Even without the `pdb` file, you can still attach a debugger and get some idea
    of how the code works.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能保护你的代码，那么你也会阻止使用调试器附加到它并逐步执行。如果编译后的应用程序有 `pdb` 文件，那么你可以附加一个调试器并逐行执行语句。即使没有
    `pdb` 文件，你仍然可以附加一个调试器并大致了解代码的工作原理。
- en: 'This is true for all programming languages. Not just .NET languages like C#,
    Visual Basic, and F#, but also C, C++, Delphi, assembly language: all can be attached
    to for debugging or to be disassembled or decompiled. Some tools used by professionals
    are shown in the following table:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这对所有编程语言都是如此。不仅仅是 .NET 语言，如 C#、Visual Basic 和 F#，还有 C、C++、Delphi、汇编语言：所有这些都可以附加到调试器中，或者被反汇编或反编译。以下表格展示了一些专业人士使用的工具：
- en: '| Type | Product | Description |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 产品 | 描述 |'
- en: '| Virtual Machine | VMware | Professionals like malware analysts always run
    software inside a VM. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟机 | VMware | 专业人士如恶意软件分析师总是在虚拟机中运行软件。 |'
- en: '| Debugger | SoftICE | Runs underneath the operating system usually in a VM.
    |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 调试器 | SoftICE | 通常在虚拟机中运行于操作系统之下。 |'
- en: '| Debugger | WinDbg | Useful for understanding Windows internals because it
    knows more about Windows data structures than other debuggers. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 调试器 | WinDbg | 由于它比其他调试器更了解 Windows 数据结构，因此对于理解 Windows 内部机制非常有用。 |'
- en: '| Disassembler | IDA Pro | Used by professional malware analysts. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 反汇编器 | IDA Pro | 专业恶意软件分析师使用。 |'
- en: '| Decompiler | HexRays | Decompiles C apps. Plugin for IDA Pro. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 反编译器 | HexRays | 反编译 C 应用程序。IDA Pro 的插件。 |'
- en: '| Decompiler | DeDe | Decompiles Delphi apps. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 反编译器 | DeDe | 反编译 Delphi 应用程序。 |'
- en: '| Decompiler | dotPeek | .NET decompiler from JetBrains. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 反编译器 | dotPeek | JetBrains 出品的 .NET 反编译器。 |'
- en: '**Good Practice**: Debugging, disassembling, and decompiling someone else''s
    software is likely against its license agreement and illegal in many jurisdictions.
    Instead of trying to protect your intellectual property with a technical solution,
    the law is sometimes your only recourse.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：调试、反汇编和反编译他人软件很可能违反其许可协议，并且在许多司法管辖区是非法的。与其试图通过技术手段保护你的知识产权，法律有时是你唯一的救济途径。'
- en: Packaging your libraries for NuGet distribution
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为NuGet分发打包你的库
- en: Before we learn how to create and package our own libraries, we will review
    how a project can use an existing package.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何创建和打包自己的库之前，我们将回顾一个项目如何使用现有包。
- en: Referencing a NuGet package
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用NuGet包
- en: 'Let''s say that you want to add a package created by a third-party developer,
    for example, `Newtonsoft.Json`, a popular package for working with the JavaScript
    Object Notation (JSON) serialization format:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想添加一个由第三方开发者创建的包，例如，`Newtonsoft.Json`，这是一个流行的用于处理JavaScript对象表示法（JSON）序列化格式的包：
- en: In the `AssembliesAndNamespaces` project, add a reference to the `Newtonsoft.Json`
    NuGet package, either using the GUI for Visual Studio 2022 or the `dotnet add
    package` command for Visual Studio Code.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AssembliesAndNamespaces`项目中，添加对`Newtonsoft.Json`NuGet包的引用，可以使用Visual Studio
    2022的GUI或Visual Studio Code的`dotnet add package`命令。
- en: 'Open the `AssembliesAndNamespaces.csproj` file and note that a package reference
    has been added, as shown in the following markup:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AssembliesAndNamespaces.csproj`文件，并注意到已添加了一个包引用，如下面的标记所示：
- en: '[PRE38]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you have a more recent version of the `newtonsoft.json` package, then it
    has been updated since this chapter was written.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有更新的`newtonsoft.json`包版本，那么自本章编写以来它已被更新。
- en: Fixing dependencies
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复依赖关系
- en: 'To consistently restore packages and write reliable code, it''s important that
    you **fix dependencies**. Fixing dependencies means you are using the same family
    of packages released for a specific version of .NET, for example, SQLite for .NET
    6.0, as shown highlighted in the following markup:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了始终恢复包并编写可靠的代码，重要的是你**修复依赖关系**。修复依赖关系意味着你正在使用为.NET的特定版本发布的同一套包，例如，SQLite for
    .NET 6.0，如下面的标记中突出显示所示：
- en: '[PRE39]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To fix dependencies, every package should have a single version with no additional
    qualifiers. Additional qualifiers include betas (`beta1`), release candidates
    (`rc4`), and wildcards (`*`).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复依赖关系，每个包应该只有一个版本，没有额外的限定词。额外的限定词包括测试版（`beta1`）、发布候选版（`rc4`）和通配符（`*`）。
- en: Wildcards allow future versions to be automatically referenced and used because
    they always represent the most recent release. But wildcards are therefore dangerous
    because they could result in the use of future incompatible packages that break
    your code.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符允许自动引用和使用未来版本，因为它们始终代表最新发布。但通配符因此具有危险性，因为它们可能导致使用未来不兼容的包，从而破坏你的代码。
- en: 'This can be worth the risk while writing a book where new preview versions
    are released every month and you do not want to keep updating the package references,
    as I did during 2021, and as shown in the following markup:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写书籍时，这可能值得冒险，因为每月都会发布新的预览版本，你不想不断更新包引用，正如我在2021年所做的，如下面的标记所示：
- en: '[PRE40]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you use the `dotnet add package` command, or Visual Studio's **Manage NuGet
    Packages**, then it will by default use the latest specific version of a package.
    But if you copy and paste configuration from a blog article or manually add a
    reference yourself, you might include wildcard qualifiers.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`dotnet add package`命令，或者Visual Studio的**管理NuGet包**，那么它将默认使用包的最新特定版本。但如果你从博客文章复制粘贴配置或手动添加引用，你可能会包含通配符限定词。
- en: 'The following dependencies are examples of NuGet package references that are
    *not* fixed and therefore should be avoided unless you know the implications:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖关系是NuGet包引用的示例，它们*未*固定，因此除非你知道其含义，否则应避免使用：
- en: '[PRE41]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Good Practice**: Microsoft guarantees that if you fixed your dependencies
    to what ships with a specific version of .NET, for example, 6.0.0, those packages
    will all work together. Almost always fix your dependencies.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：微软保证，如果你将依赖关系固定到.NET的特定版本随附的内容，例如6.0.0，那么这些包都将协同工作。几乎总是固定你的依赖关系。'
- en: Packaging a library for NuGet
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为NuGet打包一个库
- en: 'Now, let''s package the `SharedLibrary` project that you created earlier:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打包你之前创建的`SharedLibrary`项目：
- en: In the `SharedLibrary` project, rename the `Class1.cs` file to `StringExtensions.cs`.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedLibrary`项目中，将`Class1.cs`文件重命名为`StringExtensions.cs`。
- en: 'Modify its contents to provide some useful extension methods for validating
    various text values using regular expressions, as shown in the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容，以提供一些使用正则表达式验证各种文本值的有用扩展方法，如下列代码所示：
- en: '[PRE42]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You will learn how to write regular expressions in *Chapter 8*, *Working with
    Common .NET Types*.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将在*第8章*，*使用常见的.NET类型*中学习如何编写正则表达式。
- en: 'In `SharedLibrary.csproj`, modify its contents, as shown highlighted in the
    following markup, and note the following:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedLibrary.csproj`中，修改其内容，如下列标记中突出显示所示，并注意以下事项：
- en: '`PackageId` must be globally unique, so you must use a different value if you
    want to publish this NuGet package to the [https://www.nuget.org/](https://www.nuget.org/)
    public feed for others to reference and download.'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageId`必须全局唯一，因此如果您希望将此NuGet包发布到[https://www.nuget.org/](https://www.nuget.org/)公共源供他人引用和下载，则必须使用不同的值。'
- en: '`PackageLicenseExpression` must be a value from the following link: [https://spdx.org/licenses/](https://spdx.org/licenses/)
    or you could specify a custom license.'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageLicenseExpression`必须是从以下链接获取的值：[https://spdx.org/licenses/](https://spdx.org/licenses/)，或者您可以指定一个自定义许可证。'
- en: 'All the other elements are self-explanatory:'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他元素不言自明：
- en: '[PRE43]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Good Practice**: Configuration property values that are `true` or `false`
    values cannot have any whitespace so the `<PackageRequireLicenseAcceptance>` entry
    cannot have a carriage return and indentation as shown in the preceding markup.'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：配置属性值如果是`true`或`false`值，则不能包含任何空格，因此`<PackageRequireLicenseAcceptance>`条目不能像前面标记中那样包含回车和缩进。'
- en: 'Download the icon file and save it in the `SharedLibrary` folder from the following
    link: [https://github.com/markjprice/cs10dotnet6/blob/main/vs4win/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png](https://github.com/markjprice/cs10dotnet6/blob/main/vs4win/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png).'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载图标文件并保存到`SharedLibrary`文件夹：[https://github.com/markjprice/cs10dotnet6/blob/main/vs4win/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png](https://github.com/markjprice/cs10dotnet6/blob/main/vs4win/Chapter07/SharedLibrary/packt-csdotnet-sharedlibrary.png)。
- en: 'Build the release assembly:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建发布程序集：
- en: In Visual Studio, select **Release** in the toolbar, and then navigate to **Build**
    | **Build SharedLibrary**.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，从工具栏选择**发布**，然后导航至**构建** | **构建SharedLibrary**。
- en: In Visual Studio Code, in **Terminal**, enter `dotnet build -c Release`
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在**终端**中输入`dotnet build -c Release`
- en: 'If we had not set `<GeneratePackageOnBuild>` to `true` in the project file,
    then we would have to create a NuGet package manually using the following additional
    steps:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们未在项目文件中将`<GeneratePackageOnBuild>`设置为`true`，则需要按照以下额外步骤手动创建NuGet包：
- en: In Visual Studio, navigate to **Build** | **Pack SharedLibrary**.
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航至**构建** | **打包SharedLibrary**。
- en: In Visual Studio Code, in **Terminal**, enter `dotnet pack -c Release`.
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在**终端**中输入`dotnet pack -c Release`。
- en: Publishing a package to a public NuGet feed
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将包发布到公共NuGet源
- en: 'If you want everyone to be able to download and use your NuGet package, then
    you must upload it to a public NuGet feed like Microsoft''s:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望所有人都能下载并使用您的NuGet包，则必须将其上传到公共NuGet源，例如Microsoft的：
- en: 'Start your favorite browser and navigate to the following link: [https://www.nuget.org/packages/manage/upload](https://www.nuget.org/packages/manage/upload).'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的浏览器并导航至以下链接：[https://www.nuget.org/packages/manage/upload](https://www.nuget.org/packages/manage/upload)。
- en: You will need to sign in with a Microsoft account at [https://www.nuget.org/](https://www.nuget.org/)
    if you want to upload a NuGet package for other developers to reference as a dependency
    package.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您希望上传NuGet包供其他开发者作为依赖包引用，则需要在[https://www.nuget.org/](https://www.nuget.org/)使用Microsoft账户登录。
- en: Click on **Browse...** and select the `.nupkg` file that was created by generating
    the NuGet package. The folder path should be `Code\Chapter07\SharedLibrary\bin\Release`
    and the file is named `Packt.CSdotnet.SharedLibrary.6.0.0.nupkg`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**浏览...**并选择由生成NuGet包创建的`.nupkg`文件。文件夹路径应为`Code\Chapter07\SharedLibrary\bin\Release`，文件名为`Packt.CSdotnet.SharedLibrary.6.0.0.nupkg`。
- en: Verify that the information you entered in the `SharedLibrary.csproj` file has
    been correctly filled in, and then click **Submit**.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您在`SharedLibrary.csproj`文件中输入的信息已正确填写，然后点击**提交**。
- en: Wait a few seconds, and you will see a success message showing that your package
    has been uploaded, as shown in *Figure 7.8*:![](img/B17442_07_08.png)
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍等片刻，您将看到一条成功消息，显示您的包已上传，如*图7.8*所示：![](img/B17442_07_08.png)
- en: 'Figure 7.8: A NuGet package upload message'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.8*：NuGet包上传消息'
- en: '**Good Practice**: If you get an error, then review the project file for mistakes,
    or read more information about the `PackageReference` format at [https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets](https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets).'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：如果遇到错误，请检查项目文件中的错误，或阅读有关`PackageReference`格式的更多信息，网址为[https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets](https://docs.microsoft.com/en-us/nuget/reference/msbuild-targets)。'
- en: Publishing a package to a private NuGet feed
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将包发布到私有NuGet源
- en: 'Organizations can host their own private NuGet feeds. This can be a handy way
    for many developer teams to share work. You can read more at the following link:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 组织可以托管自己的私有NuGet源。这对许多开发团队来说是一种便捷的共享工作方式。你可以在以下链接了解更多信息：
- en: '[https://docs.microsoft.com/en-us/nuget/hosting-packages/overview](https://docs.microsoft.com/en-us/nuget/hosting-packages/overview)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/nuget/hosting-packages/overview](https://docs.microsoft.com/en-us/nuget/hosting-packages/overview)'
- en: Exploring NuGet packages with a tool
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工具探索NuGet包
- en: 'A handy tool named **NuGet Package Explorer** for opening and reviewing more
    details about a NuGet package was created by Uno Platform. As well as being a
    website, it can be installed as a cross-platform app. Let''s see what it can do:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为**NuGet Package Explorer**的便捷工具，由Uno Platform创建，用于打开并查看NuGet包的更多详细信息。它不仅是一个网站，还可以作为跨平台应用安装。让我们看看它能做什么：
- en: 'Start your favorite browser and navigate to the following link: [https://nuget.info](https://nuget.info).'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你最喜欢的浏览器并导航至以下链接：[https://nuget.info](https://nuget.info)。
- en: In the search box, enter `Packt.CSdotnet.SharedLibrary`.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`Packt.CSdotnet.SharedLibrary`。
- en: Select the package **v6.0.0** published by **Mark J Price** and then click the
    **Open** button.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择由**Mark J Price**发布的**v6.0.0**包，然后点击**打开**按钮。
- en: In the **Contents** section, expand the **lib** folder and the **netstandard2.0**
    folder.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**目录**部分，展开**lib**文件夹和**netstandard2.0**文件夹。
- en: Select **SharedLibrary.dll**, and note the details, as shown in *Figure 7.9*:![](img/B17442_07_09.png)
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**SharedLibrary.dll**，并注意详细信息，如*图7.9*所示：![](img/B17442_07_09.png)
- en: 'Figure 7.9: Exploring my package using NuGet Package Explorer from Uno Platform'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图7.9*：使用Uno Platform的NuGet Package Explorer探索我的包'
- en: If you want to use this tool locally in the future, click the install button
    in your browser.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想将来在本地使用此工具，请在你的浏览器中点击安装按钮。
- en: Close your browser.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: Not all browsers support installing web apps like this. I recommend Chrome for
    testing and development.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有浏览器都支持安装此类网络应用。我推荐使用Chrome进行测试和开发。
- en: Testing your class library package
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的类库包
- en: 'You will now test your uploaded package by referencing it in the `AssembliesAndNamespaces`
    project:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将通过在`AssembliesAndNamespaces`项目中引用它来测试你上传的包：
- en: 'In the `AssembliesAndNamespaces` project, add a reference to your (or my) package,
    as shown highlighted in the following markup:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AssembliesAndNamespaces`项目中，添加对你（或我）的包的引用，如下所示高亮显示：
- en: '[PRE44]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Build the console app.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建控制台应用。
- en: In `Program.cs`, import the `Packt.Shared` namespace.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入`Packt.Shared`命名空间。
- en: 'In `Program.cs`, prompt the user to enter some `string` values, and then validate
    them using the extension methods in the package, as shown in the following code:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，提示用户输入一些`string`值，然后使用包中的扩展方法进行验证，如下所示：
- en: '[PRE45]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the code, enter some values as prompted, and view the results, as shown
    in the following output:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按提示输入一些值，并查看结果，如下所示：
- en: '[PRE46]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Porting from .NET Framework to modern .NET
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从.NET Framework迁移到现代.NET
- en: If you are an existing .NET Framework developer, then you may have existing
    applications that you think you should port to modern .NET. But you should carefully
    consider if porting is the right choice for your code, because sometimes, the
    best choice is not to port.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是现有的.NET Framework开发者，那么你可能拥有一些你认为应该迁移到现代.NET的应用程序。但你应该仔细考虑迁移是否是你的代码的正确选择，因为有时候，最好的选择是不迁移。
- en: For example, you might have a complex website project that runs on .NET Framework
    4.8 but is only visited by a small number of users. If it works and handles the
    visitor traffic on minimal hardware, then potentially spending months porting
    it to .NET 6 could be a waste of time. But if the website currently requires many
    expensive Windows servers, then the cost of porting could eventually pay off if
    you can migrate to fewer, less costly Linux servers.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能有一个复杂的网站项目，运行在 .NET Framework 4.8 上，但只有少数用户访问。如果它运行良好，并且能够在最少的硬件上处理访问者流量，那么可能花费数月时间将其移植到
    .NET 6 可能是浪费时间。但如果该网站目前需要许多昂贵的 Windows 服务器，那么移植的成本最终可能会得到回报，如果您能迁移到更少、成本更低的 Linux
    服务器。
- en: Could you port?
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您能移植吗？
- en: 'Modern .NET has great support for the following types of applications on Windows,
    macOS, and Linux so they are good candidates for porting:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 .NET 对 Windows、macOS 和 Linux 上的以下类型的应用程序有很好的支持，因此它们是很好的移植候选：
- en: '**ASP.NET Core MVC** websites.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET Core MVC** 网站。'
- en: '**ASP.NET Core Web API** web services (REST/HTTP).'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET Core Web API** 网络服务（REST/HTTP）。'
- en: '**ASP.NET Core SignalR** services.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET Core SignalR** 服务。'
- en: '**Console application** command-line interfaces.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台应用程序** 命令行界面。'
- en: 'Modern .NET has decent support for the following types of applications on Windows,
    so they are potential candidates for porting:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 .NET 对 Windows 上的以下类型的应用程序有不错的支持，因此它们是潜在的移植候选：
- en: '**Windows Forms** applications.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Forms** 应用程序。'
- en: '**Windows Presentation Foundation** (**WPF**) applications.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Presentation Foundation** (**WPF**) 应用程序。'
- en: 'Modern .NET has good support for the following types of applications on cross-platform
    desktop and mobile devices:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 .NET 对跨平台桌面和移动设备上的以下类型的应用程序有良好的支持：
- en: '**Xamarin** apps for mobile iOS and Android.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xamarin** 移动 iOS 和 Android 应用。'
- en: '**.NET MAUI** for desktop Windows and macOS, or mobile iOS and Android.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET MAUI** 用于桌面 Windows 和 macOS，或移动 iOS 和 Android。'
- en: 'Modern .NET does not support the following types of legacy Microsoft projects:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 .NET 不支持以下类型的遗留 Microsoft 项目：
- en: '**ASP.NET Web Forms** websites. These might be best reimplemented using **ASP.NET
    Core Razor Pages** or **Blazor**.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET Web Forms** 网站。这些可能最好使用 **ASP.NET Core Razor Pages** 或 **Blazor**
    重新实现。'
- en: '**Windows Communication Foundation** (**WCF**) services (but there is an open-source
    project named **CoreWCF** that you might be able to use depending on requirements).
    WCF services might be better reimplemented using **ASP.NET Core gRPC** services.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows Communication Foundation** (**WCF**) 服务（但有一个名为 **CoreWCF** 的开源项目，您可能可以根据需求使用）。WCF
    服务可能最好使用 **ASP.NET Core gRPC** 服务重新实现。'
- en: '**Silverlight** applications. These might be best reimplemented using **.NET
    MAUI**.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Silverlight** 应用程序。这些可能最好使用 **.NET MAUI** 重新实现。'
- en: Silverlight and ASP.NET Web Forms applications will never be able to be ported
    to modern .NET, but existing Windows Forms and WPF applications could be ported
    to .NET on Windows in order to benefit from the new APIs and faster performance.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Silverlight 和 ASP.NET Web Forms 应用程序将永远无法移植到现代 .NET，但现有的 Windows Forms 和 WPF
    应用程序可以移植到 Windows 上的 .NET，以便利用新的 API 和更快的性能。
- en: Legacy ASP.NET MVC web applications and ASP.NET Web API web services currently
    on .NET Framework could be ported to modern .NET and then be hosted on Windows,
    Linux, or macOS.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留的 ASP.NET MVC 网络应用程序和当前在 .NET Framework 上的 ASP.NET Web API 网络服务可以移植到现代 .NET，然后托管在
    Windows、Linux 或 macOS 上。
- en: Should you port?
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您应该移植吗？
- en: 'Even if you *could* port, *should* you? What benefits do you gain? Some common
    benefits include the following:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您 *能* 移植，您 *应该* 移植吗？您能获得什么好处？一些常见的好处包括以下几点：
- en: '**Deployment to Linux, Docker, or Kubernetes for websites and web services**:
    These OSes are lightweight and cost-effective as website and web service platforms,
    especially when compared to the more costly Windows Server.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署到 Linux、Docker 或 Kubernetes 的网站和网络服务**：这些操作系统作为网站和网络服务平台轻量且成本效益高，尤其是与更昂贵的
    Windows Server 相比。'
- en: '**Removal of dependency on IIS and System.Web.dll**: Even if you continue to
    deploy to Windows Server, ASP.NET Core can be hosted on lightweight, higher-performance
    Kestrel (or other) web servers.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除对 IIS 和 System.Web.dll 的依赖**：即使您继续部署到 Windows Server，ASP.NET Core 也可以托管在轻量级、高性能的
    Kestrel（或其他）Web 服务器上。'
- en: '**Command-line tools**: Tools that developers and administrators use to automate
    their tasks are often built as console applications. The ability to run a single
    tool cross-platform is very useful.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行工具**：开发人员和管理员用于自动化任务的工具通常构建为控制台应用程序。能够在跨平台上运行单个工具非常有用。'
- en: Differences between .NET Framework and modern .NET
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET Framework 与现代 .NET 之间的差异
- en: 'There are three key differences, as shown in the following table:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个关键差异，如下表所示：
- en: '| Modern .NET | .NET Framework |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| 现代 .NET | .NET Framework |'
- en: '| Distributed as NuGet packages, so each application can be deployed with its
    own app-local copy of the version of .NET that it needs. | Distributed as a system-wide,
    shared set of assemblies (literally, in the Global Assembly Cache (GAC)). |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| 作为 NuGet 包分发，因此每个应用程序都可以部署其所需的 .NET 版本的本地副本。 | 作为系统范围的共享程序集集（实际上，在全局程序集缓存
    (GAC) 中）分发。 |'
- en: '| Split into small, layered components, so a minimal deployment can be performed.
    | Single, monolithic deployment. |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| 拆分为小的、分层的组件，以便可以执行最小部署。 | 单一的、整体的部署。 |'
- en: '| Removes older technologies, such as ASP.NET Web Forms, and non-cross-platform
    features, such as AppDomains, .NET Remoting, and binary serialization. | As well
    as some similar technologies to those in modern .NET like ASP.NET Core MVC, it
    also retains some older technologies, such as ASP.NET Web Forms. |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| 移除旧技术，如 ASP.NET Web Forms，以及非跨平台特性，如 AppDomains、.NET Remoting 和二进制序列化。 |
    以及一些与现代 .NET 中类似的技术，如 ASP.NET Core MVC，它还保留了一些旧技术，如 ASP.NET Web Forms。 |'
- en: Understanding the .NET Portability Analyzer
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 .NET Portability Analyzer
- en: 'Microsoft has a useful tool that you can run against your existing applications
    to generate a report for porting. You can watch a demonstration of the tool at
    the following link: [https://channel9.msdn.com/Blogs/Seth-Juarez/A-Brief-Look-at-the-NET-Portability-Analyzer](https://channel9.msdn.com/Blogs/Seth-Juarez/A-Brief-Look-at-the-NET-Portability-Analyzer).'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 有一个有用的工具，你可以针对现有应用程序运行它来生成移植报告。你可以在以下链接观看该工具的演示：[https://channel9.msdn.com/Blogs/Seth-Juarez/A-Brief-Look-at-the-NET-Portability-Analyzer](https://channel9.msdn.com/Blogs/Seth-Juarez/A-Brief-Look-at-the-NET-Portability-Analyzer)。
- en: Understanding the .NET Upgrade Assistant
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 .NET Upgrade Assistant
- en: Microsoft's latest tool for upgrading legacy projects to modern .NET is the
    .NET Upgrade Assistant.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 最新推出的用于将遗留项目升级到现代 .NET 的工具是 .NET Upgrade Assistant。
- en: For my day job, I work for a company named Optimizely. We have an enterprise-scale
    Digital Experience Platform (DXP) based on .NET Framework comprising a Content
    Management System (CMS) and for building digital commerce websites. Microsoft
    needed a challenging migration project to design and test the .NET Upgrade Assistant
    with, so we worked with them to build a great tool.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的日常工作中，我为一家名为 Optimizely 的公司工作。我们有一个基于 .NET Framework 的企业级数字体验平台 (DXP)，包括内容管理系统
    (CMS) 和构建数字商务网站。Microsoft 需要一个具有挑战性的迁移项目来设计和测试 .NET Upgrade Assistant，因此我们与他们合作构建了一个出色的工具。
- en: 'Currently, it supports the following .NET Framework project types and more
    will be added later:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它支持以下 .NET Framework 项目类型，未来还将添加更多：
- en: ASP.NET MVC
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET MVC
- en: Windows Forms
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Forms
- en: WPF
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WPF
- en: Console Application
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Console Application
- en: Class Library
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Class Library
- en: 'It is installed as a global `dotnet` tool, as shown in the following command:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为全局 `dotnet` 工具安装，如下面的命令所示：
- en: '[PRE47]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can read more about this tool and how to use it at the following link:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于此工具及其使用方法的信息：
- en: '[https://docs.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview](https://docs.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview](https://docs.microsoft.com/en-us/dotnet/core/porting/upgrade-assistant-overview)'
- en: Using non-.NET Standard libraries
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非 .NET Standard 库
- en: Most existing NuGet packages can be used with modern .NET, even if they are
    not compiled for .NET Standard or a modern version like .NET 6\. If you find a
    package that does not officially support .NET Standard, as shown on its [nuget.org](https://www.nuget.org/)
    web page, you do not have to give up. You should try it and see if it works.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现有的 NuGet 包都可以与现代 .NET 配合使用，即使它们不是为 .NET Standard 或类似 .NET 6 这样的现代版本编译的。如果你发现一个包在其
    [nuget.org](https://www.nuget.org/) 网页上并未正式支持 .NET Standard，你不必放弃。你应该尝试一下，看看它是否能正常工作。
- en: 'For example, there is a package of custom collections for handling matrices
    created by Dialect Software LLC, documented at the following link:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Dialect Software LLC 创建了一个处理矩阵的自定义集合包，其文档链接如下：
- en: '[https://www.nuget.org/packages/DialectSoftware.Collections.Matrix/](https://www.nuget.org/packages/DialectSoftware.Collections.Matrix/)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.nuget.org/packages/DialectSoftware.Collections.Matrix/](https://www.nuget.org/packages/DialectSoftware.Collections.Matrix/)'
- en: This package was last updated in 2013, which was long before .NET Core or .NET
    6 existed, so this package was built for .NET Framework. As long as an assembly
    package like this only uses APIs available in .NET Standard, it can be used in
    a modern .NET project.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包最后一次更新是在2013年，远在.NET Core或.NET 6出现之前，所以这个包是为.NET Framework构建的。只要像这样的程序集包仅使用.NET
    Standard中可用的API，它就可以用于现代.NET项目。
- en: 'Let''s try using it and see if it works:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来尝试使用它，看看是否有效：
- en: 'In the `AssembliesAndNamespaces` project, add a package reference for Dialect
    Software''s package, as shown in the following markup:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AssembliesAndNamespaces`项目中，添加对Dialect Software包的包引用，如下所示：
- en: '[PRE48]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Build the `AssembliesAndNamespaces` project to restore packages.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`AssembliesAndNamespaces`项目以恢复包。
- en: In `Program.cs`, add statements to import the `DialectSoftware.Collections`
    and `DialectSoftware.Collections.Generics` namespaces.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以导入`DialectSoftware.Collections`和`DialectSoftware.Collections.Generics`命名空间。
- en: 'Add statements to create instances of `Axis` and `Matrix<T>`, populate them
    with values, and output them, as shown in the following code:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以创建`Axis`和`Matrix<T>`的实例，填充它们并输出它们，如下所示：
- en: '[PRE49]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the code, noting the warning message and the results, as shown in the following
    output:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，注意警告信息和结果，如下所示：
- en: '[PRE50]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Even though this package was created before .NET 6 existed, and the compiler
    and runtime have no way of knowing if it will work and therefore show warnings,
    because it happens to only call .NET Standard-compatible APIs, it works.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个包是在.NET 6出现之前创建的，编译器和运行时无法知道它是否会工作，因此显示警告，但由于它恰好只调用与.NET Standard兼容的API，它能够工作。
- en: Working with preview features
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预览功能
- en: It is a challenge for Microsoft to deliver some new features that have cross-cutting
    effects across many parts of .NET like the runtime, language compilers, and API
    libraries. It is the classic chicken and egg problem. What do you do first?
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微软来说，提供一些具有跨领域影响的全新功能是一项挑战，这些功能涉及.NET的许多部分，如运行时、语言编译器和API库。这是一个经典的先有鸡还是先有蛋的问题。你首先应该做什么？
- en: From a practical perspective, it means that although Microsoft might have completed
    the majority of the work needed for a feature, the whole thing might not be ready
    until very late in their now annual cycle of .NET releases, too late for proper
    testing in "the wild."
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度来看，这意味着尽管微软可能已经完成了大部分所需工作，但整个功能可能要到.NET年度发布周期的后期才能准备就绪，那时已太晚，无法在“野外”进行适当的测试。
- en: So, from .NET 6 onward, Microsoft will include preview features in **general
    availability** (**GA**) releases. Developers can opt into these preview features
    and provide Microsoft with feedback. In a later GA release, they can be enabled
    for everyone.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从.NET 6开始，微软将在**正式发布**（**GA**）版本中包含预览功能。开发者可以选择加入这些预览功能并向微软提供反馈。在后续的GA版本中，这些功能可以为所有人启用。
- en: '**Good Practice**: Preview features are not supported in production code. Preview
    features are likely to have breaking changes before the final release. Enable
    preview features at your own risk.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：预览功能不支持在生产代码中使用。预览功能在最终发布前可能会发生重大变更。启用预览功能需自行承担风险。'
- en: Requiring preview features
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要预览功能
- en: The `[RequiresPreviewFeatures]` attribute is used to indicate assemblies, types,
    or members that use and therefore require warnings about preview features. A code
    analyzer then scans for this assembly and generates warnings if needed. If your
    code does not use any preview features, you will not see any warnings. If you
    use any preview features, then your code should warn consumers of your code that
    you use preview features.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`[RequiresPreviewFeatures]`属性用于标识使用预览功能并因此需要关于预览功能的警告的程序集、类型或成员。代码分析器随后扫描此程序集，并在必要时生成警告。如果您的代码未使用任何预览功能，您将不会看到任何警告。如果您使用了任何预览功能，那么您的代码应该警告使用您代码的消费者，您使用了预览功能。'
- en: Enabling preview features
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用预览功能
- en: 'Let''s look at an example of a preview feature available in .NET 6, the ability
    to define an interface with a static abstract method:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个.NET 6中可用的预览功能示例，即定义一个带有静态抽象方法的接口的能力：
- en: Use your preferred code editor to add a new console app named `UsingPreviewFeatures`
    to the `Chapter07` solution/workspace.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，在`Chapter07`解决方案/工作区中添加一个名为`UsingPreviewFeatures`的新控制台应用程序。
- en: In Visual Studio Code, select `UsingPreviewFeatures` as the active OmniSharp
    project. When you see the pop-up warning message saying that required assets are
    missing, click **Yes** to add them.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`UsingPreviewFeatures`作为活动的OmniSharp项目。当看到弹出警告消息提示缺少必需资产时，点击**是**以添加它们。
- en: 'In the project file, add an element to enable preview features and an element
    to enable preview language features, as shown highlighted in the following markup:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，添加一个元素以启用预览功能，并添加一个元素以启用预览语言功能，如以下标记中突出显示的那样：
- en: '[PRE51]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In `Program.cs`, delete the comment and statically import the `Console` class.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除注释并静态导入`Console`类。
- en: 'Add statements to define an interface with a static abstract method, a class
    that implements it, and then call the method in the top-level program, as shown
    in the following code:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义具有静态抽象方法的接口、实现该接口的类，然后在顶层程序中调用该方法，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Run the console app and note that it outputs correctly.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用并注意其输出是否正确。
- en: Generic mathematics
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型数学
- en: Why has Microsoft added the ability to define static abstract methods? What
    are they useful for?
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么微软增加了定义静态抽象方法的能力？它们有何用途？
- en: For a long time, developers have asked Microsoft for the ability to use operators
    like * on generic types. This would enable a developer to define mathematical
    methods to perform operations like adding, averaging, and so on to any generic
    type rather than having to create dozens of overloaded methods for all the numeric
    types they want to support. Support for static abstract methods in interfaces
    is a foundational feature that would enable generic mathematics.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，开发者一直要求微软提供在泛型类型上使用*等运算符的能力。这将使开发者能够定义数学方法，对任何泛型类型执行加法、平均值等操作，而不必为所有想要支持的数值类型创建数十个重载方法。接口中对静态抽象方法的支持是一个基础特性，它将使泛型数学成为可能。
- en: 'If you are interested, you can read more about this at the following link:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此感兴趣，可以在以下链接中阅读更多信息：
- en: '[https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/](https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/)'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/](https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/)'
- en: Practicing and exploring
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践与探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring with deeper research into topics of this chapter.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、获得一些实践经验以及深入研究本章主题，测试你的知识和理解。
- en: Exercise 7.1 – Test your knowledge
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What is the difference between a namespace and an assembly?
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间与程序集之间有何区别？
- en: How do you reference another project in a `.csproj` file?
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在`.csproj`文件中引用另一个项目？
- en: What is the benefit of a tool like ILSpy?
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像ILSpy这样的工具有什么好处？
- en: Which .NET type does the C# `float` alias represent?
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#中的`float`别名代表哪种.NET类型？
- en: When porting an application from .NET Framework to .NET 6, what tool should
    you run before porting, and what tool could you run to perform much of the porting
    work?
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将应用程序从.NET Framework迁移到.NET 6之前，应该运行什么工具，以及可以使用什么工具来执行大部分迁移工作？
- en: What is the difference between framework-dependent and self-contained deployments
    of .NET applications?
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET应用程序的框架依赖部署和自包含部署之间有何区别？
- en: What is a RID?
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是RID？
- en: What is the difference between the `dotnet pack` and `dotnet publish` commands?
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dotnet pack`和`dotnet publish`命令之间有何区别？'
- en: What types of applications written for the .NET Framework can be ported to modern
    .NET?
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的.NET Framework应用程序可以迁移到现代.NET？
- en: Can you use packages written for .NET Framework with modern .NET?
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能否使用为.NET Framework编写的包与现代.NET兼容？
- en: Exercise 7.2 – Explore topics
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.2 – 探索主题
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接，深入了解本章涵盖的主题：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-7---understanding-and-packaging-net-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-7---understanding-and-packaging-net-types)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-7---understanding-and-packaging-net-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-7---understanding-and-packaging-net-types)'
- en: Exercise 7.3 – Explore PowerShell
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.3 – 探索PowerShell
- en: PowerShell is Microsoft's scripting language for automating tasks on every operating
    system. Microsoft recommends Visual Studio Code with the PowerShell extension
    for writing PowerShell scripts.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell是微软为在每个操作系统上自动化任务而设计的脚本语言。微软推荐使用带有PowerShell扩展的Visual Studio Code来编写PowerShell脚本。
- en: 'Since PowerShell is its own extensive language there is not space in this book
    to cover it. Instead, I have created some supplementary pages on the books GitHub
    repository to introduce you to some key concepts and show some examples:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PowerShell是一种广泛的语言，本书中没有足够的篇幅来涵盖它。因此，我在书籍的GitHub仓库中创建了一些补充页面，向您介绍一些关键概念并展示一些示例：
- en: '[https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell](https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell](https://github.com/markjprice/cs10dotnet6/tree/main/docs/powershell)'
- en: Summary
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the journey to .NET 6, we explored the relationship
    between assemblies and namespaces, we saw options for publishing an app for distribution
    to multiple operating systems, packaged and distributed a class library, and we
    discussed options for porting existing .NET Framework code bases.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们回顾了通往.NET 6的旅程，探讨了程序集与命名空间之间的关系，了解了将应用程序发布到多个操作系统的选项，打包并分发了一个类库，并讨论了移植现有.NET
    Framework代码库的选项。
- en: In the next chapter, you will learn about some common Base Class Library types
    that are included with modern .NET.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习到现代.NET中包含的一些常见基类库类型。
