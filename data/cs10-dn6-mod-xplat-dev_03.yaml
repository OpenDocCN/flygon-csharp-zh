- en: '03'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '03'
- en: Controlling Flow, Converting Types, and Handling Exceptions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流程、类型转换和异常处理
- en: This chapter is all about writing code that performs simple operations on variables,
    makes decisions, performs pattern matching, repeats statements or blocks, converts
    variable or expression values from one type to another, handles exceptions, and
    checks for overflows in number variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于编写对变量执行简单操作、做出决策、执行模式匹配、重复语句或代码块、将变量或表达式的值从一种类型转换为另一种类型、处理异常以及检查数字变量溢出的代码。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Operating on variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作变量
- en: Understanding selection statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解选择语句
- en: Understanding iteration statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解迭代语句
- en: Casting and converting between types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型之间的转换和强制转换
- en: Handling exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Checking for overflow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查溢出
- en: Operating on variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作变量
- en: '**Operators** apply simple operations such as addition and multiplication to
    **operands** such as variables and literal values. They usually return a new value
    that is the result of the operation that can be assigned to a variable.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**运算符**对**操作数**（如变量和字面值）执行简单的操作，如加法和乘法。它们通常返回一个新值，即操作的结果，该结果可以分配给一个变量。'
- en: 'Most operators are binary, meaning that they work on two operands, as shown
    in the following pseudocode:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符是二元的，意味着它们作用于两个操作数，如下面的伪代码所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Examples of binary operators include adding and multiplying, as shown in the
    following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 二元运算符的例子包括加法和乘法，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some operators are unary, meaning they work on a single operand, and can apply
    before or after the operand, as shown in the following pseudocode:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些运算符是单目的，意味着它们作用于单个操作数，并且可以应用于操作数之前或之后，如下面的伪代码所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Examples of unary operators include incrementors and retrieving a type or its
    size in bytes, as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单目运算符的例子包括增量器和获取类型或其大小（以字节为单位），如下面的代码所示：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A ternary operator works on three operands, as shown in the following pseudocode:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符作用于三个操作数，如下面的伪代码所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exploring unary operators
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索单目运算符
- en: 'Two common unary operators are used to increment, `++`, and decrement, `--`,
    a number. Let us write some example code to show how they work:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两个常用的单目运算符用于增加（`++`）和减少（`--`）一个数字。让我们写一些示例代码来展示它们是如何工作的：
- en: If you've completed the previous chapters, then you will already have a `Code`
    folder. If not, then you'll need to create it.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经完成了前面的章节，那么你将已经有一个`Code`文件夹。如果没有，那么你需要创建它。
- en: 'Use your preferred coding tool to create a new console app, as defined in the
    following list:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编程工具创建一个新的控制台应用程序，如下表所定义：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter03`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter03`
- en: 'Project file and folder: `Operators`'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Operators`
- en: At the top of `Program.cs`, statically import `System.Console`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，静态导入`System.Console`。
- en: 'In `Program.cs`, declare two integer variables named `a` and `b`, set `a` to
    `3`, increment `a` while assigning the result to `b`, and then output their values,
    as shown in the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，声明两个整型变量`a`和`b`，将`a`设置为`3`，在将结果赋给`b`的同时增加`a`，然后输出它们的值，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before running the console application, ask yourself a question: what do you
    think the value of `b` will be when output? Once you''ve thought about that, run
    the code, and compare your prediction against the actual result, as shown in the
    following output:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行控制台应用程序之前，问自己一个问题：你认为输出时`b`的值会是多少？一旦你考虑了这一点，运行代码，并将你的预测与实际结果进行比较，如下面的输出所示：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The variable `b` has the value `3` because the `++` operator executes *after*
    the assignment; this is known as a **postfix operator**. If you need to increment
    *before* the assignment, then use the **prefix operator**.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量`b`的值为`3`，因为`++`运算符在赋值*之后*执行；这被称为**后缀运算符**。如果你需要在赋值*之前*增加，那么使用**前缀运算符**。
- en: 'Copy and paste the statements, and then modify them to rename the variables
    and use the prefix operator, as shown in the following code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴这些语句，然后修改它们以重命名变量并使用前缀运算符，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Rerun the code and note the result, as shown in the following output:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并注意结果，如下面的输出所示：
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Good Practice**: Due to the confusion between prefix and postfix for the
    increment and decrement operators when combined with an assignment, the Swift
    programming language designers decided to drop support for this operator in version
    3\. My recommendation for usage in C# is to never combine the use of `++` and
    `--` operators with an assignment operator, `=`. Perform the operations as separate
    statements.'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：由于增量和减量运算符的前缀和后缀结合赋值时的混淆，Swift编程语言设计者在版本3中决定不再支持此运算符。我建议在C#中使用时，切勿将`++`和`--`运算符与赋值运算符`=`结合使用。将这些操作作为单独的语句执行。'
- en: Exploring binary arithmetic operators
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索二元算术运算符
- en: 'Increment and decrement are unary arithmetic operators. Other arithmetic operators
    are usually binary and allow you to perform arithmetic operations on two numbers,
    as the following shows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 增量和减量是一元算术运算符。其他算术运算符通常是二元的，允许你对两个数字执行算术运算，如下所示：
- en: 'Add the statements to declare and assign values to two integer variables named
    `e` and `f`, and then apply the five common binary arithmetic operators to the
    two numbers, as shown in the following code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以声明并赋值给两个名为`e`和`f`的整型变量，然后对这两个数字应用五个常见的二元算术运算符，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To understand the divide `/` and modulo `%` operators when applied to integers,
    you need to think back to primary school. Imagine you have eleven sweets and three
    friends.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要理解应用于整数的除法`/`和模`%`运算符，你需要回想小学时期。想象你有十一颗糖果和三个朋友。
- en: How can you divide the sweets between your friends? You can give three sweets
    to each of your friends, and there will be two left over. Those two sweets are
    the **modulus**, also known as the **remainder** after dividing. If you have twelve
    sweets, then each friend gets four of them, and there are none left over, so the
    remainder would be 0.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你如何将糖果分给你的朋友们？你可以给每位朋友三颗糖果，剩下两颗。那两颗糖果就是**模数**，也称为除法后的**余数**。如果你有十二颗糖果，那么每位朋友得到四颗，没有剩余，所以余数为0。
- en: 'Add statements to declare and assign a value to a `double` variable named `g`
    to show the difference between whole number and real number divisions, as shown
    in the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以声明并赋值给一个名为`g`的`double`变量，以展示整数和实数除法的区别，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the first operand is a floating-point number, such as `g` with the value
    `11.0`, then the divide operator returns a floating-point value, such as `3.6666666666665`,
    rather than a whole number.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数是浮点数，例如值为`11.0`的`g`，那么除法运算符返回一个浮点值，例如`3.6666666666665`，而不是整数。
- en: Assignment operators
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: You have already been using the most common assignment operator, `=`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经一直在使用最常见的赋值运算符，`=`。
- en: 'To make your code more concise, you can combine the assignment operator with
    other operators like arithmetic operators, as shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的代码更简洁，你可以将赋值运算符与其他运算符如算术运算符结合使用，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Exploring logical operators
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索逻辑运算符
- en: 'Logical operators operate on Boolean values, so they return either `true` or
    `false`. Let''s explore binary logical operators that operate on two Boolean values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符操作于布尔值，因此它们返回`true`或`false`。让我们探索操作于两个布尔值的二元逻辑运算符：
- en: Use your preferred coding tool to add a new console app to the `Chapter03` workspace/solution
    named `BooleanOperators`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的编程工具，在`Chapter03`工作区/解决方案中添加一个名为`BooleanOperators`的新控制台应用。
- en: In Visual Studio Code, select `BooleanOperators` as the active OmniSharp project.
    When you see the pop-up warning message saying that required assets are missing,
    click **Yes** to add them.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`BooleanOperators`作为活动的OmniSharp项目。当你看到弹出警告消息说缺少必需资产时，点击**是**以添加它们。
- en: In Visual Studio, set the start up project for the solution to the current selection.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，将解决方案的启动项目设置为当前选择的项目。
- en: '**Good Practice**: Remember to statically import the `System.Console` type
    to simplify statements.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：记得静态导入`System.Console`类型以简化语句。'
- en: 'In `Program.cs`, add statements to declare two Boolean variables with values
    of `true` and `false`, and then output truth tables showing the results of applying
    AND, OR, and XOR (exclusive OR) logical operators, as shown in the following code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句以声明两个布尔变量，其值分别为 `true` 和 `false`，然后输出应用 AND、OR 和 XOR（异或）逻辑运算符的结果的真值表，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the AND `&` logical operator, both operands must be `true` for the result
    to be `true`. For the OR `|` logical operator, either operand can be `true` for
    the result to be `true`. For the XOR `^` logical operator, either operand can
    be `true` (but not both!) for the result to be `true`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 AND `&` 逻辑运算符，两个操作数都必须为 `true` 才能使结果为 `true`。对于 OR `|` 逻辑运算符，任一操作数为 `true`
    即可使结果为 `true`。对于 XOR `^` 逻辑运算符，任一操作数可以为 `true`（但不能同时为 `true`！）以使结果为 `true`。
- en: Exploring conditional logical operators
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索条件逻辑运算符
- en: Conditional logical operators are like logical operators, but you use two symbols
    instead of one, for example, `&&` instead of `&`, or `||` instead of `|`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 条件逻辑运算符类似于逻辑运算符，但你需要使用两个符号而不是一个，例如，`&&` 代替 `&`，或者 `||` 代替 `|`。
- en: In *Chapter 4*, *Writing, Debugging, and Testing Functions*, you will learn
    about functions in more detail, but I need to introduce functions now to explain
    conditional logical operators, also known as short-circuiting Boolean operators.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章*，*编写、调试和测试函数* 中，你将更详细地了解函数，但我现在需要介绍函数以解释条件逻辑运算符，也称为短路布尔运算符。
- en: 'A function executes statements and then returns a value. That value could be
    a Boolean value like `true` that is used in a Boolean operation. Let''s make use
    of conditional logical operators:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 函数执行语句然后返回一个值。该值可以是用于布尔运算的布尔值，例如 `true`。让我们利用条件逻辑运算符：
- en: 'At the bottom of `Program.cs`, write statements to declare a function that
    writes a message to the console and returns `true`, as shown in the following
    code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 底部，编写语句以声明一个向控制台写入消息并返回 `true` 的函数，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Good Practice**: If you are using .NET Interactive Notebook, write the `DoStuff`
    function in a separate code cell and then execute it to make its context available
    to other code cells.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：如果你使用的是 .NET 交互式笔记本，请在单独的代码单元格中编写 `DoStuff` 函数，然后执行它，以便其上下文可供其他代码单元格使用。'
- en: 'After the previous `WriteLine` statements, perform an AND `&` operation on
    the `a` and `b` variables and the result of calling the function, as shown in
    the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的 `WriteLine` 语句之后，对 `a` 和 `b` 变量以及调用函数的结果执行 AND `&` 操作，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the code, view the result, and note that the function was called twice,
    once for a and once for b, as shown in the following output:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意该函数被调用了两次，一次是为 a，一次是为 b，如以下输出所示：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Change the `&` operators into `&&` operators, as shown in the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `&` 运算符更改为 `&&` 运算符，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the code, view the result, and note that the function does run when combined
    with the `a` variable. It does not run when combined with the `b` variable because
    the `b` variable is `false` so the result will be `false` anyway, so it does not
    need to execute the function, as shown in the following output:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意当与 `a` 变量结合时，函数确实运行了。当与 `b` 变量结合时，它不会运行，因为 `b` 变量是 `false`，所以结果无论如何都将是
    `false`，因此不需要执行该函数，如下面的输出所示：
- en: '[PRE20]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Good Practice**: Now you can see why the conditional logical operators are
    described as being short-circuiting. They can make your apps more efficient, but
    they can also introduce subtle bugs in cases where you assume that the function
    would always be called. It is safest to avoid them when used in combination with
    functions that cause side effects.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：现在你可以明白为什么条件逻辑运算符被描述为短路运算符。它们可以使你的应用程序更高效，但它们也可能在假设函数总是被调用的情况下引入微妙的错误。当与产生副作用的函数结合使用时，最安全的是避免使用它们。'
- en: Exploring bitwise and binary shift operators
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索位运算和二进制移位运算符
- en: Bitwise operators affect the bits in a number. Binary shift operators can perform
    some common arithmetic calculations much faster than traditional operators, for
    example, any multiplication by a factor of 2.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符影响数字中的位。二进制移位运算符可以比传统运算符更快地执行一些常见的算术计算，例如，任何乘以 2 的倍数。
- en: 'Let''s explore bitwise and binary shift operators:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索位运算和二进制移位运算符：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `BitwiseAndShiftOperators`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具，在`Chapter03`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`BitwiseAndShiftOperators`。
- en: In Visual Studio Code, select `BitwiseAndShiftOperators` as the active OmniSharp
    project. When you see the pop-up warning message saying that required assets are
    missing, click **Yes** to add them.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`BitwiseAndShiftOperators`作为活动OmniSharp项目。当看到弹出警告消息提示缺少必需资产时，点击**是**以添加它们。
- en: 'In `Program.cs`, type statements to declare two integer variables with values
    10 and 6, and then output the results of applying AND, OR, and XOR bitwise operators,
    as shown in the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，键入语句以声明两个整数变量，值分别为10和6，然后输出应用AND、OR和XOR位运算符的结果，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE22]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `Program.cs`, add statements to output the results of applying the left-shift
    operator to move the bits of the variable `a` by three columns, multiplying `a`
    by 8, and right-shifting the bits of the variable `b` by one column, as shown
    in the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以输出应用左移运算符将变量`a`的位移动三列、将`a`乘以8以及右移变量`b`的位一列的结果，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE24]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `80` result is because the bits in it were shifted three columns to the
    left, so the 1-bits moved into the 64- and 16-bit columns and 64 + 16 = 80\. This
    is the equivalent of multiplying by 8, but CPUs can perform a bit-shift faster.
    The 3 result is because the 1-bits in `b` were shifted one column into the 2-
    and 1-bit columns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果`80`是因为其中的位向左移动了三列，因此1位移动到了64位和16位列，64 + 16 = 80。这相当于乘以8，但CPU可以更快地执行位移。结果3是因为`b`中的1位向右移动了一列，进入了2位和1位列。
- en: '**Good Practice**: Remember that when operating on integer values, the `&`
    and `|` symbols are bitwise operators, and when operating on Boolean values like
    `true` and `false`, the `&` and `|` symbols are logical operators.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：记住，当操作整数值时，`&`和`|`符号是位运算符，而当操作布尔值如`true`和`false`时，`&`和`|`符号是逻辑运算符。'
- en: 'We can illustrate the operations by converting the integer values into binary
    strings of zeros and ones:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将整数值转换为零和一的二进制字符串来演示这些操作：
- en: 'At the bottom of `Program.cs`, add a function to convert an integer value into
    a binary (Base2) `string` of up to eight zeros and ones, as shown in the following
    code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，添加一个函数，将整数值转换为最多包含八个零和一的二进制（Base2）`字符串`，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Above the function, add statements to output `a`, `b`, and the results of the
    various bitwise operators, as shown in the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数上方，添加语句以输出`a`、`b`以及各种位运算符的结果，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '[PRE27]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Miscellaneous operators
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项运算符
- en: '`nameof` and `sizeof` are convenient operators when working with types:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`和`sizeof`是在处理类型时方便的运算符：'
- en: '`nameof` returns the short name (without the namespace) of a variable, type,
    or member as a `string` value, which is useful when outputting exception messages.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameof`返回变量、类型或成员的简短名称（不包含命名空间）作为`字符串`值，这在输出异常消息时非常有用。'
- en: '`sizeof` returns the size in bytes of simple types, which is useful for determining
    the efficiency of data storage.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeof`返回简单类型的大小（以字节为单位），这对于确定数据存储的效率非常有用。'
- en: 'There are many other operators; for example, the dot between a variable and
    its members is called the **member access operator** and the round brackets at
    the end of a function or method name are called the **invocation operator**, as
    shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他运算符；例如，变量与其成员之间的点称为**成员访问运算符**，函数或方法名称末尾的圆括号称为**调用运算符**，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Understanding selection statements
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解选择语句
- en: Every application needs to be able to select from choices and branch along different
    code paths. The two selection statements in C# are `if` and `switch`. You can
    use `if` for all your code, but `switch` can simplify your code in some common
    scenarios such as when there is a single variable that can have multiple values
    that each require different processing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都需要能够从选项中选择并沿不同的代码路径分支。C#中的两种选择语句是`if`和`switch`。你可以使用`if`来编写所有代码，但`switch`可以在某些常见场景中简化你的代码，例如当存在一个可以有多个值的单一变量，每个值都需要不同的处理时。
- en: Branching with the if statement
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句的分支
- en: The `if` statement determines which branch to follow by evaluating a Boolean
    expression. If the expression is `true`, then the block executes. The `else` block
    is optional, and it executes if the `if` expression is `false`. The `if` statement
    can be nested.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句通过评估一个布尔表达式来决定执行哪个分支。如果表达式为`true`，则执行该代码块。`else`块是可选的，如果`if`表达式为`false`，则执行`else`块。`if`语句可以嵌套。'
- en: 'The `if` statement can be combined with other `if` statements as `else if`
    branches, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句可以与其他`if`语句结合，形成`else if`分支，如下列代码所示：'
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each `if` statement's Boolean expression is independent of the others and, unlike
    `switch` statements, does not need to reference a single value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`if`语句的布尔表达式都是独立的，与`switch`语句不同，它不需要引用单一值。
- en: 'Let''s write some code to explore selection statements like `if`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来探索像`if`这样的选择语句：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `SelectionStatements`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编程工具，在`Chapter03`工作区/解决方案中添加一个名为`SelectionStatements`的新**控制台应用程序**。
- en: In Visual Studio Code, select `SelectionStatements` as the active OmniSharp
    project.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`SelectionStatements`作为活动OmniSharp项目。
- en: 'In `Program.cs`, type statements to check if a password is at least eight characters,
    as shown in the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句以检查密码是否至少有八个字符，如下列代码所示：
- en: '[PRE30]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下列输出所示：
- en: '[PRE31]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Why you should always use braces with if statements
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么你应该始终在if语句中使用大括号
- en: 'As there is only a single statement inside each block, the preceding code could
    be written without the curly braces, as shown in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个代码块内只有一条语句，前面的代码可以不使用花括号编写，如下列代码所示：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This style of `if` statement should be avoided because it can introduce serious
    bugs, for example, the infamous #gotofail bug in Apple''s iPhone iOS operating
    system.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免这种风格的`if`语句，因为它可能引入严重的错误，例如苹果iPhone iOS操作系统中臭名昭著的#gotofail错误。
- en: For 18 months after Apple's iOS 6 was released, in September 2012, it had a
    bug in its **Secure Sockets Layer** (**SSL**) encryption code, which meant that
    any user running Safari, the device's web browser, who tried to connect to secure
    websites, such as their bank, was not properly secure because an important check
    was being accidentally skipped.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在苹果发布iOS 6后的18个月内，即2012年9月，其**安全套接字层**（**SSL**）加密代码中存在一个错误，这意味着任何使用Safari（设备上的网页浏览器）尝试连接到安全网站（如银行）的用户都没有得到适当的保护，因为一个重要的检查被意外跳过了。
- en: Just because you can leave out the curly braces doesn't mean you should. Your
    code is not "more efficient" without them; instead, it is less maintainable and
    potentially more dangerous.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为你可以在没有花括号的情况下编写代码，并不意味着你应该这样做。没有它们的代码并不会“更高效”；相反，它更难以维护，且可能更危险。
- en: Pattern matching with the if statement
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句的模式匹配
- en: 'A feature introduced with C# 7.0 and later is pattern matching. The `if` statement
    can use the `is` keyword in combination with declaring a local variable to make
    your code safer:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 引入C# 7.0及更高版本的一个特性是模式匹配。`if`语句可以通过结合使用`is`关键字和声明一个局部变量来使代码更安全：
- en: 'Add statements so that if the value stored in the variable named `o` is an
    `int`, then the value is assigned to the local variable named `i`, which can then
    be used inside the `if` statement. This is safer than using the variable named
    `o` because we know for sure that `i` is an `int` variable and not something else,
    as shown in the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句，以便如果存储在名为`o`的变量中的值是`int`，则该值被赋给局部变量`i`，然后可以在`if`语句中使用。这比使用名为`o`的变量更安全，因为我们确信`i`是一个`int`变量，而不是其他东西，如下列代码所示：
- en: '[PRE33]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE34]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Delete the double-quote characters around the `"3"` value so that the value
    stored in the variable named `o` is an `int` type instead of a `string` type.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除围绕`"3"`值的双引号字符，以便存储在名为`o`的变量中的值是`int`类型而不是`string`类型。
- en: 'Rerun the code to view the results, as shown in the following output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码以查看结果，如下面的输出所示：
- en: '[PRE35]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Branching with the switch statement
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用switch语句进行分支
- en: 'The `switch` statement is different from the `if` statement because `switch`
    compares a single expression against a list of multiple possible `case` statements.
    Every `case` statement is related to the single expression. Every `case` section
    must end with:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句与`if`语句不同，因为`switch`将单个表达式与多个可能的`case`语句列表进行比较。每个`case`语句都与单个表达式相关。每个`case`部分必须以：'
- en: The `break` keyword (like case 1 in the following code)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`break`关键字（如下面的代码中的case 1）
- en: Or the `goto` `case` keywords (like case 2 in the following code)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者使用`goto` `case`关键字（如下面的代码中的case 2）
- en: Or they should have no statements (like case 3 in the following code)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者它们可以没有任何语句（如下面的代码中的case 3）
- en: Or the `goto` keyword that references a named label (like case 5 in the following
    code)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者`goto`关键字，它引用一个命名标签（如下面的代码中的case 5）
- en: Or the `return` keyword to leave the current function (not shown in the code)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者使用`return`关键字离开当前函数（未在代码中显示）
- en: 'Let''s write some code to explore the `switch` statements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来探索`switch`语句：
- en: 'Type statements for a `switch` statement. You should note that the penultimate
    statement is a label that can be jumped to, and the first statement generates
    a random number between 1 and 6 (the number 7 in the code is an exclusive upper
    bound). The `switch` statement branches are based on the value of this random
    number, as shown in the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`switch`语句编写语句。您应该注意到倒数第二条语句是一个可以跳转到的标签，而第一条语句生成一个介于1和6之间的随机数（代码中的数字7是上限）。`switch`语句分支基于这个随机数的值，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Good Practice**: You can use the `goto` keyword to jump to another case or
    a label. The `goto` keyword is frowned upon by most programmers but can be a good
    solution to code logic in some scenarios. However, you should use it sparingly.'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：您可以使用`goto`关键字跳转到另一个case或标签。大多数程序员对`goto`关键字持反对态度，但在某些情况下，它可以是解决代码逻辑的好方法。但是，您应该谨慎使用它。'
- en: 'Run the code multiple times to see what happens in various cases of random
    numbers, as shown in the following example output:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次运行代码以查看随机数在各种情况下的结果，如下面的示例输出所示：
- en: '[PRE37]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Pattern matching with the switch statement
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用switch语句进行模式匹配
- en: Like the `if` statement, the `switch` statement supports pattern matching in
    C# 7.0 and later. The `case` values no longer need to be literal values; they
    can be patterns.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句一样，`switch`语句在C# 7.0及更高版本中支持模式匹配。`case`值不再需要是文字值；它们可以是模式。
- en: 'Let''s see an example of pattern matching with the `switch` statement using
    a folder path. If you are using macOS, then swap the commented statement that
    sets the path variable and replace my username with your user folder name:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用文件夹路径的`switch`语句进行模式匹配的示例。如果您使用的是macOS，则交换设置路径变量的注释语句，并将我的用户名替换为您的用户文件夹名称：
- en: 'Add statements to declare a `string` path to a file, open it as either a read-only
    or writeable stream, and then show a message based on what type and capabilities
    the stream has, as shown in the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以声明一个`string`路径到文件，将其打开为只读或可写流，然后根据流的类型和功能显示一条消息，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the code and note that the variable named `s` is declared as a `Stream`
    type so it could be any subtype of stream, such as a memory stream or file stream.
    In this code, the stream is created using the `File.Open` method, which returns
    a file stream and, depending on your key press, it will be writeable or read-only,
    so the result will be a message that describes the situation, as shown in the
    following output:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意名为`s`的变量被声明为`Stream`类型，因此它可以是流的任何子类型，例如内存流或文件流。在此代码中，流是通过`File.Open`方法创建的，该方法返回一个文件流，并根据您的按键，它将是可写的或只读的，因此结果将是一条描述情况的message，如下面的输出所示：
- en: '[PRE39]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In .NET, there are multiple subtypes of `Stream`, including `FileStream` and
    `MemoryStream`. In C# 7.0 and later, your code can more concisely branch, based
    on the subtype of stream, and declare and assign a local variable to safely use
    it. You will learn more about the `System.IO` namespace and the `Stream` type
    in *Chapter 9*, *Working with Files, Streams, and Serialization*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，`Stream`有多个子类型，包括`FileStream`和`MemoryStream`。在C# 7.0及更高版本中，你的代码可以根据流子类型更简洁地分支，并声明和赋值一个局部变量以安全使用。你将在*第9章*，*文件、流和序列化操作*中了解更多关于`System.IO`命名空间和`Stream`类型的信息。
- en: Additionally, `case` statements can include a `when` keyword to perform more
    specific pattern matching. In the first case statement in the preceding code,
    `s` will only be a match if the stream is a `FileStream` and its `CanWrite` property
    is `true`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`case`语句可以包含`when`关键字以执行更具体的模式匹配。在前述代码的第一个case语句中，`s`仅在流为`FileStream`且其`CanWrite`属性为`true`时匹配。
- en: Simplifying switch statements with switch expressions
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用switch表达式简化switch语句
- en: In C# 8.0 or later, you can simplify `switch` statements using **switch expressions**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0及以上版本中，你可以使用**switch表达式**简化`switch`语句。
- en: Most `switch` statements are very simple, yet they require a lot of typing.
    `switch` expressions are designed to simplify the code you need to type while
    still expressing the same intent in scenarios where all cases return a value to
    set a single variable. `switch` expressions use a lambda, `=>`, to indicate a
    return value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`switch`语句虽然简单，但需要大量输入。`switch`表达式旨在简化所需代码，同时在所有情况都返回值以设置单个变量的情况下，仍表达相同意图。`switch`表达式使用lambda
    `=>`表示返回值。
- en: 'Let''s implement the previous code that used a `switch` statement using a `switch`
    expression so that you can compare the two styles:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前使用`switch`语句的代码实现为`switch`表达式，以便比较两种风格：
- en: 'Type statements to set the message based on what type and capabilities the
    stream has, using a `switch` expression, as shown in the following code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`switch`表达式，根据流的类型和功能输入语句设置消息，如下列代码所示：
- en: '[PRE40]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The main differences are the removal of the `case` and `break` keywords. The
    underscore character `_` is used to represent the default return value.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 主要区别在于移除了`case`和`break`关键字。下划线字符`_`用于表示默认返回值。
- en: Run the code, and note the result is the same as before.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意结果与之前相同。
- en: Understanding iteration statements
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解迭代语句
- en: Iteration statements repeat a block of statements either while a condition is
    true or for each item in a collection. The choice of which statement to use is
    based on a combination of ease of understanding to solve the logic problem and
    personal preference.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句重复一个语句块，要么在条件为真时，要么对集合中的每个项。选择使用哪种语句基于解决问题逻辑的易理解性和个人偏好。
- en: Looping with the while statement
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while语句循环
- en: 'The `while` statement evaluates a Boolean expression and continues to loop
    while it is true. Let''s explore iteration statements:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句评估布尔表达式，并在其为真时继续循环。让我们探索迭代语句：'
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `IterationStatements`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的编程工具，在`Chapter03`工作区/解决方案中添加一个名为`IterationStatements`的**控制台应用程序**。
- en: In Visual Studio Code, select `IterationStatements` as the active OmniSharp
    project.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`IterationStatements`作为活动OmniSharp项目。
- en: 'In `Program.cs`, type statements to define a `while` statement that loops while
    an integer variable has a value less than 10, as shown in the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句定义一个`while`语句，当整型变量值小于10时循环，如下列代码所示：
- en: '[PRE41]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the code and view the results, which should be the numbers 0 to 9, as shown
    in the following output:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，应显示数字0至9，如下列输出所示：
- en: '[PRE42]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Looping with the do statement
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: do语句循环
- en: 'The `do` statement is like `while`, except the Boolean expression is checked
    at the bottom of the block instead of the top, which means that the block always
    executes at least once, as the following shows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`类似，`do`语句在代码块底部而非顶部检查布尔表达式，这意味着代码块至少会执行一次，如下所示：
- en: 'Type statements to define a `do` loop, as shown in the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句定义一个`do`循环，如下列代码所示：
- en: '[PRE43]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the code, and note that you are prompted to enter your password repeatedly
    until you enter it correctly, as shown in the following output:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意你需要反复输入密码，直到输入正确，如下列输出所示：
- en: '[PRE44]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As an optional challenge, add statements so that the user can only make ten
    attempts before an error message is displayed.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为可选挑战，添加语句，以便用户只能在出现错误消息之前尝试十次。
- en: Looping with the for statement
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用for语句循环
- en: 'The `for` statement is like `while`, except that it is more succinct. It combines:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句类似于`while`，只不过它更为简洁。它结合了：'
- en: An **initializer expression**, which executes once at the start of the loop.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**初始化表达式**，它在循环开始时执行一次。
- en: A **conditional expression**, which executes on every iteration at the start
    of the loop to check whether the looping should continue.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**条件表达式**，它在每次迭代开始时执行，以检查循环是否应继续。
- en: An **iterator expression**, which executes on every loop at the bottom of the
    statement.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**迭代器表达式**，它在每次循环的底部执行。
- en: 'The `for` statement is commonly used with an integer counter. Let''s explore
    some code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句通常与整数计数器一起使用。让我们探讨一些代码：'
- en: 'Type a `for` statement to output the numbers 1 to 10, as shown in the following
    code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入一个`for`语句以输出数字1到10，如下所示：
- en: '[PRE45]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the code to view the result, which should be the numbers 1 to 10.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，结果应为数字1到10。
- en: Looping with the foreach statement
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用foreach语句循环
- en: The `foreach` statement is a bit different from the previous three iteration
    statements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`语句与之前的三种迭代语句略有不同。'
- en: It is used to perform a block of statements on each item in a sequence, for
    example, an array or collection. Each item is usually read-only, and if the sequence
    structure is modified during iteration, for example, by adding or removing an
    item, then an exception will be thrown.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于对序列（例如数组或集合）中的每个项执行一组语句。通常，每个项都是只读的，如果在迭代期间修改序列结构（例如，通过添加或删除项），则会抛出异常。
- en: 'Try the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下示例：
- en: 'Type statements to create an array of string variables and then output the
    length of each one, as shown in the following code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入语句以创建一个字符串变量数组，然后输出每个变量的长度，如下所示：
- en: '[PRE46]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE47]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Understanding how foreach works internally
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解foreach内部工作原理
- en: A creator of any type that represents multiple items, like an array or collection,
    should make sure that a programmer can use the `foreach` statement to enumerate
    through the type's items.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 任何表示多个项（如数组或集合）的类型的创建者应确保程序员可以使用`foreach`语句枚举该类型的项。
- en: 'Technically, the `foreach` statement will work on any type that follows these
    rules:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`foreach`语句将适用于遵循以下规则的任何类型：
- en: The type must have a method named `GetEnumerator` that returns an object.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类型必须具有一个名为`GetEnumerator`的方法，该方法返回一个对象。
- en: The returned object must have a property named `Current` and a method named
    `MoveNext`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的对象必须具有名为`Current`的属性和名为`MoveNext`的方法。
- en: The `MoveNext` method must change the value of `Current` and return `true` if
    there are more items to enumerate through or return `false` if there are no more
    items.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MoveNext`方法必须更改`Current`的值，并在还有更多项要枚举时返回`true`，或在无更多项时返回`false`。'
- en: There are interfaces named `IEnumerable` and `IEnumerable<T>` that formally
    define these rules, but technically the compiler does not require the type to
    implement these interfaces.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 存在名为`IEnumerable`和`IEnumerable<T>`的接口，它们正式定义了这些规则，但编译器实际上并不要求类型实现这些接口。
- en: 'The compiler turns the `foreach` statement in the preceding example into something
    like the following pseudocode:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将前面的示例中的`foreach`语句转换为类似以下伪代码的内容：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Due to the use of an iterator, the variable declared in a `foreach` statement
    cannot be used to modify the value of the current item.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了迭代器，`foreach`语句中声明的变量不能用于修改当前项的值。
- en: Casting and converting between types
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型之间的转换和转换
- en: You will often need to convert values of variables between different types.
    For example, data input is often entered as text at the console, so it is initially
    stored in a variable of the `string` type, but it then needs to be converted into
    a date/time, or number, or some other data type, depending on how it should be
    stored and processed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常需要在不同类型的变量之间转换值。例如，数据输入通常作为控制台上的文本输入，因此最初存储在`string`类型的变量中，但随后需要将其转换为日期/时间，或数字，或其他数据类型，具体取决于应如何存储和处理。
- en: Sometimes you will need to convert between number types, like between an integer
    and a floating point, before performing calculations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在进行计算之前，你需要在整数和浮点数等数字类型之间进行转换。
- en: 'Converting is also known as **casting**, and it has two varieties: **implicit**
    and **explicit**. Implicit casting happens automatically, and it is safe, meaning
    that you will not lose any information.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 转换也称为**类型转换**，它有两种形式：**隐式**和**显式**。隐式转换会自动发生，是安全的，意味着不会丢失任何信息。
- en: Explicit casting must be performed manually because it may lose information,
    for example, the precision of a number. By explicitly casting, you are telling
    the C# compiler that you understand and accept the risk.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 显式转换必须手动执行，因为它可能会丢失信息，例如数字的精度。通过显式转换，你告诉C#编译器你理解并接受这种风险。
- en: Casting numbers implicitly and explicitly
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式和显式转换数字
- en: 'Implicitly casting an `int` variable into a `double` variable is safe because
    no information can be lost as the following shows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将`int`变量隐式转换为`double`变量是安全的，因为不会丢失任何信息，如下所示：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `CastingConverting`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编码工具在`Chapter03`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`CastingConverting`。
- en: In Visual Studio Code, select `CastingConverting` as the active OmniSharp project.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`CastingConverting`作为活动OmniSharp项目。
- en: 'In `Program.cs`, type statements to declare and assign an `int` variable and
    a `double` variable, and then implicitly cast the integer''s value when assigning
    it to the `double` variable, as shown in the following code:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句以声明和赋值一个`int`变量和一个`double`变量，然后当将整数值赋给`double`变量时隐式转换整数值，如下所示：
- en: '[PRE49]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Type statements to declare and assign a `double` variable and an `int` variable,
    and then implicitly cast the `double` value when assigning it to the `int` variable,
    as shown in the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以声明和赋值一个`double`变量和一个`int`变量，然后当将`double`值赋给`int`变量时隐式转换`double`值，如下所示：
- en: '[PRE50]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Run the code and note the error message, as shown in the following output:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意错误消息，如下所示：
- en: '[PRE51]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This error message will also appear in the Visual Studio Error List or Visual
    Studio Code PROBLEMS window.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此错误消息也会出现在Visual Studio错误列表或Visual Studio Code问题窗口中。
- en: You cannot implicitly cast a `double` variable into an `int` variable because
    it is potentially unsafe and could lose data, like the value after the decimal
    point. You must explicitly cast a `double` variable into an `int` variable using
    a pair of round brackets around the type you want to cast the `double` type into.
    The pair of round brackets is the **cast operator**. Even then, you must beware
    that the part after the decimal point will be trimmed off without warning because
    you have chosen to perform an explicit cast and therefore understand the consequences.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不能隐式地将`double`变量转换为`int`变量，因为这可能不安全且可能丢失数据，例如小数点后的值。你必须使用一对圆括号将要转换的`double`类型括起来，显式地将`double`变量转换为`int`变量。这对圆括号是**类型转换运算符**。即便如此，你也必须注意，小数点后的部分将被截断而不会警告，因为你选择执行显式转换，因此理解其后果。
- en: 'Modify the assignment statement for the `d` variable, as shown in the following
    code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`d`变量的赋值语句，如下所示：
- en: '[PRE52]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下所示：
- en: '[PRE53]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We must perform a similar operation when converting values between larger integers
    and smaller integers. Again, beware that you might lose information because any
    value too big will have its bits copied and then be interpreted in ways that you
    might not expect!
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当在较大整数和较小整数之间转换值时，我们必须执行类似的操作。再次提醒，你可能会丢失信息，因为任何过大的值都会复制其位，然后以你可能意想不到的方式进行解释！
- en: 'Enter statements to declare and assign a long 64-bit variable to an int 32-bit
    variable, both using a small value that will work and a too-large value that will
    not, as shown in the following code:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以声明和赋值一个长64位变量到一个int 32位变量，两者都使用一个小值和一个过大的值，如下所示：
- en: '[PRE54]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下所示：
- en: '[PRE55]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Modify the value of `e` to 5 billion, as shown in the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`e`的值修改为50亿，如下所示：
- en: '[PRE56]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下所示：
- en: '[PRE57]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Converting with the System.Convert type
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用System.Convert类型进行转换
- en: An alternative to using the cast operator is to use the `System.Convert` type.
    The `System.Convert` type can convert to and from all the C# number types, as
    well as Booleans, strings, and date and time values.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型转换操作符的替代方法是使用`System.Convert`类型。`System.Convert`类型可以转换为和从所有C#数字类型，以及布尔值、字符串和日期时间值。
- en: 'Let''s write some code to see this in action:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码来实际看看：
- en: 'At the top of `Program.cs`, statically import the `System.Convert` class, as
    shown in the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，静态导入`System.Convert`类，如下所示：
- en: '[PRE58]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At the bottom of `Program.cs`, type statements to declare and assign a value
    to a `double` variable, convert it to an integer, and then write both values to
    the console, as shown in the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，输入语句声明并赋值给一个`double`变量，将其转换为整数，然后将两个值写入控制台，如下所示：
- en: '[PRE59]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE60]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: One difference between casting and converting is that converting rounds the
    `double` value `9.8` up to `10` instead of trimming the part after the decimal
    point.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换和转换之间的一个区别是，转换将`double`值`9.8`向上取整为`10`，而不是截去小数点后的部分。
- en: Rounding numbers
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取整数字
- en: You have now seen that the cast operator trims the decimal part of a real number
    and that the `System.Convert` methods round up or down. However, what is the rule
    for rounding?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到，类型转换操作符会截去实数的小数部分，而`System.Convert`方法则会上下取整。但是，取整的规则是什么呢？
- en: Understanding the default rounding rules
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解默认的取整规则
- en: In British primary schools for children aged 5 to 11, pupils are taught to round
    *up* if the decimal part is .5 or higher and round *down* if the decimal part
    is less.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在英国5至11岁儿童的初等学校中，学生被教导如果小数部分为.5或更高，则向上取整；如果小数部分小于.5，则向下取整。
- en: 'Let''s explore if C# follows the same primary school rule:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探究一下C#是否遵循相同的初等学校规则：
- en: 'Type statements to declare and assign an array of `double` values, convert
    each of them to an integer, and then write the result to the console, as shown
    in the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句声明并赋值给一个`double`数组，将每个值转换为整数，然后将结果写入控制台，如下所示：
- en: '[PRE61]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE62]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We have shown that the rule for rounding in C# is subtly different from the
    primary school rule:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经表明，C#中的取整规则与初等学校的规则略有不同：
- en: It always rounds *down* if the decimal part is less than the midpoint .5.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分小于中点.5，它总是向下取整。
- en: It always rounds *up* if the decimal part is more than the midpoint .5.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分大于中点.5，它总是向上取整。
- en: It will round *up* if the decimal part is the midpoint .5 and the non-decimal
    part is *odd*, but it will round *down* if the non-decimal part is *even*.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分是中点.5，且非小数部分为*奇数*，则向上取整；但如果非小数部分为*偶数*，则向下取整。
- en: This rule is known as **Banker's Rounding**, and it is preferred because it
    reduces bias by alternating when it rounds up or down. Sadly, other languages
    such as JavaScript use the primary school rule.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这一规则被称为**银行家取整**，因其通过交替上下取整来减少偏差，所以被优先采用。遗憾的是，其他语言如JavaScript使用的是初等学校的规则。
- en: Taking control of rounding rules
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掌握取整规则
- en: 'You can take control of the rounding rules by using the `Round` method of the
    `Math` class:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`Math`类的`Round`方法来控制取整规则：
- en: 'Type statements to round each of the `double` values using the "away from zero"
    rounding rule, also known as rounding "up," and then write the result to the console,
    as shown in the following code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句，使用“远离零”取整规则（也称为“向上”取整）对每个`double`值进行取整，然后将结果写入控制台，如下所示：
- en: '[PRE63]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE64]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Good Practice**: For every programming language that you use, check its rounding
    rules. They may not work the way you expect!'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：对于你使用的每种编程语言，检查其取整规则。它们可能不会按照你预期的方式工作！'
- en: Converting from any type to a string
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将任何类型转换为字符串
- en: The most common conversion is from any type into a `string` variable for outputting
    as human-readable text, so all types have a method named `ToString` that they
    inherit from the `System.Object` class.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的转换是将任何类型转换为`string`变量，以便输出为人类可读的文本，因此所有类型都从`System.Object`类继承了一个名为`ToString`的方法。
- en: The `ToString` method converts the current value of any variable into a textual
    representation. Some types can't be sensibly represented as text, so they return
    their namespace and type name instead.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString`方法将任何变量的当前值转换为文本表示。某些类型无法合理地表示为文本，因此它们返回其命名空间和类型名称。'
- en: 'Let''s convert some types into a `string`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些类型转换为`字符串`：
- en: 'Type statements to declare some variables, convert them to their `string` representation,
    and write them to the console, as shown in the following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入语句以声明一些变量，将它们转换为其`字符串`表示，并将它们写入控制台，如下所示：
- en: '[PRE65]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE66]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Converting from a binary object to a string
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从二进制对象转换为字符串
- en: When you have a binary object like an image or video that you want to either
    store or transmit, you sometimes do not want to send the raw bits because you
    do not know how those bits could be misinterpreted, for example, by the network
    protocol transmitting them or another operating system that is reading the store
    binary object.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个二进制对象（如图像或视频）想要存储或传输时，有时您不希望发送原始位，因为您不知道这些位可能会如何被误解，例如，通过传输它们的网络协议或其他正在读取存储二进制对象的操作系统。
- en: The safest thing to do is to convert the binary object into a `string` of safe
    characters. Programmers call this **Base64** encoding.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的方法是将二进制对象转换为安全的字符`字符串`。程序员称这种编码为**Base64**。
- en: 'The `Convert` type has a pair of methods, `ToBase64String` and `FromBase64String`,
    that perform this conversion for you. Let''s see them in action:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Convert`类型有一对方法，`ToBase64String`和`FromBase64String`，它们为您执行此转换。让我们看看它们的实际应用：'
- en: 'Type statements to create an array of bytes randomly populated with byte values,
    write each byte nicely formatted to the console, and then write the same bytes
    converted to Base64 to the console, as shown in the following code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入语句以创建一个随机填充字节值的字节数组，将每个字节格式化良好地写入控制台，然后将相同的字节转换为Base64写入控制台，如下所示：
- en: '[PRE67]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By default, an `int` value would output assuming decimal notation, that is,
    base10\. You can use format codes such as `:X` to format the value using hexadecimal
    notation.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，`int`值会假设为十进制表示法输出，即基数10。您可以使用`：X`等格式代码以十六进制表示法格式化该值。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE68]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Parsing from strings to numbers or dates and times
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从字符串解析到数字或日期和时间
- en: The second most common conversion is from strings to numbers or date and time
    values.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第二常见的转换是从字符串到数字或日期和时间值。
- en: The opposite of `ToString` is `Parse`. Only a few types have a `Parse` method,
    including all the number types and `DateTime`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString`的相反操作是`Parse`。只有少数类型具有`Parse`方法，包括所有数字类型和`DateTime`。'
- en: 'Let''s see `Parse` in action:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Parse`的实际应用：
- en: 'Type statements to parse an integer and a date and time value from strings
    and then write the result to the console, as shown in the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入语句以从字符串解析整数和日期时间值，然后将结果写入控制台，如下所示：
- en: '[PRE69]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE70]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: By default, a date and time value outputs with the short date and time format.
    You can use format codes such as `D` to output only the date part using the long
    date format.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，日期和时间值以短日期和时间格式输出。您可以使用`D`等格式代码仅以长日期格式输出日期部分。
- en: '**Good Practice**: Use the standard date and time format specifiers, as shown
    at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：使用标准日期和时间格式说明符，如下所示：[https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers)'
- en: Errors using Parse
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Parse时的错误
- en: One problem with the `Parse` method is that it gives errors if the `string`
    cannot be converted.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parse`方法的一个问题是，如果`字符串`无法转换，它会给出错误。'
- en: 'Type a statement to attempt to parse a string containing letters into an integer
    variable, as shown in the following code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入语句以尝试将包含字母的字符串解析为整数变量，如下所示：
- en: '[PRE71]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE72]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As well as the preceding exception message, you will see a stack trace. I have
    not included stack traces in this book because they take up too much space.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述异常消息外，你还会看到堆栈跟踪。由于堆栈跟踪占用太多空间，本书中未包含。
- en: Avoiding exceptions using the TryParse method
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TryParse方法避免异常
- en: To avoid errors, you can use the `TryParse` method instead. `TryParse` attempts
    to convert the input `string` and returns `true` if it can convert it and `false`
    if it cannot.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误，你可以使用`TryParse`方法。`TryParse`尝试转换输入的`string`，如果能够转换则返回`true`，否则返回`false`。
- en: The `out` keyword is required to allow the `TryParse` method to set the count
    variable when the conversion works.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`关键字是必需的，以便`TryParse`方法在转换成功时设置计数变量。'
- en: 'Let''s see `TryParse` in action:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`TryParse`的实际应用：
- en: 'Replace the `int` `count` declaration with statements to use the `TryParse`
    method and ask the user to input a count for a number of eggs, as shown in the
    following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`int` `count`声明替换为使用`TryParse`方法的语句，并要求用户输入鸡蛋的数量，如下所示：
- en: '[PRE73]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Run the code, enter `12`, and view the result, as shown in the following output:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`12`，查看结果，如下所示：
- en: '[PRE74]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the code, enter `twelve` (or change the `string` value to `"twelve"` in
    a notebook), and view the result, as shown in the following output:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`twelve`（或在笔记本中将`string`值更改为`"twelve"`），查看结果，如下所示：
- en: '[PRE75]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can also use methods of the `System.Convert` type to convert `string` values
    into other types; however, like the `Parse` method, it gives an error if it cannot
    convert.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`System.Convert`类型的方法将`string`值转换为其他类型；然而，与`Parse`方法类似，如果无法转换，它会报错。
- en: Handling exceptions
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: You've seen several scenarios where errors have occurred when converting types.
    Some languages return error codes when something goes wrong. .NET uses exceptions
    that are richer and designed only for failure reporting compared to return values
    that have multiple uses. When this happens, we say a *runtime exception has been
    thrown*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了几种类型转换时发生错误的场景。有些语言在出现问题时返回错误代码。.NET使用异常，这些异常比返回值更丰富，专门用于失败报告，而返回值有多种用途。当这种情况发生时，我们说*运行时异常已被抛出*。
- en: When an exception is thrown, the thread is suspended and if the calling code
    has defined a `try-catch` statement, then it is given a chance to handle the exception.
    If the current method does not handle it, then its calling method is given a chance,
    and so on up the call stack.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，线程会被挂起，如果调用代码定义了`try-catch`语句，那么它就有机会处理这个异常。如果当前方法没有处理它，那么它的调用方法就有机会处理，以此类推，直到调用栈顶。
- en: As you have seen, the default behavior of a console application or a .NET Interactive
    notebook is to output a message about the exception, including a stack trace,
    and then stop running the code. The application is terminated. This is better
    than allowing the code to continue executing in a potentially corrupt state. Your
    code should only catch and handle exceptions that it understands and can properly
    fix.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，控制台应用程序或.NET Interactive笔记本的默认行为是输出有关异常的消息，包括堆栈跟踪，然后停止运行代码。应用程序终止。这比允许代码在可能损坏的状态下继续执行要好。你的代码应该只捕获和处理它理解并能正确修复的异常。
- en: '**Good Practice**: Avoid writing code that will throw an exception whenever
    possible, perhaps by performing `if` statement checks. Sometimes you can''t, and
    sometimes it is best to allow the exception to be caught by a higher-level component
    that is calling your code. You will learn how to do this in *Chapter 4*, *Writing,
    Debugging, and Testing Functions*.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：尽量避免编写可能抛出异常的代码，或许可以通过执行`if`语句检查来实现。有时你做不到，有时最好让更高层次的组件来捕获调用你代码时抛出的异常。你将在*第4章*，*编写、调试和测试函数*中学习如何做到这一点。'
- en: Wrapping error-prone code in a try block
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将易出错的代码包裹在try块中
- en: When you know that a statement can cause an error, you should wrap that statement
    in a `try` block. For example, parsing from text to a number can cause an error.
    Any statements in the `catch` block will be executed only if an exception is thrown
    by a statement in the `try` block.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道某个语句可能引发错误时，应该将该语句包裹在`try`块中。例如，从文本解析为数字可能引发错误。`catch`块中的任何语句只有在`try`块中的语句抛出异常时才会执行。
- en: 'We don''t have to do anything inside the `catch` block. Let''s see this in
    action:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无需在`catch`块中做任何事情。让我们看看实际操作：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `HandlingExceptions`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具，在`Chapter03`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`HandlingExceptions`。
- en: In Visual Studio Code, select `HandlingExceptions` as the active OmniSharp project.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`HandlingExceptions`作为活动OmniSharp项目。
- en: 'Type statements to prompt the user to enter their age and then write their
    age to the console, as shown in the following code:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以提示用户输入他们的年龄，然后将他们的年龄写入控制台，如下所示：
- en: '[PRE76]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You will see the following compiler message: `Warning CS8604 Possible null
    reference argument for parameter ''s'' in ''int int.Parse(string s)''.` By default
    in new .NET 6 projects, Microsoft has enabled nullable reference types so you
    will see many more compiler warnings like this. In production code, you should
    add code to check for `null` and handle that possibility appropriately. In this
    book, I will not include these `null` checks because the code samples are not
    designed to be production quality and `null` checks everywhere will clutter the
    code and use up valuable pages. In this case, it is impossible for `input` to
    be `null` because the user must press Enter for `ReadLine` to return and that
    will return an empty `string`. You will see hundreds of more examples of potentially
    `null` variables throughout the code samples in this book. Those warnings are
    safe to ignore for the book code examples. You only need similar warnings when
    you write your own production code. You will see more about null handling in *Chapter
    6*, *Implementing Interfaces and Inheriting Classes*.'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到以下编译器消息：`Warning CS8604 Possible null reference argument for parameter 's'
    in 'int int.Parse(string s)'`。在新建的.NET 6项目中，默认情况下，Microsoft已启用可空引用类型，因此您会看到更多此类编译器警告。在生产代码中，您应添加代码以检查`null`并适当地处理这种可能性。在本书中，我不会包含这些`null`检查，因为代码示例并非设计为生产质量，并且到处都是`null`检查会使得代码杂乱无章，占用宝贵的页面。在这种情况下，`input`不可能为`null`，因为用户必须按Enter键，`ReadLine`才会返回，而那将返回一个空`string`。您将在本书的代码示例中看到数百个可能为`null`的变量。对于本书的代码示例，这些警告可以安全地忽略。只有在编写自己的生产代码时，您才需要类似的警告。您将在*第6章*，*实现接口和继承类*中了解更多关于空处理的内容。
- en: This code includes two messages to indicate *before* parsing and *after* parsing
    to make clearer the flow through the code. These will be especially useful as
    the example code grows more complex.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码包含两个消息，以指示*解析前*和*解析后*，使代码流程更清晰。随着示例代码变得更加复杂，这些将特别有用。
- en: 'Run the code, enter `49`, and view the result, as shown in the following output:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`49`，查看结果，如下所示：
- en: '[PRE77]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Run the code, enter `Kermit`, and view the result, as shown in the following
    output:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`Kermit`，查看结果，如下所示：
- en: '[PRE78]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When the code was executed, the error exception was caught and the default message
    and stack trace were not output, and the console application continued running.
    This is better than the default behavior, but it might be useful to see the type
    of error that occurred.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，错误异常被捕获，默认消息和堆栈跟踪未输出，控制台应用程序继续运行。这比默认行为更好，但查看发生的错误类型可能会有所帮助。
- en: '**Good Practice**: You should never use an empty `catch` statement like this
    in production code because it "swallows" exceptions and hides potential problems.
    You should at least log the exception if you cannot or do not want to handle it
    properly, or rethrow it so that higher-level code can decide instead. You will
    learn about logging in *Chapter 4*, *Writing, Debugging, and Testing Functions*.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在生产代码中，您绝不应使用像这样的空`catch`语句，因为它会“吞噬”异常并隐藏潜在问题。如果您无法或不想妥善处理异常，至少应记录该异常，或者重新抛出它，以便更高级别的代码可以决定如何处理。您将在*第4章*，*编写、调试和测试函数*中学习有关日志记录的内容。'
- en: Catching all exceptions
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获所有异常
- en: 'To get information about any type of exception that might occur, you can declare
    a variable of type `System.Exception` to the `catch` block:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可能发生的任何类型异常的信息，您可以在`catch`块中声明一个类型为`System.Exception`的变量：
- en: 'Add an exception variable declaration to the `catch` block and use it to write
    information about the exception to the console, as shown in the following code:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`catch`块中添加一个异常变量声明，并使用它将有关异常的信息写入控制台，如下所示：
- en: '[PRE79]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，输入`Kermit`，查看结果，如下所示：
- en: '[PRE80]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Catching specific exceptions
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获特定异常
- en: 'Now that we know which specific type of exception occurred, we can improve
    our code by catching just that type of exception and customizing the message that
    we display to the user:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道发生了哪种类型的特定异常，我们可以通过仅捕获该类型的异常并自定义向用户显示的消息来改进我们的代码：
- en: 'Leave the existing `catch` block, and above it, add a new `catch` block for
    the format exception type, as shown in the following highlighted code:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留现有的`catch`块，并在其上方添加一个新的`catch`块，用于格式异常类型，如下面的突出显示代码所示：
- en: '[PRE81]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，再次输入`Kermit`，并查看结果，如下面的输出所示：
- en: '[PRE82]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The reason we want to leave the more general catch below is that there might
    be other types of exceptions that can occur.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望保留下面更一般的catch块的原因是，可能会有其他类型的异常发生。
- en: 'Run the code, enter `9876543210`, and view the result, as shown in the following
    output:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`9876543210`，并查看结果，如下面的输出所示：
- en: '[PRE83]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Let's add another `catch` block for this type of exception.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们为这种类型的异常再添加一个`catch`块。
- en: 'Leave the existing `catch` blocks, and add a new `catch` block for the overflow
    exception type, as shown in the following highlighted code:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留现有的`catch`块，并添加一个新的`catch`块，用于溢出异常类型，如下面的突出显示代码所示：
- en: '[PRE84]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Run the code, enter `9876543210`, and view the result, as shown in the following
    output:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`9876543210`，并查看结果，如下面的输出所示：
- en: '[PRE85]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The order in which you catch exceptions is important. The correct order is related
    to the inheritance hierarchy of the exception types. You will learn about inheritance
    in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*. However,
    don't worry too much about this—the compiler will give you build errors if you
    get exceptions in the wrong order anyway.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获异常的顺序很重要。正确的顺序与异常类型的继承层次结构有关。您将在*第5章*，*使用面向对象编程构建自己的类型*中学习继承。不过，不必过于担心这一点——如果异常顺序错误，编译器会给您构建错误。
- en: '**Good Practice**: Avoid over-catching exceptions. They should often be allowed
    to propagate up the call stack to be handled at a level where more information
    is known about the circumstances that could change the logic of how they should
    be handled. You will learn about this in *Chapter 4*, *Writing, Debugging, and
    Testing Functions*.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：避免过度捕获异常。通常应允许它们向上传播到调用堆栈，以便在更了解情况的层级处理，这可能会改变处理逻辑。您将在*第4章*，*编写、调试和测试函数*中学习到这一点。'
- en: Catching with filters
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用过滤器捕获
- en: 'You can also add filters to a catch statement using the `when` keyword, as
    shown in the following code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`when`关键字在catch语句中添加过滤器，如下面的代码所示：
- en: '[PRE86]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Checking for overflow
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查溢出
- en: Earlier, we saw that when casting between number types, it was possible to lose
    information, for example, when casting from a `long` variable to an `int` variable.
    If the value stored in a type is too big, it will overflow.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到在数字类型之间转换时，可能会丢失信息，例如，将`long`变量转换为`int`变量时。如果存储在类型中的值太大，它将溢出。
- en: Throwing overflow exceptions with the checked statement
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用checked语句抛出溢出异常
- en: The `checked` statement tells .NET to throw an exception when an overflow happens
    instead of allowing it to happen silently, which is done by default for performance
    reasons.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`checked`语句告诉.NET在发生溢出时抛出异常，而不是默认允许它静默发生，这是出于性能原因。'
- en: 'We will set the initial value of an `int` variable to its maximum value minus
    one. Then, we will increment it several times, outputting its value each time.
    Once it gets above its maximum value, it overflows to its minimum value and continues
    incrementing from there. Let''s see this in action:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个`int`变量的初始值设为其最大值减一。然后，我们将它递增几次，每次输出其值。一旦它超过其最大值，它就会溢出到最小值，并从那里继续递增。让我们看看这个过程：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `CheckingForOverflow`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编程工具，在`Chapter03`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`CheckingForOverflow`。
- en: In Visual Studio Code, select `CheckingForOverflow` as the active OmniSharp
    project.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`CheckingForOverflow`作为活动的OmniSharp项目。
- en: 'In `Program.cs`, type statements to declare and assign an integer to one less
    than its maximum possible value, and then increment it and write its value to
    the console three times, as shown in the following code:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，键入语句以声明并赋值一个整数，其值为其最大可能值减一，然后递增它并在控制台上写入其值三次，如下面的代码所示：
- en: '[PRE87]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Run the code and view the result that shows the value overflowing silently
    and wrapping around to large negative values, as shown in the following output:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，显示值无声溢出并环绕至大负值，如下所示：
- en: '[PRE88]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, let''s get the compiler to warn us about the overflow by wrapping the
    statements using a `checked` statement block, as shown highlighted in the following
    code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`checked`语句块包裹这些语句，让编译器警告我们关于溢出的问题，如下所示：
- en: '[PRE89]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run the code and view the result that shows the overflow being checked and
    causing an exception to be thrown, as shown in the following output:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，显示溢出检查导致异常抛出，如下所示：
- en: '[PRE90]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Just like any other exception, we should wrap these statements in a `try` statement
    block and display a nicer error message for the user, as shown in the following
    code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他异常一样，我们应该将这些语句包裹在`try`语句块中，并为用户显示更友好的错误消息，如下所示：
- en: '[PRE91]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE92]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Disabling compiler overflow checks with the unchecked statement
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用unchecked语句禁用编译器溢出检查
- en: The previous section was about the default overflow behavior at *runtime* and
    how to use the `checked` statement to change that behavior. This section is about
    *compile time* overflow behavior and how to use the `unchecked` statement to change
    that behavior.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节讨论了*运行时*默认的溢出行为以及如何使用`checked`语句改变这种行为。本节将探讨*编译时*溢出行为以及如何使用`unchecked`语句改变这种行为。
- en: 'A related keyword is `unchecked`. This keyword switches off overflow checks
    performed by the compiler within a block of code. Let''s see how to do this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 相关关键字是`unchecked`。此关键字在代码块内关闭编译器执行的溢出检查。让我们看看如何操作：
- en: 'Type the following statement at the end of the previous statements. The compiler
    will not compile this statement because it knows it would overflow:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的语句末尾输入以下语句。编译器不会编译此语句，因为它知道这将导致溢出：
- en: '[PRE93]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Hover your mouse pointer over the error, and note a compile-time check is shown
    as an error message, as shown in *Figure 3.1*:![Graphical user interface, text,
    application, email  Description automatically generated](img/B17442_03_01.png)
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在错误上，注意编译时检查显示为错误消息，如*图3.1*所示：![图形用户界面，文本，应用程序，电子邮件 自动生成描述](img/B17442_03_01.png)
- en: 'Figure 3.1: A compile-time check in the PROBLEMS window'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.1：PROBLEMS窗口中的编译时检查
- en: 'To disable compile-time checks, wrap the statement in an `unchecked` block,
    write the value of `y` to the console, decrement it, and repeat, as shown in the
    following code:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要禁用编译时检查，将语句包裹在`unchecked`块中，将`y`的值写入控制台，递减它，并重复，如下所示：
- en: '[PRE94]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE95]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Of course, it would be rare that you would want to explicitly switch off a check
    like this because it allows an overflow to occur. But perhaps you can think of
    a scenario where you might want that behavior.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你很少会想要明确关闭这种检查，因为它允许溢出发生。但或许你能想到一个可能需要这种行为的场景。
- en: Practicing and exploring
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践与探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into this chapter's topics.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试你的知识和理解，进行一些实践操作，并深入研究本章的主题。
- en: Exercise 3.1 – Test your knowledge
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What happens when you divide an `int` variable by `0`?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`int`变量除以`0`时，会发生什么？
- en: What happens when you divide a `double` variable by `0`?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`double`变量除以`0`时，会发生什么？
- en: What happens when you overflow an `int` variable, that is, set it to a value
    beyond its range?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`int`变量的值超出其范围（即溢出）时，会发生什么？
- en: What is the difference between `x = y++;` and `x = ++y;`?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x = y++;`和`x = ++y;`之间有何区别？'
- en: What is the difference between `break`, `continue`, and `return` when used inside
    a loop statement?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环语句中使用`break`、`continue`和`return`有何区别？
- en: What are the three parts of a `for` statement and which of them are required?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`语句的三个部分是什么，哪些是必需的？'
- en: What is the difference between the `=` and `==` operators?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`=`和`==`操作符之间有何区别？'
- en: Does the following statement compile?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句能否编译？
- en: '[PRE96]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: What does the underscore `_` represent in a `switch` expression?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`switch`表达式中，下划线`_`代表什么？
- en: What interface must an object implement to be enumerated over by using the `foreach`
    statement?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象必须实现什么接口才能通过`foreach`语句进行枚举？
- en: Exercise 3.2 – Explore loops and overflow
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.2 – 探索循环和溢出
- en: What will happen if this code executes?
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行这段代码会发生什么？
- en: '[PRE97]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Create a console application in `Chapter03` named `Exercise02` and enter the
    preceding code. Run the console application and view the output. What happens?
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter03`中创建一个名为`Exercise02`的控制台应用程序，并输入前面的代码。运行控制台应用程序并查看输出。发生了什么？
- en: What code could you add (don't change any of the preceding code) to warn us
    about the problem?
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加什么代码（不要更改前面的任何代码）来警告我们这个问题？
- en: Exercise 3.3 – Practice loops and operators
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.3 – 练习循环和运算符
- en: '**FizzBuzz** is a group word game for children to teach them about division.
    Players take turns to count incrementally, replacing any number divisible by three
    with the word *fizz*, any number divisible by five with the word *buzz*, and any
    number divisible by both with *fizzbuzz*.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**FizzBuzz** 是一种团体文字游戏，旨在教孩子们关于除法的知识。玩家轮流递增计数，用单词*fizz*替换任何可被三整除的数字，用单词*buzz*替换任何可被五整除的数字，用*fizzbuzz*替换任何可被两者整除的数字。'
- en: 'Create a console application in `Chapter03` named `Exercise03` that outputs
    a simulated FizzBuzz game counting up to 100\. The output should look something
    like *Figure 3.2*:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter03`中创建一个名为`Exercise03`的控制台应用程序，输出一个模拟的FizzBuzz游戏，计数到100。输出应类似于*图 3.2*：
- en: '![Text  Description automatically generated](img/B17442_03_02.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B17442_03_02.png)'
- en: 'Figure 3.2: A simulated FizzBuzz game output'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：模拟的FizzBuzz游戏输出
- en: Exercise 3.4 – Practice exception handling
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.4 – 练习异常处理
- en: 'Create a console application in `Chapter03` named `Exercise04` that asks the
    user for two numbers in the range 0-255 and then divides the first number by the
    second:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter03`中创建一个名为`Exercise04`的控制台应用程序，要求用户输入两个0-255范围内的数字，然后将第一个数字除以第二个数字：
- en: '[PRE98]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Write exception handlers to catch any thrown errors, as shown in the following
    output:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 编写异常处理程序以捕获任何抛出的错误，如下面的输出所示：
- en: '[PRE99]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Exercise 3.5 – Test your knowledge of operators
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.5 – 测试你对运算符的知识
- en: What are the values of `x` and `y` after the following statements execute?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下语句后，`x`和`y`的值是什么？
- en: 'Increment and addition operators:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增量和加法运算符：
- en: '[PRE100]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Binary shift operators:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制移位运算符：
- en: '[PRE101]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Bitwise operators:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位运算符：
- en: '[PRE102]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Exercise 3.6 – Explore topics
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.6 – 探索主题
- en: 'Use the links on the following page to learn about the topics covered in this
    chapter in more detail:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一页上的链接，详细了解本章涵盖的主题：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types)'
- en: Summary
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you experimented with some operators, learned how to branch
    and loop, how to convert between types, and how to catch exceptions.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你尝试了一些运算符，学习了如何分支和循环，如何进行类型转换，以及如何捕获异常。
- en: You are now ready to learn how to reuse blocks of code by defining functions,
    how to pass values into them and get values back, and how to track down bugs in
    your code and squash them!
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在准备好学习如何通过定义函数重用代码块，如何向它们传递值并获取返回值，以及如何追踪代码中的错误并消除它们！
