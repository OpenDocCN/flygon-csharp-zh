- en: '04'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing, Debugging, and Testing Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about writing functions to reuse code, debugging logic errors
    during development, logging exceptions during runtime, unit testing your code
    to remove bugs, and ensuring stability and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging during development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throwing and catching exceptions in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fundamental principle of programming is **Don't Repeat Yourself** (**DRY**).
  prefs: []
  type: TYPE_NORMAL
- en: While programming, if you find yourself writing the same statements over and
    over again, then turn those statements into a function. Functions are like tiny
    programs that complete one small task. For example, you might write a function
    to calculate sales tax and then reuse that function in many places in a financial
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Like programs, functions usually have inputs and outputs. They are sometimes
    described as black boxes, where you feed some raw materials in one end, and a
    manufactured item emerges at the other. Once created, you don't need to think
    about how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Times table example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that you want to help your child learn their times tables, so you
    want to make it easy to generate a times table for a number, such as the 12 times
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You previously learned about the `for` statement earlier in this book, so you
    know that it can be used to generate repeated lines of output when there is a
    regular pattern, such as the 12 times table, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, instead of outputting the 12 times table, we want to make this more
    flexible, so it could output the times table for any number. We can do this by
    creating a function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a times table function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explore functions by creating one to output any times table for numbers
    0 to 255 multiplied by 1 to 12:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred coding tool to create a new console app, as defined in the
    following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter04`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WritingFunctions`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Statically import `System.Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, write statements to define a function named `TimesTable`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`TimesTable` must have a `byte` value passed to it as a parameter named `number`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` is a `static` method because it will be called by the `static`
    method `Main`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` does not return a value to the caller, so it is declared with
    the `void` keyword before its name.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimesTable` uses a `for` statement to output the times table for the `number`
    passed to it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the statement that statically imports the `Console` class and before
    the `TimesTable` function, call the function and pass in a `byte` value for the
    `number` parameter, for example, `6`, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: If a function has one or more parameters where just passing
    the values may not provide enough meaning, then you can optionally specify the
    name of the parameter as well as its value, as shown in the following code: `TimesTable(number:
    6)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and then view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the number passed into the `TimesTable` function to other `byte` values
    between `0` and `255` and confirm that the output times tables are correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that if you try to pass a non-`byte` number, for example, an `int` or
    `double` or `string`, an error is returned, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Writing a function that returns a value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous function performed actions (looping and writing to the console),
    but it did not return a value. Let's say that you need to calculate sales or value-added
    tax (VAT). In Europe, VAT rates can range from 8% in Switzerland to 27% in Hungary.
    In the United States, state sales taxes can range from 0% in Oregon to 8.25% in
    California.
  prefs: []
  type: TYPE_NORMAL
- en: Tax rates change all the time, and they vary based on many factors. You do not
    need to contact me to tell me that the tax rate in Virginia is 6%. Thank you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a function to calculate taxes in various regions around the
    world:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function named `CalculateTax`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CalculateTax` has two inputs: a parameter named `amount` that will be the
    amount of money spent, and a parameter named `twoLetterRegionCode` that will be
    the region the amount is spent in.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CalculateTax` will perform a calculation using a `switch` statement and then
    return the sales tax or VAT owed on the amount as a `decimal` value; so, before
    the name of the function, we have declared the data type of the return value to
    be `decimal`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comment out the `TimesTable` method call and call the `CalculateTax` method,
    passing values for the amount such as `149` and a valid region code such as `FR`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could format the `taxToPay` output as currency by using `{taxToPay:C}` but
    it will use your local culture to decide how to format the currency symbol and
    decimals. For example, for me in the UK, I would see `£29.80`.
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of any problems with the `CalculateTax` function as written? What
    would happen if the user enters a code such as `fr` or `UK`? How could you rewrite
    the function to improve it? Would using a `switch` *expression* instead of a `switch`
    *statement* be clearer?
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers from cardinal to ordinal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numbers that are used to count are called **cardinal** numbers, for example,
    1, 2, and 3, whereas numbers used to order are **ordinal** numbers, for example,
    1st, 2nd, and 3rd. Let''s create a function to convert cardinals to ordinals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a function named `CardinalToOrdinal` that converts a cardinal `int` value
    into an ordinal `string` value; for example, it converts 1 into 1st, 2 into 2nd,
    and so on, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From the preceding code, note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CardinalToOrdinal` has one input: a parameter of the `int` type named `number`,
    and one output: a return value of the `string` type.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `switch` *statement* is used to handle the special cases of 11, 12, and 13.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `switch` *expression* then handles all other cases: if the last digit is
    1, then use `st` as the suffix; if the last digit is 2, then use `nd` as the suffix;
    if the last digit is 3, then use `rd` as the suffix; and if the last digit is
    anything else, then use `th` as the suffix.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write a function named `RunCardinalToOrdinal` that uses a `for` statement to
    loop from 1 to 40, calling the `CardinalToOrdinal` function for each number and
    writing the returned `string` to the console, separated by a space character,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Comment out the `CalculateTax` statements, and call the `RunCardinalToOrdinal`
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calculating factorials with recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factorial of 5 is 120, because factorials are calculated by multiplying
    the starting number by one less than itself, and then by one less again, and so
    on, until the number is reduced to 1\. An example can be seen here: 5 x 4 x 3
    x 2 x 1 = 120.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Factorials are written like this: 5!, where the exclamation mark is read as
    bang, so 5! = 120, that is, *five bang equals one hundred and twenty*. Bang is
    a good name for factorials because they increase in size very rapidly, just like
    an explosion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a function named `Factorial`; this will calculate the factorial
    for an `int` passed to it as a parameter. We will use a clever technique called
    **recursion**, which means a function that calls itself within its implementation,
    either directly or indirectly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function named `Factorial`, and a function to call it, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As before, there are several noteworthy elements of the preceding code, including
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the input parameter `number` is zero or negative, `Factorial` returns `0`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input parameter `number` is `1`, `Factorial` returns `1`, and therefore
    stops calling itself.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input parameter `number` is larger than one, which it will be in all
    other cases, `Factorial` multiplies the number by the result of calling itself
    and passing one less than `number`. This makes the function recursive.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More Information**: Recursion is clever, but it can lead to problems, such
    as a stack overflow due to too many function calls because memory is used to store
    data on every function call, and it eventually uses too much. Iteration is a more
    practical, if less succinct, solution in languages such as C#. You can read more
    about this at the following link: [https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration](https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursion_versus_iteration).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a function named `RunFactorial` that uses a `for` statement to output the
    factorials of numbers from 1 to 14, calls the `Factorial` function inside its
    loop, and then outputs the result, formatted using the code `N0`, which means
    number format uses thousand separators with zero decimal places, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the `RunCardinalToOrdinal` method call and call the `RunFactorial`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is not immediately obvious in the previous output, but factorials of 13 and
    higher overflow the `int` type because they are so big. 12! is 479,001,600, which
    is about half a billion. The maximum positive value that can be stored in an `int`
    variable is about two billion. 13! is 6,227,020,800, which is about six billion
    and when stored in a 32-bit integer it overflows silently without showing any
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember what we can do to be notified of a numeric overflow?
  prefs: []
  type: TYPE_NORMAL
- en: What should you do to get notified when an overflow happens? Of course, we could
    solve the problem for 13! and 14! by using a `long` (64-bit integer) instead of
    an `int` (32-bit integer), but we will quickly hit the overflow limit again.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this section is to understand that numbers can overflow and how
    to show that rather than ignore it, not specifically how to calculate factorials
    higher than 12!.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Factorial` function to check for overflows, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `RunFactorial` function to handle overflow exceptions when calling
    the `Factorial` function, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Documenting functions with XML comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, when calling a function such as `CardinalToOrdinal`, code editors
    will show a tooltip with basic information, as shown in *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17442_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: A tooltip showing the default simple method signature'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve the tooltip by adding extra information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio Code with the **C#** extension, you should navigate
    to **View** | **Command Palette** | **Preferences: Open Settings (UI)**, and then
    search for `formatOnType` and make sure that is enabled. C# XML documentation
    comments are a built-in feature of Visual Studio 2022.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the line above the `CardinalToOrdinal` function, type three forward slashes
    `///`, and note that they are expanded into an XML comment that recognizes that
    the function has a single parameter named `number`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter suitable information for the XML documentation comment for a summary
    and to describe the input parameter and the return value for the `CardinalToOrdinal`
    function, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when calling the function, you will see more details, as shown in *Figure
    4.2*:![Graphical user interface, text, application, chat or text message, email  Description
    automatically generated](img/B17442_04_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.2: A tooltip showing the more detailed method signature'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing the sixth edition, C# XML documentation comments do not
    work in .NET Interactive notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Add XML documentation comments to all your functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Using lambdas in function implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# is Microsoft's strongly typed functional-first programming language that,
    like C#, compiles to IL to be executed by .NET. Functional languages evolved from
    lambda calculus; a computational system based only on functions. The code looks
    more like mathematical functions than steps in a recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important attributes of functional languages are defined in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity**: The same benefit of defining functions in C# applies to functional
    languages. Break up a large complex code base into smaller pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutability**: Variables in the C# sense do not exist. Any data value inside
    a function cannot change. Instead, a new data value can be created from an existing
    one. This reduces bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Code is cleaner and clearer (for mathematically inclined
    programmers!).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since C# 6, Microsoft has worked to add features to the language to support
    a more functional approach. For example, adding **tuples** and **pattern matching**
    in C# 7, **non-null reference types** in C# 8, and improving pattern matching
    and adding records, that is, **immutable objects** in C# 9.
  prefs: []
  type: TYPE_NORMAL
- en: In C# 6, Microsoft added support for **expression-bodied function members**.
    We will look at an example of this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Fibonacci sequence** of numbers always starts with 0 and 1\. Then the
    rest of the sequence is generated using the rule of adding together the previous
    two numbers, as shown in the following sequence of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The next term in the sequence would be 34 + 55, which is 89.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Fibonacci sequence to illustrate the difference between an
    imperative and declarative function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a function named `FibImperative` that will be written in an imperative
    style, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function named `RunFibImperative` that calls `FibImperative` inside a
    `for` statement that loops from 1 to 30, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the other method calls and call the `RunFibImperative` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function named `FibFunctional` written in a declarative style, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function to call it inside a `for` statement that loops from 1 to 30,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the `RunFibImperative` method call, and call the `RunFibFunctional`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code and view the results (which will be the same as before).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debugging during development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to debug problems at development time. You
    must use a code editor that has debugging tools such as Visual Studio or Visual
    Studio Code. At the time of writing, you cannot use .NET Interactive Notebooks
    to debug code, but this is expected to be added in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information**: Some people find it tricky setting up the OmniSharp debugger
    for Visual Studio Code. I have included instructions for the most common issues,
    but if you still have trouble, try reading the information at the following link:
    [https://github.com/OmniSharp/omnisharp-vscode/blob/master/debugger.md](https://github.com/OmniSharp/omnisharp-vscode/blob/master/debugger.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating code with a deliberate bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore debugging by creating a console app with a deliberate bug that
    we will then use the debugger tools in your code editor to track down and fix:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter04`
    workspace/solution named `Debugging`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Debugging` as the active OmniSharp project. When
    you see the pop-up warning message saying that required assets are missing, click
    **Yes** to add them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a function with a deliberate bug, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the `Add` function, write statements to declare and set some variables
    and then add them together using the buggy function, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console application and view the result, as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But wait, there's a bug! 4.5 added to 2.5 should be 7, not 11.25!
  prefs: []
  type: TYPE_NORMAL
- en: We will use the debugging tools to hunt for and squash the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a breakpoint and start debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breakpoints allow us to mark a line of code that we want to pause at to inspect
    the program state and find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio 2022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s set a breakpoint and then start debugging using Visual Studio 2022:'
  prefs: []
  type: TYPE_NORMAL
- en: Click in the statement that declares the variable named `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Debug** | **Toggle Breakpoint** or press F9\. A red circle will
    then appear in the margin bar on the left-hand side and the statement will be
    highlighted in red to indicate that a breakpoint has been set, as shown in *Figure
    4.3*:![](img/B17442_04_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.3: Toggling breakpoints using Visual Studio 2022'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off, or right-click a breakpoint to
    see more options, such as delete, disable, or edit conditions or actions for an
    existing breakpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to **Debug** | **Start Debugging** or press F5\. Visual Studio starts
    the console application and then pauses when it hits the breakpoint. This is known
    as break mode. Extra windows titled **Locals** (showing current values of local
    variables), **Watch 1** (showing any watch expressions you have defined), **Call
    Stack**, **Exception Settings**, and **Immediate Window** appear. The **Debugging**
    toolbar appears. The line that will be executed next is highlighted in yellow,
    and a yellow arrow points at the line from the margin bar, as shown in *Figure
    4.4*:![](img/B17442_04_05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.4: Break mode in Visual Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not want to see how to use Visual Studio Code to start debugging then
    you can skip the next section and continue to the section titled *Navigating with
    the debugging toolbar*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s set a breakpoint and then start debugging using Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Click in the statement that declares the variable named `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run** | **Toggle Breakpoint** or press F9\. A red circle will
    appear in the margin bar on the left-hand side to indicate that a breakpoint has
    been set, as shown in *Figure 4.5*:![](img/B17442_04_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.5: Toggling breakpoints using Visual Studio Code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Breakpoints can be toggled off with the same action. You can also left-click
    in the margin to toggle a breakpoint on and off, or right-click to see more options,
    such as remove, edit, or disable an existing breakpoint; or adding a breakpoint,
    conditional breakpoint, or logpoint when a breakpoint does not yet exist.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Logpoints, also known as tracepoints, indicate that you want to record some
    information without having to actually stop executing the code at that point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to **View** | **Run**, or in the left navigation bar you can click
    the **Run and Debug** icon (the triangle "play" button and "bug"), as shown in
    *Figure 4.5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **DEBUG** window, click on the dropdown to the right of the
    **Start Debugging** button (green triangular "play" button), and select **.NET
    Core Launch (console) (Debugging)**, as shown in *Figure 4.6*:![](img/B17442_04_07.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.6: Selecting the project to debug using Visual Studio Code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Good Practice**: If you do not see a choice in the dropdown list for the
    **Debugging** project, it is because that project does not have the assets needed
    to debug. Those assets are stored in the `.vscode` folder. To create the `.vscode`
    folder for a project, navigate to **View** | **Command Palette**, select **OmniSharp:
    Select Project**, and then select the **Debugging** project. After a few seconds,
    when prompted, **Required assets to build and debug are missing from ''Debugging''.
    Add them?**, click **Yes** to add the missing assets.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of the **DEBUG** window, click the **Start Debugging** button (green
    triangular "play" button), or navigate to **Run** | **Start Debugging**, or press
    F5\. Visual Studio Code starts the console application and then pauses when it
    hits the breakpoint. This is known as break mode. The line that will be executed
    next is highlighted in yellow, and a yellow block points at the line from the
    margin bar, as shown in *Figure 4.7*:![](img/B17442_04_08.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.7: Break mode in Visual Studio Code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigating with the debugging toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio Code shows a floating toolbar with buttons to make it easy to
    access debugging features. Visual Studio 2022 has one button in its **Standard**
    toolbar to start or continue debugging and a separate **Debugging** toolbar for
    the rest of the tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both are shown in *Figure 4.8* and as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B17442_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Debugging toolbars in Visual Studio 2022 and Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continue**/F5: This button will continue running the program from the current
    position until it ends or hits another breakpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Over**/F10, **Step Into**/F11, and **Step Out**/Shift + F11 (blue arrows
    over dots): These buttons step through the code statements in various ways, as
    you will see in a moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restart**/Ctrl or Cmd + Shift + F5 (circular arrow): This button will stop
    and then immediately restart the program with the debugger attached again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop**/Shift + F5 (red square): This button will stop the debugging session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While debugging, both Visual Studio Code and Visual Studio show extra windows
    that allow you to monitor useful information, such as variables, while you step
    through your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful windows are described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VARIABLES**, including **Locals**, which shows the name, value, and type
    for any local variables automatically. Keep an eye on this window while you step
    through your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WATCH**, or **Watch 1**, which shows the value of variables and expressions
    that you manually enter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CALL STACK**, which shows the stack of function calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BREAKPOINTS**, which shows all your breakpoints and allows finer control
    over them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When in break mode, there is also a useful window at the bottom of the edit
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEBUG CONSOLE** or **Immediate Window** enables live interaction with your
    code. You can interrogate the program state, for example, by entering the name
    of a variable. For example, you can ask a question such as, "What is 1+2?" by
    typing `1+2` and pressing Enter, as shown in *Figure 4.9*:![](img/B17442_04_10.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 4.9: Interrogating the program state'
  prefs: []
  type: TYPE_NORMAL
- en: Stepping through code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore some ways to step through the code using either Visual Studio
    or Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Run/Debug** | **Step Into**, or click on the **Step Into** button
    in the toolbar, or press F11\. The yellow highlight steps forward one line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run/Debug** | **Step Over**, or click on the **Step Over** button
    in the toolbar, or press F10\. The yellow highlight steps forward one line. At
    the moment, you can see that there is no difference between using **Step Into**
    or **Step Over**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be on the line that calls the `Add` method, as shown in *Figure
    4.10*:![](img/B17442_04_11.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.10: Stepping into and over code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The difference between **Step Into** and **Step Over** can be seen when you
    are about to execute a method call:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you click on **Step Into**, the debugger steps *into* the method so that
    you can step through every line in that method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you click on **Step Over**, the whole method is executed in one go; it does
    not skip over the method without executing it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Step Into** to step inside the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover your mouse pointer over the `a` or `b` parameters in the code editing
    window and note that a tooltip appears showing their current value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the expression `a * b`, right-click the expression, and select **Add
    to Watch** or **Add Watch**. The expression is added to the **WATCH** window,
    showing that this operator is multiplying `a` by `b` to give the result `11.25`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **WATCH** or **Watch 1** window, right-click the expression and choose
    **Remove Expression** or **Delete Watch**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the bug by changing `*` to `+` in the `Add` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging, recompile, and restart debugging by clicking the circular arrow
    **Restart** button or pressing Ctrl or Cmd + Shift + F5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step over the function, take a minute to note how it now calculates correctly,
    and click the **Continue** button or press **F5**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Visual Studio Code, note that when writing to the console during debugging,
    the output appears in the **DEBUG CONSOLE** window instead of the **TERMINAL**
    window, as shown in *Figure 4.11*:![](img/B17442_04_13.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.11: Writing to the DEBUG CONSOLE during debugging'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Customizing breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easy to make more complex breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are still debugging, click the **Stop** button in the debugging toolbar,
    or navigate to **Run/Debug** | **Stop Debugging**, or press Shift + F5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Run** | **Remove All Breakpoints** or **Debug** | **Delete All
    Breakpoints**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `WriteLine` statement that outputs the answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a breakpoint by pressing F9 or navigating to **Run/Debug** | **Toggle Breakpoint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, right-click the breakpoint and choose **Edit Breakpoint...**,
    and then enter an expression, such as the `answer` variable must be greater than
    9, and note the expression must evaluate to true for the breakpoint to activate,
    as shown in *Figure 4.12*:![](img/B17442_04_14.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.12: Customizing a breakpoint with an expression using Visual Studio
    Code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Visual Studio, right-click the breakpoint and choose **Conditions...**, and
    then enter an expression, such as the `answer` variable must be greater than 9,
    and note the expression must evaluate to true for the breakpoint to activate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start debugging and note the breakpoint is not hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the breakpoint or its conditions and change its expression to less than
    9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start debugging and note the breakpoint is hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the breakpoint or its conditions, (in Visual Studio click **Add condition**)
    and select **Hit Count**, then enter a number such as `3`, meaning that you would
    have to hit the breakpoint three times before it activates, as shown in *Figure
    4.13*:![Graphical user interface, text, application  Description automatically
    generated](img/B17442_04_15.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.13: Customizing a breakpoint with an expression and hot count using
    Visual Studio 2022'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hover your mouse over the breakpoint's red circle to see a summary, as shown
    in *Figure 4.14*:![Graphical user interface, text, application  Description automatically
    generated](img/B17442_04_16.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.14: A summary of a customized breakpoint in Visual Studio Code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have now fixed a bug using some debugging tools and seen some advanced possibilities
    for setting breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Logging during development and runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you believe that all the bugs have been removed from your code, you would
    then compile a release version and deploy the application, so that people can
    use it. But no code is ever bug free, and during runtime unexpected errors can
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: End users are notoriously bad at remembering, admitting to, and then accurately
    describing what they were doing when an error occurred, so you should not rely
    on them accurately providing useful information to reproduce the problem to understand
    what caused the problem and then fix it. Instead, you can **instrument your code**,
    which means logging events of interest.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Add code throughout your application to log what is happening,
    and especially when exceptions occur, so that you can review the logs and use
    them to trace the issue and fix the problem. Although we will see logging again
    in *Chapter 10*, *Working with Data Using Entity Framework Core*, and in *Chapter
    15*, *Building Websites Using the Model-View-Controller Pattern*, logging is a
    huge topic, so we can only cover the basics in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding logging options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET includes some built-in ways to instrument your code by adding logging
    capabilities. We will cover the basics in this book. But logging is an area where
    third parties have created a rich ecosystem of powerful solutions that extend
    what Microsoft provides. I cannot make specific recommendations because the best
    logging framework depends on your needs. But I include some common ones in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Apache log4net
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NLog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serilog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumenting with Debug and Trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types that can be used to add simple logging to your code: `Debug`
    and `Trace`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we delve into them in more detail, let''s look at a quick overview of
    each one:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Debug` class is used to add logging that gets written only during development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Trace` class is used to add logging that gets written during both development
    and runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have seen the use of the `Console` type and its `WriteLine` method write
    out to the console window. There is also a pair of types named `Debug` and `Trace`
    that have more flexibility in where they write out to.
  prefs: []
  type: TYPE_NORMAL
- en: The `Debug` and `Trace` classes write to any trace listener. A trace listener
    is a type that can be configured to write output anywhere you like when the `WriteLine`
    method is called. There are several trace listeners provided by .NET, including
    one that outputs to the console, and you can even make your own by inheriting
    from the `TraceListener` type.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the default trace listener
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One trace listener, the `DefaultTraceListener` class, is configured automatically
    and writes to Visual Studio Code's **DEBUG CONSOLE** window or Visual Studio's
    **Debug** window. You can configure other trace listeners using code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see trace listeners in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter04`
    workspace/solution named `Instrumenting`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Instrumenting` as the active OmniSharp project.
    When you see the pop-up warning message saying that required assets are missing,
    click **Yes** to add them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, import the `System.Diagnostics` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a message from the `Debug` and `Trace` classes, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio, navigate to **View** | **Output** and make sure **Show output
    from:** **Debug** is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start debugging the `Instrumenting` console application, and note that **DEBUG
    CONSOLE** in Visual Studio Code or the **Output** window in Visual Studio 2022
    shows the two messages, mixed with other debugging information, such as loaded
    assembly DLLs, as shown in *Figures 4.15* and *4.16*:![Graphical user interface,
    text, website  Description automatically generated](img/B17442_04_17.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.15: Visual Studio Code DEBUG CONSOLE shows the two messages in blue'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17442_04_18.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.16: Visual Studio 2022 Output window shows Debug output including
    the two messages'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configuring trace listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will configure another trace listener that will write to a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `Debug` and `Trace` calls to `WriteLine`, add a statement to create
    a new text file on the desktop and pass it into a new trace listener that knows
    how to write to a text file, and enable automatic flushing for its buffer, as
    shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Any type that represents a file usually implements a buffer
    to improve performance. Instead of writing immediately to the file, data is written
    to an in-memory buffer and only once the buffer is full will it be written in
    one chunk to the file. This behavior can be confusing while debugging because
    we do not immediately see the results! Enabling `AutoFlush` means it calls the
    `Flush` method automatically after every write.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, run the release configuration of the console app by
    entering the following command in the **TERMINAL** window for the `Instrumenting`
    project and note that nothing will appear to have happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2022, in the standard toolbar, select **Release** in the **Solution
    Configurations** dropdown list, as shown in *Figure 4.17*:![](img/B17442_04_19.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.17: Selecting the Release configuration in Visual Studio'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Visual Studio 2022, run the release configuration of the console app by navigating
    to **Debug** | **Start Without Debugging**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On your desktop, open the file named `log.txt` and note that it contains the
    message `Trace says, I am watching!`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, run the debug configuration of the console app by entering
    the following command in the **TERMINAL** window for the `Instrumenting` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio, in the standard toolbar, select **Debug** in the **Solution
    Configurations** dropdown list and then run the console app by navigating to **Debug**
    | **Start Debugging**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On your desktop, open the file named `log.txt` and note that it contains both
    the message, `Debug says, I am watching!` and `Trace says, I am watching!`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: When running with the `Debug` configuration, both `Debug`
    and `Trace` are active and will write to any trace listeners. When running with
    the `Release` configuration, only `Trace` will write to any trace listeners. You
    can therefore use `Debug.WriteLine` calls liberally throughout your code, knowing
    they will be stripped out automatically when you build the release version of
    your application and will therefore not affect performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Switching trace levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Trace.WriteLine` calls are left in your code even after release. So, it
    would be great to have fine control over when they are output. This is something
    we can do with a **trace switch**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of a trace switch can be set using a number or a word. For example,
    the number `3` can be replaced with the word `Info`, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Number | Word | Description |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Off | This will output nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Error | This will output only errors. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Warning | This will output errors and warnings. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Info | This will output errors, warnings, and information. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Verbose | This will output all levels. |'
  prefs: []
  type: TYPE_TB
- en: Let's explore using trace switches. First, we will add some NuGet packages to
    our project to enable loading configuration settings from a JSON `appsettings`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding packages to a project in Visual Studio Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visual Studio Code does not have a mechanism to add NuGet packages to a project,
    so we will use the command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **TERMINAL** window for the `Instrumenting` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`dotnet add package` adds a reference to a NuGet package to your project file.
    It will be downloaded during the build process. `dotnet add reference` adds a
    project-to-project reference to your project file. The referenced project will
    be compiled if needed during the build process.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adding packages to a project in Visual Studio 2022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual Studio has a graphical user interface for adding packages.
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer**, right-click the **Instrumenting** project and select
    **Manage NuGet Packages**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Browse** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search box, enter `Microsoft.Extensions.Configuration`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select each of these NuGet packages and click the **Install** button, as shown
    in *Figure 4.18*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.Binder`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.Json`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.FileExtensions`![Graphical user interface,
    text, application  Description automatically generated](img/B17442_04_20.png)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.18: Installing NuGet packages using Visual Studio 2022'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Good Practice**: There are also packages for loading configuration from XML
    files, INI files, environment variables, and the command line. Use the most appropriate
    technique for setting configuration in your projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing project packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After adding the NuGet packages, we can see the references in the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Instrumenting.csproj` (double-click the **Instrumenting** project in
    Visual Studio''s **Solution Explorer**) and note the `<ItemGroup>` section with
    the added NuGet packages, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a file named `appsettings.json` to the `Instrumenting` project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `appsettings.json` to define a setting named `PacktSwitch` with a `Level`
    value, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2022, in **Solution Explorer**, right-click `appsettings.json`,
    select **Properties**, and then in the **Properties** window, change **Copy to
    Output Directory** to **Copy if newer**. This is necessary because unlike Visual
    Studio Code, which runs the console app in the project folder, Visual Studio runs
    the console app in `Instrumenting\bin\Debug\net6.0` or `Instrumenting\bin\Release\net6.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of `Program.cs`, import the `Microsoft.Extensions.Configuration`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some statements to the end of `Program.cs` to create a configuration builder
    that looks in the current folder for a file named `appsettings.json`, build the
    configuration, create a trace switch, set its level by binding to the configuration,
    and then output the four trace switch levels, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set a breakpoint on the `Bind` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start debugging the `Instrumenting` console app.In the **VARIABLES** or **Locals**
    window, expand the `ts` variable expression, and note that its `Level` is `Off`
    and its `TraceError`, `TraceWarning`, and so on are all `false`, as shown in *Figure
    4.19*:![Graphical user interface, text, application  Description automatically
    generated](img/B17442_04_21.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.19: Watching the trace switch variable properties in Visual Studio
    2022'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Step into the call to the `Bind` method by clicking the **Step Into** or **Step
    Over** buttons or pressing F11 or F10, and note the `ts` variable watch expression
    updates to the `Info` level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step into or over the four calls to `Trace.WriteLineIf` and note that all levels
    up to `Info` are written to the **DEBUG CONSOLE** or **Output - Debug** window,
    but not `Verbose`, as shown in *Figure 4.20*:![Graphical user interface, text,
    application  Description automatically generated](img/B17442_04_22.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.20: Different trace levels shown in the DEBUG CONSOLE in Visual Studio
    Code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stop debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `appsettings.json` to set a level of `2`, which means warning, as shown
    in the following JSON file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, run the console application by entering the following
    command in the **TERMINAL** window for the `Instrumenting` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio, in the standard toolbar, select **Release** in the **Solution
    Configurations** dropdown list and then run the console app by navigating to **Debug**
    | **Start Without Debugging**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file named `log.txt` and note that this time, only trace error and
    warning levels are the output of the four potential trace levels, as shown in
    the following text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If no argument is passed, the default trace switch level is `Off` (0), so none
    of the switch levels are output.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixing bugs in code is expensive. The earlier that a bug is discovered in the
    development process, the less expensive it will be to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is a good way to find bugs early in the development process. Some
    developers even follow the principle that programmers should create unit tests
    before they write code, and this is called **Test-Driven Development** (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has a proprietary unit testing framework known as **MS Test**. There
    is also a framework named **NUnit**. However, we will use the free and open-source
    third-party framework **xUnit.net**. xUnit was created by the same team that built
    NUnit but they fixed the mistakes they felt they made previously. xUnit is more
    extensible and has better community support.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding types of testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit testing is just one of many types of testing, as described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type of testing | Description |'
  prefs: []
  type: TYPE_TB
- en: '| Unit | Tests the smallest unit of code, typically a method or function. Unit
    testing is performed on a unit of code isolated from its dependencies by mocking
    them if needed. Each unit should have multiple tests: some with typical inputs
    and expected outputs, some with extreme input values to test boundaries, and some
    with deliberately wrong inputs to test exception handling. |'
  prefs: []
  type: TYPE_TB
- en: '| Integration | Tests if the smaller units and larger components work together
    as a single piece of software. Sometimes involves integrating with external components
    that you do not have source code for. |'
  prefs: []
  type: TYPE_TB
- en: '| System | Tests the whole system environment in which your software will run.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Tests the performance of your software; for example, your code
    must return a web page full of data to a visitor in under 20 milliseconds. |'
  prefs: []
  type: TYPE_TB
- en: '| Load | Tests how many requests your software can handle simultaneously while
    maintaining required performance, for example, 10,000 concurrent visitors to a
    website. |'
  prefs: []
  type: TYPE_TB
- en: '| User Acceptance | Tests if users can happily complete their work using your
    software. |'
  prefs: []
  type: TYPE_TB
- en: Creating a class library that needs testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create a function that needs testing. We will create it in a
    class library project. A class library is a package of code that can be distributed
    and referenced by other .NET applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Class Library** to the `Chapter04`
    workspace/solution named `CalculatorLib`. The `dotnet new` template is named `classlib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the file named `Class1.cs` to `Calculator.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the file to define a `Calculator` class (with a deliberate bug!), as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile your class library project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio 2022, navigate to **Build** | **Build CalculatorLib**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, in **TERMINAL**, enter the command `dotnet build`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **xUnit Test Project [C#]** to the
    `Chapter04` workspace/solution named `CalculatorLibUnitTests`. The `dotnet new`
    template is named `xunit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio, in **Solution Explorer**, select the `CalculatorLibUnitTests`
    project, navigate to **Project** | **Add Project Reference…**, check the box to
    select the `CalculatorLib` project, and then click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio Code, use the `dotnet add reference` command
    or click on the file named `CalculatorLibUnitTests.csproj`, and modify the configuration
    to add an item group with a project reference to the `CalculatorLib` project,
    as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `CalculatorLibUnitTests` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A well-written unit test will have three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: This part will declare and instantiate variables for input and
    output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: This part will execute the unit that you are testing. In our case,
    that means calling the method that we want to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: This part will make one or more assertions about the output. An
    assertion is a belief that, if not true, indicates a failed test. For example,
    when adding 2 and 2, we would expect the result to be 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will write some unit tests for the `Calculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the file `UnitTest1.cs` to `CalculatorUnitTests.cs` and then open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, rename the class to `CalculatorUnitTests`. (Visual Studio
    prompts you to rename the class when you rename the file.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `Packt` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `CalculatorUnitTests` class to have two test methods for adding
    2 and 2, and adding 2 and 3, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running unit tests using Visual Studio Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we are ready to run the unit tests and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CalculatorLibUnitTest` project''s **TERMINAL** window, run the tests,
    as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the results indicate that two tests ran, one test passed, and one
    test failed, as shown in *Figure 4.21*:![](img/B17442_04_23.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.21: The unit test results in Visual Studio Code''s TERMINAL'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Running unit tests using Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we are ready to run the unit tests and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Test** | **Run All Tests**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Test Explorer**, note that the results indicate that two tests ran, one
    test passed, and one test failed, as shown in *Figure 4.22*:![Graphical user interface,
    text, application, email  Description automatically generated](img/B17442_04_24.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 4.22: The unit test results in Visual Studio 2022''s Test Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Fix the bug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you can fix the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: Fix the bug in the `Add` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the unit tests again to see that the bug has now been fixed and both tests
    pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throwing and catching exceptions in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to exceptions and how to use a `try-catch` statement to handle
    them. But you should only catch and handle an exception if you have enough information
    to mitigate the issue. If you do not, then you should allow the exception to pass
    up through the call stack to a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding usage errors and execution errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Usage errors** are when a programmer misuses a function, typically by passing
    invalid values as parameters. They could be avoided by that programmer changing
    their code to pass valid values. When some programmers first learn C# and .NET,
    they sometimes think exceptions can always be avoided because they assume all
    errors are usage errors. Usage errors should all be fixed before production runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution errors** are when something happens at runtime that cannot be fixed
    by writing "better" code. Execution errors can be split into **program errors**
    and **system errors**. If you attempt to access a network resource but the network
    is down, you need to be able to handle that system error by logging an exception,
    and possibly backing off for a time and trying again. But some system errors,
    such as running out of memory, simply cannot be handled. If you attempt to open
    a file that does not exist, you might be able to catch that error and handle it
    programmatically by creating a new file. Program errors can be programmatically
    fixed by writing smart code. System errors often cannot be fixed programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Commonly thrown exceptions in functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very rarely should you define new types of exceptions to indicate usage errors.
    .NET already defines many that you should use.
  prefs: []
  type: TYPE_NORMAL
- en: When defining your own functions with parameters, your code should check the
    parameter values and throw exceptions if they have values that will prevent your
    function from properly functioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a parameter should not be `null`, throw `ArgumentNullException`.
    For other problems, throw `ArgumentException`, `NotSupportedException`, or `InvalidOperationException`.
    For any exception, include a message that describes the problem for whoever will
    have to read it (typically a developer audience for class libraries and functions,
    or end users if it is at the highest level of a GUI app), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: If a function cannot successfully perform its operation,
    you should consider that a function failure and report it by throwing an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: You should never need to write a `try-catch` statement to catch these usage
    type errors. You want the application to terminate. These exceptions should cause
    the programmer who is calling the function to fix their code to prevent the problem.
    They should be fixed before production deployment. That does not mean that your
    code does not need to throw usage error type exceptions. You should—to force other
    programmers to call your functions correctly!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the call stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The entry point for a .NET console application is the `Main` method of the `Program`
    class, regardless of if you have explicitly defined this class and method or if
    it was created for you by the top-level program feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Main` method will call other methods, that call other methods, and so
    on, and these methods could be in the current project or in referenced projects
    and NuGet packages, as shown in *Figure 4.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17442_04_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: A chain of method calls that create a call stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a similar chain of methods to explore where we could catch and
    handle exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Class Library** to the `Chapter04`
    workspace/solution named `CallStackExceptionHandlingLib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Class1.cs` file to `Calculator.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Calculator.cs` and modify its contents, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter04`
    workspace/solution named `CallStackExceptionHandling`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `CallStackExceptionHandling` as the active OmniSharp
    project. When you see the pop-up warning message saying that required assets are
    missing, click **Yes** to add them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `CallStackExceptionHandling` project, add a reference to the `CallStackExceptionHandlingLib`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to define two methods and chain calls to them,
    and the methods in the class library, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app, and note the results, as shown in the following partial
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call stack is upside-down. Starting from the bottom, you see:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first call is to the `Main` entry point function in the auto-generated `Program`
    class. This is where arguments are passed in as a `string` array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second call is to the `Alpha` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third call is to the `Beta` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth call is to the `Gamma` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth call is to the `Delta` function. This function attempts to open a
    file by passing a bad file path. This causes an exception to be thrown. Any function
    with a `try-catch` statement could catch this exception. If they do not, it is
    automatically passed up the call stack until it reaches the top, where .NET outputs
    the exception (and the details of this call stack).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to catch exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers can decide if they want to catch an exception near the failure point,
    or centralized higher up the call stack. This allows your code to be simplified
    and standardized. You might know that calling an exception could throw one or
    more types of exception, but you do not need to handle any of them at the current
    point in the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Rethrowing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you want to catch an exception, log it, and then rethrow it. There
    are three ways to rethrow an exception inside a `catch` block, as shown in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: To throw the caught exception with its original call stack, call `throw`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To throw the caught exception as if it was thrown at the current level in the
    call stack, call `throw` with the caught exception, for example, `throw ex`. This
    is usually poor practice because you have lost some potentially useful information
    for debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To wrap the caught exception in another exception that can include more information
    in a message that might help the caller understand the problem, throw a new exception
    and pass the caught exception as the `innerException` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If an error could occur when we call the `Gamma` function then we could catch
    the exception and then perform one of the three techniques of rethrowing an exception,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see this in action with our call stack example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CallStackExceptionHandling` project, in `Program.cs`, in the `Beta`
    function, add a `try-catch` statement around the call to the `Gamma` function,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the green squiggle under the `ex` to warn you that you will lose call stack
    information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the console app and note the output excludes some details of the call stack,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the `ex` when rethrowing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the console app and note the output includes all the details of the call
    stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the tester-doer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **tester-doer pattern** can avoid some thrown exceptions (but not eliminate
    them completely). This pattern uses pairs of functions: one to perform a test,
    the other to perform an action that would fail if the test is not passed.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET implements this pattern itself. For example, before adding an item to a
    collection by calling the `Add` method, you can test to see if it is read-only,
    which would cause `Add` to fail and therefore throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, before withdrawing money from a bank account, you might test that
    the account is not overdrawn, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Problems with the tester-doer pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tester-doer pattern can add performance overhead, so you can also implement
    the **try pattern**, which in effect combines the test and do parts into a single
    function, as we saw with `TryParse`.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the tester-doer pattern occurs when you are using multiple
    threads. In this scenario, one thread could call the test function and it returns
    okay. But then another thread executes that changes the state. Then the original
    thread continues executing assuming everything is fine, but it is not fine. This
    is called a race condition. We will see how we could handle it in *Chapter 12*,
    *Improving Performance and Scalability Using Multitasking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you implement your own try pattern function and it fails, remember to set
    the `out` parameter to the default value of its type and then return `false`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics covered in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions. If you get stuck, try Googling the answers
    if necessary, while remembering that if you get totally stuck, the answers are
    in the Appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: What does the C# keyword `void` mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some differences between imperative and functional programming styles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code or Visual Studio, what is the difference between pressing
    F5, Ctrl or Cmd + F5, Shift + F5, and Ctrl or Cmd + Shift + F5?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does the `Trace.WriteLine` method write its output to?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the five trace levels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `Debug` and `Trace` classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing a unit test, what are the three "A"s?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing a unit test using xUnit, what attribute must you decorate the test
    methods with?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What `dotnet` command executes xUnit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What statement should you use to rethrow a caught exception named `ex` without
    losing the stack trace?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 4.2 – Practice writing functions with debugging and unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prime factors are the combination of the smallest prime numbers that, when
    multiplied together, will produce the original number. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prime factors of 4 are: 2 x 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prime factors of 7 are: 7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prime factors of 30 are: 5 x 3 x 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prime factors of 40 are: 5 x 2 x 2 x 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prime factors of 50 are: 5 x 5 x 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a workspace/solution named `PrimeFactors` to contain three projects:
    a class library with a method named `PrimeFactors` that, when passed an `int`
    variable as a parameter, returns a `string` showing its prime factors; a unit
    tests project; and a console application to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: To keep it simple, you can assume that the largest number entered will be 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: Use the debugging tools and write unit tests to ensure that your function works
    correctly with multiple inputs and returns the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.3 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-4---writing-debugging-and-testing-functions](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-4---writing-debugging-and-testing-functions)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write reusable functions with input parameters
    and return values, in both an imperative and functional style, and then how to
    use the Visual Studio and Visual Studio Code debugging and diagnostic features
    to fix any bugs in them. Finally, you learned how to throw and catch exceptions
    in functions and understand the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build your own types using object-oriented
    programming techniques.
  prefs: []
  type: TYPE_NORMAL
