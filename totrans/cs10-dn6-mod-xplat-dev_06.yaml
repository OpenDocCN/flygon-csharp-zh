- en: '06'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Interfaces and Inheriting Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about deriving new types from existing ones using **object-oriented
    programming** (**OOP**). You will learn about defining operators and local functions
    for performing simple actions and delegates and events for exchanging messages
    between types. You will implement interfaces for common functionality. You will
    learn about generics and the difference between reference and value types. You
    will create a derived class to inherit from a base class to reuse functionality,
    override an inherited type member, and use polymorphism. Finally, you will learn
    how to create extension methods and how to cast between classes in an inheritance
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a class library and console application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More about methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising and handling events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making types safely reusable with generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing memory with reference and value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with null values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting from classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting within inheritance hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting and extending .NET types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an analyzer to write better code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a class library and console application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by defining a workspace/solution with two projects like the one
    created in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*.
    Even if you completed all the exercises in that chapter, follow the instructions
    below because we will use C# 10 features in the class library, so it needs to
    target .NET 6.0 rather than .NET Standard 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class library project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter06`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PacktLibrary`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter06`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PeopleApp`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, rename the file named `Class1.cs` to `Person.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `Person.cs` file contents, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `PeopleApp` project, add a project reference to `PacktLibrary`, as shown
    highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `PeopleApp` project and note the output indicating that both projects
    have been built successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More about methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We might want two instances of `Person` to be able to procreate. We can implement
    this by writing methods. Instance methods are actions that an object does to itself;
    static methods are actions the type does.
  prefs: []
  type: TYPE_NORMAL
- en: Which you choose depends on what makes the most sense for the action.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Having both static and instance methods to perform similar
    actions often makes sense. For example, `string` has both a `Compare` static method
    and a `CompareTo` instance method. This puts the choice of how to use the functionality
    in the hands of the programmers using your type, giving them more flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functionality using methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by implementing some functionality by using both static and instance
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add one instance method and one static method to the `Person` class that will
    allow two `Person` objects to procreate, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `static` method named `Procreate`, the `Person` objects to procreate
    are passed as parameters named `p1` and `p2`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `Person` class named `baby` is created with a name composed of a combination
    of the two people who have procreated. This could be changed later by setting
    the returned `baby` variable's `Name` property.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `baby` object is added to the `Children` collection of both parents and
    then returned. Classes are reference types, meaning a reference to the `baby`
    object stored in memory is added, not a clone of the `baby` object. You will learn
    the difference between reference types and value types later in this chapter.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the instance method named `ProcreateWith`, the `Person` object to procreate
    with is passed as a parameter named `partner`, and it, along with `this`, is passed
    to the static `Procreate` method to reuse the method implementation. `this` is
    a keyword that references the current instance of the class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: A method that creates a new object, or modifies an existing
    object, should return a reference to that object so that the caller can access
    the results.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `PeopleApp` project, at the top of the `Program.cs` file, delete the
    comment and import the namespace for our `Person` class and statically import
    the `Console` type, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, create three people and have them procreate with each other,
    noting that to add a double-quote character into a `string`, you must prefix it
    with a backslash character like this, `\"`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing functionality using operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `System.String` class has a `static` method named `Concat` that concatenates
    two string values and returns the result, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling a method like `Concat` works, but it might be more natural for a programmer
    to use the `+` symbol operator to "add" two `string` values together, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A well-known biblical phrase is *Go forth and multiply*, meaning to procreate.
    Let's write code so that the `*` (multiply) symbol will allow two `Person` objects
    to procreate.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by defining a `static` operator for the `*` symbol. The syntax is
    rather like a method, because in effect, an operator *is* a method, but uses a
    symbol instead of a method name, which makes the syntax more concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, create a `static` operator for the `*` symbol, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Unlike methods, operators do not appear in IntelliSense
    lists for a type. For every operator that you define, make a method as well, because
    it may not be obvious to a programmer that the operator is available. The implementation
    of the operator can then call the method, reusing the code you have written. A
    second reason for providing a method is that operators are not supported by every
    language compiler; for example, although arithmetic operators like * are supported
    by Visual Basic and F#, there is no requirement that other languages support all
    operators supported by C#.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, after calling the `Procreate` method and before the statements
    that write to the console, use the `*` operator to make another baby, as shown
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing functionality using local functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A language feature introduced in C# 7.0 is the ability to define a **local function**.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions are the method equivalent of local variables. In other words,
    they are methods that are only accessible from within the containing method in
    which they have been defined. In other languages, they are sometimes called **nested**
    or **inner functions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local functions can be defined anywhere inside a method: the top, the bottom,
    or even somewhere in the middle!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a local function to implement a factorial calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a `Factorial` function that uses a
    local function inside itself to calculate the result, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement to call the `Factorial` function and write
    the return value to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Raising and handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods are often described as *actions that an object can perform, either on
    itself or on related objects*. For example, `List<T>` can add an item to itself
    or clear itself, and `File` can create or delete a file in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Events are often described as *actions that happen to an object*. For example,
    in a user interface, `Button` has a `Click` event, a click being something that
    happens to a button, and `FileSystemWatcher` listens to the filesystem for change
    notifications and raises events like `Created` and `Deleted` that are triggered
    when a directory or file changes.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of thinking of events is that they provide a way of exchanging messages
    between two objects.
  prefs: []
  type: TYPE_NORMAL
- en: Events are built on **delegates**, so let's start by having a look at what delegates
    are and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods using delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have already seen the most common way to call or execute a method: use
    the `.` operator to access the method using its name. For example, `Console.WriteLine`
    tells the `Console` type to access its `WriteLine` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The other way to call or execute a method is to use a delegate. If you have
    used languages that support **function pointers**, then think of a delegate as
    being a **type-safe method pointer**.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a delegate contains the memory address of a method that matches
    the same signature as the delegate so that it can be called safely with the correct
    parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine there is a method in the `Person` class that must have
    a `string` type passed as its only parameter, and it returns an `int` type, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I can call this method on an instance of `Person` named `p1` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, I can define a delegate with a matching signature to call the
    method indirectly. Note that the names of the parameters do not have to match.
    Only the types of parameters and return values must match, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I can create an instance of the delegate, point it at the method, and
    finally, call the delegate (which calls the method), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You are probably thinking, "What's the point of that?" Well, it provides flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could use delegates to create a queue of methods that need to
    be called in order. Queuing actions that need to be performed is common in services
    to provide improved scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is to allow multiple actions to perform in parallel. Delegates
    have built-in support for asynchronous operations that run on a different thread,
    and that can provide improved responsiveness. You will learn how to do this in
    *Chapter 12*, *Improving Performance and Scalability Using Multitasking*.
  prefs: []
  type: TYPE_NORMAL
- en: The most important example is that delegates allow us to implement events for
    sending messages between different objects that do not need to know about each
    other. Events are an example of loose coupling between components because the
    components do not need to know about each other, they just need to know the event
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates and events are two of the most confusing features of C# and can take
    a few attempts to understand, so don't worry if you feel lost!
  prefs: []
  type: TYPE_NORMAL
- en: Defining and handling delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft has two predefined delegates for use as events. Their signatures
    are simple, yet flexible, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: When you want to define an event in your own types, you
    should use one of these two predefined delegates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore delegates and events:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to the `Person` class and note the following points, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It defines an `EventHandler` delegate field named `Shout`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines an `int` field to store `AngerLevel`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines a method named `Poke`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each time a person is poked, their `AngerLevel` increments. Once their `AngerLevel`
    reaches three, they raise the `Shout` event, but only if there is at least one
    event delegate pointing at a method defined somewhere else in the code; that is,
    it is not `null`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Checking whether an object is not `null` before calling one of its methods
    is very common. C# 6.0 and later allows `null` checks to be simplified inline
    using a `?` symbol before the `.` operator, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add a method with a matching signature that
    gets a reference to the `Person` object from the `sender` parameter and outputs
    some information about them, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Microsoft's convention for method names that handle events is `ObjectName_EventName`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to assign the method to the delegate field,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to call the `Poke` method four times, after assigning the method
    to the `Shout` event, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, and note that Harry says nothing the first
    two times he is poked, and only gets angry enough to shout once he''s been poked
    at least three times, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining and handling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ve now seen how delegates implement the most important functionality of
    events: the ability to define a signature for a method that can be implemented
    by a completely different piece of code, and then call that method and any others
    that are hooked up to the delegate field.'
  prefs: []
  type: TYPE_NORMAL
- en: But what about events? There is less to them than you might think.
  prefs: []
  type: TYPE_NORMAL
- en: When assigning a method to a delegate field, you should not use the simple assignment
    operator as we did in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates are multicast, meaning that you can assign multiple delegates to a
    single delegate field. Instead of the `=` assignment, we could have used the `+=`
    operator so we could add more methods to the same delegate field. When the delegate
    is called, all the assigned methods are called, although you have no control over
    the order in which they are called.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `Shout` delegate field was already referencing one or more methods,
    by assigning a method, it would replace all the others. With delegates that are
    used for events, we usually want to make sure that a programmer only ever uses
    either the `+=` operator or the `-=` operator to assign and remove methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enforce this, in `Person.cs`, add the `event` keyword to the delegate field
    declaration, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the `PeopleApp` project and note the compiler error message, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is (almost) all that the `event` keyword does! If you will never have more
    than one method assigned to a delegate field, then technically you do not need
    "events," but it is still good practice to indicate your meaning and that you
    expect a delegate field to be used as an event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the method assignment to use `+=`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code and note that it has the same behavior as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making types safely reusable with generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2005, with C# 2.0 and .NET Framework 2.0, Microsoft introduced a feature
    named **generics**, which enables your types to be more safely reusable and more
    efficient. It does this by allowing a programmer to pass types as parameters,
    similar to how you can pass objects as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Working with non-generic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's look at an example of working with a non-generic type so that you
    can understand the problem that generics are designed to solve, such as weakly
    typed parameters and values, and performance problems caused by using `System.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Collections.Hashtable` can be used to store multiple values each with
    a unique key that can later be used to quickly look up its value. Both the key
    and value can be any object because they are declared as `System.Object`. Although
    this provides flexibility when storing value types like integers, it is slow,
    and bugs are easier to introduce because no type checks are made when adding items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create an instance of the non-generic collection, `System.Collections.Hashtable`,
    and then add four items to it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to define a `key` with the value of `2` and use it to look up
    its value in the hash table, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to use the `harry` object to look up its value, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that it works, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although the code works, there is potential for mistakes because literally any
    type can be used for the key or value. If another developer used your lookup object
    and expected all the items to be a certain type, they might cast them to that
    type and get exceptions because some values might be a different type. A lookup
    object with lots of items would also give poor performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid types in the `System.Collections` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with generic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`System.Collections.Generic.Dictionary<TKey, TValue>` can be used to store
    multiple values each with a unique key that can later be used to quickly look
    up its value. Both the key and value can be any object, but you must tell the
    compiler what the types of the key and value will be when you first instantiate
    the collection. You do this by specifying types for the **generic parameters**
    in angle brackets `<>`, `TKey`, and `TValue`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: When a generic type has one definable type, it should be
    named `T`, for example, `List<T>`, where `T` is the type stored in the list. When
    a generic type has multiple definable types, they should use `T` as a name prefix
    and have a sensible name, for example, `Dictionary<TKey, TValue>`.'
  prefs: []
  type: TYPE_NORMAL
- en: This provides flexibility, it is faster, and bugs are easier to avoid because
    type checks are made when adding items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code to solve the problem by using generics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create an instance of the generic lookup collection `Dictionary<TKey,
    TValue>` and then add four items to it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the compile error when using `harry` as a key, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `harry` with `4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to set the `key` to `3` and use it to look up its value in the
    dictionary, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that it works, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are a way of connecting different types to make new things. Think
    of them like the studs on top of LEGO™ bricks, which allow them to "stick" together,
    or electrical standards for plugs and sockets.
  prefs: []
  type: TYPE_NORMAL
- en: If a type implements an interface, then it is making a promise to the rest of
    .NET that it supports specific functionality. This is why they are sometimes described
    as being contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Common interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some common interfaces that your types might need to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Interface | Method(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `IComparable` | `CompareTo(other)` | This defines a comparison method that
    a type implements to order or sort its instances. |'
  prefs: []
  type: TYPE_TB
- en: '| `IComparer` | `Compare(first, second)` | This defines a comparison method
    that a secondary type implements to order or sort instances of a primary type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IDisposable` | `Dispose()` | This defines a disposal method to release unmanaged
    resources more efficiently than waiting for a finalizer (see the *Releasing unmanaged
    resources* section later in this chapter for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| `IFormattable` | `ToString(format, culture)` | This defines a culture-aware
    method to format the value of an object into a string representation. |'
  prefs: []
  type: TYPE_TB
- en: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | This defines
    methods to convert an object to and from a stream of bytes for storage or transfer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IFormatProvider` | `GetFormat(type)` | This defines a method to format inputs
    based on a language and region. |'
  prefs: []
  type: TYPE_TB
- en: Comparing objects when sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common interfaces that you will want to implement is `IComparable`.
    It has one method named `CompareTo`. It has two variations, one that works with
    a nullable `object` type and one that works with a nullable generic type `T`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For example, the `string` type implements `IComparable` by returning `-1` if
    the `string` is less than the `string` being compared to or `1` if it is greater.
    The `int` type implements `IComparable` by returning `-1` if the `int` is less
    than the `int` being compared to or `1` if it is greater.
  prefs: []
  type: TYPE_NORMAL
- en: If a type implements one of the `IComparable` interfaces, then arrays and collections
    can sort it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement the `IComparable` interface and its `CompareTo` method
    for the `Person` class, let''s see what happens when we try to sort an array of
    `Person` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements that create an array of `Person` instances
    and write the items to the console, and then attempt to sort the array and write
    the items to the console again, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and an exception will be thrown. As the message explains, to fix
    the problem, our type must implement `IComparable`, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, after inheriting from `object`, add a comma and enter `IComparable<Person>`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your code editor will draw a red squiggle under the new code to warn you that
    you have not yet implemented the method you have promised to. Your code editor
    can write the skeleton implementation for you if you click on the light bulb and
    choose the **Implement interface** option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Scroll down to the bottom of the `Person` class to find the method that was
    written for you and delete the statement that throws the `NotImplementedException`
    error, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a statement to call the `CompareTo` method of the `Name` field, which uses
    the `string` type''s implementation of `CompareTo` and return the result, as shown
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have chosen to compare two `Person` instances by comparing their `Name` fields.
    `Person` instances will, therefore, be sorted alphabetically by their name. For
    simplicity, I have not added `null` checks throughout these examples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and note that this time it works as it should, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: If anyone will want to sort an array or collection of instances
    of your type, then implement the `IComparable` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing objects using a separate class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you won''t have access to the source code for a type, and it might
    not implement the `IComparable` interface. Luckily, there is another way to sort
    instances of a type. You can create a separate type that implements a slightly
    different interface, named `IComparer`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibrary` project, add a new class file named `PersonComparer.cs`
    containing a class that implements the `IComparer` interface that will compare
    two people, that is, two `Person` instances. Implement it by comparing the length
    of their `Name` field, or if the names are the same length, then by comparing
    the names alphabetically, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to sort the array using this alternative implementation,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, when we sort the `people` array, we explicitly ask the sorting algorithm
    to use the `PersonComparer` type instead, so that the people are sorted with the
    shortest names first, like Adam, and the longest names last, like Richard; and
    when the lengths of two or more names are equal, to sort them alphabetically,
    like Jenny and Simon.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and explicit interface implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces can be implemented implicitly and explicitly. Implicit implementations
    are simpler and more common. Explicit implementations are only necessary if a
    type must have multiple methods with the same name and signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, both `IGamePlayer` and `IKeyHolder` might have a method called
    `Lose` with the same parameters because both a game and a key can be lost. In
    a type that must implement both interfaces, only one implementation of `Lose`
    can be the implicit method. If both interfaces can share the same implementation,
    that works, but if not then the other `Lose` method will have to be implemented
    differently and called explicitly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Defining interfaces with default implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A language feature introduced in C# 8.0 is **default implementations** for
    an interface. Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new file named `IPlayable.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the statements to define a public `IPlayable` interface with two methods
    to `Play` and `Pause`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `PacktLibrary` project, add a new class file named `DvdPlayer.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the statements in the file to implement the `IPlayable` interface, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is useful, but what if we decide to add a third method named `Stop`? Before
    C# 8.0, this would be impossible once at least one type implements the original
    interface. One of the main points of an interface is that it is a fixed contract.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C# 8.0 allows an interface to add new members after release as long as they
    have a default implementation. C# purists do not like the idea, but for practical
    reasons, such as avoiding breaking changes or having to define a whole new interface,
    it is useful, and other languages such as Java and Swift enable similar techniques.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Support for default interface implementations requires some fundamental changes
    to the underlying platform, so they are only supported with C# if the target framework
    is .NET 5.0 or later, .NET Core 3.0 or later, or .NET Standard 2.1\. They are
    therefore not supported by .NET Framework.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the `IPlayable` interface to add a `Stop` method with a default implementation,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `PeopleApp` project and note that the projects compile successfully
    despite the `DvdPlayer` class not implementing `Stop`. In the future, we could
    override the default implementation of `Stop` by implementing it in the `DvdPlayer`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing memory with reference and value types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have mentioned reference types a couple of times. Let's look at them in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two categories of memory: **stack** memory and **heap** memory. With
    modern operating systems, the stack and heap can be anywhere in physical or virtual
    memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Stack memory is faster to work with (because it is managed directly by the CPU
    and because it uses a last-in, first-out mechanism, it is more likely to have
    the data in its L1 or L2 cache) but limited in size, while heap memory is slower
    but much more plentiful.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a macOS terminal, I can enter the command `ulimit -a` to discover
    that the stack size is limited to 8,192 KB and that other memory is "unlimited."
    This limited amount of stack memory is why it is so easy to fill it up and get
    a "stack overflow."
  prefs: []
  type: TYPE_NORMAL
- en: Defining reference and value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three C# keywords that you can use to define object types: `class`,
    `record`, and `struct`. All can have the same members, such as fields and methods.
    One difference between them is how memory is allocated.'
  prefs: []
  type: TYPE_NORMAL
- en: When you define a type using `record` or `class`, you are defining a **reference
    type**. This means that the memory for the object itself is allocated on the heap,
    and only the memory address of the object (and a little overhead) is stored on
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: When you define a type using `record struct` or `struct`, you are defining a
    **value type**. This means that the memory for the object itself is allocated
    on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: If a `struct` uses field types that are not of the `struct` type, then those
    fields will be stored on the heap, meaning the data for that object is stored
    in both the stack and the heap!
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most common struct types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Number** `System` **types**: `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`,
    `long`, `ulong`, `float`, `double`, and `decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other** `System` **types**: `char`, `DateTime`, and `bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Drawing` **types**: `Color`, `Point`, and `Rectangle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all the other types are `class` types, including `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the difference in terms of where in memory the data for a type is
    stored, the other major difference is that you cannot inherit from a `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: How reference and value types are stored in memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you have a console app that declares some variables, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review what memory is allocated on the stack and heap when these statements
    execute, as shown in *Figure 6.1* and as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `number1` variable is a value type (also known as `struct`) so it is allocated
    on the stack and it uses 4 bytes of memory since it is a 32-bit integer. Its value,
    49, is stored directly in the variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `number2` variable is also a value type so it is also allocated on the stack,
    and it uses 8 bytes since it is a 64-bit integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `location` variable is also a value type so it is allocated on the stack
    and it uses 8 bytes since it is made up of two 32-bit integers, `x` and `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `kevin` variable is a reference type (also known as `class`) so 8 bytes
    for a 64-bit memory address (assuming a 64-bit operating system) is allocated
    on the stack and enough bytes on the heap to store an instance of a `Person`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sally` variable is a reference type so 8 bytes for a 64-bit memory address
    is allocated on the stack. It is currently `null`, meaning no memory has yet been
    allocated for it on the heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B17442_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: How value and reference types are allocated in the stack and heap'
  prefs: []
  type: TYPE_NORMAL
- en: All the allocated memory for a reference type is stored on the heap. If a value
    type such as `DateTime` is used for a field of a reference type like `Person`,
    then the `DateTime` value is stored on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: If a value type has a field that is a reference type, then that part of the
    value type is stored on the heap. `Point` is a value type that consists of two
    fields, both of which are themselves value types, so the entire object can be
    allocated on the stack. If the `Point` value type had a field that was a reference
    type, like `string`, then the `string` bytes would be stored on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Equality of types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common to compare two variables using the `==` and `!=` operators. The
    behavior of these two operators is different for reference types and value types.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you check the equality of two value type variables, .NET literally compares
    the values of those two variables on the stack and returns `true` if they are
    equal, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When you check the equality of two reference type variables, .NET compares
    the memory addresses of those two variables and returns `true` if they are equal,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because they are not the same object. If both variables literally point
    to the same object on the heap, then they would be equal, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The one exception to this behavior is the `string` type. It is a reference
    type, but the equality operators have been overridden to make them behave as if
    they were value types, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can do something similar with your classes to make the equality operators
    return `true` even if they are not the same object (same memory address on the
    heap) but instead if their fields have the same values, but that is beyond the
    scope of this book. Alternatively, use a `record class` because one of their benefits
    is that they implement this behavior for you.
  prefs: []
  type: TYPE_NORMAL
- en: Defining struct types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore defining your own value types:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a file named `DisplacementVector.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the file, as shown in the following code, and note the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type is declared using `struct` instead of `class`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It has two `int` fields, named `X` and `Y`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a constructor for setting initial values for `X` and `Y`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an operator for adding two instances together that returns a new instance
    of the type with `X` added to `X`, and `Y` added to `Y`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create two new instances of `DisplacementVector`,
    add them together, and output the result, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: If the total bytes used by all the fields in your type is
    16 bytes or less, your type only uses value types for its fields, and you will
    never want to derive from your type, then Microsoft recommends that you use `struct`.
    If your type uses more than 16 bytes of stack memory, if it uses reference types
    for its fields, or if you might want to inherit from it, then use `class`.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with record struct types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# 10 introduced the ability to use the `record` keyword with `struct` types
    as well as with class types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could define the `DisplacementVector` type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, Microsoft recommends explicitly specifying `class` if you
    want to define a `record class` even though the `class` keyword is optional, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Releasing unmanaged resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we saw that constructors can be used to initialize
    fields and that a type may have multiple constructors. Imagine that a constructor
    allocates an unmanaged resource; that is, anything that is not controlled by .NET,
    such as a file or mutex under the control of the operating system. The unmanaged
    resource must be manually released because .NET cannot do it for us using its
    automatic garbage collection feature.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection is an advanced topic, so for this topic, I will show some
    code examples, but you do not need to write the code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Each type can have a single **finalizer** that will be called by the .NET runtime
    when the resources need to be released. A finalizer has the same name as a constructor;
    that is, the type name, but it is prefixed with a tilde, `~`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not confuse a finalizer (also known as a **destructor**) with a `Deconstruct`
    method. A destructor releases resources; that is, it destroys an object in memory.
    A `Deconstruct` method returns an object split up into its constituent parts and
    uses the C# deconstruction syntax, for example, when working with tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code example is the minimum you should do when working with unmanaged
    resources. But the problem with only providing a finalizer is that the .NET garbage
    collector requires two garbage collections to completely release the allocated
    resources for this type.
  prefs: []
  type: TYPE_NORMAL
- en: Though optional, it is recommended to also provide a method to allow a developer
    who uses your type to explicitly release resources so that the garbage collector
    can release managed parts of an unmanaged resource, such as a file, immediately
    and deterministically, and then release the managed memory part of the object
    in a single garbage collection instead of two rounds of garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a standard mechanism for doing this by implementing the `IDisposable`
    interface, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two `Dispose` methods, one `public` and one `protected`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `public void Dispose` method will be called by a developer using your type.
    When called, both unmanaged and managed resources need to be deallocated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `protected virtual void Dispose` method with a `bool` parameter is used
    internally to implement the deallocation of resources. It needs to check the `disposing`
    parameter and `disposed` field because if the finalizer thread has already run
    and it called the `~Animal` method, then only unmanaged resources need to be deallocated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `GC.SuppressFinalize(this)` is what notifies the garbage collector
    that it no longer needs to run the finalizer, and removes the need for a second
    garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that Dispose is called
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When someone uses a type that implements `IDisposable`, they can ensure that
    the public `Dispose` method is called with the `using` statement, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler converts your code into something like the following, which guarantees
    that even if an exception occurs, the `Dispose` method will still be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You will see practical examples of releasing unmanaged resources with `IDisposable`,
    `using` statements, and `try`...`finally` blocks in *Chapter 9*, *Working with
    Files, Streams, and Serialization*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with null values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to store primitive values like numbers in `struct` variables.
    But what if a variable does not yet have a value? How can we indicate that? C#
    has the concept of a `null` value, which can be used to indicate that a variable
    has not been set.
  prefs: []
  type: TYPE_NORMAL
- en: Making a value type nullable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, value types like `int` and `DateTime` must always have a value,
    hence their name. Sometimes, for example, when reading values stored in a database
    that allows empty, missing, or null values, it is convenient to allow a value
    type to be `null`. We call this a **nullable value type**.
  prefs: []
  type: TYPE_NORMAL
- en: You can enable this by adding a question mark as a suffix to the type when declaring
    a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter06`
    workspace/solution named `NullHandling`. This section requires a full application
    with a project file, so you will not be able to use a .NET Interactive notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `NullHandling` as the active OmniSharp project.
    In Visual Studio, set `NullHandling` as the startup project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare and assign values, including `null`,
    to `int` variables, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the statement that gives a compile error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line is blank because it is outputting the `null` value!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding nullable reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the `null` value is so common, in so many languages, that many experienced
    programmers never question the need for its existence. But there are many scenarios
    where we could write better, simpler code if a variable is not allowed to have
    a `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant change to the language in C# 8 was the introduction of
    nullable and non- nullable reference types. "But wait!", you are probably thinking,
    "Reference types are already nullable!"
  prefs: []
  type: TYPE_NORMAL
- en: And you would be right, but in C# 8 and later, reference types can be configured
    to no longer allow the `null` value by setting a file- or project-level option
    to enable this useful new feature. Since this is a big change for C#, Microsoft
    decided to make the feature opt-in.
  prefs: []
  type: TYPE_NORMAL
- en: It will take multiple years for this new C# language feature to make an impact
    since thousands of existing library packages and apps will expect the old behavior.
    Even Microsoft did not have time to fully implement this new feature in all the
    main .NET packages until .NET 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the transition, you can choose between several approaches for your own
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Default**: No changes are needed. Non-nullable reference types are not supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opt-in project, opt-out files**: Enable the feature at the project level
    and, for any files that need to remain compatible with old behavior, opt out.
    This is the approach Microsoft is using internally while it updates its own packages
    to use this new feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opt-in files**: Only enable the feature for individual files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling nullable and non-nullable reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable the feature at the project level, add the following to your project
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is now done by default in project templates that target .NET 6.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the feature at the file level, add the following to the top of a
    code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the feature at the file level, add the following to the top of a
    code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Declaring non-nullable variables and parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enable nullable reference types and you want a reference type to be assigned
    the `null` value, then you will have to use the same syntax as making a value
    type nullable, that is, adding a `?` symbol after the type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do nullable reference types work? Let''s look at an example. When storing
    information about an address, you might want to force a value for the street,
    city, and region, but the building can be left blank, that is, `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `NullHandling.csproj`, in `Program.cs`, at the bottom of the file, add statements
    to declare an `Address` class with four fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After a few seconds, note the warnings about non-nullable fields, like `Street`
    not being initialized, as shown in *Figure 6.2*:![Graphical user interface, text,
    application, chat or text message  Description automatically generated](img/B17442_06_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.2: Warning messages about non-nullable fields in the PROBLEMS window'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Assign the empty `string` value to each of the three fields that are non-nullable,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, at the top of the file, statically import `Console` and then
    add statements to instantiate an `Address` and set its properties, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the warnings, as shown in *Figure 6.3*:![Graphical user interface, text,
    application, chat or text message, email  Description automatically generated](img/B17442_06_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.3: Warning message about assigning null to a non-nullable field'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, this is why the new language feature is named nullable reference types.
    Starting with C# 8.0, unadorned reference types can become non-nullable, and the
    same syntax is used to make a reference type nullable as is used for value types.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checking whether a nullable reference type or nullable value type variable
    currently contains `null` is important because if you do not, a `NullReferenceException`
    can be thrown, which results in an error. You should check for a `null` value
    before using a nullable variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 7 introduced `is` combined with the `!` (not) operator as an alternative
    to `!=`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 9 introduced `is not` as an even clearer alternative, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are trying to use a member of a variable that might be `null`, use the
    null-conditional operator `?.`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you want to either assign a variable to a result or use an alternative
    value, such as `3`, if the variable is `null`. You do this using the null-coalescing
    operator, `??`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Even if you enable nullable reference types, you should
    still check non-nullable parameters for `null` and throw an `ArgumentNullException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for null in method parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When defining methods with parameters, it is good practice to check for `null`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In earlier versions of C#, you would have to write `if` statements to check
    for `null` parameter values and then throw an `ArgumentNullException` for any
    parameter that is `null`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 11 might introduce a new `!!` suffix that does this for you, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement and throwing of the exception are done for you.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Person` type we created earlier derived (inherited) from `object`, the
    alias for `System.Object`. Now, we will create a subclass that inherits from `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `Employee.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents to define a class named `Employee` that derives from `Person`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create an instance of the `Employee` class,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `Employee` class has inherited all the members of `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes to add functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will add some employee-specific members to extend the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to define two properties for an employee code
    and the date they were hired, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to set John''s employee code and hire date,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hiding members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the `WriteToConsole` method is inherited from `Person`, and it only
    outputs the employee''s name and date of birth. We might want to change what this
    method does for an employee:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to redefine the `WriteToConsole` method, as
    shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your coding tool warns you that your method now hides the method from `Person`
    by drawing a squiggle under the method name, the **PROBLEMS**/**Error List** window
    includes more details, and the compiler will output the warning when you build
    and run the console application, as shown in *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17442_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Hidden method warning'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the warning describes, you can hide this message by applying the `new` keyword
    to the method, to indicate that you are deliberately replacing the old method,
    as shown highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Overriding members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than hiding a method, it is usually better to **override** it. You can
    only override if the base class chooses to allow overriding, by applying the `virtual`
    keyword to any methods that should allow overriding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to write the value of the `john` variable
    to the console using its `string` representation, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that the `ToString` method is inherited from `System.Object`,
    so the implementation returns the namespace and type name, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Person.cs`, override this behavior by adding a `ToString` method to output
    the name of the person as well as the type name, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `base` keyword allows a subclass to access members of its superclass; that
    is, the **base class** that it inherits or derives from.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result. Now, when the `ToString` method is called,
    it outputs the person''s name, as well as returning the base class''s implementation
    of `ToString`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Many real-world APIs, for example, Microsoft''s Entity Framework
    Core, Castle''s DynamicProxy, and Episerver''s content models, require the properties
    that you define in your classes to be marked as `virtual` so that they can be
    overridden. Carefully decide which of your method and property members should
    be marked as `virtual`.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned about interfaces that can define a set
    of members that a type must have to meet a basic level of functionality. These
    are very useful, but their main limitation is that until C# 8 they could not provide
    any implementation of their own.
  prefs: []
  type: TYPE_NORMAL
- en: This is a particular problem if you still need to create class libraries that
    will work with .NET Framework and other platforms that do not support .NET Standard
    2.1.
  prefs: []
  type: TYPE_NORMAL
- en: In those earlier platforms, you could use abstract classes as a sort of halfway
    house between a pure interface and a fully implemented class.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is marked as `abstract`, this means that it cannot be instantiated
    because you are indicating that the class is not complete. It needs more implementation
    before it can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `System.IO.Stream` class is abstract because it implements
    common functionality that all streams would need but is not complete, so you cannot
    instantiate it using `new Stream()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the two types of interface and two types of class, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Preventing inheritance and overriding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can prevent another developer from inheriting from your class by applying
    the `sealed` keyword to its definition. No one can inherit from Scrooge McDuck,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: An example of `sealed` in .NET is the `string` class. Microsoft has implemented
    some extreme optimizations inside the `string` class that could be negatively
    affected by your inheritance, so Microsoft prevents that.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent someone from further overriding a `virtual` method in your
    class by applying the `sealed` keyword to the method. No one can change the way
    Lady Gaga sings, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: You can only seal an overridden method.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now seen two ways to change the behavior of an inherited method. We
    can *hide* it using the `new` keyword (known as **non-polymorphic inheritance**),
    or we can *override* it (known as **polymorphic inheritance**).
  prefs: []
  type: TYPE_NORMAL
- en: Both ways can access members of the base or superclass by using the `base` keyword,
    so what is the difference?
  prefs: []
  type: TYPE_NORMAL
- en: It all depends on the type of variable holding a reference to the object. For
    example, a variable of the `Person` type can hold a reference to a `Person` class,
    or any type that derives from `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this could affect your code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to override the `ToString` method so it writes
    the employee''s name and code to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, write statements to create a new employee named Alice, store
    it in a variable of type `Person`, and call both variables'' `WriteToConsole`
    and `ToString` methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When a method is hidden with `new`, the compiler is not smart enough to know
    that the object is an `Employee`, so it calls the `WriteToConsole` method in `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: When a method is overridden with `virtual` and `override`, the compiler is smart
    enough to know that although the variable is declared as a `Person` class, the
    object itself is an `Employee` class and, therefore, the `Employee` implementation
    of `ToString` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The member modifiers and the effect they have are summarized in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable type | Member modifier | Method executed | In class |'
  prefs: []
  type: TYPE_TB
- en: '| `Person` |  | `WriteToConsole` | `Person` |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
  prefs: []
  type: TYPE_TB
- en: '| `Person` | `virtual` | `ToString` | `Employee` |'
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | `override` | `ToString` | `Employee` |'
  prefs: []
  type: TYPE_TB
- en: In my opinion, polymorphism is academic to most programmers. If you get the
    concept, that's cool; but, if not, I suggest that you don't worry about it. Some
    people like to make others feel inferior by saying understanding polymorphism
    is important for all C# programmers to learn, but IMHO it's not.
  prefs: []
  type: TYPE_NORMAL
- en: You can have a successful career with C# and never need to be able to explain
    polymorphism, just as a racing car driver doesn't need to be able to explain the
    engineering behind fuel injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You should use `virtual` and `override` rather than `new`
    to change the implementation of an inherited method whenever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Casting within inheritance hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting between types is subtly different from converting between types. Casting
    is between similar types, like between a 16-bit integer and a 32-bit integer,
    or between a superclass and one of its subclasses. Converting is between dissimilar
    types, such as between text and a number.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, you saw how an instance of a derived type can be stored
    in a variable of its base type (or its base's base type, and so on). When we do
    this, it is called **implicit casting**.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going the other way is an explicit cast, and you must use parentheses around
    the type you want to cast into as a prefix to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to assign the `aliceInPerson` variable to
    a new `Employee` variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your coding tool displays a red squiggle and a compile error, as shown in *Figure
    6.5*:![Graphical user interface, text, application, email, website  Description
    automatically generated](img/B17442_06_05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.5: A missing explicit cast compile error'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the statement to prefix the assigned variable named with a cast to the
    `Employee` type, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Avoiding casting exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler is now happy; but, because `aliceInPerson` might be a different
    derived type, like `Student` instead of `Employee`, we need to be careful. In
    a real application with more complex code, the current value of this variable
    could have been set to a `Student` instance, and then this statement would throw
    an `InvalidCastException` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle this by writing a `try` statement, but there is a better way.
    We can check the type of an object using the `is` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the explicit cast statement in an `if` statement, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can simplify the code further using a declaration pattern and this will
    avoid needing to perform an explicit cast, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Alternatively, you can use the `as` keyword to cast. Instead of throwing an
    exception, the `as` keyword returns `null` if the type cannot be cast.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Main`, add the statements to cast Alice using the `as` keyword and then
    check whether the return value is not null, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since accessing a member of a `null` variable will throw a `NullReferenceException`
    error, you should always check for `null` before using the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What if you want to execute a block of statements when Alice is not an employee?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, you would have had to use the `!` (not) operator, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'With C# 9 and later, you can use the `not` keyword, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Use the `is` and `as` keywords to avoid throwing exceptions
    when casting between derived types. If you don''t do this, you must write `try`-`catch`
    statements for `InvalidCastException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting and extending .NET types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET has prebuilt class libraries containing hundreds of thousands of types.
    Rather than creating your own completely new types, you can often get a head start
    by deriving from one of Microsoft's types to inherit some or all of its behavior
    and then overriding or extending it.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of inheritance, we will derive a new type of exception:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `PersonException.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the contents of the file to define a class named `PersonException` with
    three constructors, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unlike ordinary methods, constructors are not inherited, so we must explicitly
    declare and explicitly call the base constructor implementations in `System.Exception`
    to make them available to programmers who might want to use those constructors
    with our custom exception.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method that throws an exception
    if a date/time parameter is earlier than a person''s date of birth, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to test what happens when employee John Jones
    tries to time travel too far back, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: When defining your own exceptions, give them the same three
    constructors that explicitly call the built-in ones.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending types when you can't inherit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we saw how the `sealed` modifier can be used to prevent inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has applied the `sealed` keyword to the `System.String` class so that
    no one can inherit and potentially break the behavior of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Can we still add new methods to strings? Yes, if we use a language feature named
    **extension methods**, which was introduced with C# 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Using static methods to reuse functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the first version of C#, we've been able to create `static` methods to
    reuse functionality, such as the ability to validate that a `string` contains
    an email address. The implementation will use a regular expression that you will
    learn more about in *Chapter 8*, *Working with Common .NET Types*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibrary` project, add a new class named `StringExtensions`, as
    shown in the following code, and note the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class imports a namespace for handling regular expressions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IsValidEmail` method is `static` and it uses the `Regex` type to check
    for matches against a simple email pattern that looks for valid characters before
    and after the `@` symbol.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to validate two examples of email addresses,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This works, but extension methods can reduce the amount of code we must type
    and simplify the usage of this function.
  prefs: []
  type: TYPE_NORMAL
- en: Using extension methods to reuse functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is easy to make `static` methods into extension methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `StringExtensions.cs`, add the `static` modifier before the class, and add
    the `this` modifier before the `string` type, as highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These two changes tell the compiler that it should treat the method as one that
    extends the `string` type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to use the extension method for `string` values
    that need to be checked for valid email addresses, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the subtle simplification in the syntax for calling the `IsValidEmail`
    method. The older, longer syntax still works too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `IsValidEmail` extension method now appears to be a method just like all
    the actual instance methods of the `string` type, such as `IsNormalized` and `Insert`,
    as shown in *Figure 6.6*:![Graphical user interface, text, application  Description
    automatically generated](img/B17442_06_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.6: Extension methods appear in IntelliSense alongside instance methods'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the code and view the result, which will be the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: Extension methods cannot replace or override existing instance
    methods. You cannot, for example, redefine the `Insert` method. The extension
    method will appear as an overload in IntelliSense, but an instance method will
    be called in preference to an extension method with the same name and signature.'
  prefs: []
  type: TYPE_NORMAL
- en: Although extension methods might not seem to give a big benefit, in *Chapter
    11*, *Querying and Manipulating Data Using LINQ*, you will see some extremely
    powerful uses of extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using an analyzer to write better code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET analyzers find potential issues and suggest fixes for them. **StyleCop**
    is a commonly used analyzer for helping you write better C# code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see it in action, advising how to improve the code in the project template
    for a console app when targeting .NET 5.0 so that the console app already has
    a `Program` class with a `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a console app project, as defined in
    the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console -f net5.0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter06`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `CodeAnalyzing`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Target framework: **.NET 5.0 (Current)**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `CodeAnalyzing` project, add a package reference for `StyleCop.Analyzers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a JSON file to your project named `stylecop.json` for controlling StyleCop
    settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `$schema` entry enables IntelliSense while editing the `stylecop.json` file
    in your code editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the project file, change the target framework to `net6.0`, add entries
    to configure the file named `stylecop.json` to not be included in published deployments,
    and to enable it as an additional file for processing during development, as shown
    highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see warnings for everything it thinks is wrong, as shown in *Figure
    6.7*:![](img/B17442_06_07.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.7: StyleCop code analyzer warnings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, it wants `using` directives to be put within the namespace declaration,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Suppressing warnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To suppress a warning, you have several options, including adding code and setting
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To suppress using an attribute, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To suppress using a directive, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppress the warning by modifying the `stylecop.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `stylecop.json`, add a configuration option to set `using` statements to
    be allowable outside a namespace, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project and note that warning SA1200 has disappeared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `stylecop.json`, set the using directives placement to `preserve`, which
    allows `using` statements both inside and outside a namespace, as shown in the
    following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fixing the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s fix all the other warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `CodeAnalyzing.csproj`, add an element to automatically generate an XML
    file for documentation, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `stylecop.json`, add a configuration option to provide values for documentation
    for the company name and copyright text, as shown highlighted in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add comments for a file header with company and copyright
    text, move the `using System;` declaration inside the namespace, and set explicit
    access modifiers and XML comments for the class and method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expand the `bin/Debug/net6.0` folder and note the autogenerated file named
    `CodeAnalyzing.xml`, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding common StyleCop recommendations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside a code file, you should order the contents, as shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: External alias directives
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using directives
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within a class, record, struct, or interface, you should order the contents,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destructors (finalizers)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nested classes and records
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: You can learn about all the StyleCop rules at the following
    link: [https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions. Get some
    hands-on practice and explore this chapter's topics with more in-depth research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a delegate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an event?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are a base class and a derived class related, and how can the derived class
    access the base class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `is` and `as` operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to prevent a class from being derived from or a method
    from being further overridden?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to prevent a class from being instantiated with the `new`
    keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to allow a member to be overridden?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between a destructor and a deconstruct method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the signatures of the constructors that all exceptions should have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an extension method, and how do you define one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 6.2 – Practice creating an inheritance hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Explore inheritance hierarchies by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new console application named `Exercise02` to your `Chapter06` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `Shape` with properties named `Height`, `Width`, and `Area`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three classes that derive from it—`Rectangle`, `Square`, and `Circle`—with
    any additional members you feel are appropriate and that override and implement
    the `Area` property correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Main`, add statements to create one instance of each shape, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console application and ensure that the result looks like the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exercise 6.3 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about local functions and operators, delegates
    and events, implementing interfaces, generics, and deriving types using inheritance
    and OOP. You also learned about base and derived classes, and how to override
    a type member, use polymorphism, and cast between types.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how .NET is packaged and deployed, and,
    in subsequent chapters, the types that it provides you with to implement common
    functionality such as file handling, database access, encryption, and multitasking.
  prefs: []
  type: TYPE_NORMAL
