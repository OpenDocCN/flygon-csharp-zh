- en: '03'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling Flow, Converting Types, and Handling Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about writing code that performs simple operations on variables,
    makes decisions, performs pattern matching, repeats statements or blocks, converts
    variable or expression values from one type to another, handles exceptions, and
    checks for overflows in number variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Operating on variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding selection statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding iteration statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting and converting between types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating on variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Operators** apply simple operations such as addition and multiplication to
    **operands** such as variables and literal values. They usually return a new value
    that is the result of the operation that can be assigned to a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most operators are binary, meaning that they work on two operands, as shown
    in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples of binary operators include adding and multiplying, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some operators are unary, meaning they work on a single operand, and can apply
    before or after the operand, as shown in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples of unary operators include incrementors and retrieving a type or its
    size in bytes, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A ternary operator works on three operands, as shown in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Exploring unary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two common unary operators are used to increment, `++`, and decrement, `--`,
    a number. Let us write some example code to show how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: If you've completed the previous chapters, then you will already have a `Code`
    folder. If not, then you'll need to create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your preferred coding tool to create a new console app, as defined in the
    following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter03`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Operators`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of `Program.cs`, statically import `System.Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, declare two integer variables named `a` and `b`, set `a` to
    `3`, increment `a` while assigning the result to `b`, and then output their values,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before running the console application, ask yourself a question: what do you
    think the value of `b` will be when output? Once you''ve thought about that, run
    the code, and compare your prediction against the actual result, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variable `b` has the value `3` because the `++` operator executes *after*
    the assignment; this is known as a **postfix operator**. If you need to increment
    *before* the assignment, then use the **prefix operator**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy and paste the statements, and then modify them to rename the variables
    and use the prefix operator, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rerun the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Due to the confusion between prefix and postfix for the
    increment and decrement operators when combined with an assignment, the Swift
    programming language designers decided to drop support for this operator in version
    3\. My recommendation for usage in C# is to never combine the use of `++` and
    `--` operators with an assignment operator, `=`. Perform the operations as separate
    statements.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exploring binary arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Increment and decrement are unary arithmetic operators. Other arithmetic operators
    are usually binary and allow you to perform arithmetic operations on two numbers,
    as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the statements to declare and assign values to two integer variables named
    `e` and `f`, and then apply the five common binary arithmetic operators to the
    two numbers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To understand the divide `/` and modulo `%` operators when applied to integers,
    you need to think back to primary school. Imagine you have eleven sweets and three
    friends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How can you divide the sweets between your friends? You can give three sweets
    to each of your friends, and there will be two left over. Those two sweets are
    the **modulus**, also known as the **remainder** after dividing. If you have twelve
    sweets, then each friend gets four of them, and there are none left over, so the
    remainder would be 0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add statements to declare and assign a value to a `double` variable named `g`
    to show the difference between whole number and real number divisions, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the first operand is a floating-point number, such as `g` with the value
    `11.0`, then the divide operator returns a floating-point value, such as `3.6666666666665`,
    rather than a whole number.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already been using the most common assignment operator, `=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your code more concise, you can combine the assignment operator with
    other operators like arithmetic operators, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Exploring logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators operate on Boolean values, so they return either `true` or
    `false`. Let''s explore binary logical operators that operate on two Boolean values:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new console app to the `Chapter03` workspace/solution
    named `BooleanOperators`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `BooleanOperators` as the active OmniSharp project.
    When you see the pop-up warning message saying that required assets are missing,
    click **Yes** to add them.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the start up project for the solution to the current selection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: Remember to statically import the `System.Console` type
    to simplify statements.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to declare two Boolean variables with values
    of `true` and `false`, and then output truth tables showing the results of applying
    AND, OR, and XOR (exclusive OR) logical operators, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the AND `&` logical operator, both operands must be `true` for the result
    to be `true`. For the OR `|` logical operator, either operand can be `true` for
    the result to be `true`. For the XOR `^` logical operator, either operand can
    be `true` (but not both!) for the result to be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring conditional logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional logical operators are like logical operators, but you use two symbols
    instead of one, for example, `&&` instead of `&`, or `||` instead of `|`.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 4*, *Writing, Debugging, and Testing Functions*, you will learn
    about functions in more detail, but I need to introduce functions now to explain
    conditional logical operators, also known as short-circuiting Boolean operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function executes statements and then returns a value. That value could be
    a Boolean value like `true` that is used in a Boolean operation. Let''s make use
    of conditional logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, write statements to declare a function that
    writes a message to the console and returns `true`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: If you are using .NET Interactive Notebook, write the `DoStuff`
    function in a separate code cell and then execute it to make its context available
    to other code cells.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After the previous `WriteLine` statements, perform an AND `&` operation on
    the `a` and `b` variables and the result of calling the function, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the function was called twice,
    once for a and once for b, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `&` operators into `&&` operators, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, view the result, and note that the function does run when combined
    with the `a` variable. It does not run when combined with the `b` variable because
    the `b` variable is `false` so the result will be `false` anyway, so it does not
    need to execute the function, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Now you can see why the conditional logical operators are
    described as being short-circuiting. They can make your apps more efficient, but
    they can also introduce subtle bugs in cases where you assume that the function
    would always be called. It is safest to avoid them when used in combination with
    functions that cause side effects.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exploring bitwise and binary shift operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bitwise operators affect the bits in a number. Binary shift operators can perform
    some common arithmetic calculations much faster than traditional operators, for
    example, any multiplication by a factor of 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore bitwise and binary shift operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `BitwiseAndShiftOperators`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `BitwiseAndShiftOperators` as the active OmniSharp
    project. When you see the pop-up warning message saying that required assets are
    missing, click **Yes** to add them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare two integer variables with values
    10 and 6, and then output the results of applying AND, OR, and XOR bitwise operators,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to output the results of applying the left-shift
    operator to move the bits of the variable `a` by three columns, multiplying `a`
    by 8, and right-shifting the bits of the variable `b` by one column, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `80` result is because the bits in it were shifted three columns to the
    left, so the 1-bits moved into the 64- and 16-bit columns and 64 + 16 = 80\. This
    is the equivalent of multiplying by 8, but CPUs can perform a bit-shift faster.
    The 3 result is because the 1-bits in `b` were shifted one column into the 2-
    and 1-bit columns.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Remember that when operating on integer values, the `&`
    and `|` symbols are bitwise operators, and when operating on Boolean values like
    `true` and `false`, the `&` and `|` symbols are logical operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can illustrate the operations by converting the integer values into binary
    strings of zeros and ones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, add a function to convert an integer value into
    a binary (Base2) `string` of up to eight zeros and ones, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above the function, add statements to output `a`, `b`, and the results of the
    various bitwise operators, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Miscellaneous operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`nameof` and `sizeof` are convenient operators when working with types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nameof` returns the short name (without the namespace) of a variable, type,
    or member as a `string` value, which is useful when outputting exception messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizeof` returns the size in bytes of simple types, which is useful for determining
    the efficiency of data storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many other operators; for example, the dot between a variable and
    its members is called the **member access operator** and the round brackets at
    the end of a function or method name are called the **invocation operator**, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Understanding selection statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application needs to be able to select from choices and branch along different
    code paths. The two selection statements in C# are `if` and `switch`. You can
    use `if` for all your code, but `switch` can simplify your code in some common
    scenarios such as when there is a single variable that can have multiple values
    that each require different processing.
  prefs: []
  type: TYPE_NORMAL
- en: Branching with the if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `if` statement determines which branch to follow by evaluating a Boolean
    expression. If the expression is `true`, then the block executes. The `else` block
    is optional, and it executes if the `if` expression is `false`. The `if` statement
    can be nested.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement can be combined with other `if` statements as `else if`
    branches, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each `if` statement's Boolean expression is independent of the others and, unlike
    `switch` statements, does not need to reference a single value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code to explore selection statements like `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `SelectionStatements`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `SelectionStatements` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to check if a password is at least eight characters,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why you should always use braces with if statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As there is only a single statement inside each block, the preceding code could
    be written without the curly braces, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This style of `if` statement should be avoided because it can introduce serious
    bugs, for example, the infamous #gotofail bug in Apple''s iPhone iOS operating
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: For 18 months after Apple's iOS 6 was released, in September 2012, it had a
    bug in its **Secure Sockets Layer** (**SSL**) encryption code, which meant that
    any user running Safari, the device's web browser, who tried to connect to secure
    websites, such as their bank, was not properly secure because an important check
    was being accidentally skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Just because you can leave out the curly braces doesn't mean you should. Your
    code is not "more efficient" without them; instead, it is less maintainable and
    potentially more dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with the if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A feature introduced with C# 7.0 and later is pattern matching. The `if` statement
    can use the `is` keyword in combination with declaring a local variable to make
    your code safer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements so that if the value stored in the variable named `o` is an
    `int`, then the value is assigned to the local variable named `i`, which can then
    be used inside the `if` statement. This is safer than using the variable named
    `o` because we know for sure that `i` is an `int` variable and not something else,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Delete the double-quote characters around the `"3"` value so that the value
    stored in the variable named `o` is an `int` type instead of a `string` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rerun the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Branching with the switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` statement is different from the `if` statement because `switch`
    compares a single expression against a list of multiple possible `case` statements.
    Every `case` statement is related to the single expression. Every `case` section
    must end with:'
  prefs: []
  type: TYPE_NORMAL
- en: The `break` keyword (like case 1 in the following code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or the `goto` `case` keywords (like case 2 in the following code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or they should have no statements (like case 3 in the following code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or the `goto` keyword that references a named label (like case 5 in the following
    code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or the `return` keyword to leave the current function (not shown in the code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write some code to explore the `switch` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements for a `switch` statement. You should note that the penultimate
    statement is a label that can be jumped to, and the first statement generates
    a random number between 1 and 6 (the number 7 in the code is an exclusive upper
    bound). The `switch` statement branches are based on the value of this random
    number, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: You can use the `goto` keyword to jump to another case or
    a label. The `goto` keyword is frowned upon by most programmers but can be a good
    solution to code logic in some scenarios. However, you should use it sparingly.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code multiple times to see what happens in various cases of random
    numbers, as shown in the following example output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pattern matching with the switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the `if` statement, the `switch` statement supports pattern matching in
    C# 7.0 and later. The `case` values no longer need to be literal values; they
    can be patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of pattern matching with the `switch` statement using
    a folder path. If you are using macOS, then swap the commented statement that
    sets the path variable and replace my username with your user folder name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to declare a `string` path to a file, open it as either a read-only
    or writeable stream, and then show a message based on what type and capabilities
    the stream has, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that the variable named `s` is declared as a `Stream`
    type so it could be any subtype of stream, such as a memory stream or file stream.
    In this code, the stream is created using the `File.Open` method, which returns
    a file stream and, depending on your key press, it will be writeable or read-only,
    so the result will be a message that describes the situation, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In .NET, there are multiple subtypes of `Stream`, including `FileStream` and
    `MemoryStream`. In C# 7.0 and later, your code can more concisely branch, based
    on the subtype of stream, and declare and assign a local variable to safely use
    it. You will learn more about the `System.IO` namespace and the `Stream` type
    in *Chapter 9*, *Working with Files, Streams, and Serialization*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `case` statements can include a `when` keyword to perform more
    specific pattern matching. In the first case statement in the preceding code,
    `s` will only be a match if the stream is a `FileStream` and its `CanWrite` property
    is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying switch statements with switch expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C# 8.0 or later, you can simplify `switch` statements using **switch expressions**.
  prefs: []
  type: TYPE_NORMAL
- en: Most `switch` statements are very simple, yet they require a lot of typing.
    `switch` expressions are designed to simplify the code you need to type while
    still expressing the same intent in scenarios where all cases return a value to
    set a single variable. `switch` expressions use a lambda, `=>`, to indicate a
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the previous code that used a `switch` statement using a `switch`
    expression so that you can compare the two styles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to set the message based on what type and capabilities the
    stream has, using a `switch` expression, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The main differences are the removal of the `case` and `break` keywords. The
    underscore character `_` is used to represent the default return value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the code, and note the result is the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding iteration statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iteration statements repeat a block of statements either while a condition is
    true or for each item in a collection. The choice of which statement to use is
    based on a combination of ease of understanding to solve the logic problem and
    personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: Looping with the while statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` statement evaluates a Boolean expression and continues to loop
    while it is true. Let''s explore iteration statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `IterationStatements`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `IterationStatements` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to define a `while` statement that loops while
    an integer variable has a value less than 10, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, which should be the numbers 0 to 9, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Looping with the do statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `do` statement is like `while`, except the Boolean expression is checked
    at the bottom of the block instead of the top, which means that the block always
    executes at least once, as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to define a `do` loop, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and note that you are prompted to enter your password repeatedly
    until you enter it correctly, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As an optional challenge, add statements so that the user can only make ten
    attempts before an error message is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looping with the for statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` statement is like `while`, except that it is more succinct. It combines:'
  prefs: []
  type: TYPE_NORMAL
- en: An **initializer expression**, which executes once at the start of the loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **conditional expression**, which executes on every iteration at the start
    of the loop to check whether the looping should continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **iterator expression**, which executes on every loop at the bottom of the
    statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `for` statement is commonly used with an integer counter. Let''s explore
    some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type a `for` statement to output the numbers 1 to 10, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code to view the result, which should be the numbers 1 to 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looping with the foreach statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `foreach` statement is a bit different from the previous three iteration
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: It is used to perform a block of statements on each item in a sequence, for
    example, an array or collection. Each item is usually read-only, and if the sequence
    structure is modified during iteration, for example, by adding or removing an
    item, then an exception will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to create an array of string variables and then output the
    length of each one, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding how foreach works internally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A creator of any type that represents multiple items, like an array or collection,
    should make sure that a programmer can use the `foreach` statement to enumerate
    through the type's items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, the `foreach` statement will work on any type that follows these
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The type must have a method named `GetEnumerator` that returns an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The returned object must have a property named `Current` and a method named
    `MoveNext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `MoveNext` method must change the value of `Current` and return `true` if
    there are more items to enumerate through or return `false` if there are no more
    items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are interfaces named `IEnumerable` and `IEnumerable<T>` that formally
    define these rules, but technically the compiler does not require the type to
    implement these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler turns the `foreach` statement in the preceding example into something
    like the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Due to the use of an iterator, the variable declared in a `foreach` statement
    cannot be used to modify the value of the current item.
  prefs: []
  type: TYPE_NORMAL
- en: Casting and converting between types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will often need to convert values of variables between different types.
    For example, data input is often entered as text at the console, so it is initially
    stored in a variable of the `string` type, but it then needs to be converted into
    a date/time, or number, or some other data type, depending on how it should be
    stored and processed.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you will need to convert between number types, like between an integer
    and a floating point, before performing calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting is also known as **casting**, and it has two varieties: **implicit**
    and **explicit**. Implicit casting happens automatically, and it is safe, meaning
    that you will not lose any information.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting must be performed manually because it may lose information,
    for example, the precision of a number. By explicitly casting, you are telling
    the C# compiler that you understand and accept the risk.
  prefs: []
  type: TYPE_NORMAL
- en: Casting numbers implicitly and explicitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implicitly casting an `int` variable into a `double` variable is safe because
    no information can be lost as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `CastingConverting`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `CastingConverting` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare and assign an `int` variable and
    a `double` variable, and then implicitly cast the integer''s value when assigning
    it to the `double` variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type statements to declare and assign a `double` variable and an `int` variable,
    and then implicitly cast the `double` value when assigning it to the `int` variable,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the error message, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This error message will also appear in the Visual Studio Error List or Visual
    Studio Code PROBLEMS window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You cannot implicitly cast a `double` variable into an `int` variable because
    it is potentially unsafe and could lose data, like the value after the decimal
    point. You must explicitly cast a `double` variable into an `int` variable using
    a pair of round brackets around the type you want to cast the `double` type into.
    The pair of round brackets is the **cast operator**. Even then, you must beware
    that the part after the decimal point will be trimmed off without warning because
    you have chosen to perform an explicit cast and therefore understand the consequences.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the assignment statement for the `d` variable, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We must perform a similar operation when converting values between larger integers
    and smaller integers. Again, beware that you might lose information because any
    value too big will have its bits copied and then be interpreted in ways that you
    might not expect!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter statements to declare and assign a long 64-bit variable to an int 32-bit
    variable, both using a small value that will work and a too-large value that will
    not, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the value of `e` to 5 billion, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Converting with the System.Convert type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to using the cast operator is to use the `System.Convert` type.
    The `System.Convert` type can convert to and from all the C# number types, as
    well as Booleans, strings, and date and time values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code to see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, statically import the `System.Convert` class, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, type statements to declare and assign a value
    to a `double` variable, convert it to an integer, and then write both values to
    the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One difference between casting and converting is that converting rounds the
    `double` value `9.8` up to `10` instead of trimming the part after the decimal
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now seen that the cast operator trims the decimal part of a real number
    and that the `System.Convert` methods round up or down. However, what is the rule
    for rounding?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the default rounding rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In British primary schools for children aged 5 to 11, pupils are taught to round
    *up* if the decimal part is .5 or higher and round *down* if the decimal part
    is less.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore if C# follows the same primary school rule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare and assign an array of `double` values, convert
    each of them to an integer, and then write the result to the console, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have shown that the rule for rounding in C# is subtly different from the
    primary school rule:'
  prefs: []
  type: TYPE_NORMAL
- en: It always rounds *down* if the decimal part is less than the midpoint .5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It always rounds *up* if the decimal part is more than the midpoint .5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will round *up* if the decimal part is the midpoint .5 and the non-decimal
    part is *odd*, but it will round *down* if the non-decimal part is *even*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This rule is known as **Banker's Rounding**, and it is preferred because it
    reduces bias by alternating when it rounds up or down. Sadly, other languages
    such as JavaScript use the primary school rule.
  prefs: []
  type: TYPE_NORMAL
- en: Taking control of rounding rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can take control of the rounding rules by using the `Round` method of the
    `Math` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to round each of the `double` values using the "away from zero"
    rounding rule, also known as rounding "up," and then write the result to the console,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: For every programming language that you use, check its rounding
    rules. They may not work the way you expect!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Converting from any type to a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common conversion is from any type into a `string` variable for outputting
    as human-readable text, so all types have a method named `ToString` that they
    inherit from the `System.Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `ToString` method converts the current value of any variable into a textual
    representation. Some types can't be sensibly represented as text, so they return
    their namespace and type name instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert some types into a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare some variables, convert them to their `string` representation,
    and write them to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Converting from a binary object to a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a binary object like an image or video that you want to either
    store or transmit, you sometimes do not want to send the raw bits because you
    do not know how those bits could be misinterpreted, for example, by the network
    protocol transmitting them or another operating system that is reading the store
    binary object.
  prefs: []
  type: TYPE_NORMAL
- en: The safest thing to do is to convert the binary object into a `string` of safe
    characters. Programmers call this **Base64** encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Convert` type has a pair of methods, `ToBase64String` and `FromBase64String`,
    that perform this conversion for you. Let''s see them in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to create an array of bytes randomly populated with byte values,
    write each byte nicely formatted to the console, and then write the same bytes
    converted to Base64 to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, an `int` value would output assuming decimal notation, that is,
    base10\. You can use format codes such as `:X` to format the value using hexadecimal
    notation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Parsing from strings to numbers or dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second most common conversion is from strings to numbers or date and time
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of `ToString` is `Parse`. Only a few types have a `Parse` method,
    including all the number types and `DateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see `Parse` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to parse an integer and a date and time value from strings
    and then write the result to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By default, a date and time value outputs with the short date and time format.
    You can use format codes such as `D` to output only the date part using the long
    date format.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Good Practice**: Use the standard date and time format specifiers, as shown
    at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Errors using Parse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One problem with the `Parse` method is that it gives errors if the `string`
    cannot be converted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type a statement to attempt to parse a string containing letters into an integer
    variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As well as the preceding exception message, you will see a stack trace. I have
    not included stack traces in this book because they take up too much space.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding exceptions using the TryParse method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid errors, you can use the `TryParse` method instead. `TryParse` attempts
    to convert the input `string` and returns `true` if it can convert it and `false`
    if it cannot.
  prefs: []
  type: TYPE_NORMAL
- en: The `out` keyword is required to allow the `TryParse` method to set the count
    variable when the conversion works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see `TryParse` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `int` `count` declaration with statements to use the `TryParse`
    method and ask the user to input a count for a number of eggs, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `12`, and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `twelve` (or change the `string` value to `"twelve"` in
    a notebook), and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also use methods of the `System.Convert` type to convert `string` values
    into other types; however, like the `Parse` method, it gives an error if it cannot
    convert.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've seen several scenarios where errors have occurred when converting types.
    Some languages return error codes when something goes wrong. .NET uses exceptions
    that are richer and designed only for failure reporting compared to return values
    that have multiple uses. When this happens, we say a *runtime exception has been
    thrown*.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is thrown, the thread is suspended and if the calling code
    has defined a `try-catch` statement, then it is given a chance to handle the exception.
    If the current method does not handle it, then its calling method is given a chance,
    and so on up the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, the default behavior of a console application or a .NET Interactive
    notebook is to output a message about the exception, including a stack trace,
    and then stop running the code. The application is terminated. This is better
    than allowing the code to continue executing in a potentially corrupt state. Your
    code should only catch and handle exceptions that it understands and can properly
    fix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid writing code that will throw an exception whenever
    possible, perhaps by performing `if` statement checks. Sometimes you can''t, and
    sometimes it is best to allow the exception to be caught by a higher-level component
    that is calling your code. You will learn how to do this in *Chapter 4*, *Writing,
    Debugging, and Testing Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping error-prone code in a try block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you know that a statement can cause an error, you should wrap that statement
    in a `try` block. For example, parsing from text to a number can cause an error.
    Any statements in the `catch` block will be executed only if an exception is thrown
    by a statement in the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t have to do anything inside the `catch` block. Let''s see this in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `HandlingExceptions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `HandlingExceptions` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type statements to prompt the user to enter their age and then write their
    age to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following compiler message: `Warning CS8604 Possible null
    reference argument for parameter ''s'' in ''int int.Parse(string s)''.` By default
    in new .NET 6 projects, Microsoft has enabled nullable reference types so you
    will see many more compiler warnings like this. In production code, you should
    add code to check for `null` and handle that possibility appropriately. In this
    book, I will not include these `null` checks because the code samples are not
    designed to be production quality and `null` checks everywhere will clutter the
    code and use up valuable pages. In this case, it is impossible for `input` to
    be `null` because the user must press Enter for `ReadLine` to return and that
    will return an empty `string`. You will see hundreds of more examples of potentially
    `null` variables throughout the code samples in this book. Those warnings are
    safe to ignore for the book code examples. You only need similar warnings when
    you write your own production code. You will see more about null handling in *Chapter
    6*, *Implementing Interfaces and Inheriting Classes*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This code includes two messages to indicate *before* parsing and *after* parsing
    to make clearer the flow through the code. These will be especially useful as
    the example code grows more complex.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code, enter `49`, and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `Kermit`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the code was executed, the error exception was caught and the default message
    and stack trace were not output, and the console application continued running.
    This is better than the default behavior, but it might be useful to see the type
    of error that occurred.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You should never use an empty `catch` statement like this
    in production code because it "swallows" exceptions and hides potential problems.
    You should at least log the exception if you cannot or do not want to handle it
    properly, or rethrow it so that higher-level code can decide instead. You will
    learn about logging in *Chapter 4*, *Writing, Debugging, and Testing Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Catching all exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get information about any type of exception that might occur, you can declare
    a variable of type `System.Exception` to the `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an exception variable declaration to the `catch` block and use it to write
    information about the exception to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Catching specific exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know which specific type of exception occurred, we can improve
    our code by catching just that type of exception and customizing the message that
    we display to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the existing `catch` block, and above it, add a new `catch` block for
    the format exception type, as shown in the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The reason we want to leave the more general catch below is that there might
    be other types of exceptions that can occur.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code, enter `9876543210`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's add another `catch` block for this type of exception.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Leave the existing `catch` blocks, and add a new `catch` block for the overflow
    exception type, as shown in the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter `9876543210`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The order in which you catch exceptions is important. The correct order is related
    to the inheritance hierarchy of the exception types. You will learn about inheritance
    in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*. However,
    don't worry too much about this—the compiler will give you build errors if you
    get exceptions in the wrong order anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid over-catching exceptions. They should often be allowed
    to propagate up the call stack to be handled at a level where more information
    is known about the circumstances that could change the logic of how they should
    be handled. You will learn about this in *Chapter 4*, *Writing, Debugging, and
    Testing Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Catching with filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also add filters to a catch statement using the `when` keyword, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Checking for overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we saw that when casting between number types, it was possible to lose
    information, for example, when casting from a `long` variable to an `int` variable.
    If the value stored in a type is too big, it will overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing overflow exceptions with the checked statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `checked` statement tells .NET to throw an exception when an overflow happens
    instead of allowing it to happen silently, which is done by default for performance
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set the initial value of an `int` variable to its maximum value minus
    one. Then, we will increment it several times, outputting its value each time.
    Once it gets above its maximum value, it overflows to its minimum value and continues
    incrementing from there. Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `CheckingForOverflow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `CheckingForOverflow` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare and assign an integer to one less
    than its maximum possible value, and then increment it and write its value to
    the console three times, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result that shows the value overflowing silently
    and wrapping around to large negative values, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s get the compiler to warn us about the overflow by wrapping the
    statements using a `checked` statement block, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result that shows the overflow being checked and
    causing an exception to be thrown, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just like any other exception, we should wrap these statements in a `try` statement
    block and display a nicer error message for the user, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Disabling compiler overflow checks with the unchecked statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous section was about the default overflow behavior at *runtime* and
    how to use the `checked` statement to change that behavior. This section is about
    *compile time* overflow behavior and how to use the `unchecked` statement to change
    that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'A related keyword is `unchecked`. This keyword switches off overflow checks
    performed by the compiler within a block of code. Let''s see how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following statement at the end of the previous statements. The compiler
    will not compile this statement because it knows it would overflow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hover your mouse pointer over the error, and note a compile-time check is shown
    as an error message, as shown in *Figure 3.1*:![Graphical user interface, text,
    application, email  Description automatically generated](img/B17442_03_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.1: A compile-time check in the PROBLEMS window'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To disable compile-time checks, wrap the statement in an `unchecked` block,
    write the value of `y` to the console, decrement it, and repeat, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Of course, it would be rare that you would want to explicitly switch off a check
    like this because it allows an overflow to occur. But perhaps you can think of
    a scenario where you might want that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into this chapter's topics.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you divide an `int` variable by `0`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you divide a `double` variable by `0`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you overflow an `int` variable, that is, set it to a value
    beyond its range?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `x = y++;` and `x = ++y;`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `break`, `continue`, and `return` when used inside
    a loop statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three parts of a `for` statement and which of them are required?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `=` and `==` operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the following statement compile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the underscore `_` represent in a `switch` expression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What interface must an object implement to be enumerated over by using the `foreach`
    statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 3.2 – Explore loops and overflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What will happen if this code executes?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Create a console application in `Chapter03` named `Exercise02` and enter the
    preceding code. Run the console application and view the output. What happens?
  prefs: []
  type: TYPE_NORMAL
- en: What code could you add (don't change any of the preceding code) to warn us
    about the problem?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.3 – Practice loops and operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**FizzBuzz** is a group word game for children to teach them about division.
    Players take turns to count incrementally, replacing any number divisible by three
    with the word *fizz*, any number divisible by five with the word *buzz*, and any
    number divisible by both with *fizzbuzz*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a console application in `Chapter03` named `Exercise03` that outputs
    a simulated FizzBuzz game counting up to 100\. The output should look something
    like *Figure 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B17442_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: A simulated FizzBuzz game output'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.4 – Practice exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console application in `Chapter03` named `Exercise04` that asks the
    user for two numbers in the range 0-255 and then divides the first number by the
    second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Write exception handlers to catch any thrown errors, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3.5 – Test your knowledge of operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are the values of `x` and `y` after the following statements execute?
  prefs: []
  type: TYPE_NORMAL
- en: 'Increment and addition operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Binary shift operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bitwise operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exercise 3.6 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn about the topics covered in this
    chapter in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you experimented with some operators, learned how to branch
    and loop, how to convert between types, and how to catch exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to learn how to reuse blocks of code by defining functions,
    how to pass values into them and get values back, and how to track down bugs in
    your code and squash them!
  prefs: []
  type: TYPE_NORMAL
