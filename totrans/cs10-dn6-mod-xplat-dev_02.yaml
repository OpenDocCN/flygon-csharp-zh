- en: '02'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '02'
- en: Speaking C#
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说C#
- en: This chapter is all about the basics of the C# programming language. Over the
    course of this chapter, you'll learn how to write statements using the grammar
    of C#, as well as being introduced to some of the common vocabulary that you will
    use every day. In addition to this, by the end of the chapter, you'll feel confident
    in knowing how to temporarily store and work with information in your computer's
    memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全是关于C#编程语言基础的。在这一章中，你将学习如何使用C#的语法编写语句，并介绍一些你每天都会用到的常用词汇。此外，到本章结束时，你将自信地知道如何暂时存储和处理计算机内存中的信息。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introducing the C# language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍C#语言
- en: Understanding C# grammar and vocabulary
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解C#语法和词汇
- en: Working with variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Exploring more about console applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨控制台应用程序
- en: Introducing the C# language
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍C#语言
- en: This part of the book is about the C# language—the grammar and vocabulary that
    you will use every day to write the source code for your applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分是关于C#语言的——你每天用来编写应用程序源代码的语法和词汇。
- en: Programming languages have many similarities to human languages, except that
    in programming languages, you can make up your own words, just like Dr. Seuss!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言与人类语言有许多相似之处，不同之处在于编程语言中，你可以创造自己的词汇，就像苏斯博士那样！
- en: 'In a book written by Dr. Seuss in 1950, *If I Ran the Zoo*, he states this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在1950年苏斯博士所著的《如果我经营动物园》一书中，他这样说道：
- en: '"And then, just to show them, I''ll sail to Ka-Troo And Bring Back an It-Kutch,
    a Preep, and a Proo, A Nerkle, a Nerd, and a Seersucker, too!"'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"然后，只是为了展示给他们看，我将航行到卡特鲁，并带回一个伊特卡奇、一个普里普、一个普鲁，一个内克尔、一个书呆子和一个条纹薄棉布！"'
- en: Understanding language versions and features
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解语言版本和特性
- en: This part of the book covers the C# programming language and is written primarily
    for beginners, so it covers the fundamental topics that all developers need to
    know, from declaring variables to storing data to how to define your own custom
    data types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分涵盖了C#编程语言，主要面向初学者，因此涵盖了所有开发者需要了解的基础主题，从声明变量到存储数据，再到如何定义自己的自定义数据类型。
- en: This book covers features of the C# language from version 1.0 up to the latest
    version 10.0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了C#语言从1.0版本到最新10.0版本的所有特性。
- en: If you already have some familiarity with older versions of C# and are excited
    to find out about the new features in the most recent versions of C#, I have made
    it easier for you to jump around by listing language versions and their important
    new features below, along with the chapter number and topic title where you can
    learn about them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经对旧版本的C#有所了解，并且对最新版本中的新特性感到兴奋，我通过列出语言版本及其重要的新特性，以及学习它们的章节号和主题标题，使你更容易跳转。
- en: C# 1.0
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 1.0
- en: C# 1.0 was released in 2002 and included all the important features of a statically
    typed object-oriented modern language, as you will see throughout *Chapters* *2*
    to *6*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C# 1.0于2002年发布，包含了静态类型、面向对象现代语言的所有重要特性，正如您将在*第2章*至*第6章*中所见。
- en: C# 2.0
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 2.0
- en: 'C# 2.0 was released in 2005 and focused on enabling strong data typing using
    generics, to improve code performance and reduce type errors, including the topics
    listed in the following table:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2.0于2005年发布，重点是使用泛型实现强类型化，以提高代码性能并减少类型错误，包括以下表格中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Nullable value types | 6 | Making a value type nullable |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 可空值类型 | 6 | 使值类型可空 |'
- en: '| Generics | 6 | Making types more reusable with generics |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 泛型 | 6 | 通过泛型使类型更可重用 |'
- en: C# 3.0
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 3.0
- en: 'C# 3.0 was released in 2007 and focused on enabling declarative coding with
    **Language INtegrated Queries** (**LINQ**) and related features like anonymous
    types and lambda expressions, including the topics listed in the following table:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3.0于2007年发布，重点是启用声明式编码，包括**语言集成查询**（**LINQ**）及相关特性，如匿名类型和lambda表达式，包括以下表格中列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Implicitly typed local variables | 2 | Inferring the type of a local variable
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 隐式类型局部变量 | 2 | 推断局部变量的类型 |'
- en: '| LINQ | 11 | All topics in *Chapter 11*, *Querying and Manipulating Data Using
    LINQ* |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| LINQ | 11 | *第11章*，*使用LINQ查询和操作数据*中的所有主题 |'
- en: C# 4.0
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 4.0
- en: 'C# 4.0 was released in 2010 and focused on improving interoperability with
    dynamic languages like F# and Python, including the topics listed in the following
    table:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: C# 4.0 于2010年发布，专注于提高与F#和Python等动态语言的互操作性，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Dynamic types | 2 | Storing dynamic types |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 动态类型 | 2 | 存储动态类型 |'
- en: '| Named/optional arguments | 5 | Optional parameters and named arguments |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 命名/可选参数 | 5 | 可选参数和命名参数 |'
- en: C# 5.0
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 5.0
- en: 'C# 5.0 was released in 2012 and focused on simplifying asynchronous operation
    support by automatically implementing complex state machines while writing what
    looks like synchronous statements, including the topics listed in the following
    table:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5.0 于2012年发布，专注于通过自动实现复杂的状态机来简化异步操作支持，同时编写看似同步的语句，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Simplified asynchronous tasks | 12 | Understanding async and await |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 简化的异步任务 | 12 | 理解异步和等待 |'
- en: C# 6.0
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 6.0
- en: 'C# 6.0 was released in 2015 and focused on minor refinements to the language,
    including the topics listed in the following table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6.0 于2015年发布，专注于对语言进行小幅优化，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| `static` imports | 2 | Simplifying the usage of the console |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `static` 导入 | 2 | 简化控制台使用 |'
- en: '| Interpolated strings | 2 | Displaying output to the user |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 内插字符串 | 2 | 向用户显示输出 |'
- en: '| Expression bodied members | 5 | Defining read-only properties |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 表达式主体成员 | 5 | 定义只读属性 |'
- en: C# 7.0
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.0
- en: 'C# 7.0 was released in March 2017 and focused on adding functional language
    features like tuples and pattern matching, as well as minor refinements to the
    language, including the topics listed in the following table:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0 于2017年3月发布，专注于添加元组和模式匹配等函数式语言特性，以及对语言进行小幅优化，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Binary literals and digit separators | 2 | Storing whole numbers |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 二进制字面量和数字分隔符 | 2 | 存储整数 |'
- en: '| Pattern matching | 3 | Pattern matching with the `if` statement |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 模式匹配 | 3 | 使用`if`语句进行模式匹配 |'
- en: '| `out` variables | 5 | Controlling how parameters are passed |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `out` 变量 | 5 | 控制参数传递方式 |'
- en: '| Tuples | 5 | Combining multiple values with tuples |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 元组 | 5 | 使用元组组合多个值 |'
- en: '| Local functions | 6 | Defining local functions |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 局部函数 | 6 | 定义局部函数 |'
- en: C# 7.1
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.1
- en: 'C# 7.1 was released in August 2017 and focused on minor refinements to the
    language, including the topics listed in the following table:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.1 于2017年8月发布，专注于对语言进行小幅优化，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Default literal expressions | 5 | Setting fields with default literal |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 默认字面量表达式 | 5 | 使用默认字面量设置字段 |'
- en: '| Inferred tuple element names | 5 | Inferring tuple names |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 推断元组元素名称 | 5 | 推断元组名称 |'
- en: '| `async` Main | 12 | Improving responsiveness for console apps |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `async` 主方法 | 12 | 提高控制台应用的响应性 |'
- en: C# 7.2
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.2
- en: 'C# 7.2 was released in November 2017 and focused on minor refinements to the
    language, including the topics listed in the following table:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.2 于2017年11月发布，专注于对语言进行小幅优化，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Leading underscores in numeric literals | 2 | Storing whole numbers |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 数值字面量中的前导下划线 | 2 | 存储整数 |'
- en: '| Non-trailing named arguments | 5 | Optional parameters and named arguments
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 非尾随命名参数 | 5 | 可选参数和命名参数 |'
- en: '| `private protected` access modifier | 5 | Understanding access modifiers
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `private protected` 访问修饰符 | 5 | 理解访问修饰符 |'
- en: '| You can test `==` and `!=` with tuple types | 5 | Comparing tuples |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 可对元组类型进行`==`和`!=`测试 | 5 | 元组比较 |'
- en: C# 7.3
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 7.3
- en: C# 7.3 was released in May 2018 and focused on performance-oriented safe code
    that improves `ref` variables, pointers, and `stackalloc`. These are advanced
    and rarely needed for most developers, so they are not covered in this book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.3 于2018年5月发布，专注于提高`ref`变量、指针和`stackalloc`的性能导向安全代码。这些特性对于大多数开发者来说较为高级且不常用，因此本书未涉及。
- en: C# 8
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 8
- en: 'C# 8 was released in September 2019 and focused on a major change to the language
    related to null handling, including the topics listed in the following table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 于2019年9月发布，专注于与空处理相关的主要语言变更，包括下表所列主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Nullable reference types | 6 | Making a reference type nullable |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 可空引用类型 | 6 | 使引用类型可空 |'
- en: '| Switch expressions | 3 | Simplifying `switch` statements with switch expressions
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 开关表达式 | 3 | 使用开关表达式简化`switch`语句 |'
- en: '| Default interface methods | 6 | Understanding default interface methods |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 默认接口方法 | 6 | 理解默认接口方法 |'
- en: C# 9
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 9
- en: 'C# 9 was released in November 2020 and focused on record types, refinements
    to pattern matching, and minimal-code console apps, including the topics listed
    in the following table:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C# 9于2020年11月发布，专注于记录类型、模式匹配的改进以及最小代码控制台应用，包括下表列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Minimal-code console apps | 1 | Top-level programs |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 最小代码控制台应用 | 1 | 顶层程序 |'
- en: '| Target-typed new | 2 | Using target-typed new to instantiate objects |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 目标类型的新 | 2 | 使用目标类型的新实例化对象 |'
- en: '| Enhanced pattern matching | 5 | Pattern matching with objects |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 增强的模式匹配 | 5 | 对象的模式匹配 |'
- en: '| Records | 5 | Working with records |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 记录 | 5 | 使用记录 |'
- en: C# 10
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C# 10
- en: 'C# 10 was released in November 2021 and focused on features that minimize the
    amount of code needed in common scenarios, including the topics listed in the
    following table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10于2021年11月发布，专注于减少常见场景中所需代码量的特性，包括下表列出的主题：
- en: '| Feature | Chapter | Topic |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 章节 | 主题 |'
- en: '| Global namespace imports | 2 | Importing namespaces |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 全局命名空间导入 | 2 | 导入命名空间 |'
- en: '| Constant string literals | 2 | Formatting using interpolated strings |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 常量字符串字面量 | 2 | 使用插值字符串格式化 |'
- en: '| File-scoped namespaces | 5 | Simplifying namespace declarations |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 文件作用域命名空间 | 5 | 简化命名空间声明 |'
- en: '| Required properties | 5 | Requiring properties to be set during instantiation
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 必需属性 | 5 | 实例化时要求属性设置 |'
- en: '| Record structs | 6 | Working with record struct types |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 记录结构 | 6 | 使用记录结构类型 |'
- en: '| Null parameter checks | 6 | Checking for null in method parameters |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 空参数检查 | 6 | 方法参数中的空值检查 |'
- en: Understanding C# standards
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C#标准
- en: 'Over the years, Microsoft has submitted a few versions of C# to standards bodies,
    as shown in the following table:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，微软已向标准机构提交了几个版本的C#，如下表所示：
- en: '| C# version | ECMA standard | ISO/IEC standard |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| C#版本 | ECMA标准 | ISO/IEC标准 |'
- en: '| 1.0 | ECMA-334:2003 | ISO/IEC 23270:2003 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | ECMA-334:2003 | ISO/IEC 23270:2003 |'
- en: '| 2.0 | ECMA-334:2006 | ISO/IEC 23270:2006 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 2.0 | ECMA-334:2006 | ISO/IEC 23270:2006 |'
- en: '| 5.0 | ECMA-334:2017 | ISO/IEC 23270:2018 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 5.0 | ECMA-334:2017 | ISO/IEC 23270:2018 |'
- en: The standard for C# 6 is still a draft and work on adding C# 7 features is progressing.
    Microsoft made C# open source in 2014.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6的标准仍处于草案阶段，而添加C# 7特性的工作正在推进中。微软于2014年将C#开源。
- en: 'There are currently three public GitHub repositories for making the work on
    C# and related technologies as open as possible, as shown in the following table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，为了尽可能开放地进行C#及相关技术的工作，有三个公开的GitHub仓库，如下表所示：
- en: '| Description | Link |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | 链接 |'
- en: '| C# language design | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| C#语言设计 | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    |'
- en: '| Compiler implementation | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 编译器实现 | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)
    |'
- en: '| Standard to describe the language | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard)
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 描述语言的标准 | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard)
    |'
- en: Discovering your C# compiler versions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现您的C#编译器版本
- en: '.NET language compilers for C# and Visual Basic, also known as Roslyn, along
    with a separate compiler for F#, are distributed as part of the .NET SDK. To use
    a specific version of C#, you must have at least that version of the .NET SDK
    installed, as shown in the following table:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: .NET语言编译器，包括C#和Visual Basic（也称为Roslyn），以及一个独立的F#编译器，作为.NET SDK的一部分分发。要使用特定版本的C#，您必须安装至少该版本的.NET
    SDK，如下表所示：
- en: '| .NET SDK | Roslyn compiler | Default C# language |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| .NET SDK | Roslyn编译器 | 默认C#语言 |'
- en: '| 1.0.4 | 2.0 - 2.2 | 7.0 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 1.0.4 | 2.0 - 2.2 | 7.0 |'
- en: '| 1.1.4 | 2.3 - 2.4 | 7.1 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 1.1.4 | 2.3 - 2.4 | 7.1 |'
- en: '| 2.1.2 | 2.6 - 2.7 | 7.2 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 2.1.2 | 2.6 - 2.7 | 7.2 |'
- en: '| 2.1.200 | 2.8 - 2.10 | 7.3 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 2.1.200 | 2.8 - 2.10 | 7.3 |'
- en: '| 3.0 | 3.0 - 3.4 | 8.0 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 3.0 | 3.0 - 3.4 | 8.0 |'
- en: '| 5.0 | 3.8 | 9.0 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 5.0 | 3.8 | 9.0 |'
- en: '| 6.0 | 3.9 - 3.10 | 10.0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 6.0 | 3.9 - 3.10 | 10.0 |'
- en: 'When you create class libraries then you can choose to target .NET Standard
    as well as versions of modern .NET. They have default C# language versions, as
    shown in the following table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建类库时，可以选择面向.NET Standard以及现代.NET的版本。它们有默认的C#语言版本，如下表所示：
- en: '| .NET Standard | C# |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| .NET Standard | C# |'
- en: '| 2.0 | 7.3 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 2.0 | 7.3 |'
- en: '| 2.1 | 8.0 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 2.1 | 8.0 |'
- en: How to output the SDK version
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何输出SDK版本
- en: 'Let''s see what .NET SDK and C# language compiler versions you have available:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您可用的.NET SDK和C#语言编译器版本：
- en: On macOS, start **Terminal**. On Windows, start **Command Prompt**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在macOS上，启动 **终端**。在Windows上，启动 **命令提示符**。
- en: 'To determine which version of the .NET SDK you have available, enter the following
    command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确定您可用的.NET SDK版本，请输入以下命令：
- en: '[PRE0]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note the version at the time of writing is 6.0.100, indicating that it is the
    initial version of the SDK without any bug fixes or new features yet, as shown
    in the following output:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，撰写本文时的版本是6.0.100，表明这是SDK的初始版本，尚未有任何错误修复或新功能，如下输出所示：
- en: '[PRE1]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Enabling a specific language version compiler
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用特定语言版本编译器
- en: 'Developer tools like Visual Studio and the `dotnet` command-line interface
    assume that you want to use the latest major version of a C# language compiler
    by default. Before C# 8.0 was released, C# 7.0 was the latest major version and
    was used by default. To use the improvements in a C# point release like 7.1, 7.2,
    or 7.3, you had to add a `<LangVersion>` configuration element to the project
    file, as shown in the following markup:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像Visual Studio和 `dotnet` 命令行接口这样的开发工具默认假设您想使用C#语言编译器的最新主版本。在C# 8.0发布之前，C# 7.0是默认使用的最新主版本。要使用C#点版本（如7.1、7.2或7.3）的改进，您必须在项目文件中添加
    `<LangVersion>` 配置元素，如下所示：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the release of C# 10.0 with .NET 6.0, if Microsoft releases a C# 10.1
    compiler and you want to use its new language features then you will have to add
    a configuration element to your project file, as shown in the following markup:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10.0随.NET 6.0发布后，如果微软发布了C# 10.1编译器，并且您想使用其新语言特性，则必须在项目文件中添加配置元素，如下所示：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Potential values for the `<LangVersion>` are shown in the following table:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了 `<LangVersion>` 的可能值：
- en: '| LangVersion | Description |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| LangVersion | 描述 |'
- en: '| 7, 7.1, 7.2, 7.38, 9, 10 | Entering a specific version number will use that
    compiler if it has been installed. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 7, 7.1, 7.2, 7.38, 9, 10 | 输入特定版本号将使用已安装的该编译器。 |'
- en: '| latestmajor | Uses the highest major number, for example, 7.0 in August 2019,
    8.0 in October 2019, 9.0 in November 2020, 10.0 in November 2021. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| latestmajor | 使用最高的主版本号，例如，2019年8月的7.0，2019年10月的8.0，2020年11月的9.0，2021年11月的10.0。
    |'
- en: '| `latest` | Uses the highest major and highest minor number, for example,
    7.2 in 2017, 7.3 in 2018, 8 in 2019, perhaps 10.1 in early 2022. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `latest` | 使用最高的主版本和次版本号，例如，2017年的7.2，2018年的7.3，2019年的8，以及2022年初可能的10.1。
    |'
- en: '| `preview` | Uses the highest available preview version, for example, 10.0
    in July 2021 with .NET 6.0 Preview 6 installed. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `preview` | 使用可用的最高预览版本，例如，2021年7月安装了.NET 6.0 Preview 6的10.0。 |'
- en: 'After creating a new project, you can edit the `.csproj` file and add the `<LangVersion>`
    element, as shown highlighted in the following markup:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新项目后，您可以编辑 `.csproj` 文件并添加 `<LangVersion>` 元素，如下所示高亮显示：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your projects must target `net6.0` to use the full features of C# 10.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目必须针对 `net6.0` 以使用C# 10的全部功能。
- en: '**Good Practice**: If you are using Visual Studio Code and you have not done
    so already, install the Visual Studio Code extension named **MSBuild project tools**.
    This will give you IntelliSense while editing `.csproj` files, including making
    it easy to add the `<LangVersion>` element with appropriate values.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您正在使用Visual Studio Code且尚未安装，请安装名为 **MSBuild项目工具** 的Visual Studio
    Code扩展。这将为您在编辑 `.csproj` 文件时提供IntelliSense，包括轻松添加带有适当值的 `<LangVersion>` 元素。'
- en: Understanding C# grammar and vocabulary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解C#语法和词汇
- en: To learn simple C# language features, you can use .NET Interactive Notebooks,
    which remove the need to create an application of any kind.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习简单的C#语言特性，您可以使用.NET交互式笔记本，这消除了创建任何类型应用程序的需要。
- en: To learn some other C# language features, you will need to create an application.
    The simplest type of application is a console application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习其他一些C#语言特性，您需要创建一个应用程序。最简单的应用程序类型是控制台应用程序。
- en: Let's start by looking at the basics of the grammar and vocabulary of C#. Throughout
    this chapter, you will create multiple console applications, with each one showing
    related features of the C# language.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从C#语法和词汇的基础开始。在本章中，您将创建多个控制台应用程序，每个都展示C#语言的相关特性。
- en: Showing the compiler version
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示编译器版本
- en: 'We will start by writing code that shows the compiler version:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写显示编译器版本的代码：
- en: If you've completed *Chapter 1*, *Hello, C#! Welcome, .NET!*, then you will
    already have a `Code` folder. If not, then you'll need to create it.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经完成了*第一章*，*你好，C#！欢迎，.NET！*，那么你将已经拥有一个`Code`文件夹。如果没有，那么你需要创建它。
- en: 'Use your preferred code editor to create a new console app, as defined in the
    following list:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的代码编辑器创建一个新的控制台应用，如下表所示：
- en: 'Project template: **Console Application [C#]** / `console`'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序[C#]** / `console`
- en: 'Workspace/solution file and folder: `Chapter02`'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter02`
- en: 'Project file and folder: `Vocabulary`'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`Vocabulary`
- en: '**Good Practice**: If you have forgotten how, or did not complete the previous
    chapter, then step-by-step instructions for creating a workspace/solution with
    multiple projects are given in *Chapter 1*, *Hello, C#! Welcome, .NET!*.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：如果你忘记了如何操作，或者没有完成前一章，那么*第一章*，*你好，C#！欢迎，.NET！*中给出了创建包含多个项目的工作区/解决方案的分步说明。'
- en: 'Open the `Program.cs` file, and at the top of the file, under the comment,
    add a statement to show the C# version as an error, as shown in the following
    code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件，在注释下方，添加一个语句以显示C#版本作为错误，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the console application:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序：
- en: In Visual Studio Code, in a terminal, enter the command `dotnet run`.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在终端输入命令`dotnet run`。
- en: In Visual Studio, navigate to **Debug** | **Start Without Debugging**. When
    prompted to continue and run the last successful build, click **No**.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航到**调试** | **开始不调试**。当提示继续并运行上次成功的构建时，点击**否**。
- en: Note the compiler version and language version appear as a compiler error message
    number `CS8304`, as shown in *Figure 2.1*:![](img/B17442_02_01.png)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意编译器版本和语言版本显示为编译器错误消息编号`CS8304`，如图2.1所示：![](img/B17442_02_01.png)
- en: 'Figure 2.1: A compiler error that shows the C# language version'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.1：显示C#语言版本的编译器错误
- en: 'The error message in the Visual Studio Code **PROBLEMS** window or Visual Studio
    **Error List** window says `Compiler version: ''4.0.0...''` with language version
    `10.0`.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code的**问题**窗口或Visual Studio的**错误列表**窗口中的错误消息显示`编译器版本：'4.0.0...'`，语言版本为`10.0`。
- en: 'Comment out the statement that causes the error, as shown in the following
    code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉导致错误的语句，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the compiler error messages disappear.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意编译器错误消息消失了。
- en: Understanding C# grammar
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C#语法
- en: The grammar of C# includes statements and blocks. To document your code, you
    can use comments.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C#的语法包括语句和块。要记录你的代码，你可以使用注释。
- en: '**Good Practice**: Comments should not be the only way that you document your
    code. Choosing sensible names for variables and functions, writing unit tests,
    and creating actual documents are other ways to document your code.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：注释不应该是你唯一用来记录代码的方式。为变量和函数选择合理的名称、编写单元测试以及创建实际文档是其他记录代码的方式。'
- en: Statements
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: In English, we indicate the end of a sentence with a full stop. A sentence can
    be composed of multiple words and phrases, with the order of words being part
    of the grammar. For example, in English, we say "the black cat."
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们用句号表示句子的结束。一个句子可以由多个单词和短语组成，单词的顺序是语法的一部分。例如，在英语中，我们说“the black cat”。
- en: 'The adjective, *black*, comes before the noun, *cat*. Whereas French grammar
    has a different order; the adjective comes after the noun: "le chat noir." What''s
    important to take away from this is that the order matters.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 形容词*black*位于名词*cat*之前。而法语语法则不同；形容词位于名词之后：“le chat noir”。重要的是要记住，顺序很重要。
- en: 'C# indicates the end of a **statement** with a semicolon. A statement can be
    composed of multiple **variables** and **expressions**. For example, in the following
    statement, `totalPrice` is a variable and `subtotal + salesTax` is an expression:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C#使用分号表示**语句**的结束。一个语句可以由多个**变量**和**表达式**组成。例如，在以下语句中，`totalPrice`是一个变量，`subtotal
    + salesTax`是一个表达式：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The expression is made up of an operand named `subtotal`, an operator `+`, and
    another operand named `salesTax`. The order of operands and operators matters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式由一个名为`subtotal`的操作数、一个运算符`+`和另一个名为`salesTax`的操作数组成。操作数和运算符的顺序很重要。
- en: Comments
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'When writing your code, you''re able to add comments to explain your code using
    a double slash, `//`. By inserting `//` the compiler will ignore everything after
    the `//` until the end of the line, as shown in the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码时，你可以使用双斜杠`//`添加注释来解释你的代码。通过插入`//`，编译器将忽略`//`之后的所有内容，直到该行结束，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To write a multiline comment, use `/*` at the beginning and `*/` at the end
    of the comment, as shown in the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写多行注释，请在注释的开头使用`/*`，在结尾使用`*/`，如下列代码所示：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Good Practice**: Well-designed code, including function signatures with well-named
    parameters and class encapsulation, can be somewhat self-documenting. When you
    find yourself putting too many comments and explanations in your code, ask yourself:
    can I rewrite, aka refactor, this code to make it more understandable without
    long comments?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：设计良好的代码，包括具有良好命名参数的函数签名和类封装，可以一定程度上自我说明。当你发现自己需要在代码中添加过多注释和解释时，问问自己：我能否通过重写（即重构）这段代码，使其在不依赖长篇注释的情况下更易于理解？'
- en: 'Your code editor has commands to make it easier to add and remove comment characters,
    as shown in the following list:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码编辑器具有命令，使得添加和删除注释字符更加容易，如下表所示：
- en: '**Visual Studio 2022 for Windows**: Navigate to **Edit** | **Advanced** | **Comment
    Selection** or **Uncomment Selection**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 版 Visual Studio 2022**：导航至**编辑** | **高级** | **注释选择** 或 **取消注释选择**'
- en: '**Visual Studio Code**: Navigate to **Edit** | **Toggle Line Comment** or **Toggle
    Block Comment**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：导航至**编辑** | **切换行注释** 或 **切换块注释**'
- en: '**Good Practice**: You **comment** code by adding descriptive text above or
    after code statements. You **comment out** code by adding comment characters before
    or around statements to make them inactive. **Uncommenting** means removing the
    comment characters.'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：您通过在代码语句上方或后方添加描述性文本来**注释**代码。您通过在语句前或周围添加注释字符来**注释掉**代码，使其失效。**取消注释**意味着移除注释字符。'
- en: Blocks
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块
- en: In English, we indicate a new paragraph by starting a new line. C# indicates
    a **block** of code with the use of curly brackets, `{ }`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，我们通过换行来表示新段落的开始。C# 使用花括号`{ }`来表示**代码块**。
- en: Blocks start with a declaration to indicate what is being defined. For example,
    a block can define the start and end of many language constructs including namespaces,
    classes, methods, or statements like `foreach`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 块以声明开始，用以指示定义的内容。例如，一个块可以定义包括命名空间、类、方法或`foreach`等语句在内的多种语言结构的开始和结束。
- en: 'You will learn more about namespaces, classes, and methods later in this chapter
    and subsequent chapters but to briefly introduce some of those concepts now:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章及后续章节中了解更多关于命名空间、类和方法的知识，但现在简要介绍一些概念：
- en: A **namespace** contains types like classes to group them together.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**包含类等类型，用于将它们组合在一起。'
- en: A **class** contains the members of an object including methods.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**包含对象的成员，包括方法。'
- en: A **method** contains statements that implement an action that an object can
    take.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**包含实现对象可执行动作的语句。'
- en: Examples of statements and blocks
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句和块的示例
- en: 'In the project template for console apps when targeting .NET 5.0, note that
    examples of the grammar of C# have been written for you by the project template.
    I''ve added some comments to the statements and blocks, as shown in the following
    code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向 .NET 5.0 的控制台应用程序项目模板中，请注意，项目模板已为您编写了 C# 语法的示例。我已对语句和块添加了一些注释，如下列代码所示：
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Understanding C# vocabulary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 C# 词汇
- en: The C# vocabulary is made up of **keywords**, **symbol characters**, and **types**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: C# 词汇由**关键字**、**符号字符**和**类型**组成。
- en: Some of the predefined, reserved keywords that you will see in this book include
    `using`, `namespace`, `class`, `static`, `int`, `string`, `double`, `bool`, `if`,
    `switch`, `break`, `while`, `do`, `for`, `foreach`, `and`, `or`, `not`, `record`,
    and `init`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中您将看到的一些预定义保留关键字包括`using`、`namespace`、`class`、`static`、`int`、`string`、`double`、`bool`、`if`、`switch`、`break`、`while`、`do`、`for`、`foreach`、`and`、`or`、`not`、`record`和`init`。
- en: Some of the symbol characters that you will see include `"`, `'`, `+`, `-`,
    `*`, `/`, `%`, `@`, and `$`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到的一些符号字符包括`"`, `'`, `+`, `-`, `*`, `/`, `%`, `@`, 和 `$`。
- en: There are other contextual keywords that only have a special meaning in a specific
    context.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他只在特定上下文中具有特殊意义的上下文关键字。
- en: However, that still means that there are only about 100 actual C# keywords in
    the language.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然意味着 C# 语言中只有大约 100 个实际的关键字。
- en: Comparing programming languages to human languages
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将编程语言与人类语言进行比较
- en: The English language has more than 250,000 distinct words, so how does C# get
    away with only having about 100 keywords? Moreover, why is C# so difficult to
    learn if it has only 0.0416% of the number of words in the English language?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 英语有超过25万个不同的单词，那么C#是如何仅用大约100个关键字就做到的呢？此外，如果C#只有英语单词数量的0.0416%，为什么它还这么难学呢？
- en: One of the key differences between a human language and a programming language
    is that developers need to be able to define the new "words" with new meanings.
    Apart from the about 100 keywords in the C# language, this book will teach you
    about some of the hundreds of thousands of "words" that other developers have
    defined, but you will also learn how to define your own "words."
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 人类语言和编程语言之间的一个关键区别是，开发者需要能够定义具有新含义的新“单词”。除了C#语言中的大约100个关键字外，本书还将教你了解其他开发者定义的数十万个“单词”，同时你还将学习如何定义自己的“单词”。
- en: 'Programmers all over the world must learn English because most programming
    languages use English words such as namespace and class. There are programming
    languages that use other human languages, such as Arabic, but they are rare. If
    you are interested in learning more, this YouTube video shows a demonstration
    of an Arabic programming language: [https://youtu.be/dkO8cdwf6v8](https://youtu.be/dkO8cdwf6v8).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地的程序员都必须学习英语，因为大多数编程语言使用英语单词，如namespace和class。有些编程语言使用其他人类语言，如阿拉伯语，但这些语言较为罕见。如果你对此感兴趣，这个YouTube视频展示了一种阿拉伯编程语言的演示：[https://youtu.be/dkO8cdwf6v8](https://youtu.be/dkO8cdwf6v8)。
- en: Changing the color scheme for C# syntax
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改C#语法的颜色方案
- en: 'By default, Visual Studio Code and Visual Studio show C# keywords in blue to
    make them easier to differentiate from other code. Both tools allow you to customize
    the color scheme:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Visual Studio Code和Visual Studio将C#关键字显示为蓝色，以便更容易与其他代码区分开来。这两个工具都允许您自定义颜色方案：
- en: In Visual Studio Code, navigate to **Code** | **Preferences** | **Color Theme**
    (it is on the **File** menu on Windows).
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，导航至**代码** | **首选项** | **颜色主题**（在Windows上的**文件**菜单中）。
- en: Select a color theme. For reference, I'll use the **Light+ (default light)**
    color theme so that the screenshots look good in a printed book.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个颜色主题。作为参考，我将使用**Light+（默认浅色）**颜色主题，以便截图在印刷书籍中看起来效果良好。
- en: In Visual Studio, navigate to **Tools** | **Options**.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航至**工具** | **选项**。
- en: In the **Options** dialog box, select **Fonts and Colors**, and then select
    the display items that you would like to customize.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**选项**对话框中，选择**字体和颜色**，然后选择您希望自定义的显示项。
- en: Help for writing correct code
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帮助编写正确的代码
- en: Plain text editors such as Notepad don't help you write correct English. Likewise,
    Notepad won't help you write correct C# either.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 像记事本这样的纯文本编辑器不会帮助你书写正确的英语。同样，记事本也不会帮助你编写正确的C#代码。
- en: Microsoft Word can help you write English by highlighting spelling mistakes
    with red squiggles, with Word saying that "icecream" should be ice-cream or ice
    cream, and grammatical errors with blue squiggles, such as a sentence should have
    an uppercase first letter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Word可以通过用红色波浪线标记拼写错误来帮助你书写英语，例如Word会提示"icecream"应为ice-cream或ice cream，并用蓝色波浪线标记语法错误，例如句子应以大写字母开头。
- en: Similarly, Visual Studio Code's C# extension and Visual Studio help you write
    C# code by highlighting spelling mistakes, such as the method name should be `WriteLine`
    with an uppercase L, and grammatical errors, such as statements that must end
    with a semicolon.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Visual Studio Code的C#扩展程序和Visual Studio通过标记拼写错误（例如方法名应为`WriteLine`，其中L为大写）和语法错误（例如语句必须以分号结尾）来帮助你编写C#代码。
- en: The C# extension constantly watches what you type and gives you feedback by
    highlighting problems with colored squiggly lines, similar to that of Microsoft
    Word.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: C#扩展程序会不断监视你输入的内容，并通过用彩色波浪线标记问题来给予你反馈，类似于Microsoft Word。
- en: 'Let''s see it in action:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的实际应用：
- en: In `Program.cs`, change the `L` in the `WriteLine` method to lowercase.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，将`WriteLine`方法中的`L`改为小写。
- en: Delete the semicolon at the end of the statement.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除语句末尾的分号。
- en: In Visual Studio Code, navigate to **View** | **Problems**, or in Visual Studio
    navigate to **View** | **Error List**, and note that a red squiggle appears under
    the code mistakes and details are shown, as you can see in *Figure 2.2*:![](img/B17442_02_02.png)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，导航至**视图** | **问题**，或在Visual Studio中导航至**视图** | **错误列表**，并注意代码错误下方会出现红色波浪线，并且会显示详细信息，如*图2.2*所示：![](img/B17442_02_02.png)
- en: 'Figure 2.2: The Error List window showing two compile errors'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.2：错误列表窗口显示两个编译错误
- en: Fix the two coding errors.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复这两个编码错误。
- en: Importing namespaces
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命名空间
- en: '`System` is a namespace, which is like an address for a type. To refer to someone''s
    location exactly, you might use `Oxford.HighStreet.BobSmith`, which tells us to
    look for a person named Bob Smith on the High Street in the city of Oxford.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`System`是一个命名空间，类似于类型的地址。为了精确地引用某人的位置，您可能会使用`Oxford.HighStreet.BobSmith`，这告诉我们需要在牛津市的高街上寻找一个名叫Bob
    Smith的人。'
- en: '`System.Console.WriteLine` tells the compiler to look for a method named `WriteLine`
    in a type named `Console` in a namespace named `System`. To simplify our code,
    the **Console Application** project template for every version of .NET before
    6.0 added a statement at the top of the code file to tell the compiler to always
    look in the `System` namespace for types that haven''t been prefixed with their
    namespace, as shown in the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Console.WriteLine`指示编译器在一个名为`Console`的类型中查找名为`WriteLine`的方法，该类型位于名为`System`的命名空间中。为了简化我们的代码，在.NET
    6.0之前的每个版本的**控制台应用程序**项目模板中，都会在代码文件顶部添加一个语句，告诉编译器始终在`System`命名空间中查找未带命名空间前缀的类型，如下列代码所示：'
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We call this *importing the namespace*. The effect of importing a namespace
    is that all available types in that namespace will be available to your program
    without needing to enter the namespace prefix and will be seen in IntelliSense
    while you write code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为*导入命名空间*。导入命名空间的效果是，该命名空间中的所有可用类型将无需输入命名空间前缀即可供您的程序使用，并在编写代码时在IntelliSense中可见。
- en: .NET Interactive notebooks have most namespaces imported automatically.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Interactive笔记本会自动导入大多数命名空间。
- en: Implicitly and globally importing namespaces
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式和全局导入命名空间
- en: 'Traditionally, every `.cs` file that needs to import namespaces would have
    to start with `using` statements to import those namespaces. Namespaces like `System`
    and `System.Linq` are needed in almost all `.cs` files, so the first few lines
    of every `.cs` file often had at least a few `using` statements, as shown in the
    following code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，每个需要导入命名空间的`.cs`文件都必须以`using`语句开始导入那些命名空间。几乎所有`.cs`文件都需要命名空间，如`System`和`System.Linq`，因此每个`.cs`文件的前几行通常至少包含几个`using`语句，如下列代码所示：
- en: '[PRE12]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When creating websites and services using ASP.NET Core, there are often dozens
    of namespaces that each file would have to import.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ASP.NET Core创建网站和服务时，每个文件通常需要导入数十个命名空间。
- en: C# 10 introduces some new features that simplify importing namespaces.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10引入了一些简化导入命名空间的新特性。
- en: 'First, the `global using` statement means you only need to import a namespace
    in one `.cs` file and it will be available throughout all `.cs` files. You could
    put `global using` statements in the `Program.cs` file but I recommend creating
    a separate file for those statements named something like `GlobalUsings.cs` or
    `GlobalNamespaces.cs`, as shown in the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`global using`语句意味着您只需在一个`.cs`文件中导入一个命名空间，它将在所有`.cs`文件中可用。您可以将`global using`语句放在`Program.cs`文件中，但我建议为这些语句创建一个单独的文件，命名为类似`GlobalUsings.cs`或`GlobalNamespaces.cs`，如下列代码所示：
- en: '[PRE13]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Good Practice**: As developers get used to this new C# feature, I expect
    one naming convention for this file to become the standard.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：随着开发者逐渐习惯这一新的C#特性，我预计该文件的一种命名约定将成为标准。'
- en: 'Second, any projects that target .NET 6.0 and therefore use the C# 10 compiler
    generate a`.cs` file in the `obj` folder to implicitly globally import some common
    namespaces like `System`. The specific list of implicitly imported namespaces
    depends on which SDK you target, as shown in the following table:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，任何面向.NET 6.0的项目，因此使用C# 10编译器，会在`obj`文件夹中生成一个`.cs`文件，以隐式全局导入一些常见命名空间，如`System`。隐式导入的命名空间列表取决于您所针对的SDK，如下表所示：
- en: '| SDK | Implicitly imported namespaces |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| SDK | 隐式导入的命名空间 |'
- en: '| `Microsoft.NET.Sdk` | `System``System.Collections.Generic``System.IO``System.Linq``System.Net.Http``System.Threading``System.Threading.Tasks`
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk` | `System``System.Collections.Generic``System.IO``System.Linq``System.Net.Http``System.Threading``System.Threading.Tasks`
    |'
- en: '| `Microsoft.NET.Sdk.Web` | Same as `Microsoft.NET.Sdk` and:`System.Net.Http.Json``Microsoft.AspNetCore.Builder``Microsoft.AspNetCore.Hosting``Microsoft.AspNetCore.Http``Microsoft.AspNetCore.Routing``Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk.Web` | 与`Microsoft.NET.Sdk`相同，并包括：`System.Net.Http.Json``Microsoft.AspNetCore.Builder``Microsoft.AspNetCore.Hosting``Microsoft.AspNetCore.Http``Microsoft.AspNetCore.Routing``Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
- en: '| `Microsoft.NET.Sdk.Worker` | Same as `Microsoft.NET.Sdk` and:`Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.NET.Sdk.Worker` | 与`Microsoft.NET.Sdk`相同，并包括：`Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
- en: 'Let''s see the current auto-generated implicit imports file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前自动生成的隐式导入文件：
- en: In **Solution Explorer**, select the `Vocabulary` project, toggle on the **Show
    All Files** button, and note the compiler-generated `bin` and `obj` folders are
    visible.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，选择`词汇`项目，打开**显示所有文件**按钮，并注意编译器生成的`bin`和`obj`文件夹可见。
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net6.0` folder,
    and open the file named `Vocabulary.GlobalUsings.g.cs`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`obj`文件夹，展开`Debug`文件夹，展开`net6.0`文件夹，并打开名为`Vocabulary.GlobalUsings.g.cs`的文件。
- en: 'Note this file is automatically created by the compiler for projects that target
    .NET 6.0, and that it imports some commonly used namespaces including `System.Threading`,
    as shown in the following code:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意此文件是由编译器为面向.NET 6.0的项目自动创建的，并且它导入一些常用命名空间，包括`System.Threading`，如下所示的代码：
- en: '[PRE14]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Close the `Vocabulary.GlobalUsings.g.cs` file.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Vocabulary.GlobalUsings.g.cs`文件。
- en: 'In **Solution Explorer**, select the project, and then add additional entries
    to the project file to control which namespaces are implicitly imported, as shown
    highlighted in the following markup:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，选择项目，然后向项目文件添加额外的条目以控制哪些命名空间被隐式导入，如下所示高亮显示的标记：
- en: '[PRE15]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save the changes to the project file.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存对项目文件的更改。
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net6.0` folder,
    and open the file named `Vocabulary.GlobalUsings.g.cs`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`obj`文件夹，展开`Debug`文件夹，展开`net6.0`文件夹，并打开名为`Vocabulary.GlobalUsings.g.cs`的文件。
- en: 'Note this file now imports `System.Numerics` instead of `System.Threading`,
    as shown highlighted in the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意此文件现在导入`System.Numerics`而不是`System.Threading`，如下所示高亮显示的代码：
- en: '[PRE16]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Close the `Vocabulary.GlobalUsings.g.cs` file.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Vocabulary.GlobalUsings.g.cs`文件。
- en: 'You can disable the implicitly imported namespaces feature for all SDKs by
    removing an entry in the project file, as shown in the following markup:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从项目文件中删除一个条目来禁用所有SDK的隐式导入命名空间功能，如下所示的标记：
- en: '[PRE17]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Verbs are methods
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动词是方法
- en: In English, verbs are doing or action words, like run and jump. In C#, doing
    or action words are called **methods**. There are hundreds of thousands of methods
    available to C#. In English, verbs change how they are written based on when in
    time the action happens. For example, Amir *was jumping* in the past, Beth *jumps*
    in the present, they *jumped* in the past, and Charlie *will jump* in the future.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，动词是表示动作或行为的词，如跑和跳。在C#中，表示动作或行为的词被称为**方法**。C#中有数十万个方法可供使用。在英语中，动词根据动作发生的时间改变其书写方式。例如，Amir
    *过去在跳*，Beth *现在跳*，他们*过去跳*，Charlie *将来会跳*。
- en: 'In C#, methods such as `WriteLine` change how they are called or executed based
    on the specifics of the action. This is called overloading, which we''ll cover
    in more detail in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*.
    But for now, consider the following example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，像`WriteLine`这样的方法会根据具体操作的细节改变其调用或执行方式。这称为重载，我们将在*第5章*，*使用面向对象编程构建自己的类型*中详细介绍。但现在，请考虑以下示例：
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A different analogy is that some words are spelled the same but have different
    meanings depending on the context.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不同的比喻是，有些单词拼写相同，但根据上下文有不同的含义。
- en: Nouns are types, variables, fields, and properties
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名词是类型、变量、字段和属性
- en: In English, nouns are names that refer to things. For example, Fido is the name
    of a dog. The word "dog" tells us the type of thing that Fido is, and so in order
    for Fido to fetch a ball, we would use his name.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，名词是用来指代事物的名称。例如，Fido是一条狗的名字。单词“狗”告诉我们Fido是什么类型的事物，因此为了让Fido去取球，我们会使用他的名字。
- en: 'In C#, their equivalents are **types**, **variables**, **fields**, and **properties**.
    For example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，它们的等价物是**类型**、**变量**、**字段**和**属性**。例如：
- en: '`Animal` and `Car` are types; they are nouns for categorizing things.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animal`和`Car`是类型；它们是用于分类事物的名词。'
- en: '`Head` and `Engine` might be fields or properties; nouns that belong to `Animal`
    and `Car`.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Head`和`Engine`可能是字段或属性；属于`Animal`和`Car`的名词。'
- en: '`Fido` and `Bob` are variables; nouns for referring to a specific object.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fido`和`Bob`是变量；用于指代特定对象的名词。'
- en: There are tens of thousands of types available to C#, though have you noticed
    how I didn't say, "There are tens of thousands of types in C#?" The difference
    is subtle but important. The language of C# only has a few keywords for types,
    such as `string` and `int`, and strictly speaking, C# doesn't define any types.
    Keywords such as `string` that look like types are **aliases**, which represent
    types provided by the platform on which C# runs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: C#可用的类型有数以万计，尽管你注意到我没有说“C#中有数以万计的类型”吗？这种区别微妙但重要。C#语言只有几个类型的关键字，如`string`和`int`，严格来说，C#并没有定义任何类型。看起来像类型的关键字，如`string`，是**别名**，它们代表C#运行的平台上提供的类型。
- en: It's important to know that C# cannot exist alone; after all, it's a language
    that runs on variants of .NET. In theory, someone could write a compiler for C#
    that uses a different platform, with different underlying types. In practice,
    the platform for C# is .NET, which provides tens of thousands of types to C#,
    including `System.Int32`, which is the C# keyword alias `int` maps to, as well
    as many more complex types, such as `System.Xml.Linq.XDocument`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道C#不能独立存在；毕竟，它是一种运行在.NET变体上的语言。理论上，有人可以为C#编写一个使用不同平台的编译器，具有不同的底层类型。实际上，C#的平台是.NET，它为C#提供了数以万计的类型，包括`System.Int32`，这是C#关键字别名`int`映射到的，以及许多更复杂的类型，如`System.Xml.Linq.XDocument`。
- en: It's worth taking note that the term **type** is often confused with **class**.
    Have you ever played the parlor game *Twenty Questions*, also known as *Animal,
    Vegetable, or Mineral*? In the game, everything can be categorized as an animal,
    vegetable, or mineral. In C#, every **type** can be categorized as a `class`,
    `struct`, `enum`, `interface`, or `delegate`. You will learn what these mean in
    *Chapter 6*, *Implementing Interfaces and Inheriting Classes*. As examples, the
    C# keyword `string` is a `class`, but `int` is a `struct`. So, it is best to use
    the term **type** to refer to both.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，术语**类型**经常与**类**混淆。你玩过*二十个问题*这个聚会游戏吗，也称为*动物、植物或矿物*？在游戏中，一切都可以归类为动物、植物或矿物。在C#中，每个**类型**都可以归类为`class`、`struct`、`enum`、`interface`或`delegate`。您将在*第6章*，*实现接口和继承类*中学习这些含义。例如，C#关键字`string`是一个`class`，但`int`是一个`struct`。因此，最好使用术语**类型**来指代两者。
- en: Revealing the extent of the C# vocabulary
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示C#词汇的范围
- en: We know that there are more than 100 keywords in C#, but how many types are
    there? Let's write some code to find out how many types (and their methods) are
    available to C# in our simple console application.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道C#中有超过100个关键字，但有多少种类型呢？让我们编写一些代码来找出在我们的简单控制台应用程序中C#可用的类型（及其方法）的数量。
- en: 'Don''t worry exactly how this code works for now but know that it uses a technique
    called **reflection**:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不必担心这段代码是如何工作的，但要知道它使用了一种称为**反射**的技术：
- en: 'We''ll start by importing the `System.Reflection` namespace at the top of the
    `Program.cs` file, as shown in the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在`Program.cs`文件顶部导入`System.Reflection`命名空间，如下所示：
- en: '[PRE19]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Delete the statement that writes `Hello World!` and replace it with the following
    code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除写入`Hello World!`的语句，并用以下代码替换：
- en: '[PRE20]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the code. You will see the actual number of types and methods that are
    available to you in the simplest application when running on your OS. The number
    of types and methods displayed will be different depending on the operating system
    that you are using, as shown in the following outputs:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。您将看到在您的操作系统上运行最简单的应用程序时，实际可用的类型和方法的数量。显示的类型和方法的数量将根据您使用的操作系统而有所不同，如下所示：
- en: '[PRE21]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Why does the `System.Runtime` assembly contain zero types? This assembly is
    special because it contains only **type-forwarders** rather than actual types.
    A type-forwarder represents a type that has been implemented outside of .NET or
    for some other advanced reason.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么`System.Runtime`程序集中不包含任何类型？这个程序集很特殊，因为它只包含**类型转发器**而不是实际类型。类型转发器表示已在外部.NET或其他高级原因中实现的一种类型。
- en: 'Add statements to the top of the file after importing the namespace to declare
    some variables, as shown highlighted in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入命名空间后，在文件顶部添加语句以声明一些变量，如下面的代码中突出显示的那样：
- en: '[PRE22]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By declaring variables that use types in other assemblies, those assemblies
    are loaded with our application, which allows our code to see all the types and
    methods in them. The compiler will warn you that you have unused variables but
    that won't stop your code from running.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过声明使用其他程序集中的类型的变量，这些程序集会随我们的应用程序一起加载，这使得我们的代码能够看到其中的所有类型和方法。编译器会警告你有未使用的变量，但这不会阻止你的代码运行。
- en: 'Run the console application again and view the results, which should look similar
    to the following outputs:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序并查看结果，结果应该类似于以下输出：
- en: '[PRE23]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, you have a better sense of why learning C# is a challenge, because there
    are so many types and methods to learn. Methods are only one category of a member
    that a type can have, and you and other programmers are constantly defining new
    types and members!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你更清楚为什么学习C#是一项挑战，因为有如此多的类型和方法需要学习。方法仅是类型可以拥有的成员类别之一，而你和其他程序员不断定义新的类型和成员！
- en: Working with variables
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理变量
- en: All applications process data. Data comes in, data is processed, and then data
    goes out.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序都处理数据。数据进来，数据被处理，然后数据出去。
- en: Data usually comes into our program from files, databases, or user input, and
    it can be put temporarily into variables that will be stored in the memory of
    the running program. When the program ends, the data in memory is lost. Data is
    usually output to files and databases, or to the screen or a printer. When using
    variables, you should think about, firstly, how much space the variable takes
    in the memory, and, secondly, how fast it can be processed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常从文件、数据库或用户输入进入我们的程序，并可以暂时存储在变量中，这些变量将存储在运行程序的内存中。当程序结束时，内存中的数据就会丢失。数据通常输出到文件和数据库，或输出到屏幕或打印机。使用变量时，首先应考虑变量在内存中占用多少空间，其次应考虑处理速度有多快。
- en: We control this by picking an appropriate type. You can think of simple common
    types such as `int` and `double` as being different-sized storage boxes, where
    a smaller box would take less memory but may not be as fast at being processed;
    for example, adding 16-bit numbers might not be processed as fast as adding 64-bit
    numbers on a 64-bit operating system. Some of these boxes may be stacked close
    by, and some may be thrown into a big heap further away.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择适当的类型来控制这一点。你可以将`int`和`double`等简单常见类型视为不同大小的存储箱，其中较小的箱子占用较少的内存，但处理速度可能不那么快；例如，在64位操作系统上，添加16位数字可能不如添加64位数字快。其中一些箱子可能堆放在附近，而有些可能被扔进更远的堆中。
- en: Naming things and assigning values
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名事物和赋值
- en: 'There are naming conventions for things, and it is good practice to follow
    them, as shown in the following table:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 事物有命名规范，遵循这些规范是良好的实践，如下表所示：
- en: '| Naming convention | Examples | Used for |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 命名规范 | 示例 | 用途 |'
- en: '| Camel case | `cost`, `orderDetail`, `dateOfBirth` | Local variables, private
    fields |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 驼峰式 | `cost`, `orderDetail`, `dateOfBirth` | 局部变量，私有字段 |'
- en: '| Title case aka Pascal case | `String`, `Int32`, `Cost`, `DateOfBirth`, `Run`
    | Types, non-private fields, and other members like methods |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 标题式（也称为帕斯卡式） | `String`, `Int32`, `Cost`, `DateOfBirth`, `Run` | 类型，非私有字段，以及其他成员如方法
    |'
- en: '**Good Practice**: Following a consistent set of naming conventions will enable
    your code to be easily understood by other developers (and yourself in the future!).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：遵循一致的命名规范将使你的代码易于被其他开发者（以及未来的你自己）理解。'
- en: 'The following code block shows an example of declaring a named local variable
    and assigning a value to it with the `=` symbol. You should note that you can
    output the name of a variable using a keyword introduced in C# 6.0, `nameof`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块展示了一个声明命名局部变量并使用`=`符号为其赋值的示例。你应该注意到，可以使用C# 6.0引入的关键字`nameof`输出变量的名称：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The message in double quotes in the preceding code wraps onto a second line
    because the width of a printed page is too narrow. When entering a statement like
    this in your code editor, type it all in a single line.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中双引号内的消息因为打印页面的宽度太窄而换到第二行。在你的代码编辑器中输入这样的语句时，请将其全部输入在同一行。
- en: Literal values
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面值
- en: When you assign to a variable, you often, but not always, assign a **literal**
    value. But what is a literal value? A literal is a notation that represents a
    fixed value. Data types have different notations for their literal values, and
    over the next few sections, you will see examples of using literal notation to
    assign values to variables.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给变量赋值时，你通常，但并非总是，赋一个**字面**值。但什么是字面值呢？字面值是一种表示固定值的符号。数据类型有不同的字面值表示法，在接下来的几节中，你将看到使用字面值表示法给变量赋值的示例。
- en: Storing text
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储文本
- en: For text, a single letter, such as an `A`, is stored as a `char` type.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本，单个字母，如`A`，存储为`char`类型。
- en: '**Good Practice**: Actually, it can be more complicated than that. Egyptian
    Hieroglyph A002 (U+13001) needs two `System.Char` values (known as surrogate pairs)
    to represent it: `\uD80C` and `\uDC01`. Do not always assume one `char` equals
    one letter or you could introduce weird bugs into your code.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：实际上，这可能比那更复杂。埃及象形文字A002（U+13001）需要两个`System.Char`值（称为代理对）来表示它：`\uD80C`和`\uDC01`。不要总是假设一个`char`等于一个字母，否则你可能在你的代码中引入奇怪的错误。'
- en: 'A `char` is assigned using single quotes around the literal value, or assigning
    the return value of a fictitious function call, as shown in the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单引号将字面值括起来，或赋值给一个虚构函数调用的返回值，来给`char`赋值，如下代码所示：
- en: '[PRE25]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For text, multiple letters, such as `Bob`, are stored as a `string` type and
    are assigned using double quotes around the literal value, or assigning the return
    value of a function call, as shown in the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本，多个字母，如`Bob`，存储为`string`类型，并使用双引号将字面值括起来，或赋值给函数调用的返回值，如下代码所示：
- en: '[PRE26]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Understanding verbatim strings
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解逐字字符串
- en: 'When storing text in a `string` variable, you can include escape sequences,
    which represent special characters like tabs and new lines using a backslash,
    as shown in the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`string`变量中存储文本时，你可以包含转义序列，这些序列使用反斜杠表示特殊字符，如制表符和新行，如下代码所示：
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But what if you are storing the path to a file on Windows, and one of the folder
    names starts with a `T`, as shown in the following code?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你要存储Windows上的文件路径，其中一个文件夹名以`T`开头，如下代码所示，该怎么办？
- en: '[PRE28]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The compiler will convert the `\t` into a tab character and you will get errors!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会将`\t`转换为制表符，你将会得到错误！
- en: 'You must prefix with the `@` symbol to use a verbatim literal `string`, as
    shown in the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须以前缀`@`符号使用逐字字面`string`，如下代码所示：
- en: '[PRE29]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To summarize:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 总结如下：
- en: '**Literal string**: Characters enclosed in double-quote characters. They can
    use escape characters like `\t` for tab. To represent a backslash, use two: `\\`.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字面字符串**：用双引号括起来的字符。它们可以使用转义字符，如`\t`表示制表符。要表示反斜杠，使用两个：`\\`。'
- en: '**Verbatim string**: A literal string prefixed with `@` to disable escape characters
    so that a backslash is a backslash. It also allows the `string` value to span
    multiple lines because the white space characters are treated as themselves instead
    of instructions to the compiler.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逐字字符串**：以`@`为前缀的字面字符串，用于禁用转义字符，使得反斜杠就是反斜杠。它还允许`string`值跨越多行，因为空白字符被视为其本身，而不是编译器的指令。'
- en: '**Interpolated string**: A literal string prefixed with `$` to enable embedded
    formatted variables. You will learn more about this later in this chapter.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内插字符串**：以`$`为前缀的字面字符串，用于启用嵌入格式化变量。你将在本章后面了解更多关于这方面的内容。'
- en: Storing numbers
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储数字
- en: Numbers are data that we want to perform an arithmetic calculation on, for example,
    multiplying. A telephone number is not a number. To decide whether a variable
    should be stored as a number or not, ask yourself whether you need to perform
    arithmetic operations on the number or whether the number includes non-digit characters
    such as parentheses or hyphens to format the number, such as (414) 555-1234\.
    In this case, the number is a sequence of characters, so it should be stored as
    a `string`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是我们想要进行算术计算的数据，例如乘法。电话号码不是数字。要决定一个变量是否应存储为数字，请问自己是否需要对该数字执行算术运算，或者该数字是否包含非数字字符，如括号或连字符来格式化数字，例如(414)
    555-1234。在这种情况下，该数字是一串字符，因此应将其存储为`string`。
- en: Numbers can be natural numbers, such as 42, used for counting (also called whole
    numbers); they can also be negative numbers, such as -42 (called integers); or,
    they can be real numbers, such as 3.9 (with a fractional part), which are called
    single- or double-precision floating-point numbers in computing.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可以是自然数，如42，用于计数（也称为整数）；它们也可以是负数，如-42（称为整数）；或者，它们可以是实数，如3.9（带有小数部分），在计算中称为单精度或双精度浮点数。
- en: 'Let''s explore numbers:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索数字：
- en: 'Use your preferred code editor to add a new **Console Application** to the
    `Chapter02` workspace/solution named `Numbers`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，在`Chapter02`工作区/解决方案中添加一个名为`Numbers`的**控制台应用程序**。
- en: In Visual Studio Code, select `Numbers` as the active OmniSharp project. When
    you see the pop-up warning message saying that required assets are missing, click
    **Yes** to add them.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Numbers`作为活动的OmniSharp项目。当看到弹出警告消息提示缺少必需资产时，点击**是**以添加它们。
- en: In Visual Studio, set the startup project to the current selection.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，将启动项目设置为当前选择。
- en: 'In `Program.cs`, delete the existing code and then type statements to declare
    some number variables using various data types, as shown in the following code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有代码，然后输入语句以声明一些使用各种数据类型的数字变量，如下列代码所示：
- en: '[PRE30]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Storing whole numbers
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储整数
- en: You might know that computers store everything as bits. The value of a bit is
    either 0 or 1\. This is called a **binary number system**. Humans use a **decimal
    number system**.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能知道计算机将所有内容存储为位。位的值要么是0，要么是1。这称为**二进制数系统**。人类使用**十进制数系统**。
- en: The decimal number system, also known as Base 10, has 10 as its **base**, meaning
    there are ten digits, from 0 to 9\. Although it is the number base most commonly
    used by human civilizations, other number base systems are popular in science,
    engineering, and computing. The binary number system, also known as Base 2, has
    two as its base, meaning there are two digits, 0 and 1.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数系统，又称基数10，其**基数**为10，意味着有十个数字，从0到9。尽管它是人类文明中最常用的数基，但科学、工程和计算领域中其他数基系统也很流行。二进制数系统，又称基数2，其基数为2，意味着有两个数字，0和1。
- en: 'The following table shows how computers store the decimal number 10\. Take
    note of the bits with the value 1 in the 8 and 2 columns; 8 + 2 = 10:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了计算机如何存储十进制数10。请注意8和2列中值为1的位；8 + 2 = 10：
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: '| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |'
- en: So, `10` in decimal is `00001010` in binary.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制中的`10`在二进制中是`00001010`。
- en: Improving legibility by using digit separators
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过使用数字分隔符提高可读性
- en: Two of the improvements seen in C# 7.0 and later are the use of the underscore
    character `_` as a digit separator, and support for binary literals.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0及更高版本中的两项改进是使用下划线字符`_`作为数字分隔符，以及支持二进制字面量。
- en: You can insert underscores anywhere into the digits of a number literal, including
    decimal, binary, or hexadecimal notation, to improve legibility.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在数字字面量的任何位置插入下划线，包括十进制、二进制或十六进制表示法，以提高可读性。
- en: For example, you could write the value for 1 million in decimal notation, that
    is, Base 10, as `1_000_000`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以将100万在十进制表示法（即基数10）中写为`1_000_000`。
- en: 'You can even use the 2/3 grouping common in India: `10_00_000`.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用印度常见的2/3分组：`10_00_000`。
- en: Using binary notation
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用二进制表示法
- en: To use binary notation, that is, Base 2, using only 1s and 0s, start the number
    literal with `0b`. To use hexadecimal notation, that is, Base 16, using 0 to 9
    and A to F, start the number literal with `0x`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用二进制表示法，即基数2，仅使用1和0，请以`0b`开始数字字面量。要使用十六进制表示法，即基数16，使用0到9和A到F，请以`0x`开始数字字面量。
- en: Exploring whole numbers
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索整数
- en: 'Let''s enter some code to see some examples:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入一些代码来查看一些示例：
- en: 'In `Program.cs`, type statements to declare some number variables using underscore
    separators, as shown in the following code:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句以声明一些使用下划线分隔符的数字变量，如下列代码所示：
- en: '[PRE31]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the code and note the result is that all three numbers are the same, as
    shown in the following output:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果是所有三个数字都相同，如下列输出所示：
- en: '[PRE32]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Computers can always exactly represent integers using the `int` type or one
    of its sibling types, such as `long` and `short`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机总能使用`int`类型或其同类类型（如`long`和`short`）精确表示整数。
- en: Storing real numbers
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储实数
- en: Computers cannot always represent real, aka decimal or non-integer, numbers
    precisely. The `float` and `double` types store real numbers using single- and
    double-precision floating points.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不能总是精确地表示实数，即小数或非整数。`float`和`double`类型使用单精度和双精度浮点来存储实数。
- en: Most programming languages implement the IEEE Standard for Floating-Point Arithmetic.
    IEEE 754 is a technical standard for floating-point arithmetic established in
    1985 by the **Institute of Electrical and Electronics Engineers** (**IEEE**).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都实现了IEEE浮点算术标准。IEEE 754是由**电气和电子工程师协会**（**IEEE**）于1985年制定的浮点算术技术标准。
- en: The following table shows a simplification of how a computer represents the
    number `12.75` in binary notation. Note the bits with the value `1` in the 8,
    4, ½, and ¼ columns.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 下表简化了计算机如何用二进制表示数字`12.75`。注意8、4、½和¼列中值为`1`的位。
- en: 8 + 4 + ½ + ¼ = 12¾ = 12.75.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 8 + 4 + ½ + ¼ = 12¾ = 12.75。
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 |'
- en: '| 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | . | 1 | 1 | 0 | 0 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | . | 1 | 1 | 0 | 0 |'
- en: So, `12.75` in decimal is `00001100.1100` in binary. As you can see, the number
    `12.75` can be exactly represented using bits. However, some numbers can't, something
    that we'll be exploring shortly.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制的`12.75`在二进制中是`00001100.1100`。如你所见，数字`12.75`可以用位精确表示。然而，有些数字则不能，我们很快就会探讨这一点。
- en: Writing code to explore number sizes
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写代码以探索数字大小
- en: 'C# has an operator named `sizeof()` that returns the number of bytes that a
    type uses in memory. Some types have members named `MinValue` and `MaxValue`,
    which return the minimum and maximum values that can be stored in a variable of
    that type. We are now going to use these features to create a console application
    to explore number types:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有一个名为`sizeof()`的运算符，它返回一个类型在内存中使用的字节数。某些类型具有名为`MinValue`和`MaxValue`的成员，这些成员返回可以存储在该类型的变量中的最小和最大值。我们现在将使用这些特性来创建一个控制台应用程序以探索数字类型：
- en: 'In `Program.cs`, type statements to show the size of three number data types,
    as shown in the following code:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句以显示三种数字数据类型的大小，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The width of the printed pages in this book makes the `string` values (in double
    quotes) wrap over multiple lines. You must type them on a single line, or you
    will get compile errors.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本书中打印页面的宽度使得`string`值（用双引号括起来）跨越多行。你必须在一行内输入它们，否则会遇到编译错误。
- en: Run the code and view the output, as shown in *Figure 2.3*:![](img/B17442_02_03.png)
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看输出，如*图2.3*所示：![](img/B17442_02_03.png)
- en: 'Figure 2.3: Size and range information for common number data types'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图2.3*：常见数字数据类型的大小和范围信息'
- en: An `int` variable uses four bytes of memory and can store positive or negative
    numbers up to about 2 billion. A `double` variable uses eight bytes of memory
    and can store much bigger values! A `decimal` variable uses 16 bytes of memory
    and can store big numbers, but not as big as a `double` type.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`变量使用四个字节的内存，并可以存储大约20亿以内的正负数。`double`变量使用八个字节的内存，可以存储更大的值！`decimal`变量使用16个字节的内存，可以存储大数字，但不如`double`类型那么大。'
- en: But you may be asking yourself, why might a `double` variable be able to store
    bigger numbers than a `decimal` variable, yet it's only using half the space in
    memory? Well, let's now find out!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能在想，为什么`double`变量能够存储比`decimal`变量更大的数字，而在内存中只占用一半的空间？那么，现在就让我们来找出答案吧！
- en: Comparing double and decimal types
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较`double`和`decimal`类型
- en: 'You will now write some code to compare `double` and `decimal` values. Although
    it isn''t hard to follow, don''t worry about understanding the syntax right now:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将编写一些代码来比较`double`和`decimal`值。尽管不难理解，但不必担心现在就掌握语法：
- en: 'Type statements to declare two `double` variables, add them together and compare
    them to the expected result, and write the result to the console, as shown in
    the following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以声明两个`double`变量，将它们相加并与预期结果进行比较，然后将结果写入控制台，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE35]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In locales that use a comma for the decimal separator the result will look
    slightly different, as shown in the following output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用逗号作为小数分隔符的地区，结果会略有不同，如下面的输出所示：
- en: '[PRE36]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `double` type is not guaranteed to be accurate because some numbers like
    `0.1` literally cannot be represented as floating-point values.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`类型不能保证精确，因为像`0.1`这样的数字实际上无法用浮点值表示。'
- en: As a rule of thumb, you should only use `double` when accuracy, especially when
    comparing the equality of two numbers, is not important. An example of this may
    be when you're measuring a person's height and you will only compare values using
    greater than or less than, but never equals.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，只有当精确度，尤其是比较两个数的相等性不重要时，才应使用`double`。例如，当你测量一个人的身高，并且只会使用大于或小于进行比较，而永远不会使用等于时，就可能属于这种情况。
- en: The problem with the preceding code is illustrated by how the computer stores
    the number `0.1`, or multiples of it. To represent `0.1` in binary, the computer
    stores 1 in the 1/16 column, 1 in the 1/32 column, 1 in the 1/256 column, 1 in
    the 1/512 column, and so on.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的问题在于计算机如何存储数字`0.1`，或其倍数。为了在二进制中表示`0.1`，计算机在1/16列存储1，在1/32列存储1，在1/256列存储1，在1/512列存储1，等等。
- en: 'The number `0.1` in decimal is `0.00011001100110011`… in binary, repeating
    forever:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`0.1`在十进制中是二进制的`0.00011001100110011`…，无限重复：'
- en: '| 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 | 1/32 | 1/64 | 1/128 | 1/256 | 1/512
    | 1/1024 | 1/2048 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | 1 | . | ½ | ¼ | 1/8 | 1/16 | 1/32 | 1/64 | 1/128 | 1/256 | 1/512
    | 1/1024 | 1/2048 |'
- en: '| 0 | 0 | 0 | . | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | . | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 |'
- en: '**Good Practice**: Never compare `double` values using `==`. During the First
    Gulf War, an American Patriot missile battery used `double` values in its calculations.
    The inaccuracy caused it to fail to track and intercept an incoming Iraqi Scud
    missile, and 28 soldiers were killed; you can read about this at [https://www.ima.umn.edu/~arnold/disasters/patriot.html](https://www.ima.umn.edu/~arnold/disasters/patriot.html).'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：切勿使用`==`比较`double`值。在第一次海湾战争期间，美国爱国者导弹电池在其计算中使用了`double`值。这种不准确性导致它未能跟踪并拦截来袭的伊拉克飞毛腿导弹，导致28名士兵丧生；你可以在[https://www.ima.umn.edu/~arnold/disasters/patriot.html](https://www.ima.umn.edu/~arnold/disasters/patriot.html)阅读有关此事件的信息。'
- en: Copy and paste the statements that you wrote before (that used the `double`
    variables).
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴你之前写的（使用了`double`变量的）语句。
- en: 'Modify the statements to use `decimal` and rename the variables to `c` and
    `d`, as shown in the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改语句以使用`decimal`，并将变量重命名为`c`和`d`，如下所示：
- en: '[PRE37]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE38]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `decimal` type is accurate because it stores the number as a large integer
    and shifts the decimal point. For example, `0.1` is stored as `1`, with a note
    to shift the decimal point one place to the left. `12.75` is stored as `1275`,
    with a note to shift the decimal point two places to the left.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal`类型之所以精确，是因为它将数字存储为一个大整数并移动小数点。例如，`0.1`存储为`1`，并注明将小数点向左移动一位。`12.75`存储为`1275`，并注明将小数点向左移动两位。'
- en: '**Good Practice**: Use `int` for whole numbers. Use `double` for real numbers
    that will not be compared for equality to other values; it is okay to compare
    `double` values being less than or greater than, and so on. Use `decimal` for
    money, CAD drawings, general engineering, and wherever the accuracy of a real
    number is important.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用`int`表示整数。使用`double`表示不会与其他值比较相等性的实数；比较`double`值是否小于或大于等是可以的。使用`decimal`表示货币、CAD图纸、通用工程以及任何对实数的精确性很重要的地方。'
- en: 'The `double` type has some useful special values: `double.NaN` represents not-a-number
    (for example, the result of dividing by zero), `double.Epsilon` represents the
    smallest positive number that can be stored in a `double`, and `double.PositiveInfinity`
    and `double.NegativeInfinity` represent infinitely large positive and negative
    values.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`类型有一些有用的特殊值：`double.NaN`表示非数字（例如，除以零的结果），`double.Epsilon`表示`double`中可以存储的最小的正数，`double.PositiveInfinity`和`double.NegativeInfinity`表示无限大的正负值。'
- en: Storing Booleans
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储布尔值
- en: 'Booleans can only contain one of the two literal values `true` or `false`,
    as shown in the following code:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值只能包含`true`或`false`这两个文字值之一，如下所示：
- en: '[PRE39]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: They are most commonly used to branch and loop. You don't need to fully understand
    them yet, as they are covered more in *Chapter 3*, *Controlling Flow, Converting
    Types, and Handling Exceptions*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 它们最常用于分支和循环。你不需要完全理解它们，因为它们在*第3章*，*控制流程、转换类型和处理异常*中会有更详细的介绍。
- en: Storing any type of object
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储任何类型的对象
- en: 'There is a special type named `object` that can store any type of data, but
    its flexibility comes at the cost of messier code and possibly poor performance.
    Because of those two reasons, you should avoid it whenever possible. The following
    steps show how to use object types if you need to use them:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`object`的特殊类型，可以存储任何类型的数据，但其灵活性是以代码更混乱和可能的性能下降为代价的。由于这两个原因，应尽可能避免使用它。以下步骤展示了如果需要使用对象类型时如何操作：
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Variables`.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，在`Chapter02`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`Variables`。
- en: In Visual Studio Code, select `Variables` as the active OmniSharp project. When
    you see the pop-up warning message saying that required assets are missing, click
    **Yes** to add them.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Variables`作为活动OmniSharp项目。当看到弹出警告消息提示缺少必需资产时，点击**是**以添加它们。
- en: 'In `Program.cs`, type statements to declare and use some variables using the
    `object` type, as shown in the following code:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，键入语句以声明和使用一些使用`object`类型的变量，如下所示：
- en: '[PRE40]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the code and note that the fourth statement cannot compile because the data
    type of the `name` variable is not known by the compiler, as shown in *Figure
    2.4*:![](img/B17442_02_04.png)
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意第四条语句无法编译，因为`name`变量的数据类型编译器未知，如图2.4所示：![](img/B17442_02_04.png)
- en: 'Figure 2.4: The object type does not have a Length property'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.4：对象类型没有Length属性
- en: Add comment double slashes to the beginning of the statement that cannot compile
    to "comment out" the statement to make it inactive.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在语句开头添加双斜杠注释，以“注释掉”无法编译的语句，使其无效。
- en: 'Run the code again and note that the compiler can access the length of a `string`
    if the programmer explicitly tells the compiler that the `object` variable contains
    a `string` by prefixing with a cast expression like `(string)`, as shown in the
    following output:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码并注意，如果程序员明确告诉编译器`object`变量包含一个`string`，通过前缀加上类型转换表达式如`(string)`，编译器可以访问`string`的长度，如下所示：
- en: '[PRE41]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `object` type has been available since the first version of C#, but C# 2.0
    and later have a better alternative called **generics**, which we will cover in
    *Chapter 6*, *Implementing Interfaces and Inheriting Classes*, which will provide
    us with the flexibility we want, but without the performance overhead.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`object`类型自C#的第一个版本起就可用，但C# 2.0及更高版本有一个更好的替代方案，称为**泛型**，我们将在*第6章*，*实现接口和继承类*中介绍，它将为我们提供所需的灵活性，而不会带来性能开销。'
- en: Storing dynamic types
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储动态类型
- en: 'There is another special type named `dynamic` that can also store any type
    of data, but even more than `object`, its flexibility comes at the cost of performance.
    The `dynamic` keyword was introduced in C# 4.0\. However, unlike `object`, the
    value stored in the variable can have its members invoked without an explicit
    cast. Let''s make use of a `dynamic` type:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`dynamic`的特殊类型，也可以存储任何类型的数据，但其灵活性甚至超过了`object`，同样以性能为代价。`dynamic`关键字是在C#
    4.0中引入的。然而，与`object`不同，存储在变量中的值可以在没有显式类型转换的情况下调用其成员。让我们利用`dynamic`类型：
- en: 'Add statements to declare a `dynamic` variable and then assign a `string` literal
    value, and then an integer value, and then an array of integer values, as shown
    in the following code:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以声明一个`dynamic`变量，然后分配一个`string`字面值，接着是一个整数值，最后是一个整数数组，如下所示：
- en: '[PRE42]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add a statement to output the length of the `dynamic` variable, as shown in
    the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个语句以输出`dynamic`变量的长度，如下所示：
- en: '[PRE43]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the code and note it works because a `string` value does have a `Length`
    property, as shown in the following output:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它有效，因为`string`值确实具有`Length`属性，如下所示：
- en: '[PRE44]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Uncomment the statement that assigns an `int` value.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释分配`int`值的语句。
- en: 'Run the code and note the runtime error because `int` does not have a `Length`
    property, as shown in the following output:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意运行时错误，因为`int`没有`Length`属性，如下所示：
- en: '[PRE45]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Uncomment the statement that assigns the array.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释分配数组的语句。
- en: 'Run the code and note the output because an array of three `int` values does
    have a `Length` property, as shown in the following output:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意输出，因为一个包含三个`int`值的数组确实具有`Length`属性，如下所示：
- en: '[PRE46]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: One limitation of `dynamic` is that code editors cannot show IntelliSense to
    help you write the code. This is because the compiler cannot check what the type
    is during build time. Instead, the CLR checks for the member at runtime and throws
    an exception if it is missing.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are a way to indicate that something has gone wrong at runtime. You
    will learn more about them and how to handle them in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Declaring local variables
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Local variables are declared inside methods, and they only exist during the
    execution of that method, and once the method returns, the memory allocated to
    any local variables is released.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, value types are released while reference types must wait
    for a garbage collection. You will learn about the difference between value types
    and reference types in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the type of a local variable
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explore local variables declared with specific types and using type
    inference:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare and assign values to some local variables using
    specific types, as shown in the following code:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Depending on your code editor and color scheme, it will show green squiggles
    under each of the variable names and lighten their text color to warn you that
    the variable is assigned but its value is never used.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Inferring the type of a local variable
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the `var` keyword to declare local variables. The compiler will
    infer the type from the value that you assign after the assignment operator, `=`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'A literal number without a decimal point is inferred as an `int` variable,
    that is, unless you add a suffix, as described in the following list:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '`L`: infers `long`'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UL`: infers `ulong`'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: infers `decimal`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: infers `double`'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F`: infers `float`'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A literal number with a decimal point is inferred as `double` unless you add
    the `M` suffix, in which case, it infers a `decimal` variable, or the `F` suffix,
    in which case, it infers a `float` variable.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'Double quotes indicate a `string` variable, single quotes indicate a `char`
    variable, and the `true` and `false` values infer a `bool` type:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the previous statements to use `var`, as shown in the following code:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Hover your mouse over each of the `var` keywords and note that your code editor
    shows a tooltip with information about the type that has been inferred.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the class file, import the namespace for working with XML to
    enable us to declare some variables using types in that namespace, as shown in
    the following code:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Good Practice**: If you are using .NET Interactive Notebooks, then add `using`
    statements in a separate code cell above the code cell where you write the main
    code. Then click **Execute Cell** to ensure the namespaces are imported. They
    will then be available in subsequent code cells.'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under the previous statements, add statements to create some new objects, as
    shown in the following code:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Good Practice**: Although using `var` is convenient, some developers avoid
    using it, to make it easier for a code reader to understand the types in use.
    Personally, I use it only when the type is obvious. For example, in the preceding
    code statements, the first statement is just as clear as the second in stating
    what the type of the `xml` variables are, but it is shorter. However, the third
    statement isn''t clear in showing the type of the `file` variable, so the fourth
    is better because it shows that the type is `StreamWriter`. If in doubt, spell
    it out!'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using target-typed new to instantiate objects
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With C# 9, Microsoft introduced another syntax for instantiating objects known
    as **target-typed new**. When instantiating an object, you can specify the type
    first and then use `new` without repeating the type, as shown in the following
    code:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you have a type with a field or property that needs to be set, then the
    type can be inferred, as shown in the following code:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Good Practice**: Use target-typed new to instantiate objects unless you must
    use a pre-version 9 C# compiler. I have used target-typed new throughout the rest
    of this book. Please let me know if you spot any cases that I missed!'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Getting and setting the default values for types
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the primitive types except `string` are **value types**, which means
    that they must have a value. You can determine the default value of a type by
    using the `default()` operator and passing the type as a parameter. You can assign
    the default value of a type by using the `default` keyword.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: The `string` type is a **reference type**. This means that `string` variables
    contain the memory address of a value, not the value itself. A reference type
    variable can have a `null` value, which is a literal that indicates that the variable
    does not reference anything (yet). `null` is the default for all reference types.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn more about value types and reference types in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore default values:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to show the default values of an `int`, `bool`, `DateTime`,
    and `string`, as shown in the following code:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the code and view the result, noting that your output for the date and
    time might be formatted differently if you are not running it in the UK, and that
    `null` values output as an empty `string`, as shown in the following output:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add statements to declare a number, assign a value, and then reset it to its
    default value, as shown in the following code:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Storing multiple values in an array
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you need to store multiple values of the same type, you can declare an
    **array**. For example, you may do this when you need to store four names in a
    `string` array.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: The code that you will write next will allocate memory for an array for storing
    four `string` values. It will then store `string` values at index positions 0
    to 3 (arrays usually have a lower bound of zero, so the index of the last item
    is one less than the length of the array).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Do not assume that all arrays count from zero. The most
    common type of array in .NET is an **szArray**, a single-dimension zero-indexed
    array, and these use the normal `[]` syntax. But .NET also has **mdArray**, a
    multi-dimensional array, and they do not have to have a lower bound of zero. These
    are rarely used but you should know they exist.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it will loop through each item in the array using a `for` statement,
    something that we will cover in more detail in *Chapter 3*, *Controlling Flow,
    Converting Types, and Handling Exceptions*.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use an array:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare and use an array of `string` values, as shown in
    the following code:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Arrays are always of a fixed size at the time of memory allocation, so you need
    to decide how many items you want to store before instantiating them.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to defining the array in three steps as above is to use array
    initializer syntax, as shown in the following code:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When you use the `new[]` syntax to allocate memory for the array, you must have
    at least one item in the curly braces so that the compiler can infer the data
    type.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are useful for temporarily storing multiple items, but collections are
    a more flexible option when adding and removing items dynamically. You don't need
    to worry about collections right now, as we will cover them in *Chapter 8*, *Working
    with Common .NET Types*.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Exploring more about console applications
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already created and used basic console applications, but we're now at
    a stage where we should delve into them more deeply.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Console applications are text-based and are run at the command line. They typically
    perform simple tasks that need to be scripted, such as compiling a file or encrypting
    a section of a configuration file.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Equally, they can also have arguments passed to them to control their behavior.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this would be to create a new console app using the F# language
    with a specified name instead of using the name of the current folder, as shown
    in the following command line:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Displaying output to the user
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two most common tasks that a console application performs are writing and
    reading data. We have already been using the `WriteLine` method to output, but
    if we didn't want a carriage return at the end of the lines, we could have used
    the `Write` method.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Formatting using numbered positional arguments
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way of generating formatted strings is to use numbered positional arguments.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: This feature is supported by methods like `Write` and `WriteLine`, and for methods
    that do not support the feature, the `string` parameter can be formatted using
    the `Format` method of `string`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: The first few code examples in this section will work with a .NET Interactive
    notebook because they are about outputting to the console. Later in this section,
    you will learn about getting input via the console and sadly notebooks do not
    support this.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin formatting:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Formatting`.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Formatting` as the active OmniSharp project.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare some number variables and write
    them to the console, as shown in the following code:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `WriteToFile` method is a nonexistent method used to illustrate the idea.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Once you become more comfortable with formatting strings,
    you should stop naming the parameters, for example, stop using `format:`, `arg0:`,
    and `arg1:`. The preceding code uses a non-canonical style to show where the `0`
    and `1` came from while you are learning.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Formatting using interpolated strings
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 6.0 and later have a handy feature named **interpolated strings**. A `string`
    prefixed with `$` can use curly braces around the name of a variable or expression
    to output the current value of that variable or expression at that position in
    the `string`, as the following shows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a statement at the bottom of the `Program.cs` file, as shown in the following
    code:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run the code and view the result, as shown in the following partial output:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For short, formatted `string` values, an interpolated `string` can be easier
    for people to read. But for code examples in a book, where lines need to wrap
    over multiple lines, this can be tricky. For many of the code examples in this
    book, I will use numbered positional arguments.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to avoid interpolated strings is that they can't be read from
    resource files to be localized.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C# 10, string constants could only be combined by using concatenation,
    as shown in the following code:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With C# 10, interpolated strings can now be used, as shown in the following
    code:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This only works for combining string constant values. It cannot work with other
    types like numbers that would require runtime data type conversions.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Understanding format strings
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variable or expression can be formatted using a format string after a comma
    or colon.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: An `N0` format string means a number with a thousand separators and no decimal
    places, while a `C` format string means currency. The currency format will be
    determined by the current thread.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you run this code on a PC in the UK, you'll get pounds sterling
    with commas as the thousand separators, but if you run this code on a PC in Germany,
    you will get euros with dots as the thousand separators.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'The full syntax of a format item is:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Each format item can have an alignment, which is useful when outputting tables
    of values, some of which might need to be left- or right-aligned within a width
    of characters. Alignment values are integers. Positive integers mean right-aligned
    and negative integers mean left-aligned.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to output a table of fruit and how many of each there are, we
    might want to left-align the names within a column of 10 characters and right-align
    the counts formatted as numbers with zero decimal places within a column of six
    characters:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, enter the following statements:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the code and note the effect of the alignment and number format, as shown
    in the following output:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Getting text input from the user
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can get text input from the user using the `ReadLine` method. This method
    waits for the user to type some text, then as soon as the user presses Enter,
    whatever the user has typed is returned as a `string` value.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If you are using a .NET Interactive notebook for this section,
    then note that it does not support reading input from the console using `Console.ReadLine()`.
    Instead, you must set literal values, as shown in the following code: `string?
    firstName = "Gary";`. This is often quicker to experiment with because you can
    simply change the literal `string` value and click the **Execute Cell** button
    instead of having to restart a console app each time you want to enter a different
    `string` value.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get input from the user:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to ask the user for their name and age and then output what
    they entered, as shown in the following code:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run the code, and then enter a name and age, as shown in the following output:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The question marks at the end of the `string?` data type declaration indicate
    that we acknowledge that a `null` (empty) value could be returned from the call
    to `ReadLine`. You will learn more about this in *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the usage of the console
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C# 6.0 and later, the `using` statement can be used not only to import a
    namespace but also to further simplify our code by importing a static class. Then,
    we won''t need to enter the `Console` type name throughout our code. You can use
    your code editor''s find and replace feature to remove the times we have previously
    written `Console`:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `Program.cs` file, add a statement to **statically import**
    the `System.Console` class, as shown in the following code:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Select the first `Console.` in your code, ensuring that you select the dot after
    the word `Console` too.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Edit** | **Find and Replace** | **Quick Replace**,
    or in Visual Studio Code, navigate to **Edit** | **Replace**, and note that an
    overlay dialog appears ready for you to enter what you would like to replace **Console.**
    with, as shown in *Figure 2.5*:![](img/B17442_02_05.png)
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.5: Using the Replace feature in Visual Studio to simplify your code'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Leave the replace box empty, click on the **Replace all** button (the second
    of the two buttons to the right of the replace box), and then close the replace
    box by clicking on the cross in its top-right corner.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting key input from the user
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can get key input from the user using the `ReadKey` method. This method waits
    for the user to press a key or key combination that is then returned as a `ConsoleKeyInfo`
    value.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'You will not be able to execute the call to the `ReadKey` method using a .NET
    Interactive notebook, but if you have created a console application, then let''s
    explore reading key presses:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to ask the user to press any key combination and then output
    information about it, as shown in the following code:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Run the code, press the K key, and note the result, as shown in the following
    output:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Run the code, hold down Shift and press the K key, and note the result, as
    shown in the following output:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the code, press the F12 key, and note the result, as shown in the following
    output:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When running a console application in a terminal within Visual Studio Code,
    some keyboard combinations will be captured by the code editor or operating system
    before they can be processed by your app.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to a console app
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have been wondering how to get any arguments that might be passed
    to a console application.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 'In every version of .NET prior to version 6.0, the console application project
    template made it obvious, as shown in the following code:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `string[] args` arguments are declared and passed in the `Main` method of
    the `Program` class. They're an array used to pass arguments into a console application.
    But in top-level programs, as used by the console application project template
    in .NET 6.0 and later, the `Program` class and its `Main` method are hidden, along
    with the declaration of the `args` string array. The trick is that you must know
    it still exists.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Command-line arguments are separated by spaces. Other characters like hyphens
    and colons are treated as part of an argument value.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: To include spaces in an argument value, enclose the argument value in single
    or double quotes.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to be able to enter the names of some colors for the foreground
    and background, and the dimensions of the terminal window at the command line.
    We would be able to read the colors and numbers by reading them from the `args`
    array, which is always passed into the `Main` method aka the entry point of a
    console application:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Arguments`. You will not be able to use a .NET Interactive
    notebook because you cannot pass arguments to a notebook.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Arguments` as the active OmniSharp project.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a statement to statically import the `System.Console` type and a statement
    to output the number of arguments passed to the application, as shown in the following
    code:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '**Good Practice**: Remember to statically import the `System.Console` type
    in all future projects to simplify your code, as these instructions will not be
    repeated every time.'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If you are using Visual Studio, then navigate to **Project** | **Arguments**
    **Properties**, select the **Debug** tab, and in the **Application arguments**
    box, enter some arguments, save the changes, and then run the console application,
    as shown in *Figure 2.6*:![Graphical user interface, text, application  Description
    automatically generated](img/B17442_02_06.png)
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.6: Entering application arguments in Visual Studio project properties'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio Code, then in a terminal, enter some arguments
    after the `dotnet run` command, as shown in the following command line:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note the result indicates four arguments, as shown in the following output:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To enumerate or iterate (that is, loop through) the values of those four arguments,
    add the following statements after outputting the length of the array:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run the code again and note the result shows the details of the four arguments,
    as shown in the following output:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Setting options with arguments
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now use these arguments to allow the user to pick a color for the background,
    foreground, and cursor size of the output window. The cursor size can be an integer
    value from 1, meaning a line at the bottom of the cursor cell, up to 100, meaning
    a percentage of the height of the cursor cell.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'The `System` namespace is already imported so that the compiler knows about
    the `ConsoleColor` and `Enum` types:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to warn the user if they do not enter three arguments and then
    parse those arguments and use them to set the color and dimensions of the console
    window, as shown in the following code:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Setting the `CursorSize` is only supported on Windows.
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Visual Studio, navigate to **Project** | **Arguments Properties**, and change
    the arguments to: `red yellow 50`, run the console app, and note the cursor is
    half the size and the colors have changed in the window, as shown in *Figure 2.7*:![Graphical
    user interface, application, website  Description automatically generated](img/B17442_02_07.png)'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.7: Setting colors and cursor size on Windows'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, run the code with arguments to set the foreground color
    to red, the background color to yellow, and the cursor size to 50%, as shown in
    the following command:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'On macOS, you''ll see an unhandled exception, as shown in *Figure 2.8*:'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17442_02_08.png)'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2.8: An unhandled exception on unsupported macOS'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Although the compiler did not give an error or warning, at runtime some API
    calls may fail on some platforms. Although a console application running on Windows
    can change its cursor size, on macOS, it cannot, and complains if you try.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Handling platforms that do not support an API
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So how do we solve this problem? We can solve this by using an exception handler.
    You will learn more details about the `try-catch` statement in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*, so for now, just enter the code:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the code to wrap the lines that change the cursor size in a `try` statement,
    as shown in the following code:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If you were to run the code on macOS then you would see the exception is caught,
    and a friendlier message is shown to the user.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to handle differences in operating systems is to use the `OperatingSystem`
    class in the `System` namespace, as shown in the following code:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `OperatingSystem` class has equivalent methods for other common operating
    systems like Android, iOS, Linux, macOS, and even the browser, which is useful
    for Blazor web components.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: A third way to handle different platforms is to use conditional compilation
    statements.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four preprocessor directives that control conditional compilation:
    `#if`, `#elif`, `#else`, and `#endif`.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'You define symbols using `#define`, as shown in the following code:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Many symbols are automatically defined for you, as shown in the following table:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '| Target Framework | Symbols |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
- en: '| .NET Standard | `NETSTANDARD2_0`, `NETSTANDARD2_1`, and so on |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
- en: '| Modern .NET | `NET6_0`, `NET6_0_ANDROID`, `NET6_0_IOS`, `NET6_0_WINDOWS`,
    and so on |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
- en: 'You can then write statements that will compile only for the specified platforms,
    as shown in the following code:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Practicing and exploring
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore the topics covered in this chapter with deeper
    research.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.1 – Test your knowledge
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get the best answer to some of these questions, you will need to do your
    own research. I want you to "think outside the book" so I have deliberately not
    provided all the answers in the book.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: I want to encourage you to get in to the good habit of looking for help elsewhere,
    following the principle of "teach a person to fish."
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: What statement can you type in a C# file to discover the compiler and language
    version?
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two types of comments in C#?
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a verbatim string and an interpolated string?
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you be careful when using `float` and `double` values?
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you determine how many bytes a type like `double` uses in memory?
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `var` keyword?
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the newest way to create an instance of a class like `XmlDocument`?
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you be careful when using the `dynamic` type?
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you right-align a format string?
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What character separates arguments for a console application?
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Appendix*, *Answers to the Test Your Knowledge Questions* is available to
    download from a link in the README on the GitHub repository: [https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6).'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise 2.2 – Test your knowledge of number types
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What type would you choose for the following "numbers"?
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: A person's telephone number
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A person's height
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A person's age
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A person's salary
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A book's ISBN
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A book's price
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A book's shipping weight
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A country's population
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of stars in the universe
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of employees in each of the small or medium businesses in the United
    Kingdom (up to about 50,000 employees per business)
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 2.3 – Practice number sizes and ranges
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter02` solution/workspace, create a console application project
    named `Exercise02` that outputs the number of bytes in memory that each of the
    following number types uses and the minimum and maximum values they can have:
    `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`,
    and `decimal`.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of running your console application should look something like *Figure
    2.9*:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B17442_02_09.png)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: The result of outputting number type sizes'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'Code solutions for all exercises are available to download or clone from the
    GitHub repository at the following link: [https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6).'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.4 – Explore topics
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Declare variables with a specified or an inferred type.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use some of the built-in types for numbers, text, and Booleans.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose between number types.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control output formatting in console apps.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about operators, branching, looping, converting
    between types, and how to handle exceptions.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
