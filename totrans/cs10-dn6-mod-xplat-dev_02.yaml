- en: '02'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about the basics of the C# programming language. Over the
    course of this chapter, you'll learn how to write statements using the grammar
    of C#, as well as being introduced to some of the common vocabulary that you will
    use every day. In addition to this, by the end of the chapter, you'll feel confident
    in knowing how to temporarily store and work with information in your computer's
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the C# language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding C# grammar and vocabulary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring more about console applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the C# language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of the book is about the C# languageâ€”the grammar and vocabulary that
    you will use every day to write the source code for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages have many similarities to human languages, except that
    in programming languages, you can make up your own words, just like Dr. Seuss!
  prefs: []
  type: TYPE_NORMAL
- en: 'In a book written by Dr. Seuss in 1950, *If I Ran the Zoo*, he states this:'
  prefs: []
  type: TYPE_NORMAL
- en: '"And then, just to show them, I''ll sail to Ka-Troo And Bring Back an It-Kutch,
    a Preep, and a Proo, A Nerkle, a Nerd, and a Seersucker, too!"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Understanding language versions and features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This part of the book covers the C# programming language and is written primarily
    for beginners, so it covers the fundamental topics that all developers need to
    know, from declaring variables to storing data to how to define your own custom
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: This book covers features of the C# language from version 1.0 up to the latest
    version 10.0.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have some familiarity with older versions of C# and are excited
    to find out about the new features in the most recent versions of C#, I have made
    it easier for you to jump around by listing language versions and their important
    new features below, along with the chapter number and topic title where you can
    learn about them.
  prefs: []
  type: TYPE_NORMAL
- en: C# 1.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# 1.0 was released in 2002 and included all the important features of a statically
    typed object-oriented modern language, as you will see throughout *Chapters* *2*
    to *6*.
  prefs: []
  type: TYPE_NORMAL
- en: C# 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 2.0 was released in 2005 and focused on enabling strong data typing using
    generics, to improve code performance and reduce type errors, including the topics
    listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Nullable value types | 6 | Making a value type nullable |'
  prefs: []
  type: TYPE_TB
- en: '| Generics | 6 | Making types more reusable with generics |'
  prefs: []
  type: TYPE_TB
- en: C# 3.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 3.0 was released in 2007 and focused on enabling declarative coding with
    **Language INtegrated Queries** (**LINQ**) and related features like anonymous
    types and lambda expressions, including the topics listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Implicitly typed local variables | 2 | Inferring the type of a local variable
    |'
  prefs: []
  type: TYPE_TB
- en: '| LINQ | 11 | All topics in *Chapter 11*, *Querying and Manipulating Data Using
    LINQ* |'
  prefs: []
  type: TYPE_TB
- en: C# 4.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 4.0 was released in 2010 and focused on improving interoperability with
    dynamic languages like F# and Python, including the topics listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic types | 2 | Storing dynamic types |'
  prefs: []
  type: TYPE_TB
- en: '| Named/optional arguments | 5 | Optional parameters and named arguments |'
  prefs: []
  type: TYPE_TB
- en: C# 5.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 5.0 was released in 2012 and focused on simplifying asynchronous operation
    support by automatically implementing complex state machines while writing what
    looks like synchronous statements, including the topics listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Simplified asynchronous tasks | 12 | Understanding async and await |'
  prefs: []
  type: TYPE_TB
- en: C# 6.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 6.0 was released in 2015 and focused on minor refinements to the language,
    including the topics listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| `static` imports | 2 | Simplifying the usage of the console |'
  prefs: []
  type: TYPE_TB
- en: '| Interpolated strings | 2 | Displaying output to the user |'
  prefs: []
  type: TYPE_TB
- en: '| Expression bodied members | 5 | Defining read-only properties |'
  prefs: []
  type: TYPE_TB
- en: C# 7.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 7.0 was released in March 2017 and focused on adding functional language
    features like tuples and pattern matching, as well as minor refinements to the
    language, including the topics listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Binary literals and digit separators | 2 | Storing whole numbers |'
  prefs: []
  type: TYPE_TB
- en: '| Pattern matching | 3 | Pattern matching with the `if` statement |'
  prefs: []
  type: TYPE_TB
- en: '| `out` variables | 5 | Controlling how parameters are passed |'
  prefs: []
  type: TYPE_TB
- en: '| Tuples | 5 | Combining multiple values with tuples |'
  prefs: []
  type: TYPE_TB
- en: '| Local functions | 6 | Defining local functions |'
  prefs: []
  type: TYPE_TB
- en: C# 7.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 7.1 was released in August 2017 and focused on minor refinements to the
    language, including the topics listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Default literal expressions | 5 | Setting fields with default literal |'
  prefs: []
  type: TYPE_TB
- en: '| Inferred tuple element names | 5 | Inferring tuple names |'
  prefs: []
  type: TYPE_TB
- en: '| `async` Main | 12 | Improving responsiveness for console apps |'
  prefs: []
  type: TYPE_TB
- en: C# 7.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 7.2 was released in November 2017 and focused on minor refinements to the
    language, including the topics listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Leading underscores in numeric literals | 2 | Storing whole numbers |'
  prefs: []
  type: TYPE_TB
- en: '| Non-trailing named arguments | 5 | Optional parameters and named arguments
    |'
  prefs: []
  type: TYPE_TB
- en: '| `private protected` access modifier | 5 | Understanding access modifiers
    |'
  prefs: []
  type: TYPE_TB
- en: '| You can test `==` and `!=` with tuple types | 5 | Comparing tuples |'
  prefs: []
  type: TYPE_TB
- en: C# 7.3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# 7.3 was released in May 2018 and focused on performance-oriented safe code
    that improves `ref` variables, pointers, and `stackalloc`. These are advanced
    and rarely needed for most developers, so they are not covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: C# 8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 8 was released in September 2019 and focused on a major change to the language
    related to null handling, including the topics listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Nullable reference types | 6 | Making a reference type nullable |'
  prefs: []
  type: TYPE_TB
- en: '| Switch expressions | 3 | Simplifying `switch` statements with switch expressions
    |'
  prefs: []
  type: TYPE_TB
- en: '| Default interface methods | 6 | Understanding default interface methods |'
  prefs: []
  type: TYPE_TB
- en: C# 9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 9 was released in November 2020 and focused on record types, refinements
    to pattern matching, and minimal-code console apps, including the topics listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Minimal-code console apps | 1 | Top-level programs |'
  prefs: []
  type: TYPE_TB
- en: '| Target-typed new | 2 | Using target-typed new to instantiate objects |'
  prefs: []
  type: TYPE_TB
- en: '| Enhanced pattern matching | 5 | Pattern matching with objects |'
  prefs: []
  type: TYPE_TB
- en: '| Records | 5 | Working with records |'
  prefs: []
  type: TYPE_TB
- en: C# 10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 10 was released in November 2021 and focused on features that minimize the
    amount of code needed in common scenarios, including the topics listed in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Global namespace imports | 2 | Importing namespaces |'
  prefs: []
  type: TYPE_TB
- en: '| Constant string literals | 2 | Formatting using interpolated strings |'
  prefs: []
  type: TYPE_TB
- en: '| File-scoped namespaces | 5 | Simplifying namespace declarations |'
  prefs: []
  type: TYPE_TB
- en: '| Required properties | 5 | Requiring properties to be set during instantiation
    |'
  prefs: []
  type: TYPE_TB
- en: '| Record structs | 6 | Working with record struct types |'
  prefs: []
  type: TYPE_TB
- en: '| Null parameter checks | 6 | Checking for null in method parameters |'
  prefs: []
  type: TYPE_TB
- en: Understanding C# standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over the years, Microsoft has submitted a few versions of C# to standards bodies,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| C# version | ECMA standard | ISO/IEC standard |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | ECMA-334:2003 | ISO/IEC 23270:2003 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.0 | ECMA-334:2006 | ISO/IEC 23270:2006 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0 | ECMA-334:2017 | ISO/IEC 23270:2018 |'
  prefs: []
  type: TYPE_TB
- en: The standard for C# 6 is still a draft and work on adding C# 7 features is progressing.
    Microsoft made C# open source in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are currently three public GitHub repositories for making the work on
    C# and related technologies as open as possible, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Description | Link |'
  prefs: []
  type: TYPE_TB
- en: '| C# language design | [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Compiler implementation | [https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Standard to describe the language | [https://github.com/dotnet/csharpstandard](https://github.com/dotnet/csharpstandard)
    |'
  prefs: []
  type: TYPE_TB
- en: Discovering your C# compiler versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET language compilers for C# and Visual Basic, also known as Roslyn, along
    with a separate compiler for F#, are distributed as part of the .NET SDK. To use
    a specific version of C#, you must have at least that version of the .NET SDK
    installed, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| .NET SDK | Roslyn compiler | Default C# language |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0.4 | 2.0 - 2.2 | 7.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.1.4 | 2.3 - 2.4 | 7.1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.1.2 | 2.6 - 2.7 | 7.2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.1.200 | 2.8 - 2.10 | 7.3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0 | 3.0 - 3.4 | 8.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0 | 3.8 | 9.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.0 | 3.9 - 3.10 | 10.0 |'
  prefs: []
  type: TYPE_TB
- en: 'When you create class libraries then you can choose to target .NET Standard
    as well as versions of modern .NET. They have default C# language versions, as
    shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| .NET Standard | C# |'
  prefs: []
  type: TYPE_TB
- en: '| 2.0 | 7.3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.1 | 8.0 |'
  prefs: []
  type: TYPE_TB
- en: How to output the SDK version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see what .NET SDK and C# language compiler versions you have available:'
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, start **Terminal**. On Windows, start **Command Prompt**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To determine which version of the .NET SDK you have available, enter the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the version at the time of writing is 6.0.100, indicating that it is the
    initial version of the SDK without any bug fixes or new features yet, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enabling a specific language version compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Developer tools like Visual Studio and the `dotnet` command-line interface
    assume that you want to use the latest major version of a C# language compiler
    by default. Before C# 8.0 was released, C# 7.0 was the latest major version and
    was used by default. To use the improvements in a C# point release like 7.1, 7.2,
    or 7.3, you had to add a `<LangVersion>` configuration element to the project
    file, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the release of C# 10.0 with .NET 6.0, if Microsoft releases a C# 10.1
    compiler and you want to use its new language features then you will have to add
    a configuration element to your project file, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Potential values for the `<LangVersion>` are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| LangVersion | Description |'
  prefs: []
  type: TYPE_TB
- en: '| 7, 7.1, 7.2, 7.38, 9, 10 | Entering a specific version number will use that
    compiler if it has been installed. |'
  prefs: []
  type: TYPE_TB
- en: '| latestmajor | Uses the highest major number, for example, 7.0 in August 2019,
    8.0 in October 2019, 9.0 in November 2020, 10.0 in November 2021. |'
  prefs: []
  type: TYPE_TB
- en: '| `latest` | Uses the highest major and highest minor number, for example,
    7.2 in 2017, 7.3 in 2018, 8 in 2019, perhaps 10.1 in early 2022. |'
  prefs: []
  type: TYPE_TB
- en: '| `preview` | Uses the highest available preview version, for example, 10.0
    in July 2021 with .NET 6.0 Preview 6 installed. |'
  prefs: []
  type: TYPE_TB
- en: 'After creating a new project, you can edit the `.csproj` file and add the `<LangVersion>`
    element, as shown highlighted in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Your projects must target `net6.0` to use the full features of C# 10.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If you are using Visual Studio Code and you have not done
    so already, install the Visual Studio Code extension named **MSBuild project tools**.
    This will give you IntelliSense while editing `.csproj` files, including making
    it easy to add the `<LangVersion>` element with appropriate values.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C# grammar and vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn simple C# language features, you can use .NET Interactive Notebooks,
    which remove the need to create an application of any kind.
  prefs: []
  type: TYPE_NORMAL
- en: To learn some other C# language features, you will need to create an application.
    The simplest type of application is a console application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the basics of the grammar and vocabulary of C#. Throughout
    this chapter, you will create multiple console applications, with each one showing
    related features of the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the compiler version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by writing code that shows the compiler version:'
  prefs: []
  type: TYPE_NORMAL
- en: If you've completed *Chapter 1*, *Hello, C#! Welcome, .NET!*, then you will
    already have a `Code` folder. If not, then you'll need to create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new console app, as defined in the
    following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application [C#]** / `console`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter02`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Vocabulary`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: If you have forgotten how, or did not complete the previous
    chapter, then step-by-step instructions for creating a workspace/solution with
    multiple projects are given in *Chapter 1*, *Hello, C#! Welcome, .NET!*.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `Program.cs` file, and at the top of the file, under the comment,
    add a statement to show the C# version as an error, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, in a terminal, enter the command `dotnet run`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Debug** | **Start Without Debugging**. When
    prompted to continue and run the last successful build, click **No**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the compiler version and language version appear as a compiler error message
    number `CS8304`, as shown in *Figure 2.1*:![](img/B17442_02_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.1: A compiler error that shows the C# language version'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The error message in the Visual Studio Code **PROBLEMS** window or Visual Studio
    **Error List** window says `Compiler version: ''4.0.0...''` with language version
    `10.0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Comment out the statement that causes the error, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the compiler error messages disappear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding C# grammar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The grammar of C# includes statements and blocks. To document your code, you
    can use comments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Comments should not be the only way that you document your
    code. Choosing sensible names for variables and functions, writing unit tests,
    and creating actual documents are other ways to document your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In English, we indicate the end of a sentence with a full stop. A sentence can
    be composed of multiple words and phrases, with the order of words being part
    of the grammar. For example, in English, we say "the black cat."
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjective, *black*, comes before the noun, *cat*. Whereas French grammar
    has a different order; the adjective comes after the noun: "le chat noir." What''s
    important to take away from this is that the order matters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# indicates the end of a **statement** with a semicolon. A statement can be
    composed of multiple **variables** and **expressions**. For example, in the following
    statement, `totalPrice` is a variable and `subtotal + salesTax` is an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The expression is made up of an operand named `subtotal`, an operator `+`, and
    another operand named `salesTax`. The order of operands and operators matters.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing your code, you''re able to add comments to explain your code using
    a double slash, `//`. By inserting `//` the compiler will ignore everything after
    the `//` until the end of the line, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To write a multiline comment, use `/*` at the beginning and `*/` at the end
    of the comment, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Well-designed code, including function signatures with well-named
    parameters and class encapsulation, can be somewhat self-documenting. When you
    find yourself putting too many comments and explanations in your code, ask yourself:
    can I rewrite, aka refactor, this code to make it more understandable without
    long comments?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code editor has commands to make it easier to add and remove comment characters,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio 2022 for Windows**: Navigate to **Edit** | **Advanced** | **Comment
    Selection** or **Uncomment Selection**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: Navigate to **Edit** | **Toggle Line Comment** or **Toggle
    Block Comment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: You **comment** code by adding descriptive text above or
    after code statements. You **comment out** code by adding comment characters before
    or around statements to make them inactive. **Uncommenting** means removing the
    comment characters.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In English, we indicate a new paragraph by starting a new line. C# indicates
    a **block** of code with the use of curly brackets, `{ }`.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks start with a declaration to indicate what is being defined. For example,
    a block can define the start and end of many language constructs including namespaces,
    classes, methods, or statements like `foreach`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn more about namespaces, classes, and methods later in this chapter
    and subsequent chapters but to briefly introduce some of those concepts now:'
  prefs: []
  type: TYPE_NORMAL
- en: A **namespace** contains types like classes to group them together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **class** contains the members of an object including methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **method** contains statements that implement an action that an object can
    take.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of statements and blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the project template for console apps when targeting .NET 5.0, note that
    examples of the grammar of C# have been written for you by the project template.
    I''ve added some comments to the statements and blocks, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Understanding C# vocabulary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# vocabulary is made up of **keywords**, **symbol characters**, and **types**.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the predefined, reserved keywords that you will see in this book include
    `using`, `namespace`, `class`, `static`, `int`, `string`, `double`, `bool`, `if`,
    `switch`, `break`, `while`, `do`, `for`, `foreach`, `and`, `or`, `not`, `record`,
    and `init`.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the symbol characters that you will see include `"`, `'`, `+`, `-`,
    `*`, `/`, `%`, `@`, and `$`.
  prefs: []
  type: TYPE_NORMAL
- en: There are other contextual keywords that only have a special meaning in a specific
    context.
  prefs: []
  type: TYPE_NORMAL
- en: However, that still means that there are only about 100 actual C# keywords in
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing programming languages to human languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The English language has more than 250,000 distinct words, so how does C# get
    away with only having about 100 keywords? Moreover, why is C# so difficult to
    learn if it has only 0.0416% of the number of words in the English language?
  prefs: []
  type: TYPE_NORMAL
- en: One of the key differences between a human language and a programming language
    is that developers need to be able to define the new "words" with new meanings.
    Apart from the about 100 keywords in the C# language, this book will teach you
    about some of the hundreds of thousands of "words" that other developers have
    defined, but you will also learn how to define your own "words."
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers all over the world must learn English because most programming
    languages use English words such as namespace and class. There are programming
    languages that use other human languages, such as Arabic, but they are rare. If
    you are interested in learning more, this YouTube video shows a demonstration
    of an Arabic programming language: [https://youtu.be/dkO8cdwf6v8](https://youtu.be/dkO8cdwf6v8).'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the color scheme for C# syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Visual Studio Code and Visual Studio show C# keywords in blue to
    make them easier to differentiate from other code. Both tools allow you to customize
    the color scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio Code, navigate to **Code** | **Preferences** | **Color Theme**
    (it is on the **File** menu on Windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a color theme. For reference, I'll use the **Light+ (default light)**
    color theme so that the screenshots look good in a printed book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Tools** | **Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Options** dialog box, select **Fonts and Colors**, and then select
    the display items that you would like to customize.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Help for writing correct code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plain text editors such as Notepad don't help you write correct English. Likewise,
    Notepad won't help you write correct C# either.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Word can help you write English by highlighting spelling mistakes
    with red squiggles, with Word saying that "icecream" should be ice-cream or ice
    cream, and grammatical errors with blue squiggles, such as a sentence should have
    an uppercase first letter.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, Visual Studio Code's C# extension and Visual Studio help you write
    C# code by highlighting spelling mistakes, such as the method name should be `WriteLine`
    with an uppercase L, and grammatical errors, such as statements that must end
    with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The C# extension constantly watches what you type and gives you feedback by
    highlighting problems with colored squiggly lines, similar to that of Microsoft
    Word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs`, change the `L` in the `WriteLine` method to lowercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the semicolon at the end of the statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, navigate to **View** | **Problems**, or in Visual Studio
    navigate to **View** | **Error List**, and note that a red squiggle appears under
    the code mistakes and details are shown, as you can see in *Figure 2.2*:![](img/B17442_02_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.2: The Error List window showing two compile errors'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fix the two coding errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`System` is a namespace, which is like an address for a type. To refer to someone''s
    location exactly, you might use `Oxford.HighStreet.BobSmith`, which tells us to
    look for a person named Bob Smith on the High Street in the city of Oxford.'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Console.WriteLine` tells the compiler to look for a method named `WriteLine`
    in a type named `Console` in a namespace named `System`. To simplify our code,
    the **Console Application** project template for every version of .NET before
    6.0 added a statement at the top of the code file to tell the compiler to always
    look in the `System` namespace for types that haven''t been prefixed with their
    namespace, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We call this *importing the namespace*. The effect of importing a namespace
    is that all available types in that namespace will be available to your program
    without needing to enter the namespace prefix and will be seen in IntelliSense
    while you write code.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Interactive notebooks have most namespaces imported automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly and globally importing namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Traditionally, every `.cs` file that needs to import namespaces would have
    to start with `using` statements to import those namespaces. Namespaces like `System`
    and `System.Linq` are needed in almost all `.cs` files, so the first few lines
    of every `.cs` file often had at least a few `using` statements, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When creating websites and services using ASP.NET Core, there are often dozens
    of namespaces that each file would have to import.
  prefs: []
  type: TYPE_NORMAL
- en: C# 10 introduces some new features that simplify importing namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `global using` statement means you only need to import a namespace
    in one `.cs` file and it will be available throughout all `.cs` files. You could
    put `global using` statements in the `Program.cs` file but I recommend creating
    a separate file for those statements named something like `GlobalUsings.cs` or
    `GlobalNamespaces.cs`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: As developers get used to this new C# feature, I expect
    one naming convention for this file to become the standard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, any projects that target .NET 6.0 and therefore use the C# 10 compiler
    generate a`.cs` file in the `obj` folder to implicitly globally import some common
    namespaces like `System`. The specific list of implicitly imported namespaces
    depends on which SDK you target, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SDK | Implicitly imported namespaces |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.NET.Sdk` | `System``System.Collections.Generic``System.IO``System.Linq``System.Net.Http``System.Threading``System.Threading.Tasks`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.NET.Sdk.Web` | Same as `Microsoft.NET.Sdk` and:`System.Net.Http.Json``Microsoft.AspNetCore.Builder``Microsoft.AspNetCore.Hosting``Microsoft.AspNetCore.Http``Microsoft.AspNetCore.Routing``Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Microsoft.NET.Sdk.Worker` | Same as `Microsoft.NET.Sdk` and:`Microsoft.Extensions.Configuration``Microsoft.Extensions.DependencyInjection``Microsoft.Extensions.Hosting``Microsoft.Extensions.Logging`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s see the current auto-generated implicit imports file:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer**, select the `Vocabulary` project, toggle on the **Show
    All Files** button, and note the compiler-generated `bin` and `obj` folders are
    visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net6.0` folder,
    and open the file named `Vocabulary.GlobalUsings.g.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note this file is automatically created by the compiler for projects that target
    .NET 6.0, and that it imports some commonly used namespaces including `System.Threading`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Close the `Vocabulary.GlobalUsings.g.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Solution Explorer**, select the project, and then add additional entries
    to the project file to control which namespaces are implicitly imported, as shown
    highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the changes to the project file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net6.0` folder,
    and open the file named `Vocabulary.GlobalUsings.g.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note this file now imports `System.Numerics` instead of `System.Threading`,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Close the `Vocabulary.GlobalUsings.g.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can disable the implicitly imported namespaces feature for all SDKs by
    removing an entry in the project file, as shown in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Verbs are methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In English, verbs are doing or action words, like run and jump. In C#, doing
    or action words are called **methods**. There are hundreds of thousands of methods
    available to C#. In English, verbs change how they are written based on when in
    time the action happens. For example, Amir *was jumping* in the past, Beth *jumps*
    in the present, they *jumped* in the past, and Charlie *will jump* in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, methods such as `WriteLine` change how they are called or executed based
    on the specifics of the action. This is called overloading, which we''ll cover
    in more detail in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*.
    But for now, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A different analogy is that some words are spelled the same but have different
    meanings depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: Nouns are types, variables, fields, and properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In English, nouns are names that refer to things. For example, Fido is the name
    of a dog. The word "dog" tells us the type of thing that Fido is, and so in order
    for Fido to fetch a ball, we would use his name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, their equivalents are **types**, **variables**, **fields**, and **properties**.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Animal` and `Car` are types; they are nouns for categorizing things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Head` and `Engine` might be fields or properties; nouns that belong to `Animal`
    and `Car`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fido` and `Bob` are variables; nouns for referring to a specific object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are tens of thousands of types available to C#, though have you noticed
    how I didn't say, "There are tens of thousands of types in C#?" The difference
    is subtle but important. The language of C# only has a few keywords for types,
    such as `string` and `int`, and strictly speaking, C# doesn't define any types.
    Keywords such as `string` that look like types are **aliases**, which represent
    types provided by the platform on which C# runs.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to know that C# cannot exist alone; after all, it's a language
    that runs on variants of .NET. In theory, someone could write a compiler for C#
    that uses a different platform, with different underlying types. In practice,
    the platform for C# is .NET, which provides tens of thousands of types to C#,
    including `System.Int32`, which is the C# keyword alias `int` maps to, as well
    as many more complex types, such as `System.Xml.Linq.XDocument`.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth taking note that the term **type** is often confused with **class**.
    Have you ever played the parlor game *Twenty Questions*, also known as *Animal,
    Vegetable, or Mineral*? In the game, everything can be categorized as an animal,
    vegetable, or mineral. In C#, every **type** can be categorized as a `class`,
    `struct`, `enum`, `interface`, or `delegate`. You will learn what these mean in
    *Chapter 6*, *Implementing Interfaces and Inheriting Classes*. As examples, the
    C# keyword `string` is a `class`, but `int` is a `struct`. So, it is best to use
    the term **type** to refer to both.
  prefs: []
  type: TYPE_NORMAL
- en: Revealing the extent of the C# vocabulary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that there are more than 100 keywords in C#, but how many types are
    there? Let's write some code to find out how many types (and their methods) are
    available to C# in our simple console application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry exactly how this code works for now but know that it uses a technique
    called **reflection**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by importing the `System.Reflection` namespace at the top of the
    `Program.cs` file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the statement that writes `Hello World!` and replace it with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code. You will see the actual number of types and methods that are
    available to you in the simplest application when running on your OS. The number
    of types and methods displayed will be different depending on the operating system
    that you are using, as shown in the following outputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why does the `System.Runtime` assembly contain zero types? This assembly is
    special because it contains only **type-forwarders** rather than actual types.
    A type-forwarder represents a type that has been implemented outside of .NET or
    for some other advanced reason.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add statements to the top of the file after importing the namespace to declare
    some variables, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By declaring variables that use types in other assemblies, those assemblies
    are loaded with our application, which allows our code to see all the types and
    methods in them. The compiler will warn you that you have unused variables but
    that won't stop your code from running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the console application again and view the results, which should look similar
    to the following outputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you have a better sense of why learning C# is a challenge, because there
    are so many types and methods to learn. Methods are only one category of a member
    that a type can have, and you and other programmers are constantly defining new
    types and members!
  prefs: []
  type: TYPE_NORMAL
- en: Working with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All applications process data. Data comes in, data is processed, and then data
    goes out.
  prefs: []
  type: TYPE_NORMAL
- en: Data usually comes into our program from files, databases, or user input, and
    it can be put temporarily into variables that will be stored in the memory of
    the running program. When the program ends, the data in memory is lost. Data is
    usually output to files and databases, or to the screen or a printer. When using
    variables, you should think about, firstly, how much space the variable takes
    in the memory, and, secondly, how fast it can be processed.
  prefs: []
  type: TYPE_NORMAL
- en: We control this by picking an appropriate type. You can think of simple common
    types such as `int` and `double` as being different-sized storage boxes, where
    a smaller box would take less memory but may not be as fast at being processed;
    for example, adding 16-bit numbers might not be processed as fast as adding 64-bit
    numbers on a 64-bit operating system. Some of these boxes may be stacked close
    by, and some may be thrown into a big heap further away.
  prefs: []
  type: TYPE_NORMAL
- en: Naming things and assigning values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are naming conventions for things, and it is good practice to follow
    them, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Naming convention | Examples | Used for |'
  prefs: []
  type: TYPE_TB
- en: '| Camel case | `cost`, `orderDetail`, `dateOfBirth` | Local variables, private
    fields |'
  prefs: []
  type: TYPE_TB
- en: '| Title case aka Pascal case | `String`, `Int32`, `Cost`, `DateOfBirth`, `Run`
    | Types, non-private fields, and other members like methods |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice**: Following a consistent set of naming conventions will enable
    your code to be easily understood by other developers (and yourself in the future!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows an example of declaring a named local variable
    and assigning a value to it with the `=` symbol. You should note that you can
    output the name of a variable using a keyword introduced in C# 6.0, `nameof`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The message in double quotes in the preceding code wraps onto a second line
    because the width of a printed page is too narrow. When entering a statement like
    this in your code editor, type it all in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Literal values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you assign to a variable, you often, but not always, assign a **literal**
    value. But what is a literal value? A literal is a notation that represents a
    fixed value. Data types have different notations for their literal values, and
    over the next few sections, you will see examples of using literal notation to
    assign values to variables.
  prefs: []
  type: TYPE_NORMAL
- en: Storing text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For text, a single letter, such as an `A`, is stored as a `char` type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Actually, it can be more complicated than that. Egyptian
    Hieroglyph A002 (U+13001) needs two `System.Char` values (known as surrogate pairs)
    to represent it: `\uD80C` and `\uDC01`. Do not always assume one `char` equals
    one letter or you could introduce weird bugs into your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `char` is assigned using single quotes around the literal value, or assigning
    the return value of a fictitious function call, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For text, multiple letters, such as `Bob`, are stored as a `string` type and
    are assigned using double quotes around the literal value, or assigning the return
    value of a function call, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Understanding verbatim strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When storing text in a `string` variable, you can include escape sequences,
    which represent special characters like tabs and new lines using a backslash,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: But what if you are storing the path to a file on Windows, and one of the folder
    names starts with a `T`, as shown in the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will convert the `\t` into a tab character and you will get errors!
  prefs: []
  type: TYPE_NORMAL
- en: 'You must prefix with the `@` symbol to use a verbatim literal `string`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Literal string**: Characters enclosed in double-quote characters. They can
    use escape characters like `\t` for tab. To represent a backslash, use two: `\\`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verbatim string**: A literal string prefixed with `@` to disable escape characters
    so that a backslash is a backslash. It also allows the `string` value to span
    multiple lines because the white space characters are treated as themselves instead
    of instructions to the compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpolated string**: A literal string prefixed with `$` to enable embedded
    formatted variables. You will learn more about this later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers are data that we want to perform an arithmetic calculation on, for example,
    multiplying. A telephone number is not a number. To decide whether a variable
    should be stored as a number or not, ask yourself whether you need to perform
    arithmetic operations on the number or whether the number includes non-digit characters
    such as parentheses or hyphens to format the number, such as (414) 555-1234\.
    In this case, the number is a sequence of characters, so it should be stored as
    a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers can be natural numbers, such as 42, used for counting (also called whole
    numbers); they can also be negative numbers, such as -42 (called integers); or,
    they can be real numbers, such as 3.9 (with a fractional part), which are called
    single- or double-precision floating-point numbers in computing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new **Console Application** to the
    `Chapter02` workspace/solution named `Numbers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Numbers` as the active OmniSharp project. When
    you see the pop-up warning message saying that required assets are missing, click
    **Yes** to add them.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project to the current selection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing code and then type statements to declare
    some number variables using various data types, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Storing whole numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might know that computers store everything as bits. The value of a bit is
    either 0 or 1\. This is called a **binary number system**. Humans use a **decimal
    number system**.
  prefs: []
  type: TYPE_NORMAL
- en: The decimal number system, also known as Base 10, has 10 as its **base**, meaning
    there are ten digits, from 0 to 9\. Although it is the number base most commonly
    used by human civilizations, other number base systems are popular in science,
    engineering, and computing. The binary number system, also known as Base 2, has
    two as its base, meaning there are two digits, 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows how computers store the decimal number 10\. Take
    note of the bits with the value 1 in the 8 and 2 columns; 8 + 2 = 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: So, `10` in decimal is `00001010` in binary.
  prefs: []
  type: TYPE_NORMAL
- en: Improving legibility by using digit separators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two of the improvements seen in C# 7.0 and later are the use of the underscore
    character `_` as a digit separator, and support for binary literals.
  prefs: []
  type: TYPE_NORMAL
- en: You can insert underscores anywhere into the digits of a number literal, including
    decimal, binary, or hexadecimal notation, to improve legibility.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could write the value for 1 million in decimal notation, that
    is, Base 10, as `1_000_000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even use the 2/3 grouping common in India: `10_00_000`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using binary notation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use binary notation, that is, Base 2, using only 1s and 0s, start the number
    literal with `0b`. To use hexadecimal notation, that is, Base 16, using 0 to 9
    and A to F, start the number literal with `0x`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring whole numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s enter some code to see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare some number variables using underscore
    separators, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result is that all three numbers are the same, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Computers can always exactly represent integers using the `int` type or one
    of its sibling types, such as `long` and `short`.
  prefs: []
  type: TYPE_NORMAL
- en: Storing real numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computers cannot always represent real, aka decimal or non-integer, numbers
    precisely. The `float` and `double` types store real numbers using single- and
    double-precision floating points.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages implement the IEEE Standard for Floating-Point Arithmetic.
    IEEE 754 is a technical standard for floating-point arithmetic established in
    1985 by the **Institute of Electrical and Electronics Engineers** (**IEEE**).
  prefs: []
  type: TYPE_NORMAL
- en: The following table shows a simplification of how a computer represents the
    number `12.75` in binary notation. Note the bits with the value `1` in the 8,
    4, Â½, and Â¼ columns.
  prefs: []
  type: TYPE_NORMAL
- en: 8 + 4 + Â½ + Â¼ = 12Â¾ = 12.75.
  prefs: []
  type: TYPE_NORMAL
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | . | Â½ | Â¼ | 1/8 | 1/16 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 1 | 1 | 0 | 0 | . | 1 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: So, `12.75` in decimal is `00001100.1100` in binary. As you can see, the number
    `12.75` can be exactly represented using bits. However, some numbers can't, something
    that we'll be exploring shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code to explore number sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# has an operator named `sizeof()` that returns the number of bytes that a
    type uses in memory. Some types have members named `MinValue` and `MaxValue`,
    which return the minimum and maximum values that can be stored in a variable of
    that type. We are now going to use these features to create a console application
    to explore number types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to show the size of three number data types,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The width of the printed pages in this book makes the `string` values (in double
    quotes) wrap over multiple lines. You must type them on a single line, or you
    will get compile errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the code and view the output, as shown in *Figure 2.3*:![](img/B17442_02_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.3: Size and range information for common number data types'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An `int` variable uses four bytes of memory and can store positive or negative
    numbers up to about 2 billion. A `double` variable uses eight bytes of memory
    and can store much bigger values! A `decimal` variable uses 16 bytes of memory
    and can store big numbers, but not as big as a `double` type.
  prefs: []
  type: TYPE_NORMAL
- en: But you may be asking yourself, why might a `double` variable be able to store
    bigger numbers than a `decimal` variable, yet it's only using half the space in
    memory? Well, let's now find out!
  prefs: []
  type: TYPE_NORMAL
- en: Comparing double and decimal types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will now write some code to compare `double` and `decimal` values. Although
    it isn''t hard to follow, don''t worry about understanding the syntax right now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare two `double` variables, add them together and compare
    them to the expected result, and write the result to the console, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In locales that use a comma for the decimal separator the result will look
    slightly different, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `double` type is not guaranteed to be accurate because some numbers like
    `0.1` literally cannot be represented as floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, you should only use `double` when accuracy, especially when
    comparing the equality of two numbers, is not important. An example of this may
    be when you're measuring a person's height and you will only compare values using
    greater than or less than, but never equals.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the preceding code is illustrated by how the computer stores
    the number `0.1`, or multiples of it. To represent `0.1` in binary, the computer
    stores 1 in the 1/16 column, 1 in the 1/32 column, 1 in the 1/256 column, 1 in
    the 1/512 column, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number `0.1` in decimal is `0.00011001100110011`â€¦ in binary, repeating
    forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 4 | 2 | 1 | . | Â½ | Â¼ | 1/8 | 1/16 | 1/32 | 1/64 | 1/128 | 1/256 | 1/512
    | 1/1024 | 1/2048 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | . | 0 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice**: Never compare `double` values using `==`. During the First
    Gulf War, an American Patriot missile battery used `double` values in its calculations.
    The inaccuracy caused it to fail to track and intercept an incoming Iraqi Scud
    missile, and 28 soldiers were killed; you can read about this at [https://www.ima.umn.edu/~arnold/disasters/patriot.html](https://www.ima.umn.edu/~arnold/disasters/patriot.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste the statements that you wrote before (that used the `double`
    variables).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the statements to use `decimal` and rename the variables to `c` and
    `d`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `decimal` type is accurate because it stores the number as a large integer
    and shifts the decimal point. For example, `0.1` is stored as `1`, with a note
    to shift the decimal point one place to the left. `12.75` is stored as `1275`,
    with a note to shift the decimal point two places to the left.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use `int` for whole numbers. Use `double` for real numbers
    that will not be compared for equality to other values; it is okay to compare
    `double` values being less than or greater than, and so on. Use `decimal` for
    money, CAD drawings, general engineering, and wherever the accuracy of a real
    number is important.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `double` type has some useful special values: `double.NaN` represents not-a-number
    (for example, the result of dividing by zero), `double.Epsilon` represents the
    smallest positive number that can be stored in a `double`, and `double.PositiveInfinity`
    and `double.NegativeInfinity` represent infinitely large positive and negative
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Booleans can only contain one of the two literal values `true` or `false`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: They are most commonly used to branch and loop. You don't need to fully understand
    them yet, as they are covered more in *Chapter 3*, *Controlling Flow, Converting
    Types, and Handling Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: Storing any type of object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a special type named `object` that can store any type of data, but
    its flexibility comes at the cost of messier code and possibly poor performance.
    Because of those two reasons, you should avoid it whenever possible. The following
    steps show how to use object types if you need to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Variables`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Variables` as the active OmniSharp project. When
    you see the pop-up warning message saying that required assets are missing, click
    **Yes** to add them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare and use some variables using the
    `object` type, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code and note that the fourth statement cannot compile because the data
    type of the `name` variable is not known by the compiler, as shown in *Figure
    2.4*:![](img/B17442_02_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.4: The object type does not have a Length property'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add comment double slashes to the beginning of the statement that cannot compile
    to "comment out" the statement to make it inactive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code again and note that the compiler can access the length of a `string`
    if the programmer explicitly tells the compiler that the `object` variable contains
    a `string` by prefixing with a cast expression like `(string)`, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `object` type has been available since the first version of C#, but C# 2.0
    and later have a better alternative called **generics**, which we will cover in
    *Chapter 6*, *Implementing Interfaces and Inheriting Classes*, which will provide
    us with the flexibility we want, but without the performance overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Storing dynamic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another special type named `dynamic` that can also store any type
    of data, but even more than `object`, its flexibility comes at the cost of performance.
    The `dynamic` keyword was introduced in C# 4.0\. However, unlike `object`, the
    value stored in the variable can have its members invoked without an explicit
    cast. Let''s make use of a `dynamic` type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to declare a `dynamic` variable and then assign a `string` literal
    value, and then an integer value, and then an array of integer values, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a statement to output the length of the `dynamic` variable, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note it works because a `string` value does have a `Length`
    property, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Uncomment the statement that assigns an `int` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and note the runtime error because `int` does not have a `Length`
    property, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Uncomment the statement that assigns the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and note the output because an array of three `int` values does
    have a `Length` property, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One limitation of `dynamic` is that code editors cannot show IntelliSense to
    help you write the code. This is because the compiler cannot check what the type
    is during build time. Instead, the CLR checks for the member at runtime and throws
    an exception if it is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are a way to indicate that something has gone wrong at runtime. You
    will learn more about them and how to handle them in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring local variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Local variables are declared inside methods, and they only exist during the
    execution of that method, and once the method returns, the memory allocated to
    any local variables is released.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, value types are released while reference types must wait
    for a garbage collection. You will learn about the difference between value types
    and reference types in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the type of a local variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explore local variables declared with specific types and using type
    inference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare and assign values to some local variables using
    specific types, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on your code editor and color scheme, it will show green squiggles
    under each of the variable names and lighten their text color to warn you that
    the variable is assigned but its value is never used.
  prefs: []
  type: TYPE_NORMAL
- en: Inferring the type of a local variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the `var` keyword to declare local variables. The compiler will
    infer the type from the value that you assign after the assignment operator, `=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A literal number without a decimal point is inferred as an `int` variable,
    that is, unless you add a suffix, as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`L`: infers `long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UL`: infers `ulong`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: infers `decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D`: infers `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F`: infers `float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A literal number with a decimal point is inferred as `double` unless you add
    the `M` suffix, in which case, it infers a `decimal` variable, or the `F` suffix,
    in which case, it infers a `float` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double quotes indicate a `string` variable, single quotes indicate a `char`
    variable, and the `true` and `false` values infer a `bool` type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the previous statements to use `var`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hover your mouse over each of the `var` keywords and note that your code editor
    shows a tooltip with information about the type that has been inferred.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the class file, import the namespace for working with XML to
    enable us to declare some variables using types in that namespace, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: If you are using .NET Interactive Notebooks, then add `using`
    statements in a separate code cell above the code cell where you write the main
    code. Then click **Execute Cell** to ensure the namespaces are imported. They
    will then be available in subsequent code cells.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under the previous statements, add statements to create some new objects, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Although using `var` is convenient, some developers avoid
    using it, to make it easier for a code reader to understand the types in use.
    Personally, I use it only when the type is obvious. For example, in the preceding
    code statements, the first statement is just as clear as the second in stating
    what the type of the `xml` variables are, but it is shorter. However, the third
    statement isn''t clear in showing the type of the `file` variable, so the fourth
    is better because it shows that the type is `StreamWriter`. If in doubt, spell
    it out!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using target-typed new to instantiate objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With C# 9, Microsoft introduced another syntax for instantiating objects known
    as **target-typed new**. When instantiating an object, you can specify the type
    first and then use `new` without repeating the type, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a type with a field or property that needs to be set, then the
    type can be inferred, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Use target-typed new to instantiate objects unless you must
    use a pre-version 9 C# compiler. I have used target-typed new throughout the rest
    of this book. Please let me know if you spot any cases that I missed!'
  prefs: []
  type: TYPE_NORMAL
- en: Getting and setting the default values for types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the primitive types except `string` are **value types**, which means
    that they must have a value. You can determine the default value of a type by
    using the `default()` operator and passing the type as a parameter. You can assign
    the default value of a type by using the `default` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `string` type is a **reference type**. This means that `string` variables
    contain the memory address of a value, not the value itself. A reference type
    variable can have a `null` value, which is a literal that indicates that the variable
    does not reference anything (yet). `null` is the default for all reference types.
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn more about value types and reference types in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore default values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to show the default values of an `int`, `bool`, `DateTime`,
    and `string`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, noting that your output for the date and
    time might be formatted differently if you are not running it in the UK, and that
    `null` values output as an empty `string`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to declare a number, assign a value, and then reset it to its
    default value, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Storing multiple values in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you need to store multiple values of the same type, you can declare an
    **array**. For example, you may do this when you need to store four names in a
    `string` array.
  prefs: []
  type: TYPE_NORMAL
- en: The code that you will write next will allocate memory for an array for storing
    four `string` values. It will then store `string` values at index positions 0
    to 3 (arrays usually have a lower bound of zero, so the index of the last item
    is one less than the length of the array).
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Do not assume that all arrays count from zero. The most
    common type of array in .NET is an **szArray**, a single-dimension zero-indexed
    array, and these use the normal `[]` syntax. But .NET also has **mdArray**, a
    multi-dimensional array, and they do not have to have a lower bound of zero. These
    are rarely used but you should know they exist.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it will loop through each item in the array using a `for` statement,
    something that we will cover in more detail in *Chapter 3*, *Controlling Flow,
    Converting Types, and Handling Exceptions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use an array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to declare and use an array of `string` values, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Arrays are always of a fixed size at the time of memory allocation, so you need
    to decide how many items you want to store before instantiating them.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to defining the array in three steps as above is to use array
    initializer syntax, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When you use the `new[]` syntax to allocate memory for the array, you must have
    at least one item in the curly braces so that the compiler can infer the data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are useful for temporarily storing multiple items, but collections are
    a more flexible option when adding and removing items dynamically. You don't need
    to worry about collections right now, as we will cover them in *Chapter 8*, *Working
    with Common .NET Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring more about console applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already created and used basic console applications, but we're now at
    a stage where we should delve into them more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Console applications are text-based and are run at the command line. They typically
    perform simple tasks that need to be scripted, such as compiling a file or encrypting
    a section of a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Equally, they can also have arguments passed to them to control their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this would be to create a new console app using the F# language
    with a specified name instead of using the name of the current folder, as shown
    in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Displaying output to the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two most common tasks that a console application performs are writing and
    reading data. We have already been using the `WriteLine` method to output, but
    if we didn't want a carriage return at the end of the lines, we could have used
    the `Write` method.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting using numbered positional arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way of generating formatted strings is to use numbered positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is supported by methods like `Write` and `WriteLine`, and for methods
    that do not support the feature, the `string` parameter can be formatted using
    the `Format` method of `string`.
  prefs: []
  type: TYPE_NORMAL
- en: The first few code examples in this section will work with a .NET Interactive
    notebook because they are about outputting to the console. Later in this section,
    you will learn about getting input via the console and sadly notebooks do not
    support this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Formatting`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Formatting` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to declare some number variables and write
    them to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `WriteToFile` method is a nonexistent method used to illustrate the idea.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Once you become more comfortable with formatting strings,
    you should stop naming the parameters, for example, stop using `format:`, `arg0:`,
    and `arg1:`. The preceding code uses a non-canonical style to show where the `0`
    and `1` came from while you are learning.'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting using interpolated strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C# 6.0 and later have a handy feature named **interpolated strings**. A `string`
    prefixed with `$` can use curly braces around the name of a variable or expression
    to output the current value of that variable or expression at that position in
    the `string`, as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a statement at the bottom of the `Program.cs` file, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For short, formatted `string` values, an interpolated `string` can be easier
    for people to read. But for code examples in a book, where lines need to wrap
    over multiple lines, this can be tricky. For many of the code examples in this
    book, I will use numbered positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to avoid interpolated strings is that they can't be read from
    resource files to be localized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before C# 10, string constants could only be combined by using concatenation,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'With C# 10, interpolated strings can now be used, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This only works for combining string constant values. It cannot work with other
    types like numbers that would require runtime data type conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding format strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variable or expression can be formatted using a format string after a comma
    or colon.
  prefs: []
  type: TYPE_NORMAL
- en: An `N0` format string means a number with a thousand separators and no decimal
    places, while a `C` format string means currency. The currency format will be
    determined by the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you run this code on a PC in the UK, you'll get pounds sterling
    with commas as the thousand separators, but if you run this code on a PC in Germany,
    you will get euros with dots as the thousand separators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full syntax of a format item is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Each format item can have an alignment, which is useful when outputting tables
    of values, some of which might need to be left- or right-aligned within a width
    of characters. Alignment values are integers. Positive integers mean right-aligned
    and negative integers mean left-aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to output a table of fruit and how many of each there are, we
    might want to left-align the names within a column of 10 characters and right-align
    the counts formatted as numbers with zero decimal places within a column of six
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, enter the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the effect of the alignment and number format, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting text input from the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can get text input from the user using the `ReadLine` method. This method
    waits for the user to type some text, then as soon as the user presses Enter,
    whatever the user has typed is returned as a `string` value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If you are using a .NET Interactive notebook for this section,
    then note that it does not support reading input from the console using `Console.ReadLine()`.
    Instead, you must set literal values, as shown in the following code: `string?
    firstName = "Gary";`. This is often quicker to experiment with because you can
    simply change the literal `string` value and click the **Execute Cell** button
    instead of having to restart a console app each time you want to enter a different
    `string` value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get input from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to ask the user for their name and age and then output what
    they entered, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, and then enter a name and age, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The question marks at the end of the `string?` data type declaration indicate
    that we acknowledge that a `null` (empty) value could be returned from the call
    to `ReadLine`. You will learn more about this in *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the usage of the console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C# 6.0 and later, the `using` statement can be used not only to import a
    namespace but also to further simplify our code by importing a static class. Then,
    we won''t need to enter the `Console` type name throughout our code. You can use
    your code editor''s find and replace feature to remove the times we have previously
    written `Console`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `Program.cs` file, add a statement to **statically import**
    the `System.Console` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Select the first `Console.` in your code, ensuring that you select the dot after
    the word `Console` too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Edit** | **Find and Replace** | **Quick Replace**,
    or in Visual Studio Code, navigate to **Edit** | **Replace**, and note that an
    overlay dialog appears ready for you to enter what you would like to replace **Console.**
    with, as shown in *Figure 2.5*:![](img/B17442_02_05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.5: Using the Replace feature in Visual Studio to simplify your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Leave the replace box empty, click on the **Replace all** button (the second
    of the two buttons to the right of the replace box), and then close the replace
    box by clicking on the cross in its top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting key input from the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can get key input from the user using the `ReadKey` method. This method waits
    for the user to press a key or key combination that is then returned as a `ConsoleKeyInfo`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will not be able to execute the call to the `ReadKey` method using a .NET
    Interactive notebook, but if you have created a console application, then let''s
    explore reading key presses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to ask the user to press any key combination and then output
    information about it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, press the K key, and note the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, hold down Shift and press the K key, and note the result, as
    shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, press the F12 key, and note the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When running a console application in a terminal within Visual Studio Code,
    some keyboard combinations will be captured by the code editor or operating system
    before they can be processed by your app.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to a console app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have been wondering how to get any arguments that might be passed
    to a console application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In every version of .NET prior to version 6.0, the console application project
    template made it obvious, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `string[] args` arguments are declared and passed in the `Main` method of
    the `Program` class. They're an array used to pass arguments into a console application.
    But in top-level programs, as used by the console application project template
    in .NET 6.0 and later, the `Program` class and its `Main` method are hidden, along
    with the declaration of the `args` string array. The trick is that you must know
    it still exists.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line arguments are separated by spaces. Other characters like hyphens
    and colons are treated as part of an argument value.
  prefs: []
  type: TYPE_NORMAL
- en: To include spaces in an argument value, enclose the argument value in single
    or double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to be able to enter the names of some colors for the foreground
    and background, and the dimensions of the terminal window at the command line.
    We would be able to read the colors and numbers by reading them from the `args`
    array, which is always passed into the `Main` method aka the entry point of a
    console application:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console Application** to the `Chapter02`
    workspace/solution named `Arguments`. You will not be able to use a .NET Interactive
    notebook because you cannot pass arguments to a notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Arguments` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a statement to statically import the `System.Console` type and a statement
    to output the number of arguments passed to the application, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Remember to statically import the `System.Console` type
    in all future projects to simplify your code, as these instructions will not be
    repeated every time.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using Visual Studio, then navigate to **Project** | **Arguments**
    **Properties**, select the **Debug** tab, and in the **Application arguments**
    box, enter some arguments, save the changes, and then run the console application,
    as shown in *Figure 2.6*:![Graphical user interface, text, application  Description
    automatically generated](img/B17442_02_06.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.6: Entering application arguments in Visual Studio project properties'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio Code, then in a terminal, enter some arguments
    after the `dotnet run` command, as shown in the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the result indicates four arguments, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enumerate or iterate (that is, loop through) the values of those four arguments,
    add the following statements after outputting the length of the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again and note the result shows the details of the four arguments,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting options with arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now use these arguments to allow the user to pick a color for the background,
    foreground, and cursor size of the output window. The cursor size can be an integer
    value from 1, meaning a line at the bottom of the cursor cell, up to 100, meaning
    a percentage of the height of the cursor cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `System` namespace is already imported so that the compiler knows about
    the `ConsoleColor` and `Enum` types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to warn the user if they do not enter three arguments and then
    parse those arguments and use them to set the color and dimensions of the console
    window, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting the `CursorSize` is only supported on Windows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Visual Studio, navigate to **Project** | **Arguments Properties**, and change
    the arguments to: `red yellow 50`, run the console app, and note the cursor is
    half the size and the colors have changed in the window, as shown in *Figure 2.7*:![Graphical
    user interface, application, website  Description automatically generated](img/B17442_02_07.png)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 2.7: Setting colors and cursor size on Windows'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, run the code with arguments to set the foreground color
    to red, the background color to yellow, and the cursor size to 50%, as shown in
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On macOS, you''ll see an unhandled exception, as shown in *Figure 2.8*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B17442_02_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2.8: An unhandled exception on unsupported macOS'
  prefs: []
  type: TYPE_NORMAL
- en: Although the compiler did not give an error or warning, at runtime some API
    calls may fail on some platforms. Although a console application running on Windows
    can change its cursor size, on macOS, it cannot, and complains if you try.
  prefs: []
  type: TYPE_NORMAL
- en: Handling platforms that do not support an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So how do we solve this problem? We can solve this by using an exception handler.
    You will learn more details about the `try-catch` statement in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*, so for now, just enter the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the code to wrap the lines that change the cursor size in a `try` statement,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you were to run the code on macOS then you would see the exception is caught,
    and a friendlier message is shown to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to handle differences in operating systems is to use the `OperatingSystem`
    class in the `System` namespace, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `OperatingSystem` class has equivalent methods for other common operating
    systems like Android, iOS, Linux, macOS, and even the browser, which is useful
    for Blazor web components.
  prefs: []
  type: TYPE_NORMAL
- en: A third way to handle different platforms is to use conditional compilation
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four preprocessor directives that control conditional compilation:
    `#if`, `#elif`, `#else`, and `#endif`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You define symbols using `#define`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Many symbols are automatically defined for you, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Target Framework | Symbols |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Standard | `NETSTANDARD2_0`, `NETSTANDARD2_1`, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| Modern .NET | `NET6_0`, `NET6_0_ANDROID`, `NET6_0_IOS`, `NET6_0_WINDOWS`,
    and so on |'
  prefs: []
  type: TYPE_TB
- en: 'You can then write statements that will compile only for the specified platforms,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore the topics covered in this chapter with deeper
    research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.1 â€“ Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get the best answer to some of these questions, you will need to do your
    own research. I want you to "think outside the book" so I have deliberately not
    provided all the answers in the book.
  prefs: []
  type: TYPE_NORMAL
- en: I want to encourage you to get in to the good habit of looking for help elsewhere,
    following the principle of "teach a person to fish."
  prefs: []
  type: TYPE_NORMAL
- en: What statement can you type in a C# file to discover the compiler and language
    version?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two types of comments in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a verbatim string and an interpolated string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you be careful when using `float` and `double` values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you determine how many bytes a type like `double` uses in memory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `var` keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the newest way to create an instance of a class like `XmlDocument`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you be careful when using the `dynamic` type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you right-align a format string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What character separates arguments for a console application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Appendix*, *Answers to the Test Your Knowledge Questions* is available to
    download from a link in the README on the GitHub repository: [https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise 2.2 â€“ Test your knowledge of number types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What type would you choose for the following "numbers"?
  prefs: []
  type: TYPE_NORMAL
- en: A person's telephone number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A person's height
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A person's age
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A person's salary
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A book's ISBN
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A book's price
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A book's shipping weight
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A country's population
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of stars in the universe
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of employees in each of the small or medium businesses in the United
    Kingdom (up to about 50,000 employees per business)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 2.3 â€“ Practice number sizes and ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter02` solution/workspace, create a console application project
    named `Exercise02` that outputs the number of bytes in memory that each of the
    following number types uses and the minimum and maximum values they can have:
    `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`,
    and `decimal`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of running your console application should look something like *Figure
    2.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B17442_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: The result of outputting number type sizes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code solutions for all exercises are available to download or clone from the
    GitHub repository at the following link: [https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.4 â€“ Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-2---speaking-c)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare variables with a specified or an inferred type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use some of the built-in types for numbers, text, and Booleans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose between number types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control output formatting in console apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about operators, branching, looping, converting
    between types, and how to handle exceptions.
  prefs: []
  type: TYPE_NORMAL
