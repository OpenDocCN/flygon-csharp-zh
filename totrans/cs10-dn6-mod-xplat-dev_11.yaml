- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Querying and Manipulating Data Using LINQ
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LINQ查询和操作数据
- en: This chapter is about **Language INtegrated Query** (**LINQ**) expressions.
    LINQ is a set of language extensions that add the ability to work with sequences
    of items and then filter, sort, and project them into different outputs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于**语言集成查询**（**LINQ**）表达式的。LINQ是一系列语言扩展，它增加了处理项目序列的能力，然后对其进行过滤、排序，并将其投影到不同的输出中。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Writing LINQ expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写LINQ表达式
- en: Working with sets using LINQ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ处理集合
- en: Using LINQ with EF Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将LINQ与EF Core结合使用
- en: Sweetening LINQ syntax with syntactic sugar
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用语法糖美化LINQ语法
- en: Using multiple threads with parallel LINQ
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行LINQ进行多线程处理
- en: Creating your own LINQ extension methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的LINQ扩展方法
- en: Working with LINQ to XML
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ to XML
- en: Writing LINQ expressions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写LINQ表达式
- en: Although we wrote a few LINQ expressions in *Chapter 10*, *Working with Data
    Using Entity Framework Core*, they weren't the focus, and so I didn't properly
    explain how LINQ works, so let's now take time to properly understand them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在*第10章*，*使用Entity Framework Core处理数据*中写了一些LINQ表达式，但它们并非重点，因此我没有适当地解释LINQ的工作原理，所以现在让我们花时间来正确理解它们。
- en: What makes LINQ?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何为LINQ？
- en: 'LINQ has several parts; some are required, and some are optional:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ包含多个部分；有些是必选的，有些是可选的：
- en: '**Extension methods (required)**: These include examples such as `Where`, `OrderBy`,
    and `Select`. These are what provide the functionality of LINQ.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展方法（必选）**：这些包括`Where`、`OrderBy`和`Select`等示例。正是这些方法提供了LINQ的功能。'
- en: '**LINQ providers (required)**: These include LINQ to Objects for processing
    in-memory objects, LINQ to Entities for processing data stored in external databases
    and modeled with EF Core, and LINQ to XML for processing data stored as XML. These
    providers are what execute LINQ expressions in a way specific to different types
    of data.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ提供程序（必选）**：这些包括用于处理内存中对象的LINQ to Objects、用于处理存储在外部数据库中并由EF Core建模的数据的LINQ
    to Entities，以及用于处理存储为XML的数据的LINQ to XML。这些提供程序是针对不同类型的数据执行LINQ表达式的方式。'
- en: '**Lambda expressions (optional)**: These can be used instead of named methods
    to simplify LINQ queries, for example, for the conditional logic of the `Where`
    method for filtering.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda表达式（可选）**：这些可以用来代替命名方法来简化LINQ查询，例如，用于`Where`方法的过滤条件逻辑。'
- en: '**LINQ query comprehension syntax (optional)**: These include C# keywords like
    `from`, `in`, `where`, `orderby`, `descending`, and `select`. These are aliases
    for some of the LINQ extension methods, and their use can simplify the queries
    you write, especially if you already have experience with other query languages,
    such as **Structured Query Language** (**SQL**).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LINQ查询理解语法（可选）**：这些包括`from`、`in`、`where`、`orderby`、`descending`和`select`等C#关键字。它们是一些LINQ扩展方法的别名，使用它们可以简化你编写的查询，特别是如果你已经有其他查询语言（如**结构化查询语言**（**SQL**））的经验。'
- en: When programmers are first introduced to LINQ, they often believe that LINQ
    query comprehension syntax is LINQ, but ironically, that is one of the parts of
    LINQ that is optional!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员首次接触LINQ时，他们常常认为LINQ查询理解语法就是LINQ，但讽刺的是，这是LINQ中可选的部分之一！
- en: Building LINQ expressions with the Enumerable class
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Enumerable类构建LINQ表达式
- en: The LINQ extension methods, such as `Where` and `Select`, are appended by the
    `Enumerable` static class to any type, known as a **sequence**, that implements
    `IEnumerable<T>`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ扩展方法，如`Where`和`Select`，由`Enumerable`静态类附加到任何实现`IEnumerable<T>`的类型，这种类型被称为**序列**。
- en: For example, an array of any type implements the `IEnumerable<T>` class, where
    `T` is the type of item in the array. This means that all arrays support LINQ
    to query and manipulate them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何类型的数组都实现了`IEnumerable<T>`类，其中`T`是数组中项目的类型。这意味着所有数组都支持LINQ来查询和操作它们。
- en: All generic collections, such as `List<T>`, `Dictionary<TKey, TValue>`, `Stack<T>`,
    and `Queue<T>`, implement `IEnumerable<T>`, so they can be queried and manipulated
    with LINQ too.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有泛型集合，如`List<T>`、`Dictionary<TKey, TValue>`、`Stack<T>`和`Queue<T>`，都实现了`IEnumerable<T>`，因此它们也可以用LINQ进行查询和操作。
- en: '`Enumerable` defines more than 50 extension methods, as summarized in the following
    table:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable`定义了超过50个扩展方法，如下表总结：'
- en: '| Method(s) | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 方法(s) | 描述 |'
- en: '| `First`, `FirstOrDefault`, `Last`, `LastOrDefault` | Get the first or last
    item in the sequence or throw an exception, or return the default value for the
    type, for example, `0` for an `int` and `null` for a reference type, if there
    is not a first or last item. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `First`, `FirstOrDefault`, `Last`, `LastOrDefault` | 获取序列中的第一个或最后一个项，如果没有则抛出异常，或者返回类型的默认值，例如，`int`的`0`和引用类型的`null`。'
- en: '| `Where` | Return a sequence of items that match a specified filter. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `Where` | 返回与指定筛选器匹配的项序列。'
- en: '| `Single`, `SingleOrDefault` | Return an item that matches a specific filter
    or throw an exception, or return the default value for the type if there is not
    exactly one match. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `Single`, `SingleOrDefault` | 返回与特定筛选器匹配的项，如果没有恰好一个匹配项，则抛出异常，或者返回类型的默认值。'
- en: '| `ElementAt`, `ElementAtOrDefault` | Return an item at a specified index position
    or throw an exception, or return the default value for the type if there is not
    an item at that position. New in .NET 6 are overloads that can be passed an `Index`
    instead of an `int`, which is more efficient when working with `Span<T>` sequences.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `ElementAt`, `ElementAtOrDefault` | 返回指定索引位置的项，如果没有该位置的项，则抛出异常，或者返回类型的默认值。.NET
    6 中新增了可以传入`Index`而不是`int`的重载，这在处理`Span<T>`序列时更高效。'
- en: '| `Select`, `SelectMany` | Project items into a different shape, that is, a
    different type, and flatten a nested hierarchy of items. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `Select`, `SelectMany` | 将项投影到不同形状，即不同类型，并展平嵌套的项层次结构。'
- en: '| `OrderBy`, `OrderByDescending`, `ThenBy`, `ThenByDescending` | Sort items
    by a specified field or property. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `OrderBy`, `OrderByDescending`, `ThenBy`, `ThenByDescending` | 按指定字段或属性排序项。'
- en: '| `Reverse` | Reverse the order of the items. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Reverse` | 反转项的顺序。'
- en: '| `GroupBy`, `GroupJoin`, `Join` | Group and/or join two sequences. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `GroupBy`, `GroupJoin`, `Join` | 对两个序列进行分组和/或连接。'
- en: '| `Skip`, `SkipWhile` | Skip a number of items; or skip while an expression
    is `true`. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `Skip`, `SkipWhile` | 跳过一定数量的项；或在表达式为`true`时跳过。'
- en: '| `Take`, `TakeWhile` | Take a number of items; or take while an expression
    is `true`. New in .NET 6 is a `Take` overload that can be passed a `Range`, for
    example, `Take(range: 3..^5)` meaning take a subset starting 3 items in from the
    start and ending 5 items in from the end, or instead of `Skip(4)` you could use
    `Take(4..)`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `Take`, `TakeWhile` | 获取一定数量的项；或在表达式为`true`时获取。.NET 6 中新增了`Take`的重载，可以传入一个`Range`，例如，`Take(range:
    3..^5)`表示从开始处算起第3项到结束处算起第5项的子集，或者可以用`Take(4..)`代替`Skip(4)`。'
- en: '| `Aggregate`, `Average`, `Count`, `LongCount`, `Max`, `Min`, `Sum` | Calculate
    aggregate values. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `Aggregate`, `Average`, `Count`, `LongCount`, `Max`, `Min`, `Sum` | 计算聚合值。'
- en: '| `TryGetNonEnumeratedCount` | `Count()` checks if a `Count` property is implemented
    on the sequence and returns its value, or it enumerates the entire sequence to
    count its items. New in .NET 6 is this method that only checks for `Count` and
    if it is missing it returns `false` and sets the `out` parameter to `0` to avoid
    a potentially poor-performing operation. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `TryGetNonEnumeratedCount` | `Count()`检查序列上是否实现了`Count`属性并返回其值，或者枚举整个序列以计算其项数。.NET
    6 中新增了这个方法，它仅检查`Count`，如果缺失则返回`false`并将`out`参数设置为`0`，以避免潜在的性能不佳的操作。'
- en: '| `All`, `Any`, `Contains` | Return `true` if all or any of the items match
    the filter, or if the sequence contains a specified item. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `All`, `Any`, `Contains` | 如果所有或任何项匹配筛选器，或者序列包含指定项，则返回`true`。'
- en: '| `Cast` | Cast items into a specified type. It is useful to convert non-generic
    objects to a generic type in scenarios where the compiler would otherwise complain.
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Cast` | 将项转换为指定类型。在编译器可能抱怨的情况下，将非泛型对象转换为泛型类型时非常有用。'
- en: '| `OfType` | Remove items that do not match a specified type. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `OfType` | 移除与指定类型不匹配的项。'
- en: '| `Distinct` | Remove duplicate items. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Distinct` | 移除重复项。'
- en: '| `Except`, `Intersect`, `Union` | Perform operations that return sets. Sets
    cannot have duplicate items. Although the inputs can be any sequence and so the
    inputs can have duplicates, the result is always a set. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `Except`, `Intersect`, `Union` | 执行返回集合的操作。集合不能有重复项。尽管输入可以是任何序列，因此输入可以有重复项，但结果始终是一个集合。'
- en: '| `Chunk` | Divide a sequence into sized batches. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `Chunk` | 将序列分割成定长批次。'
- en: '| `Append`, `Concat`, `Prepend` | Perform sequence-combining operations. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `Append`, `Concat`, `Prepend` | 执行序列合并操作。'
- en: '| `Zip` | Perform a match operation on two sequences based on the position
    of items, for example, the item at position 1 in the first sequence matches the
    item at position 1 in the second sequence. New in .NET 6 is a match operation
    on three sequences. Previously you would have had to run the two sequences overload
    twice to achieve the same goal. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `Zip` | 基于项的位置对两个序列执行匹配操作，例如，第一个序列中位置1的项与第二个序列中位置1的项匹配。.NET 6中新增了对三个序列的匹配操作。以前，您需要运行两次两个序列的重载才能达到相同目的。
    |'
- en: '| `ToArray`, `ToList`, `ToDictionary`, `ToHashSet`, `ToLookup` | Convert the
    sequence into an array or collection. These are the only extension methods that
    execute the LINQ expression. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `ToArray`, `ToList`, `ToDictionary`, `ToHashSet`, `ToLookup` | 将序列转换为数组或集合。这些是唯一执行LINQ表达式的扩展方法。
    |'
- en: '| `DistinctBy`, `ExceptBy`, `IntersectBy`, `UnionBy`, `MinBy`, `MaxBy` | New
    in .NET 6 are the `By` extension methods. They allow the comparison to be performed
    on a subset of the item rather than the entire item. For example, instead of removing
    duplicates by comparing an entire `Person` object, you could remove duplicates
    by comparing just their `LastName` and `DateOfBirth`. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `DistinctBy`, `ExceptBy`, `IntersectBy`, `UnionBy`, `MinBy`, `MaxBy` | .NET
    6中新增了`By`扩展方法。它们允许在项的子集上进行比较，而不是整个项。例如，您可以仅通过比较他们的`LastName`和`DateOfBirth`来移除重复项，而不是通过比较整个`Person`对象。
    |'
- en: 'The `Enumerable` class also has some methods that are not extension methods,
    as shown in the following table:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enumerable`类还包含一些非扩展方法，如下表所示：'
- en: '| Method | Description |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `Empty<T>` | Returns an empty sequence of the specified type `T`. It is useful
    for passing an empty sequence to a method that requires an `IEnumerable<T>`. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `Empty<T>` | 返回指定类型`T`的空序列。它对于向需要`IEnumerable<T>`的方法传递空序列非常有用。 |'
- en: '| `Range` | Returns a sequence of integers from the `start` value with `count`
    items. For example, `Enumerable.Range(start: 5, count: 3)` would contain the integers
    5, 6, and 7. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `Range` | 从`start`值开始返回包含`count`个整数的序列。例如，`Enumerable.Range(start: 5, count:
    3)`将包含整数5、6和7。 |'
- en: '| `Repeat` | Returns a sequence that contains the same `element` repeated `count`
    times. For example, `Enumerable.Repeat(element: "5", count: 3)` would contain
    the `string` values "5", "5", and "5". |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Repeat` | 返回一个包含相同`element`重复`count`次的序列。例如，`Enumerable.Repeat(element:
    "5", count: 3)`将包含字符串值“5”、“5”和“5”。 |'
- en: Understanding deferred execution
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解延迟执行
- en: 'LINQ uses **deferred execution**. It is important to understand that calling
    most of these extension methods does not execute the query and get the results.
    Most of these extension methods return a LINQ expression that represents a *question*,
    not an *answer*. Let''s explore:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ使用**延迟执行**。重要的是要理解，调用这些扩展方法中的大多数并不会执行查询并获取结果。这些扩展方法中的大多数返回一个代表*问题*而非*答案*的LINQ表达式。让我们来探讨：
- en: Use your preferred code editor to create a new solution/workspace named `Chapter11`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器创建一个名为`Chapter11`的新解决方案/工作区。
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用项目，如下表所定义：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter11`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter11`
- en: 'Project file and folder: `LinqWithObjects`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`LinqWithObjects`
- en: In `Program.cs`, delete the existing code and statically import `Console`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有代码并静态导入`Console`。
- en: 'Add statements to define a sequence of `string` values for people who work
    in an office, as shown in the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义一个`string`值序列，表示在办公室工作的人员，如下列代码所示：
- en: '[PRE0]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To ask the question and get the answer, i.e. execute the query, you must **materialize**
    it by either calling one of the "To" methods like `ToArray` or `ToLookup` or by
    enumerating the query, as shown in the following code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提出问题并获得答案，即执行查询，您必须**具体化**它，通过调用诸如`ToArray`或`ToLookup`之类的“To”方法之一，或者通过枚举查询，如下列代码所示：
- en: '[PRE1]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the console app and note the result, as shown in the following output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用并注意结果，如下所示：
- en: '[PRE2]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Due to deferred execution, after outputting the first result, `Pam`, if the
    original array values change, then by the time we loop back around, there are
    no more matches because `Jim` has become `Jimmy` and does not end with an `M`,
    so only `Pam` is outputted.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于延迟执行，在输出第一个结果“Pam”后，如果原始数组值发生改变，那么当我们再次循环时，将不再有匹配项，因为“Jim”已变为“Jimmy”，且不再以“M”结尾，因此只输出“Pam”。
- en: Before we get too deep into the weeds, let's slow down and look at some common
    LINQ extension methods and how to use them, one at a time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们放慢脚步，逐一查看一些常见的LINQ扩展方法及其使用方法。
- en: Filtering entities with Where
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Where过滤实体
- en: 'The most common reason for using LINQ is to filter items in a sequence using
    the `Where` extension method. Let''s explore filtering by defining a sequence
    of names and then applying LINQ operations to it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ最常见的用途是使用`Where`扩展方法对序列中的项进行过滤。让我们通过定义一个名字序列，然后对其应用LINQ操作来探索过滤：
- en: 'In the project file, comment out the element that enables implicit usings,
    as shown highlighted in the following markup:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，注释掉启用隐式引用的元素，如下列标记中高亮所示：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `Program.cs`, attempt to call the `Where` extension method on the array
    of names, as shown in the following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，尝试对名字数组调用`Where`扩展方法，如下列代码所示：
- en: '[PRE4]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you try to type the `Where` method, note that it is missing from the IntelliSense
    list of members of a string array, as shown in *Figure 11.1*:![](img/B17442_12_01.png)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你尝试输入`Where`方法时，注意它从字符串数组的IntelliSense成员列表中缺失，如*图11.1*所示：![](img/B17442_12_01.png)
- en: 'Figure 11.1: IntelliSense with the Where extension method missing'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.1：缺少Where扩展方法的IntelliSense
- en: This is because `Where` is an extension method. It does not exist on the array
    type. To make the `Where` extension method available, we must import the `System.Linq`
    namespace. This is implicitly imported by default in new .NET 6 projects, but
    we disabled it.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为`Where`是一个扩展方法。它并不存在于数组类型上。为了使`Where`扩展方法可用，我们必须导入`System.Linq`命名空间。这在新的.NET
    6项目中默认是隐式导入的，但我们禁用了它。
- en: In the project file, uncomment out the element that enables implicit usings.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，取消注释启用隐式引用的元素。
- en: Retype the `Where` method and note that the IntelliSense list now includes the
    extension methods added by the `Enumerable` class, as shown in *Figure 11.2*:![](img/B17442_12_02.png)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新输入`Where`方法，并注意IntelliSense列表现在包括了由`Enumerable`类添加的扩展方法，如*图11.2*所示：![](img/B17442_12_02.png)
- en: 'Figure 11.2: IntelliSense showing LINQ Enumerable extension methods now'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图11.2：IntelliSense显示LINQ Enumerable扩展方法
- en: As you type the parentheses for the `Where` method, IntelliSense tells us that
    to call `Where`, we must pass in an instance of a `Func<string, bool>` delegate.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你输入`Where`方法的括号时，IntelliSense告诉我们，要调用`Where`，我们必须传入一个`Func<string, bool>`委托的实例。
- en: 'Enter an expression to create a new instance of a `Func<string, bool>` delegate,
    and for now note that we have not yet supplied a method name because we will define
    it in the next step, as shown in the following code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个表达式以创建`Func<string, bool>`委托的新实例，目前请注意我们尚未提供方法名，因为我们将在下一步定义它，如下列代码所示：
- en: '[PRE5]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Func<string, bool>` delegate tells us that for each `string` variable passed
    to the method, the method must return a `bool` value. If the method returns `true`,
    it indicates that we should include the `string` in the results, and if the method
    returns `false`, it indicates that we should exclude it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Func<string, bool>`委托告诉我们，对于传递给该方法的每个`string`变量，该方法必须返回一个`bool`值。如果方法返回`true`，则表示我们应该在结果中包含该`string`，如果方法返回`false`，则表示我们应该排除它。'
- en: Targeting a named method
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对命名方法
- en: 'Let''s define a method that only includes names that are longer than four characters:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个只包含长度超过四个字符的名字的方法：
- en: 'At the bottom of `Program.cs`, define a method that will include only names
    longer than four characters, as shown in the following code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，定义一个方法，该方法将只包含长度超过四个字符的名字，如下列代码所示：
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Above the `NameLongerThanFour` method, pass the method''s name into the `Func<string,
    bool>` delegate, and then loop through the query items, as shown highlighted in
    the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NameLongerThanFour`方法上方，将方法名传递给`Func<string, bool>`委托，然后遍历查询项，如下列高亮代码所示：
- en: '[PRE7]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the code and view the results, noting that only names longer than four
    letters are listed, as shown in the following output:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，注意只有长度超过四个字母的名字被列出，如下列输出所示：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Simplifying the code by removing the explicit delegate instantiation
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过移除显式委托实例化来简化代码
- en: 'We can simplify the code by deleting the explicit instantiation of the `Func<string,
    bool>` delegate because the C# compiler can instantiate the delegate for us:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除`Func<string, bool>`委托的显式实例化来简化代码，因为C#编译器可以为我们实例化委托：
- en: To help you learn by seeing progressively improved code, copy and paste the
    query
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助你通过逐步改进的代码学习，复制并粘贴查询
- en: 'Comment out the first example, as shown in the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉第一个示例，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Modify the copy to remove the explicit instantiation of the delegate, as shown
    in the following code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改副本以删除委托的显式实例化，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the code and note that it has the same behavior.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它具有相同的行为。
- en: Targeting a lambda expression
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对 lambda 表达式
- en: We can simplify our code even further using a **lambda expression** in place
    of a named method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**lambda 表达式**代替命名方法，进一步简化代码。
- en: 'Although it can look complicated at first, a lambda expression is simply a
    *nameless function*. It uses the `=>` (read as "goes to") symbol to indicate the
    return value:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始看起来可能很复杂，但 lambda 表达式只是一个*无名函数*。它使用`=>`（读作“转到”）符号来指示返回值：
- en: 'Copy and paste the query, comment the second example, and modify the query,
    as shown in the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴查询，注释第二个示例，并修改查询，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that the syntax for a lambda expression includes all the important parts
    of the `NameLongerThanFour` method, but nothing more. A lambda expression only
    needs to define the following:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，lambda 表达式的语法包括了`NameLongerThanFour`方法的所有重要部分，但仅此而已。lambda 表达式只需要定义以下内容：
- en: 'The names of input parameters: `name`'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入参数的名称：`name`
- en: 'A return value expression: `name.Length > 4`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值表达式：`name.Length > 4`
- en: The type of the `name` input parameter is inferred from the fact that the sequence
    contains `string` values, and the return type must be a `bool` value as defined
    by the delegate for `Where` to work, so the expression after the `=>` symbol must
    return a `bool` value.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`name`输入参数的类型是从序列包含`string`值这一事实推断出来的，并且返回类型必须是一个`bool`值，这是由`Where`工作的委托定义的，因此`=>`符号后面的表达式必须返回一个`bool`值。'
- en: The compiler does most of the work for us, so our code can be as concise as
    possible.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编译器为我们完成了大部分工作，因此我们的代码可以尽可能简洁。
- en: Run the code and note that it has the same behavior.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它具有相同的行为。
- en: Sorting entities
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对实体进行排序
- en: Other commonly used extension methods are `OrderBy` and `ThenBy`, used for sorting
    a sequence.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常用的扩展方法是`OrderBy`和`ThenBy`，用于对序列进行排序。
- en: Extension methods can be chained if the previous method returns another sequence,
    that is, a type that implements the `IEnumerable<T>` interface.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一个方法返回另一个序列，即实现`IEnumerable<T>`接口的类型，则可以链接扩展方法。
- en: Sorting by a single property using OrderBy
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OrderBy 按单个属性排序
- en: 'Let''s continue working with the current project to explore sorting:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用当前项目来探索排序：
- en: 'Append a call to `OrderBy` to the end of the existing query, as shown in the
    following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有查询的末尾添加对`OrderBy`的调用，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Good Practice**: Format the LINQ statement so that each extension method
    call happens on its own line to make them easier to read.'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：将 LINQ 语句格式化，使每个扩展方法调用都发生在一行上，以便更容易阅读。'
- en: 'Run the code and note that the names are now sorted by shortest first, as shown
    in the following output:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意，现在名字按最短的先排序，如下面的输出所示：
- en: '[PRE13]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To put the longest name first, you would use `OrderByDescending`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将最长的名字放在前面，您将使用`OrderByDescending`。
- en: Sorting by a subsequent property using ThenBy
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ThenBy 按后续属性排序
- en: 'We might want to sort by more than one property, for example, to sort names
    of the same length in alphabetical order:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望按多个属性排序，例如，对相同长度的名字按字母顺序排序：
- en: 'Add a call to the `ThenBy` method at the end of the existing query, as shown
    highlighted in the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有查询的末尾添加对`ThenBy`方法的调用，如下面的代码中突出显示的那样：
- en: '[PRE14]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the code and note the slight difference in the following sort order. Within
    a group of names of the same length, the names are sorted alphabetically by the
    full value of the `string`, so `Creed` comes before `Kevin`, and `Angela` comes
    before `Dwight`, as shown in the following output:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意以下排序顺序的微小差异。在长度相同的名字组中，名字按`string`的完整值进行字母排序，因此`Creed`出现在`Kevin`之前，`Angela`出现在`Dwight`之前，如下面的输出所示：
- en: '[PRE15]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Declaring a query using var or a specified type
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 var 或指定类型声明查询
- en: 'While writing a LINQ expression it is convenient to use `var` to declare the
    query object. This is because the type frequently changes as you work on the LINQ
    expression. For example, our query started as an `IEnumerable<string>` and is
    currently an `IOrderedEnumerable<string>`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 LINQ 表达式时，使用`var`声明查询对象很方便。这是因为随着您在 LINQ 表达式上的工作，类型经常发生变化。例如，我们的查询最初是`IEnumerable<string>`，目前是`IOrderedEnumerable<string>`：
- en: Hover your mouse over the `var` keyword and note that its type is `IOrderedEnumerable<string>`
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在`var`关键字上，并注意其类型为`IOrderedEnumerable<string>`
- en: 'Replace `var` with the actual type, as shown highlighted in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`var`替换为实际类型，如下面的代码中突出显示的那样：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Good Practice**: Once you have finished working on a query, you could change
    the declared type from `var` to the actual type to make it clearer what the type
    is. This is easy because your code editor can tell you what it is.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：一旦完成查询工作，您可以将声明的类型从`var`更改为实际类型，以使其更清楚地了解类型是什么。这很容易，因为您的代码编辑器可以告诉您它是什么。'
- en: Filtering by type
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按类型筛选
- en: The `Where` extension method is great for filtering by values, such as text
    and numbers. But what if the sequence contains multiple types, and you want to
    filter by a specific type and respect any inheritance hierarchy?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Where`扩展方法非常适合按值筛选，例如文本和数字。但如果序列包含多种类型，并且您想要按特定类型筛选并尊重任何继承层次结构，该怎么办？'
- en: 'Imagine that you have a sequence of exceptions. There are hundreds of exception
    types that form a complex hierarchy, as partially shown in *Figure 11.3*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一个异常序列。有数百种异常类型形成了一个复杂的层次结构，部分显示在*图11.3*中：
- en: '![Diagram  Description automatically generated](img/B17442_12_04.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17442_12_04.png)'
- en: 'Figure 11.3: A partial exception inheritance hierarchy'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：部分异常继承层次结构
- en: 'Let''s explore filtering by type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨按类型筛选：
- en: 'In `Program.cs`, define a list of exception-derived objects, as shown in the
    following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，定义一个异常派生对象列表，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write statements using the `OfType<T>` extension method to remove exceptions
    that are not arithmetic exceptions and write only the arithmetic exceptions to
    the console, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`OfType<T>`扩展方法编写语句，以删除不是算术异常的异常，并将仅算术异常写入控制台，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code and note that the results only include exceptions of the `ArithmeticException`
    type, or the `ArithmeticException`-derived types, as shown in the following output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果仅包括`ArithmeticException`类型的异常，或`ArithmeticException`派生的类型，如下面的输出所示：
- en: '[PRE19]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Working with sets and bags using LINQ
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LINQ处理集合和包
- en: Sets are one of the most fundamental concepts in mathematics. A **set** is a
    collection of one or more unique objects. A **multiset**, aka **bag**, is a collection
    of one or more objects that can have duplicates.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是数学中最基本的概念之一。**集合**是一个或多个唯一对象的集合。**多重集合**，又称**包**，是一个或多个对象的集合，可以有重复项。
- en: You might remember being taught about Venn diagrams in school. Common set operations
    include the **intersect** or **union** between sets.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在学校学过的维恩图。常见的集合操作包括集合之间的**交集**或**并集**。
- en: 'Let''s create a console application that will define three arrays of `string`
    values for cohorts of apprentices and then perform some common set and multiset
    operations on them:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个控制台应用程序，该应用程序将定义三个`string`值数组，用于学徒队列，然后对它们执行一些常见的集合和多重集合操作：
- en: 'Use your preferred code editor to add a new console app named `LinqWithSets`
    to the `Chapter11` solution/workspace:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，在`Chapter11`解决方案/工作区中添加一个名为`LinqWithSets`的新控制台应用程序：
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，将解决方案的启动项目设置为当前选择。
- en: In Visual Studio Code, select `LinqWithSets` as the active OmniSharp project.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`LinqWithSets`作为活动OmniSharp项目。
- en: 'In `Program.cs`, delete the existing code and statically import the `Console`
    type, as shown in the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有代码并静态导入`Console`类型，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At the bottom of `Program.cs`, add the following method that outputs any sequence
    of `string` variables as a comma-separated single `string` to the console output,
    along with an optional description, as shown in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，添加以下方法，该方法将任何`string`变量序列输出为以逗号分隔的单个`string`到控制台输出，以及一个可选描述，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Above the `Output` method, add statements to define three arrays of names,
    output them, and then perform various set operations on them, as shown in the
    following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Output`方法上方，添加语句以定义三个名称数组，输出它们，然后对它们执行各种集合操作，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With `Zip`, if there are unequal numbers of items in the two sequences, then
    some items will not have a matching partner. Those without a partner, like `Jared`,
    will not be included in the result.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Zip`时，如果两个序列中的项数不相等，那么有些项将没有匹配的伙伴。没有伙伴的项，如`Jared`，将不会包含在结果中。
- en: For the `DistinctBy` example, instead of removing duplicates by comparing the
    whole name, we define a lambda key selector to remove duplicates by comparing
    the first two characters, so `Jared` is removed because `Jack` already is a name
    that starts with `Ja`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`DistinctBy`示例，我们不是通过比较整个名称来移除重复项，而是定义了一个lambda键选择器，通过比较前两个字符来移除重复项，因此`Jared`被移除，因为`Jack`已经是一个以`Ja`开头的名称。
- en: So far, we have used the LINQ to Objects provider to work with in-memory objects.
    Next, we will use the LINQ to Entities provider to work with entities stored in
    a database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了LINQ to Objects提供程序来处理内存中的对象。接下来，我们将使用LINQ to Entities提供程序来处理存储在数据库中的实体。
- en: Using LINQ with EF Core
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LINQ与EF Core
- en: We have looked at LINQ queries that filter and sort, but none that change the
    shape of the items in the sequence. This is called **projection** because it's
    about projecting items of one shape into another shape. To learn about projection,
    it is best to have some more complex types to work with, so in the next project,
    instead of using `string` sequences, we will use sequences of entities from the
    Northwind sample database.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过过滤和排序的LINQ查询，但没有改变序列中项的形状的查询。这称为**投影**，因为它涉及将一种形状的项投影到另一种形状。为了学习投影，最好有一些更复杂的类型来操作，所以在下一个项目中，我们将不再使用`string`序列，而是使用来自Northwind示例数据库的实体序列。
- en: I will give instructions to use SQLite because it is cross-platform but if you
    prefer to use SQL Server then feel free to do so. I have included some commented
    code to enable SQL Server if you choose.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我将给出使用SQLite的指令，因为它跨平台，但如果你更喜欢使用SQL Server，请随意。我已包含一些注释代码，以便在你选择时启用SQL Server。
- en: Building an EF Core model
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建EF Core模型
- en: 'We must define an EF Core model to represent the database and tables that we
    will work with. We will define the model manually to take complete control and
    to prevent a relationship from being automatically defined between the `Categories`
    and `Products` tables. Later, you will use LINQ to join the two entity sets:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义一个EF Core模型来表示我们将要操作的数据库和表。我们将手动定义模型以完全控制并防止在`Categories`和`Products`表之间自动定义关系。稍后，您将使用LINQ来连接这两个实体集：
- en: Use your preferred code editor to add a new console app named `LinqWithEFCore`
    to the `Chapter11` solution/workspace.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向`Chapter11`解决方案/工作区中添加一个名为`LinqWithEFCore`的新控制台应用程序。
- en: In Visual Studio Code, select `LinqWithEFCore` as the active OmniSharp project.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`LinqWithEFCore`作为活动OmniSharp项目。
- en: 'In the `LinqWithEFCore` project, add a package reference to the EF Core provider
    for SQLite and/or SQL Server, as shown in the following markup:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LinqWithEFCore`项目中，添加对SQLite和/或SQL Server的EF Core提供程序的包引用，如下所示：
- en: '[PRE24]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Build the project to restore packages.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: Copy the `Northwind4Sqlite.sql` file into the `LinqWithEFCore` folder.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Northwind4Sqlite.sql`文件复制到`LinqWithEFCore`文件夹中。
- en: 'At a command prompt or terminal, create the Northwind database by executing
    the following command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，执行以下命令创建Northwind数据库：
- en: '[PRE25]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Be patient because this command might take a while to create the database structure.
    Eventually you will see the SQLite command prompt, as shown in the following output:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请耐心等待，因为这个命令可能需要一段时间来创建数据库结构。最终，您将看到SQLite命令提示符，如下所示：
- en: '[PRE26]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Press cmd + D on macOS or Ctrl + C on Windows to exit SQLite command mode.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在macOS上按cmd + D或在Windows上按Ctrl + C退出SQLite命令模式。
- en: Add three class files to the project, named `Northwind.cs`, `Category.cs`, and
    `Product.cs`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加三个类文件，分别命名为`Northwind.cs`、`Category.cs`和`Product.cs`。
- en: 'Modify the class file named `Northwind.cs`, as shown in the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为`Northwind.cs`的类文件，如下所示：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Modify the class file named `Category.cs`, as shown in the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为`Category.cs`的类文件，如下所示：
- en: '[PRE28]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Modify the class file named `Product.cs`, as shown in the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为`Product.cs`的类文件，如下所示：
- en: '[PRE29]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Build the project and fix any compiler errors.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并修复任何编译器错误。
- en: If you are using Visual Studio 2022 for Windows, then the compiled application
    executes in the `LinqWithEFCore\bin\Debug\net6.0` folder so it will not find the
    database file unless we indicate that it should always be copied to the output
    directory.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows上的Visual Studio 2022，那么编译后的应用程序将在`LinqWithEFCore\bin\Debug\net6.0`文件夹中执行，因此除非我们指示应始终将其复制到输出目录，否则它将找不到数据库文件。
- en: In **Solution Explorer**, right-click the `Northwind.db` file and select **Properties**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，右键单击`Northwind.db`文件并选择**属性**。
- en: In **Properties**, set **Copy to Output Directory** to **Copy always**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**中，将**复制到输出目录**设置为**始终复制**。
- en: Filtering and sorting sequences
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和排序序列
- en: 'Now let''s write statements to filter and sort sequences of rows from the tables:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写语句来过滤和排序来自表的行序列：
- en: 'In `Program.cs`, statically import the `Console` type and namespaces for working
    with EF Core and your entity model using LINQ, as shown in the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，静态导入`Console`类型和用于使用EF Core和实体模型进行LINQ操作的命名空间，如下列代码所示：
- en: '[PRE30]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At the bottom of `Program.cs`, write a method to filter and sort products,
    as shown in the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，编写一个方法来过滤和排序产品，如下列代码所示：
- en: '[PRE31]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`DbSet<T>` implements `IEnumerable<T>`, so LINQ can be used to query and manipulate
    collections of entities in models built for EF Core. (Actually, I should say `TEntity`
    instead of `T` but the name of this generic type has no functional effect. The
    only requirement is that the type is a `class`. The name just indicates the class
    is expected to be an entity model.)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DbSet<T>`实现`IEnumerable<T>`，因此LINQ可用于查询和操作为EF Core构建的模型中的实体集合。（实际上，我应该说`TEntity`而不是`T`，但此泛型类型的名称没有功能性影响。唯一的要求是类型是一个`class`。名称仅表示预期该类是一个实体模型。）'
- en: You might have also noticed that the sequences implement `IQueryable<T>` (or
    `IOrderedQueryable<T>` after a call to an ordering LINQ method) instead of `IEnumerable<T>`
    or `IOrderedEnumerable<T>`.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能还注意到，序列实现的是`IQueryable<T>`（或在调用排序LINQ方法后实现`IOrderedQueryable<T>`）而不是`IEnumerable<T>`或`IOrderedEnumerable<T>`。
- en: This is an indication that we are using a LINQ provider that builds the query
    in memory using expression trees. They represent code in a tree-like data structure
    and enable the creation of dynamic queries, which is useful for building LINQ
    queries for external data providers like SQLite.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表明我们正在使用一个LINQ提供程序，该提供程序使用表达式树在内存中构建查询。它们以树状数据结构表示代码，并支持创建动态查询，这对于构建针对SQLite等外部数据提供程序的LINQ查询非常有用。
- en: The LINQ expression will be converted into another query language, such as SQL.
    Enumerating the query with `foreach` or calling a method such as `ToArray` will
    force the execution of the query and materialize the results.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LINQ表达式将被转换成另一种查询语言，如SQL。使用`foreach`枚举查询或调用`ToArray`等方法将强制执行查询并具体化结果。
- en: After the namespace imports in `Program.cs`, call the `FilterAndSort` method.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中的命名空间导入之后，调用`FilterAndSort`方法。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE32]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Although this query outputs the information we want, it does so inefficiently
    because it gets all columns from the `Products` table instead of just the three
    columns we need, which is the equivalent of the following SQL statement:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此查询输出了我们所需的信息，但这样做效率低下，因为它从`Products`表中获取了所有列，而不是我们需要的三个列，这相当于以下SQL语句：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In *Chapter 10*, *Working with Data Using Entity Framework Core*, you learned
    how to log the SQL commands executed against SQLite so that you could see this
    for yourself.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第10章*，*使用Entity Framework Core处理数据*中，您学习了如何记录针对SQLite执行的SQL命令，以便您可以亲自查看。
- en: Projecting sequences into new types
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将序列投影到新类型
- en: 'Before we look at projection, we need to review object initialization syntax.
    If you have a class defined, then you can instantiate an object using the class
    name, `new()`, and curly braces to set initial values for fields and properties,
    as shown in the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看投影之前，我们需要回顾对象初始化语法。如果您定义了一个类，那么您可以使用类名、`new()`和花括号来设置字段和属性的初始值，如下列代码所示：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'C# 3.0 and later allow instances of **anonymous types** to be instantiated
    using the `var` keyword, as shown in the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3.0及更高版本允许使用`var`关键字实例化**匿名类型**，如下列代码所示：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Although we did not specify a type, the compiler can infer an anonymous type
    from the setting of two properties named `Name` and `DateOfBirth`. The compiler
    can infer the types of the two properties from the values assigned: a literal
    `string` and a new instance of a date/time value.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有指定类型，但编译器可以从设置的两个属性`Name`和`DateOfBirth`推断出匿名类型。编译器可以从分配的值推断出这两个属性的类型：一个字符串字面量和一个新的日期/时间值实例。
- en: This capability is especially useful when writing LINQ queries to project an
    existing type into a new type without having to explicitly define the new type.
    Since the type is anonymous, this can only work with `var`-declared local variables.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写LINQ查询以将现有类型投影到新类型而不必显式定义新类型时，此功能特别有用。由于类型是匿名的，因此这只能与`var`声明的局部变量一起工作。
- en: 'Let''s make the SQL command executed against the database table more efficient
    by adding a call to the `Select` method to project instances of the `Product`
    class into instances of a new anonymous type with only three properties:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加对`Select`方法的调用，将`Product`类的实例投影到仅具有三个属性的新匿名类型的实例，从而使针对数据库表执行的SQL命令更高效：
- en: 'In `FilterAndSort`, add a statement to extend the LINQ query to use the `Select`
    method to return only the three properties (that is, table columns) that we need,
    and modify the `foreach` statement to use the `var` keyword and the projection
    LINQ expression, as shown highlighted in the following code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FilterAndSort`中，添加一条语句以扩展LINQ查询，使用`Select`方法仅返回我们需要的三个属性（即表列），并修改`foreach`语句以使用`var`关键字和投影LINQ表达式，如下所示高亮显示：
- en: '[PRE36]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Hover your mouse over the `new` keyword in the `Select` method call and the
    `var` keyword in the `foreach` statement and note that it is an anonymous type,
    as shown in *Figure 11.4*:![](img/B17442_12_05.png)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在`Select`方法调用中的`new`关键字和`foreach`语句中的`var`关键字上，并注意它是一个匿名类型，如*图11.4*所示：![](img/B17442_12_05.png)
- en: 'Figure 11.4: An anonymous type used during LINQ projection'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图11.4*：LINQ投影期间使用的匿名类型'
- en: Run the code and confirm that the output is the same as before.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并确认输出与之前相同。
- en: Joining and grouping sequences
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和分组序列
- en: 'There are two extension methods for joining and grouping:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 连接和分组有两种扩展方法：
- en: '**Join**: This method has four parameters: the sequence that you want to join
    with, the property or properties on the *left* sequence to match on, the property
    or properties on the *right* sequence to match on, and a projection.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Join**：此方法有四个参数：您想要连接的序列，要匹配的*左侧*序列上的属性或属性，要匹配的*右侧*序列上的属性或属性，以及一个投影。'
- en: '**GroupJoin**: This method has the same parameters, but it combines the matches
    into a group object with a `Key` property for the matching value and an `IEnumerable<T>`
    type for the multiple matches.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GroupJoin**：此方法具有相同的参数，但它将匹配项合并到一个组对象中，该对象具有用于匹配值的`Key`属性和用于多个匹配项的`IEnumerable<T>`类型。'
- en: Joining sequences
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接序列
- en: 'Let''s explore these methods when working with two tables: `Categories` and
    `Products`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在处理两个表：`Categories`和`Products`时探索这些方法：
- en: 'At the bottom of `Program.cs`, create a method to select categories and products,
    join them, and output them, as shown in the following code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个方法来选择类别和产品，将它们连接起来并输出，如下所示：
- en: '[PRE37]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In a join, there are two sequences, *outer* and *inner*. In the previous example,
    `categories` is the outer sequence and `products` is the inner sequence.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在连接中，有两个序列，*外部*和*内部*。在前面的示例中，`categories`是外部序列，`products`是内部序列。
- en: At the top of `Program.cs`, comment out the call to `FilterAndSort` and call
    `JoinCategoriesAndProducts`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉对`FilterAndSort`的调用，改为调用`JoinCategoriesAndProducts`。
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, as shown in the following output (edited to only
    include the first 10 items):'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果。请注意，对于77种产品中的每一种，都有一行输出，如下所示的输出（编辑后仅包括前10项）：
- en: '[PRE38]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At the end of the existing query, call the `OrderBy` method to sort by `CategoryName`,
    as shown in the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有查询的末尾，调用`OrderBy`方法按`CategoryName`排序，如下所示：
- en: '[PRE39]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, and the results show all products in the `Beverages`
    category first, then the `Condiments` category, and so on, as shown in the following
    partial output:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果。请注意，对于77种产品中的每一种，都有一行输出，结果首先显示`Beverages`类别中的所有产品，然后是`Condiments`类别，依此类推，如下所示的部分输出：
- en: '[PRE40]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Group-joining sequences
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组连接序列
- en: 'At the bottom of `Program.cs`, create a method to group and join, show the
    group name, and then show all the items within each group, as shown in the following
    code:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个方法来分组和连接，显示组名，然后显示每个组内的所有项，如下列代码所示：
- en: '[PRE41]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we had not called the `AsEnumerable` method, then a runtime exception would
    have been thrown, as shown in the following output:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们没有调用`AsEnumerable`方法，那么将会抛出一个运行时异常，如下列输出所示：
- en: '[PRE42]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is because not all LINQ extension methods can be converted from expression
    trees into some other query syntax like SQL. In these cases, we can convert from
    `IQueryable<T>` to `IEnumerable<T>` by calling the `AsEnumerable` method, which
    forces query processing to use LINQ to EF Core only to bring the data into the
    application and then use LINQ to Objects to execute more complex processing in
    memory. But, often, this is less efficient.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为并非所有LINQ扩展方法都能从表达式树转换为其他查询语法，如SQL。在这些情况下，我们可以通过调用`AsEnumerable`方法将`IQueryable<T>`转换为`IEnumerable<T>`，这迫使查询处理仅使用LINQ
    to EF Core将数据带入应用程序，然后使用LINQ to Objects在内存中执行更复杂的处理。但通常，这效率较低。
- en: At the top of `Program.cs`, comment out the previous method call and call `GroupJoinCategoriesAndProducts`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，并调用`GroupJoinCategoriesAndProducts`。
- en: 'Run the code, view the results, and note that the products inside each category
    have been sorted by their name, as defined in the query and as shown in the following
    partial output:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意每个类别内的产品已按其名称排序，正如查询中所定义，并在以下部分输出中所示：
- en: '[PRE43]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Aggregating sequences
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合序列
- en: 'There are LINQ extension methods to perform aggregation functions, such as
    `Average` and `Sum`. Let''s write some code to see some of these methods in action
    aggregating information from the `Products` table:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有LINQ扩展方法可执行聚合函数，如`Average`和`Sum`。让我们编写一些代码，看看这些方法如何从`Products`表中聚合信息：
- en: 'At the bottom of `Program.cs`, create a method to show the use of the aggregation
    extension methods, as shown in the following code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个方法来展示聚合扩展方法的使用，如下列代码所示：
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: At the top of `Program.cs`, comment out the previous method and call `AggregateProducts`
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，并调用`AggregateProducts`
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE45]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Sweetening LINQ syntax with syntactic sugar
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用语法糖美化LINQ语法
- en: C# 3.0 introduced some new language keywords in 2008 to make it easier for programmers
    with experience with SQL to write LINQ queries. This syntactic sugar is sometimes
    called the **LINQ query comprehension syntax**.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3.0在2008年引入了一些新的语言关键字，以便有SQL经验的程序员更容易编写LINQ查询。这种语法糖有时被称为**LINQ查询理解语法**。
- en: 'Consider the following array of `string` values:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`string`值数组：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To filter and sort the names, you could use extension methods and lambda expressions,
    as shown in the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要筛选和排序名称，可以使用扩展方法和lambda表达式，如下列代码所示：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or you could achieve the same results by using query comprehension syntax,
    as shown in the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用查询理解语法实现相同的结果，如下列代码所示：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The compiler changes the query comprehension syntax to the equivalent extension
    methods and lambda expressions for you.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会将查询理解语法转换为等效的扩展方法和lambda表达式。
- en: The `select` keyword is always required for LINQ query comprehension syntax.
    The `Select` extension method is optional when using extension methods and lambda
    expressions because if you do not call `Select`, then the whole item is implicitly
    selected.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`关键字在LINQ查询理解语法中始终是必需的。当使用扩展方法和lambda表达式时，`Select`扩展方法是可选的，因为如果你没有调用`Select`，那么整个项会被隐式选中。'
- en: Not all extension methods have a C# keyword equivalent, for example, the `Skip`
    and `Take` extension methods, which are commonly used to implement paging for
    lots of data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有扩展方法都有C#关键字等效项，例如，常用的`Skip`和`Take`扩展方法，用于为大量数据实现分页。
- en: 'A query that skips and takes cannot be written using only the query comprehension
    syntax, so we could write the query using all extension methods, as shown in the
    following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询理解语法无法编写跳过和获取的查询，因此我们可以使用所有扩展方法编写查询，如下列代码所示：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Or you can wrap query comprehension syntax in parentheses and then switch to
    using extension methods, as shown in the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将查询理解语法括在括号内，然后切换到使用扩展方法，如下列代码所示：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Good Practice**: Learn both extension methods with lambda expressions and
    the query comprehension syntax ways of writing LINQ queries, because you are likely
    to have to maintain code that uses both.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple threads with parallel LINQ
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, only one thread is used to execute a LINQ query. **Parallel LINQ**
    (**PLINQ**) is an easy way to enable multiple threads to execute a LINQ query.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Do not assume that using parallel threads will improve the
    performance of your applications. Always measure real-world timings and resource
    usage.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app that benefits from multiple threads
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see it in action, we will start with some code that only uses a single thread
    to calculate Fibonacci numbers for 45 integers. We will use the `StopWatch` type
    to measure the change in performance.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: We will use operating system tools to monitor the CPU and CPU core usage. If
    you do not have multiple CPUs or at least multiple cores, then this exercise won't
    show much!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `LinqInParallel`
    to the `Chapter11` solution/workspace.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `LinqInParallel` as the active OmniSharp project.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, delete the existing statements and then import the `System.Diagnostics`
    namespace so that we can use the `StopWatch` type, and statically import the `System.Console`
    type.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to create a stopwatch to record timings, wait for a keypress
    before starting the timer, create 45 integers, calculate the last Fibonacci number
    for each of them, stop the timer, and display the elapsed milliseconds, as shown
    in the following code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Run the code, but do not press Enter to start the stopwatch yet because we need
    to make sure a monitoring tool is showing processor activity.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Windows
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Windows, then right-click on the Windows **Start** button or
    press Ctrl + Alt + Delete, and then click on **Task Manager**.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the **Task Manager** window, click **More details**.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **Task Manager** window, click on the **Performance** tab.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **CPU Utilization** graph, select **Change graph to**, and
    then select **Logical processors**.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using macOS
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using macOS, then launch **Activity Monitor**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **View** | **Update Frequency Very often (1 sec)**.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see the CPU graphs, navigate to **Window** | **CPU History**.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For all operating systems
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rearrange your monitoring tool and your code editor so that they are side by
    side.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the CPUs to settle and then press Enter to start the stopwatch and
    run the query. The result should be a number of elapsed milliseconds, as shown
    in the following output:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The monitoring tool will probably show that one or two CPUs were used the most,
    alternating over time. Others may execute background tasks at the same time, such
    as the garbage collector, so the other CPUs or cores won't be completely flat,
    but the work is certainly not being evenly spread among all the possible CPUs
    or cores. Also, note that some of the logical processors are maxing out at 100%.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 监控工具可能会显示，有一两个CPU使用率最高，随着时间交替变化，其他CPU可能同时执行后台任务，如垃圾收集器，因此其他CPU或核心不会完全空闲，但工作显然没有均匀分布在所有可能的CPU或核心上。还要注意，一些逻辑处理器达到了100%的峰值。
- en: 'In `Program.cs`, modify the query to make a call to the `AsParallel` extension
    method and to sort the resulting sequence because when processing in parallel
    the results can become misordered, as shown highlighted in the following code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，修改查询以调用`AsParallel`扩展方法并对结果序列进行排序，因为在并行处理时结果可能会变得无序，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Good Practice**: Never call `AsParallel` at the end of a query. This does
    nothing. You must perform at least one operation after the call to `AsParallel`
    for that operation to be parallelized. .NET 6 introduces a code analyzer that
    will warn about this type of misuse.'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：切勿在查询的末尾调用`AsParallel`。这没有任何作用。你必须在调用`AsParallel`之后至少执行一个操作，以便该操作可以并行化。.NET
    6引入了一个代码分析器，它会警告这种误用。'
- en: 'Run the code, wait for CPU charts in your monitoring tool to settle, and then
    press Enter to start the stopwatch and run the query. This time, the application
    should complete in less time (although it might not be as less as you might hope
    for—managing those multiple threads takes extra effort!):'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，等待监控工具中的CPU图表稳定，然后按Enter键启动秒表并运行查询。这次，应用程序应该在更短的时间内完成（尽管可能不会像你希望的那样短——管理那些多线程需要额外的努力！）：
- en: '[PRE54]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The monitoring tool should show that all CPUs were used equally to execute the
    LINQ query, and note that none of the logical processors max out at 100% because
    the work is more evenly spread.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控工具应该显示所有CPU都平均用于执行LINQ查询，并注意没有逻辑处理器达到100%的峰值，因为工作分布更为均匀。
- en: You will learn more about managing multiple threads in *Chapter 12*, *Improving
    Performance and Scalability Using Multitasking*.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在*第12章*，*使用多任务提高性能和可扩展性*中了解更多关于管理多线程的知识。
- en: Creating your own LINQ extension methods
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的LINQ扩展方法
- en: In *Chapter 6*, *Implementing Interfaces and Inheriting Classes*, you learned
    how to create your own extension methods. To create LINQ extension methods, all
    you must do is extend the `IEnumerable<T>` type.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*，*实现接口和继承类*中，你学习了如何创建自己的扩展方法。要创建LINQ扩展方法，你所需要做的就是扩展`IEnumerable<T>`类型。
- en: '**Good Practice**: Put your own extension methods in a separate class library
    so that they can be easily deployed as their own assembly or NuGet package.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：将你自己的扩展方法放在一个单独的类库中，以便它们可以轻松地作为自己的程序集或NuGet包部署。'
- en: 'We will improve the `Average` extension method as an example. A well-educated
    school child will tell you that *average* can mean one of three things:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以改进`Average`扩展方法为例。一个受过良好教育的学童会告诉你，*平均*可以指三种情况之一：
- en: '**Mean**: Sum the numbers and divide by the count.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均值**：将数字求和并除以计数。'
- en: '**Mode**: The most common number.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**众数**：最常见的数字。'
- en: '**Median**: The number in the middle of the numbers when ordered.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中位数**：当数字排序时位于中间的数字。'
- en: 'Microsoft''s implementation of the `Average` extension method calculates the
    *mean*. We might want to define our own extension methods for `Mode` and `Median`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 微软实现的`Average`扩展方法计算的是*均值*。我们可能希望为`Mode`和`Median`定义自己的扩展方法：
- en: In the `LinqWithEFCore` project, add a new class file named `MyLinqExtensions.cs`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LinqWithEFCore`项目中，添加一个名为`MyLinqExtensions.cs`的新类文件。
- en: 'Modify the class, as shown in the following code:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码所示修改类：
- en: '[PRE55]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If this class was in a separate class library, to use your LINQ extension methods,
    you simply need to reference the class library assembly because the `System.Linq`
    namespace is already implicitly imported.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个类位于一个单独的类库中，要使用你的LINQ扩展方法，你只需引用类库程序集，因为`System.Linq`命名空间已经隐式导入。
- en: '**Warning!** All but one of the above extension methods cannot be used with
    `IQueryable` sequences like those used by LINQ to SQLite or LINQ to SQL Server
    because we have not implemented a way to translate our code into the underlying
    query language like SQL.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**上述扩展方法中除一个外，都不能与`IQueryable`序列（如LINQ to SQLite或LINQ to SQL Server使用的序列）一起使用，因为我们没有实现将我们的代码翻译成底层查询语言（如SQL）的方法。'
- en: Trying the chainable extension method
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试使用链式扩展方法
- en: 'First, we will try chaining the `ProcessSequence` method with other extension
    methods:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将尝试将`ProcessSequence`方法与其他扩展方法链接起来：
- en: 'In `Program.cs`, in the `FilterAndSort` method, modify the LINQ query for `Products`
    to call your custom chainable extension method, as shown highlighted in the following
    code:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在`FilterAndSort`方法中，修改`Products`的LINQ查询以调用您的自定义链式扩展方法，如下面的代码中突出显示的那样：
- en: '[PRE56]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In `Program.cs`, uncomment the `FilterAndSort` method and comment out any calls
    to other methods.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，取消注释`FilterAndSort`方法，并注释掉对其他方法的任何调用。
- en: Run the code and note that you see the same output as before because your method
    doesn't modify the sequence. But you now know how to extend a LINQ expression
    with your own functionality.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意您看到与之前相同的输出，因为您的方法没有修改序列。但现在您知道如何通过自己的功能扩展LINQ表达式。
- en: Trying the mode and median methods
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试使用众数和中位数方法
- en: 'Second, we will try using the `Mode` and `Median` methods to calculate other
    kinds of average:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将尝试使用`Mode`和`Median`方法来计算其他类型的平均值：
- en: 'At the bottom of `Program.cs`, create a method to output the mean, median,
    and mode, for `UnitsInStock` and `UnitPrice` for products, using your custom extension
    methods and the built-in `Average` extension method, as shown in the following
    code:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个方法来输出产品的`UnitsInStock`和`UnitPrice`的平均值、中位数和众数，使用您的自定义扩展方法和内置的`Average`扩展方法，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In `Program.cs`, comment any previous method calls and call `CustomExtensionMethods`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉任何之前的方法调用，并调用`CustomExtensionMethods`。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE58]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are four products with a unit price of $18.00\. There are five products
    with 0 units in stock.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种产品的单价为$18.00。有五种产品的库存量为0。
- en: Working with LINQ to XML
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LINQ to XML进行工作
- en: '**LINQ to XML** is a LINQ provider that allows you to query and manipulate
    XML.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**LINQ to XML**是一种LINQ提供程序，允许您查询和操作XML。'
- en: Generating XML using LINQ to XML
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LINQ to XML生成XML
- en: 'Let''s create a method to convert the `Products` table into XML:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个方法将`Products`表转换为XML：
- en: In the `LinqWithEFCore` project, at the top of `Program.cs`, import the `System.Xml.Linq`
    namespace.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LinqWithEFCore`项目中，在`Program.cs`顶部导入`System.Xml.Linq`命名空间。
- en: 'At the bottom of `Program.cs`, create a method to output the products in XML
    format, as shown in the following code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个方法以XML格式输出产品，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In `Program.cs`, comment the previous method call and call `OutputProductsAsXml`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的方法调用，并调用`OutputProductsAsXml`。
- en: 'Run the code, view the result, and note that the structure of the XML generated
    matches the elements and attributes that the LINQ to XML statement declaratively
    described in the preceding code, as shown in the following partial output:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意生成的XML结构与LINQ to XML语句在前述代码中声明性地描述的元素和属性相匹配，如下面的部分输出所示：
- en: '[PRE60]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Reading XML using LINQ to XML
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LINQ to XML读取XML
- en: 'You might want to use LINQ to XML to easily query or process XML files:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望使用LINQ to XML轻松查询或处理XML文件：
- en: In the `LinqWithEFCore` project, add a file named `settings.xml`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LinqWithEFCore`项目中，添加一个名为`settings.xml`的文件。
- en: 'Modify its contents, as shown in the following markup:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改其内容，如下面的标记所示：
- en: '[PRE61]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you are using Visual Studio 2022 for Windows, then the compiled application
    executes in the `LinqWithEFCore\bin\Debug\net6.0` folder so it will not find the
    `settings.xml` file unless we indicate that it should always be copied to the
    output directory.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows上的Visual Studio 2022，那么编译后的应用程序将在`LinqWithEFCore\bin\Debug\net6.0`文件夹中执行，因此除非我们指示它始终复制到输出目录，否则它将找不到`settings.xml`文件。
- en: In **Solution Explorer**, right-click the `settings.xml` file and select **Properties**.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中，右键单击`settings.xml`文件并选择**属性**。
- en: In **Properties**, set **Copy to Output Directory** to **Copy always**.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**中，将**复制到输出目录**设置为**始终复制**。
- en: 'At the bottom of `Program.cs`, create a method to complete these tasks, as
    shown in the following code:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个方法来完成这些任务，如下面的代码所示：
- en: Load the XML file.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载XML文件。
- en: Use LINQ to XML to search for an element named `appSettings` and its descendants
    named `add`.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ to XML搜索名为`appSettings`的元素及其名为`add`的后代。
- en: Project the XML into an array of an anonymous type with `Key` and `Value` properties.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将XML投影成具有`Key`和`Value`属性的匿名类型数组。
- en: 'Enumerate through the array to show the results:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数组以显示结果：
- en: '[PRE62]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In `Program.cs`, comment the previous method call and call `ProcessSettings`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉之前的方法调用，并调用`ProcessSettings`。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE63]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Practicing and exploring
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践与探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics covered in
    this chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题，进行一些实践练习，并深入研究本章涵盖的主题，来测试你的知识和理解。
- en: Exercise 11.1 – Test your knowledge
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What are the two required parts of LINQ?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LINQ的两个必要组成部分是什么？
- en: Which LINQ extension method would you use to return a subset of properties from
    a type?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要返回一个类型的部分属性子集，你会使用哪个LINQ扩展方法？
- en: Which LINQ extension method would you use to filter a sequence?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要过滤序列，你会使用哪个LINQ扩展方法？
- en: List five LINQ extension methods that perform aggregation.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出五个执行聚合操作的LINQ扩展方法。
- en: What is the difference between the `Select` and `SelectMany` extension methods?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展方法`Select`和`SelectMany`之间有何区别？
- en: What is the difference between `IEnumerable<T>` and `IQueryable<T>`? And how
    do you switch between them?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`与`IQueryable<T>`的区别是什么？以及如何在这两者之间切换？'
- en: What does the last type parameter `T` in generic `Func` delegates like `Func<T1,
    T2, T>` represent?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型`Func`委托（如`Func<T1, T2, T>`）中最后一个类型参数`T`代表什么？
- en: What is the benefit of a LINQ extension method that ends with `OrDefault`?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`OrDefault`结尾的LINQ扩展方法有何好处？
- en: Why is query comprehension syntax optional?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么查询理解语法是可选的？
- en: How can you create your own LINQ extension methods?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建自己的LINQ扩展方法？
- en: Exercise 11.2 – Practice querying with LINQ
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.2 – 实践LINQ查询
- en: 'In the `Chapter11` solution/workspace, create a console application, named
    `Exercise02`, that prompts the user for a city and then lists the company names
    for Northwind customers in that city, as shown in the following output:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter11`解决方案/工作区中，创建一个名为`Exercise02`的控制台应用程序，提示用户输入城市，然后列出该城市中Northwind客户的公司名称，如下所示：
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, enhance the application by displaying a list of all unique cities that
    customers already reside in as a prompt to the user before they enter their preferred
    city, as shown in the following output:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过显示所有客户已居住的独特城市列表作为用户输入首选城市前的提示，来增强应用程序，如下所示：
- en: '[PRE65]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Exercise 11.3 – Explore topics
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.3 – 探索主题
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接，深入了解本章涉及的主题：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-11---querying-and-manipulating-data-using-linq](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-11---querying-and-manipulating-data-using-linq)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-11---querying-and-manipulating-data-using-linq](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-11---querying-and-manipulating-data-using-linq)'
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to write LINQ queries to select, project, filter,
    sort, join, and group data in many different formats, including XML, which are
    tasks you will perform every day.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你学习了如何编写LINQ查询来选择、投影、过滤、排序、连接和分组多种不同格式的数据，包括XML，这些都是你每天要执行的任务。
- en: In the next chapter, you will use the `Task` type to improve the performance
    of your applications.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章中，你将使用`Task`类型来提升应用程序的性能。
