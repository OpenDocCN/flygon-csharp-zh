- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Querying and Manipulating DataÂ Using LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about **Language INtegrated Query** (**LINQ**) expressions.
    LINQ is a set of language extensions that add the ability to work with sequences
    of items and then filter, sort, and project them into different outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing LINQ expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with sets using LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ with EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweetening LINQ syntax with syntactic sugar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple threads with parallel LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own LINQ extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with LINQ to XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing LINQ expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we wrote a few LINQ expressions in *Chapter 10*, *Working with Data
    Using Entity Framework Core*, they weren't the focus, and so I didn't properly
    explain how LINQ works, so let's now take time to properly understand them.
  prefs: []
  type: TYPE_NORMAL
- en: What makes LINQ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LINQ has several parts; some are required, and some are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extension methods (required)**: These include examples such as `Where`, `OrderBy`,
    and `Select`. These are what provide the functionality of LINQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ providers (required)**: These include LINQ to Objects for processing
    in-memory objects, LINQ to Entities for processing data stored in external databases
    and modeled with EF Core, and LINQ to XML for processing data stored as XML. These
    providers are what execute LINQ expressions in a way specific to different types
    of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lambda expressions (optional)**: These can be used instead of named methods
    to simplify LINQ queries, for example, for the conditional logic of the `Where`
    method for filtering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ query comprehension syntax (optional)**: These include C# keywords like
    `from`, `in`, `where`, `orderby`, `descending`, and `select`. These are aliases
    for some of the LINQ extension methods, and their use can simplify the queries
    you write, especially if you already have experience with other query languages,
    such as **Structured Query Language** (**SQL**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When programmers are first introduced to LINQ, they often believe that LINQ
    query comprehension syntax is LINQ, but ironically, that is one of the parts of
    LINQ that is optional!
  prefs: []
  type: TYPE_NORMAL
- en: Building LINQ expressions with the Enumerable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LINQ extension methods, such as `Where` and `Select`, are appended by the
    `Enumerable` static class to any type, known as a **sequence**, that implements
    `IEnumerable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an array of any type implements the `IEnumerable<T>` class, where
    `T` is the type of item in the array. This means that all arrays support LINQ
    to query and manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: All generic collections, such as `List<T>`, `Dictionary<TKey, TValue>`, `Stack<T>`,
    and `Queue<T>`, implement `IEnumerable<T>`, so they can be queried and manipulated
    with LINQ too.
  prefs: []
  type: TYPE_NORMAL
- en: '`Enumerable` defines more than 50 extension methods, as summarized in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `First`, `FirstOrDefault`, `Last`, `LastOrDefault` | Get the first or last
    item in the sequence or throw an exception, or return the default value for the
    type, for example, `0` for an `int` and `null` for a reference type, if there
    is not a first or last item. |'
  prefs: []
  type: TYPE_TB
- en: '| `Where` | Return a sequence of items that match a specified filter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Single`, `SingleOrDefault` | Return an item that matches a specific filter
    or throw an exception, or return the default value for the type if there is not
    exactly one match. |'
  prefs: []
  type: TYPE_TB
- en: '| `ElementAt`, `ElementAtOrDefault` | Return an item at a specified index position
    or throw an exception, or return the default value for the type if there is not
    an item at that position. New in .NET 6 are overloads that can be passed an `Index`
    instead of an `int`, which is more efficient when working with `Span<T>` sequences.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Select`, `SelectMany` | Project items into a different shape, that is, a
    different type, and flatten a nested hierarchy of items. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderBy`, `OrderByDescending`, `ThenBy`, `ThenByDescending` | Sort items
    by a specified field or property. |'
  prefs: []
  type: TYPE_TB
- en: '| `Reverse` | Reverse the order of the items. |'
  prefs: []
  type: TYPE_TB
- en: '| `GroupBy`, `GroupJoin`, `Join` | Group and/or join two sequences. |'
  prefs: []
  type: TYPE_TB
- en: '| `Skip`, `SkipWhile` | Skip a number of items; or skip while an expression
    is `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Take`, `TakeWhile` | Take a number of items; or take while an expression
    is `true`. New in .NET 6 is a `Take` overload that can be passed a `Range`, for
    example, `Take(range: 3..^5)` meaning take a subset starting 3 items in from the
    start and ending 5 items in from the end, or instead of `Skip(4)` you could use
    `Take(4..)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Aggregate`, `Average`, `Count`, `LongCount`, `Max`, `Min`, `Sum` | Calculate
    aggregate values. |'
  prefs: []
  type: TYPE_TB
- en: '| `TryGetNonEnumeratedCount` | `Count()` checks if a `Count` property is implemented
    on the sequence and returns its value, or it enumerates the entire sequence to
    count its items. New in .NET 6 is this method that only checks for `Count` and
    if it is missing it returns `false` and sets the `out` parameter to `0` to avoid
    a potentially poor-performing operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `All`, `Any`, `Contains` | Return `true` if all or any of the items match
    the filter, or if the sequence contains a specified item. |'
  prefs: []
  type: TYPE_TB
- en: '| `Cast` | Cast items into a specified type. It is useful to convert non-generic
    objects to a generic type in scenarios where the compiler would otherwise complain.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OfType` | Remove items that do not match a specified type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Distinct` | Remove duplicate items. |'
  prefs: []
  type: TYPE_TB
- en: '| `Except`, `Intersect`, `Union` | Perform operations that return sets. Sets
    cannot have duplicate items. Although the inputs can be any sequence and so the
    inputs can have duplicates, the result is always a set. |'
  prefs: []
  type: TYPE_TB
- en: '| `Chunk` | Divide a sequence into sized batches. |'
  prefs: []
  type: TYPE_TB
- en: '| `Append`, `Concat`, `Prepend` | Perform sequence-combining operations. |'
  prefs: []
  type: TYPE_TB
- en: '| `Zip` | Perform a match operation on two sequences based on the position
    of items, for example, the item at position 1 in the first sequence matches the
    item at position 1 in the second sequence. New in .NET 6 is a match operation
    on three sequences. Previously you would have had to run the two sequences overload
    twice to achieve the same goal. |'
  prefs: []
  type: TYPE_TB
- en: '| `ToArray`, `ToList`, `ToDictionary`, `ToHashSet`, `ToLookup` | Convert the
    sequence into an array or collection. These are the only extension methods that
    execute the LINQ expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `DistinctBy`, `ExceptBy`, `IntersectBy`, `UnionBy`, `MinBy`, `MaxBy` | New
    in .NET 6 are the `By` extension methods. They allow the comparison to be performed
    on a subset of the item rather than the entire item. For example, instead of removing
    duplicates by comparing an entire `Person` object, you could remove duplicates
    by comparing just their `LastName` and `DateOfBirth`. |'
  prefs: []
  type: TYPE_TB
- en: 'The `Enumerable` class also has some methods that are not extension methods,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Empty<T>` | Returns an empty sequence of the specified type `T`. It is useful
    for passing an empty sequence to a method that requires an `IEnumerable<T>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Range` | Returns a sequence of integers from the `start` value with `count`
    items. For example, `Enumerable.Range(start: 5, count: 3)` would contain the integers
    5, 6, and 7. |'
  prefs: []
  type: TYPE_TB
- en: '| `Repeat` | Returns a sequence that contains the same `element` repeated `count`
    times. For example, `Enumerable.Repeat(element: "5", count: 3)` would contain
    the `string` values "5", "5", and "5". |'
  prefs: []
  type: TYPE_TB
- en: Understanding deferred execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LINQ uses **deferred execution**. It is important to understand that calling
    most of these extension methods does not execute the query and get the results.
    Most of these extension methods return a LINQ expression that represents a *question*,
    not an *answer*. Let''s explore:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `Chapter11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter11`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `LinqWithObjects`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, delete the existing code and statically import `Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to define a sequence of `string` values for people who work
    in an office, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ask the question and get the answer, i.e. execute the query, you must **materialize**
    it by either calling one of the "To" methods like `ToArray` or `ToLookup` or by
    enumerating the query, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Due to deferred execution, after outputting the first result, `Pam`, if the
    original array values change, then by the time we loop back around, there are
    no more matches because `Jim` has become `Jimmy` and does not end with an `M`,
    so only `Pam` is outputted.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get too deep into the weeds, let's slow down and look at some common
    LINQ extension methods and how to use them, one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering entities with Where
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common reason for using LINQ is to filter items in a sequence using
    the `Where` extension method. Let''s explore filtering by defining a sequence
    of names and then applying LINQ operations to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project file, comment out the element that enables implicit usings,
    as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, attempt to call the `Where` extension method on the array
    of names, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you try to type the `Where` method, note that it is missing from the IntelliSense
    list of members of a string array, as shown in *Figure 11.1*:![](img/B17442_12_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.1: IntelliSense with the Where extension method missing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is because `Where` is an extension method. It does not exist on the array
    type. To make the `Where` extension method available, we must import the `System.Linq`
    namespace. This is implicitly imported by default in new .NET 6 projects, but
    we disabled it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the project file, uncomment out the element that enables implicit usings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retype the `Where` method and note that the IntelliSense list now includes the
    extension methods added by the `Enumerable` class, as shown in *Figure 11.2*:![](img/B17442_12_02.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.2: IntelliSense showing LINQ Enumerable extension methods now'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you type the parentheses for the `Where` method, IntelliSense tells us that
    to call `Where`, we must pass in an instance of a `Func<string, bool>` delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter an expression to create a new instance of a `Func<string, bool>` delegate,
    and for now note that we have not yet supplied a method name because we will define
    it in the next step, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Func<string, bool>` delegate tells us that for each `string` variable passed
    to the method, the method must return a `bool` value. If the method returns `true`,
    it indicates that we should include the `string` in the results, and if the method
    returns `false`, it indicates that we should exclude it.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting a named method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a method that only includes names that are longer than four characters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, define a method that will include only names
    longer than four characters, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above the `NameLongerThanFour` method, pass the method''s name into the `Func<string,
    bool>` delegate, and then loop through the query items, as shown highlighted in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, noting that only names longer than four
    letters are listed, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Simplifying the code by removing the explicit delegate instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can simplify the code by deleting the explicit instantiation of the `Func<string,
    bool>` delegate because the C# compiler can instantiate the delegate for us:'
  prefs: []
  type: TYPE_NORMAL
- en: To help you learn by seeing progressively improved code, copy and paste the
    query
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Comment out the first example, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the copy to remove the explicit instantiation of the delegate, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code and note that it has the same behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Targeting a lambda expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can simplify our code even further using a **lambda expression** in place
    of a named method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it can look complicated at first, a lambda expression is simply a
    *nameless function*. It uses the `=>` (read as "goes to") symbol to indicate the
    return value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy and paste the query, comment the second example, and modify the query,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the syntax for a lambda expression includes all the important parts
    of the `NameLongerThanFour` method, but nothing more. A lambda expression only
    needs to define the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The names of input parameters: `name`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A return value expression: `name.Length > 4`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the `name` input parameter is inferred from the fact that the sequence
    contains `string` values, and the return type must be a `bool` value as defined
    by the delegate for `Where` to work, so the expression after the `=>` symbol must
    return a `bool` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The compiler does most of the work for us, so our code can be as concise as
    possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the code and note that it has the same behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sorting entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other commonly used extension methods are `OrderBy` and `ThenBy`, used for sorting
    a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods can be chained if the previous method returns another sequence,
    that is, a type that implements the `IEnumerable<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by a single property using OrderBy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s continue working with the current project to explore sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Append a call to `OrderBy` to the end of the existing query, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Format the LINQ statement so that each extension method
    call happens on its own line to make them easier to read.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and note that the names are now sorted by shortest first, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To put the longest name first, you would use `OrderByDescending`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by a subsequent property using ThenBy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might want to sort by more than one property, for example, to sort names
    of the same length in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to the `ThenBy` method at the end of the existing query, as shown
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the slight difference in the following sort order. Within
    a group of names of the same length, the names are sorted alphabetically by the
    full value of the `string`, so `Creed` comes before `Kevin`, and `Angela` comes
    before `Dwight`, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declaring a query using var or a specified type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While writing a LINQ expression it is convenient to use `var` to declare the
    query object. This is because the type frequently changes as you work on the LINQ
    expression. For example, our query started as an `IEnumerable<string>` and is
    currently an `IOrderedEnumerable<string>`:'
  prefs: []
  type: TYPE_NORMAL
- en: Hover your mouse over the `var` keyword and note that its type is `IOrderedEnumerable<string>`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace `var` with the actual type, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Once you have finished working on a query, you could change
    the declared type from `var` to the actual type to make it clearer what the type
    is. This is easy because your code editor can tell you what it is.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Where` extension method is great for filtering by values, such as text
    and numbers. But what if the sequence contains multiple types, and you want to
    filter by a specific type and respect any inheritance hierarchy?
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a sequence of exceptions. There are hundreds of exception
    types that form a complex hierarchy, as partially shown in *Figure 11.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17442_12_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: A partial exception inheritance hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore filtering by type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, define a list of exception-derived objects, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write statements using the `OfType<T>` extension method to remove exceptions
    that are not arithmetic exceptions and write only the arithmetic exceptions to
    the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note that the results only include exceptions of the `ArithmeticException`
    type, or the `ArithmeticException`-derived types, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with sets and bags using LINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets are one of the most fundamental concepts in mathematics. A **set** is a
    collection of one or more unique objects. A **multiset**, aka **bag**, is a collection
    of one or more objects that can have duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: You might remember being taught about Venn diagrams in school. Common set operations
    include the **intersect** or **union** between sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a console application that will define three arrays of `string`
    values for cohorts of apprentices and then perform some common set and multiset
    operations on them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new console app named `LinqWithSets`
    to the `Chapter11` solution/workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `LinqWithSets` as the active OmniSharp project.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing code and statically import the `Console`
    type, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add the following method that outputs any sequence
    of `string` variables as a comma-separated single `string` to the console output,
    along with an optional description, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Above the `Output` method, add statements to define three arrays of names,
    output them, and then perform various set operations on them, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `Zip`, if there are unequal numbers of items in the two sequences, then
    some items will not have a matching partner. Those without a partner, like `Jared`,
    will not be included in the result.
  prefs: []
  type: TYPE_NORMAL
- en: For the `DistinctBy` example, instead of removing duplicates by comparing the
    whole name, we define a lambda key selector to remove duplicates by comparing
    the first two characters, so `Jared` is removed because `Jack` already is a name
    that starts with `Ja`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used the LINQ to Objects provider to work with in-memory objects.
    Next, we will use the LINQ to Entities provider to work with entities stored in
    a database.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at LINQ queries that filter and sort, but none that change the
    shape of the items in the sequence. This is called **projection** because it's
    about projecting items of one shape into another shape. To learn about projection,
    it is best to have some more complex types to work with, so in the next project,
    instead of using `string` sequences, we will use sequences of entities from the
    Northwind sample database.
  prefs: []
  type: TYPE_NORMAL
- en: I will give instructions to use SQLite because it is cross-platform but if you
    prefer to use SQL Server then feel free to do so. I have included some commented
    code to enable SQL Server if you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Building an EF Core model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must define an EF Core model to represent the database and tables that we
    will work with. We will define the model manually to take complete control and
    to prevent a relationship from being automatically defined between the `Categories`
    and `Products` tables. Later, you will use LINQ to join the two entity sets:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `LinqWithEFCore`
    to the `Chapter11` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `LinqWithEFCore` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `LinqWithEFCore` project, add a package reference to the EF Core provider
    for SQLite and/or SQL Server, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Northwind4Sqlite.sql` file into the `LinqWithEFCore` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal, create the Northwind database by executing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Be patient because this command might take a while to create the database structure.
    Eventually you will see the SQLite command prompt, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press cmd + D on macOS or Ctrl + C on Windows to exit SQLite command mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three class files to the project, named `Northwind.cs`, `Category.cs`, and
    `Product.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class file named `Northwind.cs`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the class file named `Category.cs`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the class file named `Product.cs`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project and fix any compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 2022 for Windows, then the compiled application
    executes in the `LinqWithEFCore\bin\Debug\net6.0` folder so it will not find the
    database file unless we indicate that it should always be copied to the output
    directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In **Solution Explorer**, right-click the `Northwind.db` file and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Properties**, set **Copy to Output Directory** to **Copy always**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filtering and sorting sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s write statements to filter and sort sequences of rows from the tables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, statically import the `Console` type and namespaces for working
    with EF Core and your entity model using LINQ, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, write a method to filter and sort products,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DbSet<T>` implements `IEnumerable<T>`, so LINQ can be used to query and manipulate
    collections of entities in models built for EF Core. (Actually, I should say `TEntity`
    instead of `T` but the name of this generic type has no functional effect. The
    only requirement is that the type is a `class`. The name just indicates the class
    is expected to be an entity model.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might have also noticed that the sequences implement `IQueryable<T>` (or
    `IOrderedQueryable<T>` after a call to an ordering LINQ method) instead of `IEnumerable<T>`
    or `IOrderedEnumerable<T>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is an indication that we are using a LINQ provider that builds the query
    in memory using expression trees. They represent code in a tree-like data structure
    and enable the creation of dynamic queries, which is useful for building LINQ
    queries for external data providers like SQLite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The LINQ expression will be converted into another query language, such as SQL.
    Enumerating the query with `foreach` or calling a method such as `ToArray` will
    force the execution of the query and materialize the results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the namespace imports in `Program.cs`, call the `FilterAndSort` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although this query outputs the information we want, it does so inefficiently
    because it gets all columns from the `Products` table instead of just the three
    columns we need, which is the equivalent of the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In *Chapter 10*, *Working with Data Using Entity Framework Core*, you learned
    how to log the SQL commands executed against SQLite so that you could see this
    for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting sequences into new types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we look at projection, we need to review object initialization syntax.
    If you have a class defined, then you can instantiate an object using the class
    name, `new()`, and curly braces to set initial values for fields and properties,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 3.0 and later allow instances of **anonymous types** to be instantiated
    using the `var` keyword, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we did not specify a type, the compiler can infer an anonymous type
    from the setting of two properties named `Name` and `DateOfBirth`. The compiler
    can infer the types of the two properties from the values assigned: a literal
    `string` and a new instance of a date/time value.'
  prefs: []
  type: TYPE_NORMAL
- en: This capability is especially useful when writing LINQ queries to project an
    existing type into a new type without having to explicitly define the new type.
    Since the type is anonymous, this can only work with `var`-declared local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the SQL command executed against the database table more efficient
    by adding a call to the `Select` method to project instances of the `Product`
    class into instances of a new anonymous type with only three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `FilterAndSort`, add a statement to extend the LINQ query to use the `Select`
    method to return only the three properties (that is, table columns) that we need,
    and modify the `foreach` statement to use the `var` keyword and the projection
    LINQ expression, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hover your mouse over the `new` keyword in the `Select` method call and the
    `var` keyword in the `foreach` statement and note that it is an anonymous type,
    as shown in *Figure 11.4*:![](img/B17442_12_05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.4: An anonymous type used during LINQ projection'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the code and confirm that the output is the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Joining and grouping sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two extension methods for joining and grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Join**: This method has four parameters: the sequence that you want to join
    with, the property or properties on the *left* sequence to match on, the property
    or properties on the *right* sequence to match on, and a projection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GroupJoin**: This method has the same parameters, but it combines the matches
    into a group object with a `Key` property for the matching value and an `IEnumerable<T>`
    type for the multiple matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explore these methods when working with two tables: `Categories` and
    `Products`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, create a method to select categories and products,
    join them, and output them, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a join, there are two sequences, *outer* and *inner*. In the previous example,
    `categories` is the outer sequence and `products` is the inner sequence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of `Program.cs`, comment out the call to `FilterAndSort` and call
    `JoinCategoriesAndProducts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, as shown in the following output (edited to only
    include the first 10 items):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the existing query, call the `OrderBy` method to sort by `CategoryName`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, and the results show all products in the `Beverages`
    category first, then the `Condiments` category, and so on, as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Group-joining sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, create a method to group and join, show the
    group name, and then show all the items within each group, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we had not called the `AsEnumerable` method, then a runtime exception would
    have been thrown, as shown in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because not all LINQ extension methods can be converted from expression
    trees into some other query syntax like SQL. In these cases, we can convert from
    `IQueryable<T>` to `IEnumerable<T>` by calling the `AsEnumerable` method, which
    forces query processing to use LINQ to EF Core only to bring the data into the
    application and then use LINQ to Objects to execute more complex processing in
    memory. But, often, this is less efficient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the top of `Program.cs`, comment out the previous method call and call `GroupJoinCategoriesAndProducts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, view the results, and note that the products inside each category
    have been sorted by their name, as defined in the query and as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Aggregating sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are LINQ extension methods to perform aggregation functions, such as
    `Average` and `Sum`. Let''s write some code to see some of these methods in action
    aggregating information from the `Products` table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, create a method to show the use of the aggregation
    extension methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of `Program.cs`, comment out the previous method and call `AggregateProducts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sweetening LINQ syntax with syntactic sugar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# 3.0 introduced some new language keywords in 2008 to make it easier for programmers
    with experience with SQL to write LINQ queries. This syntactic sugar is sometimes
    called the **LINQ query comprehension syntax**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following array of `string` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To filter and sort the names, you could use extension methods and lambda expressions,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you could achieve the same results by using query comprehension syntax,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The compiler changes the query comprehension syntax to the equivalent extension
    methods and lambda expressions for you.
  prefs: []
  type: TYPE_NORMAL
- en: The `select` keyword is always required for LINQ query comprehension syntax.
    The `Select` extension method is optional when using extension methods and lambda
    expressions because if you do not call `Select`, then the whole item is implicitly
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: Not all extension methods have a C# keyword equivalent, for example, the `Skip`
    and `Take` extension methods, which are commonly used to implement paging for
    lots of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A query that skips and takes cannot be written using only the query comprehension
    syntax, so we could write the query using all extension methods, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can wrap query comprehension syntax in parentheses and then switch to
    using extension methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: Learn both extension methods with lambda expressions and
    the query comprehension syntax ways of writing LINQ queries, because you are likely
    to have to maintain code that uses both.'
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple threads with parallel LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, only one thread is used to execute a LINQ query. **Parallel LINQ**
    (**PLINQ**) is an easy way to enable multiple threads to execute a LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Do not assume that using parallel threads will improve the
    performance of your applications. Always measure real-world timings and resource
    usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app that benefits from multiple threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see it in action, we will start with some code that only uses a single thread
    to calculate Fibonacci numbers for 45 integers. We will use the `StopWatch` type
    to measure the change in performance.
  prefs: []
  type: TYPE_NORMAL
- en: We will use operating system tools to monitor the CPU and CPU core usage. If
    you do not have multiple CPUs or at least multiple cores, then this exercise won't
    show much!
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `LinqInParallel`
    to the `Chapter11` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `LinqInParallel` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, delete the existing statements and then import the `System.Diagnostics`
    namespace so that we can use the `StopWatch` type, and statically import the `System.Console`
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to create a stopwatch to record timings, wait for a keypress
    before starting the timer, create 45 integers, calculate the last Fibonacci number
    for each of them, stop the timer, and display the elapsed milliseconds, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code, but do not press Enter to start the stopwatch yet because we need
    to make sure a monitoring tool is showing processor activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Windows, then right-click on the Windows **Start** button or
    press Ctrl + Alt + Delete, and then click on **Task Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the **Task Manager** window, click **More details**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **Task Manager** window, click on the **Performance** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **CPU Utilization** graph, select **Change graph to**, and
    then select **Logical processors**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using macOS, then launch **Activity Monitor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **View** | **Update Frequency Very often (1 sec)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see the CPU graphs, navigate to **Window** | **CPU History**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For all operating systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rearrange your monitoring tool and your code editor so that they are side by
    side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the CPUs to settle and then press Enter to start the stopwatch and
    run the query. The result should be a number of elapsed milliseconds, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The monitoring tool will probably show that one or two CPUs were used the most,
    alternating over time. Others may execute background tasks at the same time, such
    as the garbage collector, so the other CPUs or cores won't be completely flat,
    but the work is certainly not being evenly spread among all the possible CPUs
    or cores. Also, note that some of the logical processors are maxing out at 100%.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, modify the query to make a call to the `AsParallel` extension
    method and to sort the resulting sequence because when processing in parallel
    the results can become misordered, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Never call `AsParallel` at the end of a query. This does
    nothing. You must perform at least one operation after the call to `AsParallel`
    for that operation to be parallelized. .NET 6 introduces a code analyzer that
    will warn about this type of misuse.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code, wait for CPU charts in your monitoring tool to settle, and then
    press Enter to start the stopwatch and run the query. This time, the application
    should complete in less time (although it might not be as less as you might hope
    forâmanaging those multiple threads takes extra effort!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The monitoring tool should show that all CPUs were used equally to execute the
    LINQ query, and note that none of the logical processors max out at 100% because
    the work is more evenly spread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will learn more about managing multiple threads in *Chapter 12*, *Improving
    Performance and Scalability Using Multitasking*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own LINQ extension methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 6*, *Implementing Interfaces and Inheriting Classes*, you learned
    how to create your own extension methods. To create LINQ extension methods, all
    you must do is extend the `IEnumerable<T>` type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Put your own extension methods in a separate class library
    so that they can be easily deployed as their own assembly or NuGet package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will improve the `Average` extension method as an example. A well-educated
    school child will tell you that *average* can mean one of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean**: Sum the numbers and divide by the count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mode**: The most common number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Median**: The number in the middle of the numbers when ordered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft''s implementation of the `Average` extension method calculates the
    *mean*. We might want to define our own extension methods for `Mode` and `Median`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqWithEFCore` project, add a new class file named `MyLinqExtensions.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If this class was in a separate class library, to use your LINQ extension methods,
    you simply need to reference the class library assembly because the `System.Linq`
    namespace is already implicitly imported.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** All but one of the above extension methods cannot be used with
    `IQueryable` sequences like those used by LINQ to SQLite or LINQ to SQL Server
    because we have not implemented a way to translate our code into the underlying
    query language like SQL.'
  prefs: []
  type: TYPE_NORMAL
- en: Trying the chainable extension method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will try chaining the `ProcessSequence` method with other extension
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, in the `FilterAndSort` method, modify the LINQ query for `Products`
    to call your custom chainable extension method, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, uncomment the `FilterAndSort` method and comment out any calls
    to other methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code and note that you see the same output as before because your method
    doesn't modify the sequence. But you now know how to extend a LINQ expression
    with your own functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trying the mode and median methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Second, we will try using the `Mode` and `Median` methods to calculate other
    kinds of average:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, create a method to output the mean, median,
    and mode, for `UnitsInStock` and `UnitPrice` for products, using your custom extension
    methods and the built-in `Average` extension method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment any previous method calls and call `CustomExtensionMethods`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are four products with a unit price of $18.00\. There are five products
    with 0 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Working with LINQ to XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LINQ to XML** is a LINQ provider that allows you to query and manipulate
    XML.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating XML using LINQ to XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a method to convert the `Products` table into XML:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqWithEFCore` project, at the top of `Program.cs`, import the `System.Xml.Linq`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, create a method to output the products in XML
    format, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment the previous method call and call `OutputProductsAsXml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the structure of the XML generated
    matches the elements and attributes that the LINQ to XML statement declaratively
    described in the preceding code, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reading XML using LINQ to XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might want to use LINQ to XML to easily query or process XML files:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqWithEFCore` project, add a file named `settings.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using Visual Studio 2022 for Windows, then the compiled application
    executes in the `LinqWithEFCore\bin\Debug\net6.0` folder so it will not find the
    `settings.xml` file unless we indicate that it should always be copied to the
    output directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In **Solution Explorer**, right-click the `settings.xml` file and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Properties**, set **Copy to Output Directory** to **Copy always**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, create a method to complete these tasks, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the XML file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use LINQ to XML to search for an element named `appSettings` and its descendants
    named `add`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Project the XML into an array of an anonymous type with `Key` and `Value` properties.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enumerate through the array to show the results:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Program.cs`, comment the previous method call and call `ProcessSettings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics covered in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 11.1 â Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the two required parts of LINQ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which LINQ extension method would you use to return a subset of properties from
    a type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which LINQ extension method would you use to filter a sequence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List five LINQ extension methods that perform aggregation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `Select` and `SelectMany` extension methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `IEnumerable<T>` and `IQueryable<T>`? And how
    do you switch between them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the last type parameter `T` in generic `Func` delegates like `Func<T1,
    T2, T>` represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of a LINQ extension method that ends with `OrDefault`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is query comprehension syntax optional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create your own LINQ extension methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 11.2 â Practice querying with LINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter11` solution/workspace, create a console application, named
    `Exercise02`, that prompts the user for a city and then lists the company names
    for Northwind customers in that city, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enhance the application by displaying a list of all unique cities that
    customers already reside in as a prompt to the user before they enter their preferred
    city, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 11.3 â Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-11---querying-and-manipulating-data-using-linq](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-11---querying-and-manipulating-data-using-linq)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write LINQ queries to select, project, filter,
    sort, join, and group data in many different formats, including XML, which are
    tasks you will perform every day.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will use the `Task` type to improve the performance
    of your applications.
  prefs: []
  type: TYPE_NORMAL
