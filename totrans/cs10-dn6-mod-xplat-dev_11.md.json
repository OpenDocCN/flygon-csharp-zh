["```cs\n    // a string array is a sequence that implements IEnumerable<string>\n    string[] names = new[] { \"Michael\", \"Pam\", \"Jim\", \"Dwight\", \n      \"Angela\", \"Kevin\", \"Toby\", \"Creed\" };\n    WriteLine(\"Deferred execution\");\n    // Question: Which names end with an M?\n    // (written using a LINQ extension method)\n    var query1 = names.Where(name => name.EndsWith(\"m\"));\n    // Question: Which names end with an M?\n    // (written using LINQ query comprehension syntax)\n    var query2 = from name in names where name.EndsWith(\"m\") select name; \n    ```", "```cs\n    // Answer returned as an array of strings containing Pam and Jim\n    string[] result1 = query1.ToArray();\n    // Answer returned as a list of strings containing Pam and Jim\n    List<string> result2 = query2.ToList();\n    // Answer returned as we enumerate over the results\n    foreach (string name in query1)\n    {\n      WriteLine(name); // outputs Pam\n      names[2] = \"Jimmy\"; // change Jim to Jimmy\n      // on the second iteration Jimmy does not end with an M\n    } \n    ```", "```cs\n    Deferred execution\n    Pam \n    ```", "```cs\n    <Project Sdk=\"Microsoft.NET.Sdk\">\n      <PropertyGroup>\n        <OutputType>Exe</OutputType>\n        <TargetFramework>net6.0</TargetFramework>\n        <Nullable>enable</Nullable>\n     **<!--<ImplicitUsings>enable</ImplicitUsings>-->**\n      </PropertyGroup>\n    </Project> \n    ```", "```cs\n    WriteLine(\"Writing queries\"); \n    var query = names.W \n    ```", "```cs\n    var query = names.Where(new Func<string, bool>( )) \n    ```", "```cs\n    static bool NameLongerThanFour(string name)\n    {\n      return name.Length > 4;\n    } \n    ```", "```cs\n    var query = names.Where(\n      new Func<string, bool>(**NameLongerThanFour**));\n    **foreach** **(****string** **item** **in** **query)**\n    **{**\n     **WriteLine(item);**\n    **}** \n    ```", "```cs\n    Writing queries\n    Michael \n    Dwight \n    Angela \n    Kevin \n    Creed \n    ```", "```cs\n    // var query = names.Where(\n    //   new Func<string, bool>(NameLongerThanFour)); \n    ```", "```cs\n    var query = names.Where(NameLongerThanFour); \n    ```", "```cs\n    var query = names.Where(name => name.Length > 4); \n    ```", "```cs\n    var query = names\n      .Where(name => name.Length > 4)\n      .OrderBy(name => name.Length); \n    ```", "```cs\n    Kevin \n    Creed \n    Dwight \n    Angela \n    Michael \n    ```", "```cs\n    var query = names\n      .Where(name => name.Length > 4)\n      .OrderBy(name => name.Length)\n     **.ThenBy(name => name);** \n    ```", "```cs\n    Creed \n    Kevin \n    Angela \n    Dwight \n    Michael \n    ```", "```cs\n    **IOrderedEnumerable<****string****>** query = names\n      .Where(name => name.Length > 4)\n      .OrderBy(name => name.Length)\n      .ThenBy(name => name); \n    ```", "```cs\n    WriteLine(\"Filtering by type\");\n    List<Exception> exceptions = new()\n    {\n      new ArgumentException(), \n      new SystemException(),\n      new IndexOutOfRangeException(),\n      new InvalidOperationException(),\n      new NullReferenceException(),\n      new InvalidCastException(),\n      new OverflowException(),\n      new DivideByZeroException(),\n      new ApplicationException()\n    }; \n    ```", "```cs\n    IEnumerable<ArithmeticException> arithmeticExceptionsQuery = \n      exceptions.OfType<ArithmeticException>();\n    foreach (ArithmeticException exception in arithmeticExceptionsQuery)\n    {\n      WriteLine(exception);\n    } \n    ```", "```cs\n    System.OverflowException: Arithmetic operation resulted in an overflow.\n    System.DivideByZeroException: Attempted to divide by zero. \n    ```", "```cs\n    using static System.Console; \n    ```", "```cs\n    static void Output(IEnumerable<string> cohort, string description = \"\")\n    {\n      if (!string.IsNullOrEmpty(description))\n      {\n        WriteLine(description);\n      }\n      Write(\" \");\n      WriteLine(string.Join(\", \", cohort.ToArray()));\n      WriteLine();\n    } \n    ```", "```cs\n    string[] cohort1 = new[]\n      { \"Rachel\", \"Gareth\", \"Jonathan\", \"George\" }; \n    string[] cohort2 = new[]\n      { \"Jack\", \"Stephen\", \"Daniel\", \"Jack\", \"Jared\" }; \n    string[] cohort3 = new[]\n      { \"Declan\", \"Jack\", \"Jack\", \"Jasmine\", \"Conor\" }; \n    Output(cohort1, \"Cohort 1\");\n    Output(cohort2, \"Cohort 2\");\n    Output(cohort3, \"Cohort 3\"); \n    Output(cohort2.Distinct(), \"cohort2.Distinct()\"); \n    Output(cohort2.DistinctBy(name => name.Substring(0, 2)), \n      \"cohort2.DistinctBy(name => name.Substring(0, 2)):\");\n    Output(cohort2.Union(cohort3), \"cohort2.Union(cohort3)\"); \n    Output(cohort2.Concat(cohort3), \"cohort2.Concat(cohort3)\"); \n    Output(cohort2.Intersect(cohort3), \"cohort2.Intersect(cohort3)\"); \n    Output(cohort2.Except(cohort3), \"cohort2.Except(cohort3)\"); \n    Output(cohort1.Zip(cohort2,(c1, c2) => $\"{c1} matched with {c2}\"), \n      \"cohort1.Zip(cohort2)\"); \n    ```", "```cs\n    Cohort 1\n      Rachel, Gareth, Jonathan, George \n    Cohort 2\n      Jack, Stephen, Daniel, Jack, Jared \n    Cohort 3\n      Declan, Jack, Jack, Jasmine, Conor \n    cohort2.Distinct()\n      Jack, Stephen, Daniel, Jared \n    cohort2.DistinctBy(name => name.Substring(0, 2)):\n      Jack, Stephen, Daniel \n    cohort2.Union(cohort3)\n      Jack, Stephen, Daniel, Jared, Declan, Jasmine, Conor \n    cohort2.Concat(cohort3)\n      Jack, Stephen, Daniel, Jack, Jared, Declan, Jack, Jack, Jasmine, Conor \n    cohort2.Intersect(cohort3)\n      Jack \n    cohort2.Except(cohort3)\n      Stephen, Daniel, Jared \n    cohort1.Zip(cohort2)\n      Rachel matched with Jack, Gareth matched with Stephen, Jonathan matched with Daniel, George matched with Jack \n    ```", "```cs\n    <ItemGroup>\n      <PackageReference\n        Include=\"Microsoft.EntityFrameworkCore.Sqlite\"\n        Version=\"6.0.0\" />\n      <PackageReference\n        Include=\"Microsoft.EntityFrameworkCore.SqlServer\"\n        Version=\"6.0.0\" />\n    </ItemGroup> \n    ```", "```cs\n    sqlite3 Northwind.db -init Northwind4Sqlite.sql \n    ```", "```cs\n     -- Loading resources from Northwind.sql \n    SQLite version 3.36.0 2021-08-02 15:20:15\n    Enter \".help\" for usage hints.\n    sqlite> \n    ```", "```cs\n    using Microsoft.EntityFrameworkCore; // DbContext, DbSet<T>\n    namespace Packt.Shared;\n    // this manages the connection to the database\n    public class Northwind : DbContext\n    {\n      // these properties map to tables in the database\n      public DbSet<Category>? Categories { get; set; }\n      public DbSet<Product>? Products { get; set; }\n      protected override void OnConfiguring(\n        DbContextOptionsBuilder optionsBuilder)\n      {\n        string path = Path.Combine(\n          Environment.CurrentDirectory, \"Northwind.db\");\n        optionsBuilder.UseSqlite($\"Filename={path}\");\n        /*\n        string connection = \"Data Source=.;\" +\n            \"Initial Catalog=Northwind;\" +\n            \"Integrated Security=true;\" +\n            \"MultipleActiveResultSets=true;\";\n        optionsBuilder.UseSqlServer(connection);\n        */\n      }\n      protected override void OnModelCreating(\n        ModelBuilder modelBuilder)\n      {\n        modelBuilder.Entity<Product>()\n          .Property(product => product.UnitPrice)\n          .HasConversion<double>();\n      }\n    } \n    ```", "```cs\n    using System.ComponentModel.DataAnnotations;\n    namespace Packt.Shared;\n    public class Category\n    {\n      public int CategoryId { get; set; }\n      [Required]\n      [StringLength(15)]\n      public string CategoryName { get; set; } = null!;\n      public string? Description { get; set; }\n    } \n    ```", "```cs\n    using System.ComponentModel.DataAnnotations; \n    using System.ComponentModel.DataAnnotations.Schema;\n    namespace Packt.Shared;\n    public class Product\n    {\n      public int ProductId { get; set; }\n      [Required]\n      [StringLength(40)]\n      public string ProductName { get; set; } = null!;\n      public int? SupplierId { get; set; }\n      public int? CategoryId { get; set; }\n      [StringLength(20)]\n      public string? QuantityPerUnit { get; set; }\n      [Column(TypeName = \"money\")] // required for SQL Server provider\n      public decimal? UnitPrice { get; set; }\n      public short? UnitsInStock { get; set; }\n      public short? UnitsOnOrder { get; set; }\n      public short? ReorderLevel { get; set; }\n      public bool Discontinued { get; set; }\n    } \n    ```", "```cs\n    using Packt.Shared; // Northwind, Category, Product\n    using Microsoft.EntityFrameworkCore; // DbSet<T>\n    using static System.Console; \n    ```", "```cs\n    static void FilterAndSort()\n    {\n      using (Northwind db = new())\n      {\n        DbSet<Product> allProducts = db.Products;\n        IQueryable<Product> filteredProducts = \n          allProducts.Where(product => product.UnitPrice < 10M);\n        IOrderedQueryable<Product> sortedAndFilteredProducts = \n          filteredProducts.OrderByDescending(product => product.UnitPrice);\n        WriteLine(\"Products that cost less than $10:\");\n        foreach (Product p in sortedAndFilteredProducts)\n        {\n          WriteLine(\"{0}: {1} costs {2:$#,##0.00}\",\n            p.ProductId, p.ProductName, p.UnitPrice);\n        }\n        WriteLine();\n      }\n    } \n    ```", "```cs\n    Products that cost less than $10:\n    41: Jack's New England Clam Chowder costs $9.65 \n    45: Rogede sild costs $9.50\n    47: Zaanse koeken costs $9.50\n    19: Teatime Chocolate Biscuits costs $9.20 \n    23: Tunnbröd costs $9.00\n    75: Rhönbräu Klosterbier costs $7.75 \n    54: Tourtière costs $7.45\n    52: Filo Mix costs $7.00 \n    13: Konbu costs $6.00\n    24: Guaraná Fantástica costs $4.50 \n    33: Geitost costs $2.50 \n    ```", "```cs\nSELECT * FROM Products; \n```", "```cs\npublic class Person\n{\n  public string Name { get; set; }\n  public DateTime DateOfBirth { get; set; }\n}\nPerson knownTypeObject = new()\n{\n  Name = \"Boris Johnson\",\n  DateOfBirth = new(year: 1964, month: 6, day: 19)\n}; \n```", "```cs\nvar anonymouslyTypedObject = new\n{\n  Name = \"Boris Johnson\",\n  DateOfBirth = new DateTime(year: 1964, month: 6, day: 19)\n}; \n```", "```cs\n    IOrderedQueryable<Product> sortedAndFilteredProducts = \n      filteredProducts.OrderByDescending(product => product.UnitPrice);\n    **var** **projectedProducts = sortedAndFilteredProducts**\n     **.Select(product =>** **new****// anonymous type**\n     **{**\n     **product.ProductId,**\n     **product.ProductName,** \n     **product.UnitPrice**\n     **});**\n    WriteLine(\"Products that cost less than $10:\");\n    foreach (**var** **p** **in** **projectedProducts**)\n    { \n    ```", "```cs\n    static void JoinCategoriesAndProducts()\n    {\n      using (Northwind db = new())\n      {\n        // join every product to its category to return 77 matches\n        var queryJoin = db.Categories.Join(\n          inner: db.Products,\n          outerKeySelector: category => category.CategoryId,\n          innerKeySelector: product => product.CategoryId,\n          resultSelector: (c, p) =>\n            new { c.CategoryName, p.ProductName, p.ProductId });\n        foreach (var item in queryJoin)\n        {\n          WriteLine(\"{0}: {1} is in {2}.\",\n            arg0: item.ProductId,\n            arg1: item.ProductName,\n            arg2: item.CategoryName);\n        }\n      }\n    } \n    ```", "```cs\n    1: Chai is in Beverages. \n    2: Chang is in Beverages.\n    3: Aniseed Syrup is in Condiments.\n    4: Chef Anton's Cajun Seasoning is in Condiments. \n    5: Chef Anton's Gumbo Mix is in Condiments.\n    6: Grandma's Boysenberry Spread is in Condiments. \n    7: Uncle Bob's Organic Dried Pears is in Produce. \n    8: Northwoods Cranberry Sauce is in Condiments.\n    9: Mishi Kobe Niku is in Meat/Poultry. \n    10: Ikura is in Seafood.\n    ... \n    ```", "```cs\n    .OrderBy(cp => cp.CategoryName); \n    ```", "```cs\n    1: Chai is in Beverages. \n    2: Chang is in Beverages.\n    24: Guaraná Fantástica is in Beverages. \n    34: Sasquatch Ale is in Beverages.\n    35: Steeleye Stout is in Beverages. \n    38: Côte de Blaye is in Beverages. \n    39: Chartreuse verte is in Beverages. \n    43: Ipoh Coffee is in Beverages.\n    67: Laughing Lumberjack Lager is in Beverages. \n    70: Outback Lager is in Beverages.\n    75: Rhönbräu Klosterbier is in Beverages. \n    76: Lakkalikööri is in Beverages.\n    3: Aniseed Syrup is in Condiments.\n    4: Chef Anton's Cajun Seasoning is in Condiments.\n    ... \n    ```", "```cs\n    static void GroupJoinCategoriesAndProducts()\n    {\n      using (Northwind db = new())\n      {\n        // group all products by their category to return 8 matches\n        var queryGroup = db.Categories.AsEnumerable().GroupJoin(\n          inner: db.Products,\n          outerKeySelector: category => category.CategoryId,\n          innerKeySelector: product => product.CategoryId,\n          resultSelector: (c, matchingProducts) => new\n          {\n            c.CategoryName,\n            Products = matchingProducts.OrderBy(p => p.ProductName)\n          });\n        foreach (var category in queryGroup)\n        {\n          WriteLine(\"{0} has {1} products.\",\n            arg0: category.CategoryName,\n            arg1: category.Products.Count());\n          foreach (var product in category.Products)\n          {\n            WriteLine($\" {product.ProductName}\");\n          }\n        }\n      }\n    } \n    ```", "```cs\n    Unhandled exception. System.ArgumentException:  Argument type 'System.Linq.IOrderedQueryable`1[Packt.Shared.Product]' does not match the corresponding member type 'System.Linq.IOrderedEnumerable`1[Packt.Shared.Product]' (Parameter 'arguments[1]') \n    ```", "```cs\n    Beverages has 12 products.\n      Chai\n      Chang\n      Chartreuse verte\n      Côte de Blaye\n      Guaraná Fantástica\n      Ipoh Coffee\n      Lakkalikööri\n      Laughing Lumberjack Lager\n      Outback Lager\n      Rhönbräu Klosterbier\n      Sasquatch Ale\n      Steeleye Stout\n    Condiments has 12 products.\n      Aniseed Syrup\n      Chef Anton's Cajun Seasoning\n      Chef Anton's Gumbo Mix\n    ... \n    ```", "```cs\n    static void AggregateProducts()\n    {\n      using (Northwind db = new())\n      {\n        WriteLine(\"{0,-25} {1,10}\",\n          arg0: \"Product count:\",\n          arg1: db.Products.Count());\n        WriteLine(\"{0,-25} {1,10:$#,##0.00}\",\n          arg0: \"Highest product price:\",\n          arg1: db.Products.Max(p => p.UnitPrice));\n        WriteLine(\"{0,-25} {1,10:N0}\",\n          arg0: \"Sum of units in stock:\",\n          arg1: db.Products.Sum(p => p.UnitsInStock));\n        WriteLine(\"{0,-25} {1,10:N0}\",\n          arg0: \"Sum of units on order:\",\n          arg1: db.Products.Sum(p => p.UnitsOnOrder));\n        WriteLine(\"{0,-25} {1,10:$#,##0.00}\",\n          arg0: \"Average unit price:\",\n          arg1: db.Products.Average(p => p.UnitPrice));\n        WriteLine(\"{0,-25} {1,10:$#,##0.00}\",\n          arg0: \"Value of units in stock:\",\n          arg1: db.Products\n            .Sum(p => p.UnitPrice * p.UnitsInStock));\n      }\n    } \n    ```", "```cs\n    Product count:                    77\n    Highest product price:       $263.50\n    Sum of units in stock:         3,119\n    Sum of units on order:           780\n    Average unit price:           $28.87\n    Value of units in stock:  $74,050.85 \n    ```", "```cs\nstring[] names = new[] { \"Michael\", \"Pam\", \"Jim\", \"Dwight\", \n  \"Angela\", \"Kevin\", \"Toby\", \"Creed\" }; \n```", "```cs\nvar query = names\n  .Where(name => name.Length > 4)\n  .OrderBy(name => name.Length)\n  .ThenBy(name => name); \n```", "```cs\nvar query = from name in names\n  where name.Length > 4\n  orderby name.Length, name \n  select name; \n```", "```cs\nvar query = names\n  .Where(name => name.Length > 4)\n  .Skip(80)\n  .Take(10); \n```", "```cs\nvar query = (from name in names\n  where name.Length > 4\n  select name)\n  .Skip(80)\n  .Take(10); \n```", "```cs\n    Stopwatch watch = new(); \n    Write(\"Press ENTER to start. \"); \n    ReadLine();\n    watch.Start();\n    int max = 45;\n    IEnumerable<int> numbers = Enumerable.Range(start: 1, count: max);\n    WriteLine($\"Calculating Fibonacci sequence up to {max}. Please wait...\");\n    int[] fibonacciNumbers = numbers\n      .Select(number => Fibonacci(number)).ToArray(); \n    watch.Stop();\n    WriteLine(\"{0:#,##0} elapsed milliseconds.\",\n      arg0: watch.ElapsedMilliseconds);\n    Write(\"Results:\");\n    foreach (int number in fibonacciNumbers)\n    {\n      Write($\" {number}\");\n    }\n    static int Fibonacci(int term) =>\n      term switch\n      {\n        1 => 0,\n        2 => 1,\n        _ => Fibonacci(term - 1) + Fibonacci(term - 2)\n      }; \n    ```", "```cs\n    Press ENTER to start. \n    Calculating Fibonacci sequence up to 45\\. Please wait...\n    17,624 elapsed milliseconds.\n    Results: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 \n    ```", "```cs\n    int[] fibonacciNumbers = numbers.**AsParallel()**\n      .Select(number => Fibonacci(number))\n     **.OrderBy(number => number)**\n      .ToArray(); \n    ```", "```cs\n    Press ENTER to start. \n    Calculating Fibonacci sequence up to 45\\. Please wait...\n    9,028 elapsed milliseconds.\n    Results: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 \n    ```", "```cs\n    namespace System.Linq; // extend Microsoft's namespace\n    public static class MyLinqExtensions\n    {\n      // this is a chainable LINQ extension method\n      public static IEnumerable<T> ProcessSequence<T>(\n        this IEnumerable<T> sequence)\n      {\n        // you could do some processing here\n        return sequence;\n      }\n      public static IQueryable<T> ProcessSequence<T>(\n        this IQueryable<T> sequence)\n      {\n        // you could do some processing here\n        return sequence;\n      }\n      // these are scalar LINQ extension methods\n      public static int? Median(\n        this IEnumerable<int?> sequence)\n      {\n        var ordered = sequence.OrderBy(item => item);\n        int middlePosition = ordered.Count() / 2;\n        return ordered.ElementAt(middlePosition);\n      }\n      public static int? Median<T>(\n        this IEnumerable<T> sequence, Func<T, int?> selector)\n      {\n        return sequence.Select(selector).Median();\n      }\n      public static decimal? Median(\n        this IEnumerable<decimal?> sequence)\n      {\n        var ordered = sequence.OrderBy(item => item);\n        int middlePosition = ordered.Count() / 2;\n        return ordered.ElementAt(middlePosition);\n      }\n      public static decimal? Median<T>(\n        this IEnumerable<T> sequence, Func<T, decimal?> selector)\n      {\n        return sequence.Select(selector).Median();\n      }\n      public static int? Mode(\n        this IEnumerable<int?> sequence)\n      {\n        var grouped = sequence.GroupBy(item => item);\n        var orderedGroups = grouped.OrderByDescending(\n          group => group.Count());\n        return orderedGroups.FirstOrDefault()?.Key;\n      }\n      public static int? Mode<T>(\n        this IEnumerable<T> sequence, Func<T, int?> selector)\n      {\n        return sequence.Select(selector)?.Mode();\n      }\n      public static decimal? Mode(\n        this IEnumerable<decimal?> sequence)\n      {\n        var grouped = sequence.GroupBy(item => item);\n        var orderedGroups = grouped.OrderByDescending(\n          group => group.Count());\n        return orderedGroups.FirstOrDefault()?.Key;\n      }\n      public static decimal? Mode<T>(\n        this IEnumerable<T> sequence, Func<T, decimal?> selector)\n      {\n        return sequence.Select(selector).Mode();\n      }\n    } \n    ```", "```cs\n    DbSet<Product>? allProducts = db.Products;\n    if (allProducts is null)\n    {\n      WriteLine(\"No products found.\");\n      return;\n    }\n    **IQueryable<Product> processedProducts = allProducts.ProcessSequence();**\n    IQueryable<Product> filteredProducts = **processedProducts**\n      .Where(product => product.UnitPrice < 10M); \n    ```", "```cs\n    static void CustomExtensionMethods()\n    {\n      using (Northwind db = new())\n      {\n        WriteLine(\"Mean units in stock: {0:N0}\",\n          db.Products.Average(p => p.UnitsInStock));\n        WriteLine(\"Mean unit price: {0:$#,##0.00}\",\n          db.Products.Average(p => p.UnitPrice));\n        WriteLine(\"Median units in stock: {0:N0}\",\n          db.Products.Median(p => p.UnitsInStock));\n        WriteLine(\"Median unit price: {0:$#,##0.00}\",\n          db.Products.Median(p => p.UnitPrice));\n        WriteLine(\"Mode units in stock: {0:N0}\",\n          db.Products.Mode(p => p.UnitsInStock));\n        WriteLine(\"Mode unit price: {0:$#,##0.00}\",\n          db.Products.Mode(p => p.UnitPrice));\n      }\n    } \n    ```", "```cs\n    Mean units in stock: 41 \n    Mean unit price: $28.87 \n    Median units in stock: 26 \n    Median unit price: $19.50 \n    Mode units in stock: 0 \n    Mode unit price: $18.00 \n    ```", "```cs\n    static void OutputProductsAsXml()\n    {\n      using (Northwind db = new())\n      {\n        Product[] productsArray = db.Products.ToArray();\n        XElement xml = new(\"products\",\n          from p in productsArray\n          select new XElement(\"product\",\n            new XAttribute(\"id\",  p.ProductId),\n            new XAttribute(\"price\", p.UnitPrice),\n           new XElement(\"name\", p.ProductName)));\n        WriteLine(xml.ToString());\n      }\n    } \n    ```", "```cs\n    <products>\n      <product id=\"1\" price=\"18\">\n        <name>Chai</name>\n      </product>\n      <product id=\"2\" price=\"19\">\n        <name>Chang</name>\n      </product>\n    ... \n    ```", "```cs\n    <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n    <appSettings>\n      <add key=\"color\" value=\"red\" />\n      <add key=\"size\" value=\"large\" />\n      <add key=\"price\" value=\"23.99\" />\n    </appSettings> \n    ```", "```cs\n    static void ProcessSettings()\n    {\n      XDocument doc = XDocument.Load(\"settings.xml\");\n      var appSettings = doc.Descendants(\"appSettings\")\n        .Descendants(\"add\")\n        .Select(node => new\n        {\n          Key = node.Attribute(\"key\")?.Value,\n          Value = node.Attribute(\"value\")?.Value\n        }).ToArray();\n      foreach (var item in appSettings)\n      {\n        WriteLine($\"{item.Key}: {item.Value}\");\n      }\n    } \n    ```", "```cs\n    color: red \n    size: large \n    price: 23.99 \n    ```", "```cs\nEnter the name of a city: London \nThere are 6 customers in London: \nAround the Horn\nB's Beverages \nConsolidated Holdings \nEastern Connection \nNorth/South\nSeven Seas Imports \n```", "```cs\nAachen, Albuquerque, Anchorage, Århus, Barcelona, Barquisimeto, Bergamo, Berlin, Bern, Boise, Bräcke, Brandenburg, Bruxelles, Buenos Aires, Butte, Campinas, Caracas, Charleroi, Cork, Cowes, Cunewalde, Elgin, Eugene, Frankfurt a.M., Genève, Graz, Helsinki, I. de Margarita, Kirkland, Kobenhavn, Köln, Lander, Leipzig, Lille, Lisboa, London, Luleå, Lyon, Madrid, Mannheim, Marseille, México D.F., Montréal, München, Münster, Nantes, Oulu, Paris, Portland, Reggio Emilia, Reims, Resende, Rio de Janeiro, Salzburg, San Cristóbal, San Francisco, Sao Paulo, Seattle, Sevilla, Stavern, Strasbourg, Stuttgart, Torino, Toulouse, Tsawassen, Vancouver, Versailles, Walla Walla, Warszawa \n```"]