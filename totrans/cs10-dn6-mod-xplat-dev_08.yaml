- en: 08
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 08
- en: Working with Common .NET Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常见的 .NET 类型
- en: This chapter is about some common types that are included with .NET. These include
    types for manipulating numbers, text, collections, network access, reflection,
    and attributes; improving working with spans, indexes, and ranges; manipulating
    images; and internationalization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些随 .NET 一起提供的常见类型。这些类型包括用于操作数字、文本、集合、网络访问、反射和属性的类型；改进与跨度、索引和范围的工作；处理图像；以及国际化。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Working with numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数字
- en: Working with text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文本
- en: Working with dates and times
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理日期和时间
- en: Pattern matching with regular expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式进行模式匹配
- en: Storing multiple objects in collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集合中存储多个对象
- en: Working with spans, indexes, and ranges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理跨度、索引和范围
- en: Working with network resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理网络资源
- en: Working with reflection and attributes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反射和属性
- en: Working with images
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理图像
- en: Internationalizing your code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化你的代码
- en: Working with numbers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数字
- en: 'One of the most common types of data is numbers. The most common types in .NET
    for working with numbers are shown in the following table:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的数据类型之一是数字。.NET 中处理数字的最常见类型如下表所示：
- en: '| Namespace | Example type(s) | Description |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 示例类型 | 描述 |'
- en: '| `System` | `SByte`, `Int16`, `Int32`, `Int64` | Integers; that is, zero and
    positive and negative whole numbers |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `SByte`, `Int16`, `Int32`, `Int64` | 整数；即零和正负整数 |'
- en: '| `System` | `Byte`, `UInt16`, `UInt32`, `UInt64` | Cardinals; that is, zero
    and positive whole numbers |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `Byte`, `UInt16`, `UInt32`, `UInt64` | 基数；即零和正整数 |'
- en: '| `System` | `Half`, `Single`, `Double` | Reals; that is, floating-point numbers
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `Half`, `Single`, `Double` | 实数；即浮点数 |'
- en: '| `System` | `Decimal` | Accurate reals; that is, for use in science, engineering,
    or financial scenarios |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `Decimal` | 精确实数；即用于科学、工程或金融场景 |'
- en: '| `System.Numerics` | `BigInteger`, `Complex`, `Quaternion` | Arbitrarily large
    integers, complex numbers, and quaternion numbers |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `System.Numerics` | `BigInteger`, `Complex`, `Quaternion` | 任意大整数、复数和四元数
    |'
- en: .NET has had the 32-bit float and 64-bit double types since .NET Framework 1.0\.
    The IEEE 754 specification also defines a 16-bit floating point standard. Machine
    learning and other algorithms would benefit from this smaller, lower-precision
    number type so Microsoft introduced the `System.Half` type with .NET 5 and later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 自 .NET Framework 1.0 起就拥有 32 位浮点数和 64 位双精度类型。IEEE 754 标准还定义了一个 16 位浮点标准。机器学习和其他算法将从这种更小、精度更低的数字类型中受益，因此微软在
    .NET 5 及更高版本中引入了 `System.Half` 类型。
- en: Currently, the C# language does not define a `half` alias so you must use the
    .NET type `System.Half`. This might change in the future.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，C# 语言未定义 `half` 别名，因此必须使用 .NET 类型 `System.Half`。未来可能会发生变化。
- en: Working with big integers
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理大整数
- en: The largest whole number that can be stored in .NET types that have a C# alias
    is about eighteen and a half quintillion, stored in an unsigned `long` integer.
    But what if you need to store numbers larger than that?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 类型中能用 C# 别名表示的最大整数大约是十八万五千亿，存储在无符号 `long` 整数中。但如果需要存储更大的数字呢？
- en: 'Let''s explore numerics:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索数字：
- en: Use your preferred code editor to create a new solution/workspace named `Chapter08`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器创建一个名为 `Chapter08` 的新解决方案/工作区。
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用程序项目，如下表所示：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter08`'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter08`
- en: 'Project file and folder: `WorkingWithNumbers`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`WorkingWithNumbers`
- en: 'In `Program.cs`, delete the existing statements and add a statement to import
    `System.Numerics`, as shown in the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句并添加一条语句以导入`System.Numerics`，如下所示：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add statements to output the maximum value of the `ulong` type, and a number
    with 30 digits using `BigInteger`, as shown in the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以输出 `ulong` 类型的最大值，以及使用 `BigInteger` 表示的具有 30 位数字的数，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `40` in the format code means right-align 40 characters, so both numbers
    are lined up to the right-hand edge. The `N0` means use thousand separators and
    zero decimal places.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 格式代码中的 `40` 表示右对齐 40 个字符，因此两个数字都排列在右侧边缘。`N0` 表示使用千位分隔符且小数点后为零。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Working with complex numbers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理复数
- en: A complex number can be expressed as *a + bi*, where *a* and *b* are real numbers,
    and *i* is an imaginary unit, where *i*² *= −1*. If the real part *a* is zero,
    it is a pure imaginary number. If the imaginary part *b* is zero, it is a real
    number.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 复数可以表示为*a + bi*，其中*a*和*b*是实数，*i*是虚数单位，其中*i*² *= −1*。如果实部*a*为零，则它是纯虚数。如果虚部*b*为零，则它是实数。
- en: 'Complex numbers have practical applications in many **STEM** (**science, technology,
    engineering, and mathematics**) fields of study. Additionally, they are added
    by separately adding the real and imaginary parts of the summands; consider this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 复数在许多**STEM**（**科学、技术、工程和数学**）研究领域具有实际应用。此外，它们是通过分别添加被加数的实部和虚部来相加的；考虑这一点：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s explore complex numbers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索复数：
- en: 'In `Program.cs`, add statements to add two complex numbers, as shown in the
    following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以添加两个复数，如下列代码所示：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Understanding quaternions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解四元数
- en: Quaternions are a number system that extends complex numbers. They form a four-dimensional
    associative normed division algebra over the real numbers, and therefore also
    a domain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数是一种扩展复数系统的数字系统。它们构成了一个四维的关联范数除法代数，覆盖实数，因此也是一个域。
- en: Huh? Yes, I know. I don't understand that either. Don't worry; we're not going
    to write any code using them! Suffice to say, they are good at describing spatial
    rotations, so video game engines use them, as do many computer simulations and
    flight control systems.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯？是的，我知道。我也不明白。别担心，我们不会用它们来编写任何代码！可以说，它们擅长描述空间旋转，因此视频游戏引擎使用它们，许多计算机模拟和飞行控制系统也是如此。
- en: Working with text
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文本
- en: 'One of the other most common types of data for variables is text. The most
    common types in .NET for working with text are shown in the following table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的另一种最常见类型是文本。.NET中最常见的处理文本的类型如下表所示：
- en: '| Namespace | Type | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 类型 | 描述 |'
- en: '| `System` | `Char` | Storage for a single text character |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `Char` | 存储单个文本字符 |'
- en: '| `System` | `String` | Storage for multiple text characters |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `System` | `String` | 存储多个文本字符 |'
- en: '| `System.Text` | `StringBuilder` | Efficiently manipulates strings |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `System.Text` | `StringBuilder` | 高效地操作字符串 |'
- en: '| `System.Text.RegularExpressions` | `Regex` | Efficiently pattern-matches
    strings |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `System.Text.RegularExpressions` | `Regex` | 高效地匹配字符串模式 |'
- en: Getting the length of a string
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取字符串长度
- en: 'Let''s explore some common tasks when working with text; for example, sometimes
    you need to find out the length of a piece of text stored in a `string` variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一下处理文本时的一些常见任务；例如，有时您需要找出存储在`string`变量中的文本片段的长度：
- en: 'Use your preferred code editor to add a new console app named `WorkingWithText`
    to the `Chapter08` solution/workspace:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，在`Chapter08`解决方案/工作区中添加一个名为`WorkingWithText`的新控制台应用：
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，将解决方案的启动项目设置为当前选择。
- en: In Visual Studio Code, select `WorkingWithText` as the active OmniSharp project.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithText`作为活动的OmniSharp项目。
- en: 'In the `WorkingWithText` project, in `Program.cs`, add statements to define
    a variable to store the name of the city London, and then write its name and length
    to the console, as shown in the following code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithText`项目中，在`Program.cs`文件里，添加语句定义一个变量来存储城市伦敦的名称，然后将其名称和长度写入控制台，如下列代码所示：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Getting the characters of a string
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取字符串的字符
- en: The `string` class uses an array of `char` internally to store the text. It
    also has an indexer, which means that we can use the array syntax to read its
    characters. Array indexes start at zero, so the third character will be at index
    2.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类内部使用`char`数组来存储文本。它还有一个索引器，这意味着我们可以使用数组语法来读取其字符。数组索引从零开始，因此第三个字符将在索引2处。'
- en: 'Let''s see this in action:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何实际操作：
- en: 'Add a statement to write the characters at the first and third positions in
    the `string` variable, as shown in the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一条语句，以写出`string`变量中第一和第三位置的字符，如下列代码所示：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Splitting a string
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割字符串
- en: 'Sometimes, you need to split some text wherever there is a character, such
    as a comma:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要根据某个字符（如逗号）分割文本：
- en: 'Add statements to define a single `string` variable containing comma-separated
    city names, then use the `Split` method and specify that you want to treat commas
    as the separator, and then enumerate the returned array of `string` values, as
    shown in the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义一个包含逗号分隔的城市名称的单个`字符串`变量，然后使用`Split`方法并指定你希望将逗号作为分隔符，接着枚举返回的`字符串`值数组，如下所示：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Later in this chapter, you will learn how to handle more complex scenarios.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本章稍后，你将学习如何处理更复杂的场景。
- en: Getting part of a string
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取字符串的一部分
- en: 'Sometimes, you need to get part of some text. The `IndexOf` method has nine
    overloads that return the index position of a specified `char` or `string` within
    a `string`. The `Substring` method has two overloads, as shown in the following
    list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要获取文本的一部分。`IndexOf`方法有九个重载，它们返回指定`字符`或`字符串`在`字符串`中的索引位置。`Substring`方法有两个重载，如下所示：
- en: '`Substring(startIndex, length)`: returns a substring starting at `startIndex`
    and containing the next `length` characters.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Substring(startIndex, length)`：返回从`startIndex`开始并包含接下来`length`个字符的子字符串。'
- en: '`Substring(startIndex)`: returns a substring starting at `startIndex` and containing
    all characters up to the end of the string.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Substring(startIndex)`：返回从`startIndex`开始并包含所有字符直到字符串末尾的子字符串。'
- en: 'Let''s explore a simple example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子：
- en: 'Add statements to store a person''s full name in a `string` variable with a
    space character between the first and last name, find the position of the space,
    and then extract the first name and last name as two parts so that they can be
    recombined in a different order, as shown in the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以在`字符串`变量中存储一个人的全名，其中名字和姓氏之间有一个空格字符，找到空格的位置，然后提取名字和姓氏作为两个部分，以便它们可以以不同的顺序重新组合，如下所示：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the format of the initial full name was different, for example, `"LastName,
    FirstName"`, then the code would need to be different. As an optional exercise,
    try writing some statements that would change the input `"Jones, Alan"` into `"Alan
    Jones"`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始全名的格式不同，例如`"姓氏, 名字"`，那么代码将需要有所不同。作为可选练习，尝试编写一些语句，将输入`"Jones, Alan"`转换为`"Alan
    Jones"`。
- en: Checking a string for content
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查字符串内容
- en: 'Sometimes, you need to check whether a piece of text starts or ends with some
    characters or contains some characters. You can achieve this with methods named
    `StartsWith`, `EndsWith`, and `Contains`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要检查一段文本是否以某些字符开始或结束，或者是否包含某些字符。你可以使用名为`StartsWith`、`EndsWith`和`Contains`的方法来实现这一点：
- en: 'Add statements to store a `string` value and then check if it starts with or
    contains a couple of different `string` values, as shown in the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以存储一个`字符串`值，然后检查它是否以或包含几个不同的`字符串`值，如下所示：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Joining, formatting, and other string members
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接、格式化及其他字符串成员
- en: 'There are many other `string` members, as shown in the following table:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的`字符串`成员，如下表所示：
- en: '| Member | Description |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| `Trim`, `TrimStart`, `TrimEnd` | These methods trim whitespace characters
    such as space, tab, and carriage return from the beginning and/or end. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `修剪`，`TrimStart`，`TrimEnd` | 这些方法从开头和/或结尾修剪空格、制表符和回车等空白字符。 |'
- en: '| `ToUpper`, `ToLower` | These convert all the characters into uppercase or
    lowercase. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `ToUpper`，`ToLower` | 这些方法将所有字符转换为大写或小写。 |'
- en: '| `Insert`, `Remove` | These methods insert or remove some text. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `插入`，`移除` | 这些方法用于插入或移除某些文本。 |'
- en: '| `Replace` | This replaces some text with other text. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `替换` | 这会将某些文本替换为其他文本。 |'
- en: '| `string.Empty` | This can be used instead of allocating memory each time
    you use a literal `string` value using an empty pair of double quotes (`""`).
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `string.Empty` | 这可以用来代替每次使用空的双引号(`""`)字面量`字符串`值时分配内存。 |'
- en: '| `string.Concat` | This concatenates two `string` variables. The + operator
    does the equivalent when used between `string` operands. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `string.Concat` | 这会将两个`字符串`变量连接起来。当在`字符串`操作数之间使用时，+ 运算符执行等效操作。 |'
- en: '| `string.Join` | This concatenates one or more `string` variables with a character
    in between each one. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `string.Join` | 这会将一个或多个`字符串`变量与每个变量之间的字符连接起来。 |'
- en: '| `string.IsNullOrEmpty` | This checks whether a `string` variable is `null`
    or empty. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `string.IsNullOrEmpty` | 这检查`字符串`变量是否为`null`或空。 |'
- en: '| `string.IsNullOrWhitespace` | This checks whether a `string` variable is
    `null` or whitespace; that is, a mix of any number of horizontal and vertical
    spacing characters, for example, tab, space, carriage return, line feed, and so
    on. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `string.IsNullOrWhitespace` | 这检查`字符串`变量是否为`null`或空白；即，任意数量的水平和垂直空白字符的混合，例如，制表符、空格、回车、换行等。
    |'
- en: '| `string.Format` | An alternative method to string interpolation for outputting
    formatted `string` values, which uses positioned instead of named parameters.
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `string.Format` | 输出格式化`字符串`值的另一种方法，使用定位参数而不是命名参数。 |'
- en: Some of the preceding methods are static methods. This means that the method
    can only be called from the type, not from a variable instance. In the preceding
    table, I indicated the static methods by prefixing them with `string.`, as in
    `string.Format`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的一些方法是静态方法。这意味着该方法只能从类型调用，而不能从变量实例调用。在前面的表格中，我通过在它们前面加上`string.`来指示静态方法，例如`string.Format`。
- en: 'Let''s explore some of these methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些这些方法：
- en: 'Add statements to take an array of string values and combine them back together
    into a single string variable with separators using the `Join` method, as shown
    in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以使用`Join`方法将字符串值数组重新组合成带有分隔符的单个字符串变量，如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add statements to use positioned parameters and interpolated string formatting
    syntax to output the same three variables twice, as shown in the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以使用定位参数和插值字符串格式化语法来输出相同的三个变量两次，如下所示：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we could have simplified the second statement because `WriteLine`
    supports the same format codes as `string.Format`, as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以简化第二条语句，因为`WriteLine`支持与`string.Format`相同的格式代码，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Building strings efficiently
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效构建字符串
- en: You can concatenate two strings to make a new `string` using the `String.Concat`
    method or simply by using the `+` operator. But both of these choices are bad
    practice because .NET must create a completely new `string` in memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`String.Concat`方法或简单的`+`运算符将两个字符串连接起来以创建新的`字符串`。但这两种选择都是不良实践，因为.NET必须在内存中创建一个全新的`字符串`。
- en: This might not be noticeable if you are only adding two `string` values, but
    if you concatenate inside a loop with many iterations, it can have a significant
    negative impact on performance and memory use. In *Chapter 12*, *Improving Performance
    and Scalability Using Multitasking*, you will learn how to concatenate `string`
    variables efficiently using the `StringBuilder` type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是添加两个`字符串`值，这可能不明显，但如果您在循环中进行连接，并且迭代次数很多，它可能会对性能和内存使用产生显著的负面影响。在*第12章*，*使用多任务提高性能和可扩展性*中，您将学习如何使用`StringBuilder`类型高效地连接`字符串`变量。
- en: Working with dates and times
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日期和时间
- en: 'After numbers and text, the next most popular types of data to work with are
    dates and times. The two main types are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字和文本之后，接下来最常处理的数据类型是日期和时间。这两种主要类型如下：
- en: '`DateTime`: represents a combined date and time value for a fixed point in
    time.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime`：表示一个固定时间点的日期和时间值。'
- en: '`TimeSpan`: represents a duration of time.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeSpan`：表示一段时间。'
- en: These two types are often used together. For example, if you subtract one `DateTime`
    value from another, the result is a `TimeSpan`. If you add a `TimeSpan` to a `DateTime`
    then the result is a `DateTime` value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型通常一起使用。例如，如果您从一个`DateTime`值中减去另一个，结果是一个`TimeSpan`。如果您将一个`TimeSpan`添加到`DateTime`，则结果是一个`DateTime`值。
- en: Specifying date and time values
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定日期和时间值
- en: 'A common way to create a date and time value is to specify individual values
    for the date and time components like day and hour, as described in the following
    table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建日期和时间值的常见方法是分别为日期和时间组件（如日和小时）指定单独的值，如下表所述：
- en: '| Date/time parameter | Value range |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 日期/时间参数 | 值范围 |'
- en: '| `year` | 1 to 9999 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `年` | 1 到 9999 |'
- en: '| `month` | 1 to 12 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `月` | 1 到 12 |'
- en: '| `day` | 1 to the number of days in that month |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `日` | 1 到该月的天数 |'
- en: '| `hour` | 0 to 23 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `小时` | 0 到 23 |'
- en: '| `minute` | 0 to 59 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `分钟` | 0 到 59 |'
- en: '| `second` | 0 to 59 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `秒` | 0 到 59 |'
- en: An alternative is to provide the value as a `string` to be parsed, but this
    can be misinterpreted depending on the default culture of the thread. For example,
    in the UK, dates are specified as day/month/year, compared to the US, where dates
    are specified as month/day/year.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是提供一个`string`值进行解析，但这可能会根据线程的默认文化被误解。例如，在英国，日期指定为日/月/年，而在美国，日期指定为月/日/年。
- en: 'Let''s see what you might want to do with dates and times:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可能想要如何处理日期和时间：
- en: Use your preferred code editor to add a new console app named `WorkingWithTime`
    to the `Chapter08` solution/workspace.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器，在`Chapter08`解决方案/工作区中添加一个名为`WorkingWithTime`的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithTime` as the active OmniSharp project.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithTime`作为活动OmniSharp项目。
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    initialize some special date/time values, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句，然后添加语句以初始化一些特殊的日期/时间值，如以下代码所示：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add statements to define Christmas Day in 2021 (if this is in the past then
    use a future year) and display it in various ways, as shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义2021年的圣诞节（如果这已过去，则使用未来的一年），并以多种方式展示，如以下代码所示：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE24]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add statements to perform addition and subtraction with Christmas, as shown
    in the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以执行与圣诞节相关的加法和减法，如以下代码所示：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add statements to define the time on Christmas Day that your children might
    wake up to open presents, and display it in various ways, as shown in the following
    code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义圣诞节那天你的孩子们可能醒来打开礼物的时刻，并以多种方式展示，如以下代码所示：
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Globalization with dates and times
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球化与日期和时间
- en: 'The current culture controls how dates and times are parsed:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文化控制日期和时间的解析方式：
- en: At the top of `Program.cs`, import the `System.Globalization` namespace.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，导入`System.Globalization`命名空间。
- en: 'Add statements to show the current culture that is used to display date and
    time values, and then parse United States Independence Day and display it in various
    ways, as shown in the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以显示用于显示日期和时间值的当前文化，然后解析美国独立日并以多种方式展示，如以下代码所示：
- en: '[PRE29]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE30]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On my computer, the current culture is British English. If a date is given as
    4 July 2021, then it is correctly parsed regardless of whether the current culture
    is British or American. But if the date is given as 7/4/2021, then it is wrongly
    parsed as 7 April. You can override the current culture by specifying the correct
    culture as a provider when parsing, as shown in the third example above.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我的电脑上，当前文化是英式英语。如果给定日期为2021年7月4日，则无论当前文化是英式还是美式，都能正确解析。但如果日期给定为7/4/2021，则会被错误解析为4月7日。你可以通过在解析时指定正确的文化作为提供者来覆盖当前文化，如上文第三个示例所示。
- en: 'Add statements to loop from the year 2020 to 2025, displaying if the year is
    a leap year and how many days there are in February, and then show if Christmas
    and Independence Day are during daylight saving time, as shown in the following
    code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以循环从2020年到2025年，显示该年是否为闰年以及二月有多少天，然后展示圣诞节和独立日是否在夏令时期间，如以下代码所示：
- en: '[PRE31]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE32]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Working with only a date or a time
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅处理日期或时间
- en: .NET 6 introduces some new types for working with only a date value or only
    a time value named `DateOnly` and `TimeOnly`. These are better than using a `DateTime`
    value with a zero time to store a date-only value because it is type-safe and
    avoids misuse. `DateOnly` also maps better to database column types, for example,
    a `date` column in SQL Server. `TimeOnly` is good for setting alarms and scheduling
    regular meetings or events, and it maps to a `time` column in SQL Server.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 引入了一些新类型，用于仅处理日期值或时间值，分别名为 `DateOnly` 和 `TimeOnly`。这些类型比使用时间部分为零的 `DateTime`
    值来存储仅日期值更好，因为它们类型安全且避免了误用。`DateOnly` 也更适合映射到数据库列类型，例如 SQL Server 中的 `date` 列。`TimeOnly`
    适合设置闹钟和安排定期会议或活动，并映射到 SQL Server 中的 `time` 列。
- en: 'Let''s use them to plan a party for the Queen of England:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用它们来为英国女王策划一场派对：
- en: 'Add statements to define the Queen''s birthday, and a time for her party to
    start, and then combine the two values to make a calendar entry so we don''t miss
    her party, as shown in the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义女王的生日及派对开始时间，然后将这两个值合并以创建日历条目，以免错过她的派对，如下列代码所示：
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下列输出所示：
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Pattern matching with regular expressions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式模式匹配
- en: Regular expressions are useful for validating input from the user. They are
    very powerful and can get very complicated. Almost all programming languages have
    support for regular expressions and use a common set of special characters to
    define them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对于验证用户输入非常有用。它们功能强大且可能非常复杂。几乎所有编程语言都支持正则表达式，并使用一组通用的特殊字符来定义它们。
- en: 'Let''s try out some example regular expressions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些正则表达式的示例：
- en: Use your preferred code editor to add a new console app named `WorkingWithRegularExpressions`
    to the `Chapter08` solution/workspace.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，在 `Chapter08` 解决方案/工作区中添加一个名为 `WorkingWithRegularExpressions` 的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithRegularExpressions` as the active
    OmniSharp project.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，选择 `WorkingWithRegularExpressions` 作为活动 OmniSharp 项目。
- en: 'In `Program.cs`, import the following namespace:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，导入以下命名空间：
- en: '[PRE35]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Checking for digits entered as text
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查作为文本输入的数字
- en: 'We will start by implementing the common example of validating number input:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现验证数字输入的常见示例开始：
- en: 'Add statements to prompt the user to enter their age and then check that it
    is valid using a regular expression that looks for a digit character, as shown
    in the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句提示用户输入年龄，然后使用正则表达式检查其有效性，该正则表达式查找数字字符，如下列代码所示：
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note the following about the code:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下关于代码的内容：
- en: The `@` character switches off the ability to use escape characters in the string.
    Escape characters are prefixed with a backslash. For example, `\t` means a tab
    and `\n` means a new line. When writing regular expressions, we need to disable
    this feature. To paraphrase the television show The West Wing, "Let backslash
    be backslash."
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@` 字符关闭了在字符串中使用转义字符的能力。转义字符以前缀反斜杠表示。例如，`\t` 表示制表符，`\n` 表示新行。在编写正则表达式时，我们需要禁用此功能。借用电视剧《白宫风云》中的一句话，“让反斜杠就是反斜杠。”'
- en: Once escape characters are disabled with `@`, then they can be interpreted by
    a regular expression. For example, `\d` means digit. You will learn more regular
    expressions that are prefixed with a backslash later in this topic.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦使用 `@` 禁用了转义字符，它们就可以被正则表达式解释。例如，`\d` 表示数字。在本主题后面，您将学习更多以反斜杠为前缀的正则表达式。
- en: 'Run the code, enter a whole number such as `34` for the age, and view the result,
    as shown in the following output:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入一个整数如 `34` 作为年龄，并查看结果，如下列输出所示：
- en: '[PRE37]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the code again, enter `carrots`, and view the result, as shown in the following
    output:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，输入 `carrots`，并查看结果，如下列输出所示：
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the code again, enter `bob30smith`, and view the result, as shown in the
    following output:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，输入 `bob30smith`，并查看结果，如下列输出所示：
- en: '[PRE39]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The regular expression we used is `\d`, which means *one digit*. However, it
    does not specify what can be entered before and after that one digit. This regular
    expression could be described in English as "Enter any characters you want as
    long as you enter at least one digit character."
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用的正则表达式是 `\d`，表示*一个数字*。然而，它并未指定在该数字之前和之后可以输入什么。这个正则表达式可以用英语描述为“输入任何你想要的字符，只要你至少输入一个数字字符。”
- en: In regular expressions, you indicate the start of some input with the caret
    `^` symbol and the end of some input with the dollar `$` symbol. Let's use these
    symbols to indicate that we expect nothing else between the start and end of the
    input except for a digit.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在正则表达式中，您使用插入符号`^`符号表示某些输入的开始，使用美元`$`符号表示某些输入的结束。让我们使用这些符号来表示我们期望在输入的开始和结束之间除了数字外没有任何其他内容。
- en: 'Change the regular expression to `^\d$`, as shown highlighted in the following
    code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正则表达式更改为`^\d$`，如下面的代码中突出显示：
- en: '[PRE40]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the code again and note that it rejects any input except a single digit.
    We want to allow one or more digits. To do this, we add a `+` after the `\d` expression
    to modify the meaning to one or more.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码并注意它拒绝除单个数字外的任何输入。我们希望允许一个或多个数字。为此，我们在`\d`表达式后添加一个`+`，以修改其含义为一个或多个。
- en: 'Change the regular expression, as shown highlighted in the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改正则表达式，如下面的代码中突出显示：
- en: '[PRE41]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Run the code again and note the regular expression only allows zero or positive
    whole numbers of any length.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码并注意正则表达式仅允许长度为零或正整数的任何长度的数字。
- en: Regular expression performance improvements
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式性能改进
- en: The .NET types for working with regular expressions are used throughout the
    .NET platform and many of the apps built with it. As such, they have a significant
    impact on performance, but until now, they have not received much optimization
    attention from Microsoft.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中用于处理正则表达式的类型被广泛应用于.NET平台及其构建的许多应用程序中。因此，它们对性能有重大影响，但直到现在，它们还没有得到微软太多的优化关注。
- en: With .NET 5 and later, the `System.Text.RegularExpressions` namespace has rewritten
    internals to squeeze out maximum performance. Common regular expression benchmarks
    using methods like `IsMatch` are now five times faster. And the best thing is,
    you do not have to change your code to get the benefits!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 5及更高版本中，`System.Text.RegularExpressions`命名空间已重写内部以挤出最大性能。使用`IsMatch`等方法的常见正则表达式基准测试现在快了五倍。最好的事情是，您无需更改代码即可获得这些好处！
- en: Understanding the syntax of a regular expression
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解正则表达式的语法
- en: 'Here are some common regular expression symbols that you can use in regular
    expressions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些您可以在正则表达式中使用的常见正则表达式符号：
- en: '| Symbol | Meaning | Symbol | Meaning |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 | 符号 | 含义 |'
- en: '| `^` | Start of input | `$` | End of input |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 输入开始 | `$` | 输入结束 |'
- en: '| `\d` | A single digit | `\D` | A single NON-digit |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 单个数字 | `\D` | 单个非数字 |'
- en: '| `\s` | Whitespace | `\S` | NON-whitespace |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 空白 | `\S` | 非空白 |'
- en: '| `\w` | Word characters | `\W` | NON-word characters |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 单词字符 | `\W` | 非单词字符 |'
- en: '| `[A-Za-z0-9]` | Range(s) of characters | `\^` | ^ (caret) character |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Za-z0-9]` | 字符范围 | `\^` | ^（插入符号）字符 |'
- en: '| `[aeiou]` | Set of characters | `[^aeiou]` | NOT in a set of characters |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `[aeiou]` | 字符集 | `[^aeiou]` | 不在字符集中 |'
- en: '| `.` | Any single character | `\.` | . (dot) character |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 任何单个字符 | `\.` | .（点）字符 |'
- en: 'In addition, here are some regular expression quantifiers that affect the previous
    symbols in a regular expression:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是一些影响正则表达式中前述符号的正则表达式量词：
- en: '| Symbol | Meaning | Symbol | Meaning |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 | 符号 | 含义 |'
- en: '| `+` | One or more | `?` | One or none |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 一个或多个 | `?` | 一个或无 |'
- en: '| `{3}` | Exactly three | `{3,5}` | Three to five |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `{3}` | 恰好三个 | `{3,5}` | 三个到五个 |'
- en: '| `{3,}` | At least three | `{,3}` | Up to three |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `{3,}` | 至少三个 | `{,3}` | 最多三个 |'
- en: Examples of regular expressions
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式示例
- en: 'Here are some examples of regular expressions with a description of their meaning:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些带有其含义描述的正则表达式示例：
- en: '| Expression | Meaning |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 含义 |'
- en: '| `\d` | A single digit somewhere in the input |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 输入中某处的单个数字 |'
- en: '| `a` | The character *a* somewhere in the input |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 输入中某处的字符*a* |'
- en: '| `Bob` | The word *Bob* somewhere in the input |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `Bob` | 输入中某处的单词*Bob* |'
- en: '| `^Bob` | The word *Bob* at the start of the input |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `^Bob` | 输入开头的单词*Bob* |'
- en: '| `Bob$` | The word *Bob* at the end of the input |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `Bob$` | 输入末尾的单词*Bob* |'
- en: '| `^\d{2}$` | Exactly two digits |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `^\d{2}$` | 恰好两个数字 |'
- en: '| `^[0-9]{2}$` | Exactly two digits |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `^[0-9]{2}$` | 恰好两个数字 |'
- en: '| `^[A-Z]{4,}$` | At least four uppercase English letters in the ASCII character
    set only |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `^[A-Z]{4,}$` | ASCII字符集中仅包含至少四个大写英文字母 |'
- en: '| `^[A-Za-z]{4,}$` | At least four upper or lowercase English letters in the
    ASCII character set only |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `^[A-Za-z]{4,}$` | ASCII字符集中仅包含至少四个大写或小写英文字母 |'
- en: '| `^[A-Z]{2}\d{3}$` | Two uppercase English letters in the ASCII character
    set and three digits only |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `^[A-Z]{2}\d{3}$` | ASCII字符集中仅包含两个大写英文字母和三个数字 |'
- en: '| `^[A-Za-z\u00c0-\u017e]+$` | At least one uppercase or lowercase English
    letter in the ASCII character set or European letters in the Unicode character
    set, as shown in the following list:ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿıŒœŠšŸ
    Žž |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `^[A-Za-z\u00c0-\u017e]+$` | 至少一个ASCII字符集中的大写或小写英文字母，或Unicode字符集中的欧洲字母，如下表所示：ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿıŒœŠšŸ
    Žž |'
- en: '| `^d.g$` | The letter *d*, then any character, and then the letter *g*, so
    it would match both *dig* and *dog* or any single character between the *d* and
    *g* |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `^d.g$` | 字母*d*，然后是任何字符，然后是字母*g*，因此它会匹配*dig*和*dog*或*d*和*g*之间的任何单个字符 |'
- en: '| `^d\.g$` | The letter *d*, then a dot (.), and then the letter *g*, so it
    would match *d.g* only |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `^d\.g$` | 字母*d*，然后是一个点（.），然后是字母*g*，因此它只会匹配*d.g* |'
- en: '**Good Practice**: Use regular expressions to validate input from the user.
    The same regular expressions can be reused in other languages such as JavaScript
    and Python.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：使用正则表达式验证用户输入。相同的正则表达式可以在JavaScript和Python等其他语言中重复使用。'
- en: Splitting a complex comma-separated string
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割复杂的逗号分隔字符串
- en: Earlier in this chapter, you learned how to split a simple comma-separated string
    variable. But what about the following example of film titles?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面，你学习了如何分割一个简单的逗号分隔的字符串变量。但电影标题的以下示例呢？
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `string` value uses double quotes around each film title. We can use these
    to identify whether we need to split on a comma (or not). The `Split` method is
    not powerful enough, so we can use a regular expression instead.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串值使用双引号围绕每个电影标题。我们可以利用这些来判断是否需要在逗号处分割（或不分割）。`Split`方法不够强大，因此我们可以使用正则表达式代替。
- en: '**Good Practice**: You can read a fuller explanation in the Stack Overflow
    article that inspired this task at the following link: [https://stackoverflow.com/questions/18144431/regex-to-split-a-csv](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：你可以在Stack Overflow文章中找到更详细的解释，该文章启发了此任务，链接如下：[https://stackoverflow.com/questions/18144431/regex-to-split-a-csv](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv)'
- en: 'To include double quotes inside a `string` value, we prefix them with a backslash:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`string`值中包含双引号，我们可以在它们前面加上反斜杠：
- en: 'Add statements to store a complex comma-separated `string` variable, and then
    split it in a dumb way using the `Split` method, as shown in the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以存储一个复杂的逗号分隔的`string`变量，然后使用`Split`方法以一种笨拙的方式分割它，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add statements to define a regular expression to split and write the film titles
    in a smart way, as shown in the following code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义一个正则表达式，用于智能地分割并写出电影标题，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE45]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Storing multiple objects in collections
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集合中存储多个对象
- en: Another of the most common types of data is collections. If you need to store
    multiple values in a variable, then you can use a collection.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种最常见的数据类型是集合。如果你需要在变量中存储多个值，那么你可以使用集合。
- en: A collection is a data structure in memory that can manage multiple items in
    different ways, although all collections have some shared functionality.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一种内存中的数据结构，可以以不同方式管理多个项目，尽管所有集合都具有一些共享功能。
- en: 'The most common types in .NET for working with collections are shown in the
    following table:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中用于处理集合的最常见类型如下表所示：
- en: '| Namespace | Example type(s) | Description |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 示例类型 | 描述 |'
- en: '| `System .Collections` | `IEnumerable`, `IEnumerable<T>` | Interfaces and
    base classes used by collections. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `System .Collections` | `IEnumerable`, `IEnumerable<T>` | 集合使用的接口和基类。 |'
- en: '| `System .Collections .Generic` | `List<T>`, `Dictionary<T>`, `Queue<T>`,
    `Stack<T>` | Introduced in C# 2.0 with .NET Framework 2.0\. These collections
    allow you to specify the type you want to store using a generic type parameter
    (which is safer, faster, and more efficient). |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `System .Collections .Generic` | `List<T>`, `Dictionary<T>`, `Queue<T>`,
    `Stack<T>` | 在C# 2.0和.NET Framework 2.0中引入，这些集合允许你使用泛型类型参数指定要存储的类型（更安全、更快、更高效）。
    |'
- en: '| `System .Collections .Concurrent` | `BlockingCollection`, `ConcurrentDictionary`,
    `ConcurrentQueue` | These collections are safe to use in multithreaded scenarios.
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `System .Collections .Concurrent` | `BlockingCollection`, `ConcurrentDictionary`,
    `ConcurrentQueue` | 这些集合在多线程场景中使用是安全的。 |'
- en: '| `System .Collections .Immutable` | `ImmutableArray`, `ImmutableDictionary`,
    `ImmutableList`, `ImmutableQueue` | Designed for scenarios where the contents
    of the original collection will never change, although they can create modified
    collections as a new instance. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Immutable` | `ImmutableArray`、`ImmutableDictionary`、`ImmutableList`、`ImmutableQueue`
    | 设计用于原始集合内容永远不会改变的场景，尽管它们可以创建作为新实例的修改后的集合。'
- en: Common features of all collections
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有集合的共同特点
- en: 'All collections implement the `ICollection` interface; this means that they
    must have a `Count` property to tell you how many objects are in them, as shown
    in the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合都实现了`ICollection`接口；这意味着它们必须有一个`Count`属性来告诉你其中有多少对象，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For example, if we had a collection named `passengers`, we could do this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个名为`passengers`的集合，我们可以这样做：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'All collections implement the `IEnumerable` interface, which means that they
    can be iterated using the `foreach` statement. They must have a `GetEnumerator`
    method that returns an object that implements `IEnumerator`; this means that the
    returned `object` must have `MoveNext` and `Reset` methods for navigating through
    the collection and a `Current` property containing the current item in the collection,
    as shown in the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合都实现了`IEnumerable`接口，这意味着它们可以使用`foreach`语句进行迭代。它们必须有一个`GetEnumerator`方法，该方法返回一个实现了`IEnumerator`的对象；这意味着返回的`对象`必须具有`MoveNext`和`Reset`方法来遍历集合，以及一个包含集合中当前项的`Current`属性，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For example, to perform an action on each object in the `passengers` collection,
    we could write the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要对`passengers`集合中的每个对象执行一个操作，我们可以编写以下代码：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As well as `object`-based collection interfaces, there are also generic interfaces
    and classes, where the generic type defines the type stored in the collection,
    as shown in the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于`object`的集合接口外，还有泛型接口和类，其中泛型类型定义了集合中存储的类型，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Improving performance by ensuring the capacity of a collection
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过确保集合的容量来提高性能
- en: Since .NET 1.1, types like `StringBuilder` have had a method named `EnsureCapacity`
    that can presize its internal storage array to the expected final size of the
    `string`. This improves performance because it does not have to repeatedly increment
    the size of the array as more characters are appended.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 自.NET 1.1以来，像`StringBuilder`这样的类型就有一个名为`EnsureCapacity`的方法，可以预先设置其内部存储数组到预期的最终大小。这提高了性能，因为它不需要在添加更多字符时反复增加数组的大小。
- en: Since .NET Core 2.1, types like `Dictionary<T>` and `HashSet<T>` have also had
    `EnsureCapacity`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 自.NET Core 2.1以来，像`Dictionary<T>`和`HashSet<T>`这样的类型也有了`EnsureCapacity`。
- en: 'In .NET 6 and later, collections like `List<T>`, `Queue<T>`, and `Stack<T>`
    now have an `EnsureCapacity` method too, as shown in the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET 6及更高版本中，像`List<T>`、`Queue<T>`和`Stack<T>`这样的集合现在也有了一个`EnsureCapacity`方法，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Understanding collection choices
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解集合选择
- en: 'There are several different choices of collection that you can use for different
    purposes: lists, dictionaries, stacks, queues, sets, and many other more specialized
    collections.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的集合选择，你可以根据不同的目的使用：列表、字典、栈、队列、集合，以及许多其他更专业的集合。
- en: Lists
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'Lists, that is, a type that implements `IList<T>`, are **ordered collections**,
    as shown in the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，即实现`IList<T>`的类型，是**有序集合**，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`IList<T>` derives from `ICollection<T>` so it has a `Count` property, and
    an `Add` method to put an item at the end of the collection, as well as an `Insert`
    method to put an item in the list at a specified position, and `RemoveAt` to remove
    an item at a specified position.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList<T>`继承自`ICollection<T>`，因此它具有一个`Count`属性，以及一个`Add`方法，用于在集合末尾添加一个项，以及一个`Insert`方法，用于在列表中指定位置插入一个项，以及`RemoveAt`方法，用于在指定位置删除一个项。'
- en: 'Lists are a good choice when you want to manually control the order of items
    in a collection. Each item in a list has a unique index (or position) that is
    automatically assigned. Items can be any type defined by `T` and items can be
    duplicated. Indexes are `int` types and start from `0`, so the first item in a
    list is at index `0`, as shown in the following table:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要手动控制集合中项目的顺序时，列表是一个好的选择。列表中的每个项目都有一个自动分配的唯一索引（或位置）。项目可以是`T`定义的任何类型，并且项目可以重复。索引是`int`类型，从`0`开始，因此列表中的第一个项目位于索引`0`处，如下表所示：
- en: '| Index | Item |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 项 |'
- en: '| 0 | London |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 伦敦 |'
- en: '| 1 | Paris |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 巴黎 |'
- en: '| 2 | London |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 伦敦 |'
- en: '| 3 | Sydney |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 悉尼 |'
- en: 'If a new item (for example, Santiago) is inserted between London and Sydney,
    then the index of Sydney is automatically incremented. Therefore, you must be
    aware that an item''s index can change after inserting or removing items, as shown
    in the following table:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个新项（例如，圣地亚哥）被插入到伦敦和悉尼之间，那么悉尼的索引会自动增加。因此，你必须意识到，在插入或删除项后，项的索引可能会改变，如下表所示：
- en: '| Index | Item |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 项 |'
- en: '| 0 | London |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 伦敦 |'
- en: '| 1 | Paris |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 巴黎 |'
- en: '| 2 | London |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 伦敦 |'
- en: '| 3 | Santiago |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 圣地亚哥 |'
- en: '| 4 | Sydney |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 悉尼 |'
- en: Dictionaries
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: Dictionaries are a good choice when each **value** (or object) has a unique
    sub value (or a made-up value) that can be used as a **key** to quickly find a
    value in the collection later. The key must be unique. For example, if you are
    storing a list of people, you could choose to use a government-issued identity
    number as the key.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个**值**（或对象）有一个唯一的子值（或自定义值）可以用作**键**，以便稍后在集合中快速找到一个值时，字典是一个好选择。键必须是唯一的。例如，如果你正在存储一个人员列表，你可以选择使用政府颁发的身份证号码作为键。
- en: Think of the key as being like an index entry in a real-world dictionary. It
    allows you to quickly find the definition of a word because the words (for example,
    keys) are kept sorted, and if we know we're looking for the definition of *manatee*,
    we would jump to the middle of the dictionary to start looking, because the letter
    *M* is in the middle of the alphabet.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 将键想象成现实世界词典中的索引条目。它允许你快速找到一个词的定义，因为词（例如，键）是按顺序排列的，如果我们知道要查找*海牛*的定义，我们会跳到词典中间开始查找，因为字母*M*位于字母表的中间。
- en: 'Dictionaries in programming are similarly smart when looking something up.
    They must implement the interface `IDictionary<TKey, TValue>`, as shown in the
    following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的字典在查找内容时同样智能。它们必须实现接口`IDictionary<TKey, TValue>`，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Items in a dictionary are instances of the `struct`, aka the value type `KeyValuePair<TKey,
    TValue>`, where `TKey` is the type of the key and `TValue` is the type of the
    value, as shown in the following code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的项是`struct`的实例，也就是值类型`KeyValuePair<TKey, TValue>`，其中`TKey`是键的类型，`TValue`是值的类型，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'An example `Dictionary<string, Person>` uses a `string` as the key and a `Person`
    instance as the value. `Dictionary<string, string>` uses `string` values for both,
    as shown in the following table:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例`Dictionary<string, Person>`使用`string`作为键，`Person`实例作为值。`Dictionary<string,
    string>`对两者都使用`string`值，如下表所示：
- en: '| Key | Value |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 键 | 值 |'
- en: '| BSA | Bob Smith |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| BSA | 鲍勃·史密斯 |'
- en: '| MW | Max Williams |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| MW | 马克斯·威廉姆斯 |'
- en: '| BSB | Bob Smith |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| BSB | 鲍勃·史密斯 |'
- en: '| AM | Amir Mohammed |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| AM | 阿米尔·穆罕默德 |'
- en: Stacks
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: Stacks are a good choice when you want to implement **last-in, first-out** (**LIFO**)
    behavior. With a stack, you can only directly access or remove the one item at
    the top of the stack, although you can enumerate to read through the whole stack
    of items. You cannot, for example, directly access the second item in a stack.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要实现**后进先出**（**LIFO**）行为时，栈是一个好选择。使用栈，你只能直接访问或移除栈顶的项，尽管你可以枚举来读取整个栈的项。例如，你不能直接访问栈中的第二个项。
- en: For example, word processors use a stack to remember the sequence of actions
    you have recently performed, and then when you press Ctrl + Z, it will undo the
    last action in the stack, and then the next-to-last action, and so on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，文字处理器使用栈来记住你最近执行的操作顺序，然后当你按下Ctrl + Z时，它会撤销栈中的最后一个操作，然后是倒数第二个操作，依此类推。
- en: Queues
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列
- en: Queues are a good choice when you want to implement the **first-in, first-out**
    (**FIFO**) behavior. With a queue, you can only directly access or remove the
    one item at the front of the queue, although you can enumerate to read through
    the whole queue of items. You cannot, for example, directly access the second
    item in a queue.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要实现**先进先出**（**FIFO**）行为时，队列是一个好选择。使用队列，你只能直接访问或移除队列前端的项，尽管你可以枚举来读取整个队列的项。例如，你不能直接访问队列中的第二个项。
- en: For example, background processes use a queue to process work items in the order
    that they arrive, just like people standing in line at the post office.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，后台进程使用队列按到达顺序处理工作项，就像人们在邮局排队一样。
- en: .NET 6 introduces the `PriorityQueue`, where each item in the queue has a priority
    value assigned as well as their position in the queue.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 引入了`PriorityQueue`，其中队列中的每个项都有一个优先级值以及它们在队列中的位置。
- en: Sets
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: Sets are a good choice when you want to perform set operations between two collections.
    For example, you may have two collections of city names, and you want to know
    which names appear in both sets (known as the *intersect* between the sets). Items
    in a set must be unique.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在两个集合之间执行集合操作时，集合是一个好的选择。例如，你可能有两个城市名称的集合，并且你想要知道哪些名称同时出现在两个集合中（这被称为集合之间的*交集*）。集合中的项必须是唯一的。
- en: Collection methods summary
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合方法总结
- en: 'Each collection has a different set of methods for adding and removing items,
    as shown in the following table:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 每种集合都有一套不同的添加和移除项的方法，如下表所示：
- en: '| Collection | Add methods | Remove methods | Description |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 添加方法 | 移除方法 | 描述 |'
- en: '| List | `Add`, `Insert` | `Remove`, `RemoveAt` | Lists are ordered so items
    have an integer index position. `Add` will add a new item at the end of the list.
    `Insert` will add a new item at the index position specified. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | `添加`，`插入` | `移除`，`移除位置` | 列表是有序的，因此项具有整数索引位置。`添加`将在列表末尾添加一个新项。`插入`将在指定的索引位置添加一个新项。'
- en: '| Dictionary | `Add` | `Remove` | Dictionaries are not ordered so items do
    not have integer index positions. You can check if a key has been used by calling
    the `ContainsKey` method. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 字典 | `添加` | `移除` | 字典是无序的，因此项没有整数索引位置。你可以通过调用`ContainsKey`方法来检查一个键是否已被使用。'
- en: '| Stack | `Push` | `Pop` | Stacks always add a new item at the top of the stack
    using the `Push` method. The first item is at the bottom. Items are always removed
    from the top of the stack using the `Pop` method. Call the `Peek` method to see
    this value without removing it. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 栈 | `压栈` | `弹栈` | 栈总是使用`压栈`方法在栈顶添加一个新项。第一个项位于栈底。总是使用`弹栈`方法从栈顶移除项。调用`Peek`方法可以查看此值而不移除它。'
- en: '| Queue | `Enqueue` | `Dequeue` | Queues always add a new item at the end of
    the queue using the `Enqueue` method. The first item is at the front of the queue.
    Items are always removed from the front of the queue using the `Dequeue` method.
    Call the `Peek` method to see this value without removing it. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 队列 | `入队` | `出队` | 队列总是使用`入队`方法在队列末尾添加一个新项。第一个项位于队列前端。总是使用`出队`方法从队列前端移除项。调用`Peek`方法可以查看此值而不移除它。'
- en: Working with lists
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列表
- en: 'Let''s explore lists:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索列表：
- en: Use your preferred code editor to add a new console app named `WorkingWithCollections`
    to the `Chapter08` solution/workspace.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器，在`Chapter08`解决方案/工作区中添加一个名为`WorkingWithCollections`的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithCollections` as the active OmniSharp
    project.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithCollections`作为活动的OmniSharp项目。
- en: 'In `Program.cs`, delete the existing statements and then define a function
    to output a collection of `string` values with a title, as shown in the following
    code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句，然后定义一个函数，输出带有标题的`string`值集合，如下所示：
- en: '[PRE55]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define a static method named `WorkingWithLists` to illustrate some of the common
    ways of defining and working with lists, as shown in the following code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`WorkingWithLists`的静态方法，以展示一些定义和使用列表的常见方式，如下所示：
- en: '[PRE56]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'At the top of `Program.cs`, after the namespace imports, call the `WorkingWithLists`
    method, as shown in the following code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，在命名空间导入之后，调用`WorkingWithLists`方法，如下所示：
- en: '[PRE57]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE58]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Working with dictionaries
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字典
- en: 'Let''s explore dictionaries:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索字典：
- en: 'In `Program.cs`, define a static method named `WorkingWithDictionaries` to
    illustrate some of the common ways of working with dictionaries, for example,
    looking up word definitions, as shown in the following code:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，定义一个名为`WorkingWithDictionaries`的静态方法，以展示一些使用字典的常见方式，例如，查找单词定义，如下所示：
- en: '[PRE59]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At the top of `Program.cs`, comment out the previous method call and then call
    the `WorkingWithDictionaries` method, as shown in the following code:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，然后调用`WorkingWithDictionaries`方法，如下所示：
- en: '[PRE60]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE61]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Working with queues
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用队列
- en: 'Let''s explore queues:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索队列：
- en: 'In `Program.cs`, define a static method named `WorkingWithQueues` to illustrate
    some of the common ways of working with queues, for example, handling customers
    in a queue for coffee, as shown in the following code:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，定义一个名为`WorkingWithQueues`的静态方法，以展示一些使用队列的常见方式，例如，处理排队购买咖啡的顾客，如下所示：
- en: '[PRE62]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: At the top of `Program.cs`, comment out the previous method calls and call the
    `WorkingWithQueues` method.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，并调用`WorkingWithQueues`方法。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE63]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define a static method named `OutputPQ`, as shown in the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`OutputPQ`的静态方法，如下所示：
- en: '[PRE64]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that the `OutputPQ` method is generic. You can specify the two types used
    in the tuples that are passed in as `collection`.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，`OutputPQ`方法是泛型的。你可以指定作为`collection`传递的元组中使用的两个类型。
- en: 'Define a static method named `WorkingWithPriorityQueues`, as shown in the following
    code:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`WorkingWithPriorityQueues`的静态方法，如下所示：
- en: '[PRE65]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: At the top of `Program.cs`, comment out the previous method calls and call the
    `WorkingWithPriorityQueues` method.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，并调用`WorkingWithPriorityQueues`方法。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE66]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Sorting collections
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序集合
- en: A `List<T>` class can be sorted by manually calling its `Sort` method (but remember
    that the indexes of each item will change). Manually sorting a list of `string`
    values or other built-in types will work without extra effort on your part, but
    if you create a collection of your own type, then that type must implement an
    interface named `IComparable`. You learned how to do this in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`类可以通过手动调用其`Sort`方法进行排序（但请记住，每个项的索引会改变）。手动对`string`值或其他内置类型的列表进行排序无需额外努力，但如果你创建了自己的类型的集合，则该类型必须实现名为`IComparable`的接口。你在《第6章：实现接口和继承类》中学过如何做到这一点。'
- en: A `Stack<T>` or `Queue<T>` collection cannot be sorted because you wouldn't
    usually want that functionality; for example, you would probably never sort a
    queue of guests checking into a hotel. But sometimes, you might want to sort a
    dictionary or a set.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack<T>`或`Queue<T>`集合无法排序，因为你通常不需要这种功能；例如，你可能永远不会对入住酒店的客人队列进行排序。但有时，你可能想要对字典或集合进行排序。'
- en: Sometimes it would be useful to have an automatically sorted collection, that
    is, one that maintains the items in a sorted order as you add and remove them.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有时拥有一个自动排序的集合会很有用，即在添加和删除项时保持项的排序顺序。
- en: There are multiple auto-sorting collections to choose from. The differences
    between these sorted collections are often subtle but can have an impact on the
    memory requirements and performance of your application, so it is worth putting
    effort into picking the most appropriate option for your requirements.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种自动排序集合可供选择。这些排序集合之间的差异通常很微妙，但可能会影响应用程序的内存需求和性能，因此值得努力选择最适合你需求的选项。
- en: 'Some common auto-sorting collections are shown in the following table:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的自动排序集合如下表所示：
- en: '| Collection | Description |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 描述 |'
- en: '| `SortedDictionary<TKey, TValue>` | This represents a collection of key/value
    pairs that are sorted by key. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `SortedDictionary<TKey, TValue>` | 这表示一个按键排序的键/值对集合。 |'
- en: '| `SortedList<TKey, TValue>` | This represents a collection of key/value pairs
    that are sorted by key. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `SortedList<TKey, TValue>` | 这表示一个按键排序的键/值对集合。 |'
- en: '| `SortedSet<T>` | This represents a collection of unique objects that are
    maintained in a sorted order. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `SortedSet<T>` | 这表示一个唯一的对象集合，这些对象按排序顺序维护。 |'
- en: More specialized collections
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更专业的集合
- en: There are a few other collections for special situations.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些用于特殊情况的集合。
- en: Working with a compact array of bit values
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用紧凑的位值数组
- en: The `System.Collections.BitArray` collection manages a compact array of bit
    values, which are represented as Booleans, where `true` indicates that the bit
    is on (value is 1) and `false` indicates the bit is off (value is 0).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.BitArray`集合管理一个紧凑的位值数组，这些位值表示为布尔值，其中`true`表示位已打开（值为1），`false`表示位已关闭（值为0）。'
- en: Working with efficient lists
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高效地使用列表
- en: The `System.Collections.Generics.LinkedList<T>` collection represents a doubly
    linked list where every item has a reference to its previous and next items. They
    provide better performance compared to `List<T>` for scenarios where you will
    frequently insert and remove items from the middle of the list. In a `LinkedList<T>`
    the items do not have to be rearranged in memory.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Generics.LinkedList<T>`集合表示一个双向链表，其中每个项都有对其前一个和下一个项的引用。与`List<T>`相比，在频繁从列表中间插入和删除项的场景中，它们提供了更好的性能。在`LinkedList<T>`中，项无需在内存中重新排列。'
- en: Using immutable collections
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不可变集合
- en: Sometimes you need to make a collection immutable, meaning that its members
    cannot change; that is, you cannot add or remove them.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要使集合不可变，这意味着其成员不可更改；即，你不能添加或删除它们。
- en: If you import the `System.Collections.Immutable` namespace, then any collection
    that implements `IEnumerable<T>` is given six extension methods to convert it
    into an immutable list, dictionary, hash set, and so on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入了`System.Collections.Immutable`命名空间，那么任何实现`IEnumerable<T>`的集合都会获得六个扩展方法，用于将其转换为不可变列表、字典、哈希集等。
- en: 'Let''s see a simple example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: In the `WorkingWithCollections` project, in `Program.cs`, import the `System.Collections.Immutable`
    namespace.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithCollections`项目中，在`Program.cs`中，导入`System.Collections.Immutable`命名空间。
- en: 'In the `WorkingWithLists` method, add statements to the end of the method to
    convert the `cities` list into an immutable list and then add a new city to it,
    as shown in the following code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithLists`方法中，在方法末尾添加语句，将`cities`列表转换为不可变列表，然后向其添加一个新城市，如下代码所示：
- en: '[PRE67]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: At the top of `Program.cs`, comment the previous method calls and uncomment
    the call to the `WorkingWithLists` method.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，并取消对`WorkingWithLists`方法调用的注释。
- en: 'Run the code, view the result, and note that the immutable list of cities does
    not get modified when you call the `Add` method on it; instead, it returns a new
    list with the newly added city, as shown in the following output:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意当对不可变城市列表调用`Add`方法时，该列表并未被修改；相反，它返回了一个包含新添加城市的新列表，如下输出所示：
- en: '[PRE68]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**Good Practice**: To improve performance, many applications store a shared
    copy of commonly accessed objects in a central cache. To safely allow multiple
    threads to work with those objects knowing they won''t change, you should make
    them immutable or use a concurrent collection type that you can read about at
    the following link: [https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：为了提高性能，许多应用程序在中央缓存中存储了常用对象的共享副本。为了安全地允许多个线程使用这些对象，同时确保它们不会被更改，你应该使它们不可变，或者使用并发集合类型，你可以在以下链接中了解相关信息：[https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent)'
- en: Good practice with collections
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的良好实践
- en: 'Let''s say you need to create a method to process a collection. For maximum
    flexibility, you could declare the input parameter to be `IEnumerable<T>` and
    make the method generic, as shown in the following code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要创建一个处理集合的方法。为了最大程度地灵活，你可以声明输入参数为`IEnumerable<T>`，并使方法泛型化，如下代码所示：
- en: '[PRE69]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: I could pass an array, a list, a queue, a stack, or anything else that implements
    `IEnumerable<T>` into this method and it will process the items. However, the
    flexibility to pass any collection to this method comes at a performance cost.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将数组、列表、队列、栈或任何其他实现`IEnumerable<T>`的集合传递给此方法，它将处理这些项。然而，将任何集合传递给此方法的灵活性是以性能为代价的。
- en: 'One of the performance problems with `IEnumerable<T>` is also one of its benefits:
    deferred execution, also known as lazy loading. Types that implement this interface
    do not have to implement deferred execution, but many do.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`的一个性能问题同时也是其优点之一：延迟执行，亦称为懒加载。实现此接口的类型并非必须实现延迟执行，但许多类型确实如此。'
- en: 'But the worst performance problem with `IEnumerable<T>` is that the iteration
    has to allocate an object on the heap. To avoid this memory allocation, you should
    define your method using a concrete type, as shown highlighted in the following
    code:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 但`IEnumerable<T>`最糟糕的性能问题是迭代时必须在堆上分配一个对象。为了避免这种内存分配，你应该使用具体类型定义你的方法，如下代码中突出显示的部分所示：
- en: '[PRE70]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will use the `List<T>.Enumerator GetEnumerator()` method that returns a
    `struct` instead of the `IEnumerator<T> GetEnumerator()` method that returns a
    reference type. Your code will be two to three times faster and require less memory.
    As with all recommendations related to performance, you should confirm the benefit
    by running performance tests on your actual code in a product environment. You
    will learn how to do this in *Chapter 12*, *Improving Performance and Scalability
    Using Multitasking*.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `List<T>.Enumerator GetEnumerator()` 方法，该方法返回一个 `struct`，而不是返回引用类型的 `IEnumerator<T>
    GetEnumerator()` 方法。您的代码将快两到三倍，并且需要更少的内存。与所有与性能相关的建议一样，您应该通过在产品环境中运行实际代码的性能测试来确认好处。您将在*第
    12 章*，*使用多任务提高性能和可扩展性*中学习如何做到这一点。
- en: Working with spans, indexes, and ranges
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理跨度、索引和范围
- en: One of Microsoft's goals with .NET Core 2.1 was to improve performance and resource
    usage. A key .NET feature that enables this is the `Span<T>` type.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 在 .NET Core 2.1 中的目标之一是提高性能和资源使用率。实现这一目标的关键 .NET 特性是 `Span<T>` 类型。
- en: Using memory efficiently using spans
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跨度高效利用内存
- en: When manipulating arrays, you will often create new copies of subsets of existing
    ones so that you can process just the subset. This is not efficient because duplicate
    objects must be created in memory.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作数组时，您通常会创建现有子集的新副本，以便仅处理该子集。这样做效率不高，因为必须在内存中创建重复对象。
- en: If you need to work with a subset of an array, use a **span** because it is
    like a window into the original array. This is more efficient in terms of memory
    usage and improves performance. Spans only work with arrays, not collections,
    because the memory must be contiguous.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要处理数组的子集，请使用**跨度**，因为它就像原始数组的窗口。这在内存使用方面更有效，并提高了性能。跨度仅适用于数组，不适用于集合，因为内存必须是连续的。
- en: 'Before we look at spans in more detail, we need to understand some related
    objects: indexes and ranges.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地了解跨度之前，我们需要了解一些相关对象：索引和范围。
- en: Identifying positions with the Index type
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Index 类型识别位置
- en: C# 8.0 introduced two features for identifying an item's index within an array
    and a range of items using two indexes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0 引入了两个特性，用于识别数组中项的索引以及使用两个索引的范围。
- en: 'You learned in the previous topic that objects in a list can be accessed by
    passing an integer into their indexer, as shown in the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 您在上一主题中学到，可以通过将整数传递给其索引器来访问列表中的对象，如下所示：
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `Index` value type is a more formal way of identifying a position, and
    supports counting from the end, as shown in the following code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index` 值类型是一种更正式的识别位置的方式，并支持从末尾计数，如下所示：'
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Identifying ranges with the Range type
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Range 类型识别范围
- en: 'The `Range` value type uses `Index` values to indicate the start and end of
    its range, using its constructor, C# syntax, or its static methods, as shown in
    the following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`Range` 值类型使用 `Index` 值来指示其范围的起始和结束，使用其构造函数、C# 语法或其静态方法，如下所示：'
- en: '[PRE73]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Extension methods have been added to `string` values (that internally use an
    array of `char`), `int` arrays, and spans to make ranges easier to work with.
    These extension methods accept a range as a parameter and return a `Span<T>`.
    This makes them very memory efficient.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 已向 `string` 值（内部使用 `char` 数组）、`int` 数组和跨度添加了扩展方法，以使范围更易于使用。这些扩展方法接受一个范围作为参数并返回一个
    `Span<T>`。这使得它们非常节省内存。
- en: Using indexes, ranges, and spans
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用索引、范围和跨度
- en: 'Let''s explore using indexes and ranges to return spans:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用索引和范围来返回跨度：
- en: Use your preferred code editor to add a new console app named `WorkingWithRanges`
    to the `Chapter08` solution/workspace.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器将名为 `WorkingWithRanges` 的新控制台应用程序添加到 `Chapter08` 解决方案/工作区。
- en: In Visual Studio Code, select `WorkingWithRanges` as the active OmniSharp project.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，选择 `WorkingWithRanges` 作为活动 OmniSharp 项目。
- en: 'In `Program.cs`, type statements to compare using the `string` type''s `Substring`
    method using ranges to extract parts of someone''s name, as shown in the following
    code:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，键入语句以使用 `string` 类型的 `Substring` 方法使用范围来提取某人姓名的部分，如下所示：
- en: '[PRE74]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE75]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Working with network resources
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理网络资源
- en: 'Sometimes you will need to work with network resources. The most common types
    in .NET for working with network resources are shown in the following table:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要处理网络资源。.NET 中用于处理网络资源的最常见类型如下表所示：
- en: '| Namespace | Example type(s) | Description |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 示例类型 | 描述 |'
- en: '| `System.Net` | `Dns`, `Uri`, `Cookie`, `WebClient`, `IPAddress` | These are
    for working with DNS servers, URIs, IP addresses, and so on. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net` | `Dns`, `Uri`, `Cookie`, `WebClient`, `IPAddress` | 这些用于处理DNS服务器、URI、IP地址等。'
- en: '| `System.Net` | `FtpStatusCode`, `FtpWebRequest`, `FtpWebResponse` | These
    are for working with FTP servers. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net` | `FtpStatusCode`, `FtpWebRequest`, `FtpWebResponse` | 这些用于与FTP服务器进行交互。'
- en: '| `System.Net` | `HttpStatusCode`, `HttpWebRequest`, `HttpWebResponse` | These
    are for working with HTTP servers; that is, websites and services. Types from
    `System.Net.Http` are easier to use. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net` | `HttpStatusCode`, `HttpWebRequest`, `HttpWebResponse` | 这些用于与HTTP服务器进行交互；即网站和服务。来自`System.Net.Http`的类型更容易使用。'
- en: '| `System.Net.Http` | `HttpClient`, `HttpMethod`, `HttpRequestMessage`, `HttpResponseMessage`
    | These are for working with HTTP servers; that is, websites and services. You
    will learn how to use these in *Chapter 16*, *Building and Consuming Web Services*.
    |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.Http` | `HttpClient`, `HttpMethod`, `HttpRequestMessage`, `HttpResponseMessage`
    | 这些用于与HTTP服务器（即网站和服务）进行交互。你将在*第16章*，*构建和消费Web服务*中学习如何使用这些。'
- en: '| `System.Net.Mail` | `Attachment`, `MailAddress`, `MailMessage`, `SmtpClient`
    | These are for working with SMTP servers; that is, sending email messages. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.Mail` | `Attachment`, `MailAddress`, `MailMessage`, `SmtpClient`
    | 这些用于处理SMTP服务器；即发送电子邮件。'
- en: '| `System.Net .NetworkInformation` | `IPStatus`, `NetworkChange`, `Ping`, `TcpStatistics`
    | These are for working with low-level network protocols. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `System.Net.NetworkInformation` | `IPStatus`, `NetworkChange`, `Ping`, `TcpStatistics`
    | 这些用于处理低级网络协议。'
- en: Working with URIs, DNS, and IP addresses
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理URI、DNS和IP地址
- en: 'Let''s explore some common types for working with network resources:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些用于处理网络资源的常见类型：
- en: Use your preferred code editor to add a new console app named `WorkingWithNetworkResources`
    to the `Chapter08` solution/workspace.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器，在`Chapter08`解决方案/工作区中添加一个名为`WorkingWithNetworkResources`的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithNetworkResources` as the active OmniSharp
    project.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithNetworkResources`作为活动OmniSharp项目。
- en: 'At the top of `Program.cs`, import the namespace for working with the network,
    as shown in the following code:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，导入用于处理网络的命名空间，如下所示：
- en: '[PRE76]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Type statements to prompt the user to enter a website address, and then use
    the `Uri` type to break it down into its parts, including the scheme (HTTP, FTP,
    and so on), port number, and host, as shown in the following code:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句以提示用户输入网站地址，然后使用`Uri`类型将其分解为其组成部分，包括方案（HTTP、FTP等）、端口号和主机，如下所示：
- en: '[PRE77]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: For convenience, the code also allows the user to press ENTER to use an example
    URL.
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了方便，代码还允许用户按下ENTER键使用示例URL。
- en: 'Run the code, enter a valid website address or press ENTER, and view the result,
    as shown in the following output:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入有效的网站地址或按下ENTER键，查看结果，如下所示：
- en: '[PRE78]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Add statements to get the IP address for the entered website, as shown in the
    following code:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以获取输入网站的IP地址，如下所示：
- en: '[PRE79]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Run the code, enter a valid website address or press ENTER, and view the result,
    as shown in the following output:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入有效的网站地址或按下ENTER键，查看结果，如下所示：
- en: '[PRE80]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Pinging a server
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ping服务器
- en: 'Now you will add code to ping a web server to check its health:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将添加代码以ping一个Web服务器以检查其健康状况：
- en: 'Import the namespace to get more information about networks, as shown in the
    following code:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入命名空间以获取更多网络信息，如下所示：
- en: '[PRE81]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Add statements to ping the entered website, as shown in the following code:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以ping输入的网站，如下所示：
- en: '[PRE82]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the code, press ENTER, and view the result, as shown in the following output
    on macOS:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，按下ENTER键，查看结果，如下所示在macOS上的输出：
- en: '[PRE83]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Run the code again but this time enter [http://google.com](http://google.com),
    as shown in the following output:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，但这次输入[http://google.com](http://google.com)，如下所示：
- en: '[PRE84]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Working with reflection and attributes
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理反射和属性
- en: '**Reflection** is a programming feature that allows code to understand and
    manipulate itself. An assembly is made up of up to four parts:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射**是一种编程特性，允许代码理解和操作自身。一个程序集由最多四个部分组成：'
- en: '**Assembly metadata and manifest**: Name, assembly, and file version, referenced
    assemblies, and so on.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序集元数据和清单**：名称、程序集和文件版本、引用的程序集等。'
- en: '**Type metadata**: Information about the types, their members, and so on.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型元数据**：关于类型、其成员等的信息。'
- en: '**IL code**: Implementation of methods, properties, constructors, and so on.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IL代码**：方法、属性、构造函数等的实现。'
- en: '**Embedded resources** (optional): Images, strings, JavaScript, and so on.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入资源**（可选）：图像、字符串、JavaScript等。'
- en: The metadata comprises items of information about your code. The metadata is
    generated automatically from your code (for example, information about the types
    and members) or applied to your code using attributes.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据包含有关您的代码的信息项。元数据自动从您的代码生成（例如，关于类型和成员的信息）或使用属性应用于您的代码。
- en: 'Attributes can be applied at multiple levels: to assemblies, to types, and
    to their members, as shown in the following code:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以应用于多个级别：程序集、类型及其成员，如下列代码所示：
- en: '[PRE85]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Attribute-based programming is used a lot in app models like ASP.NET Core to
    enable features like routing, security, and caching.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的编程在ASP.NET Core等应用程序模型中大量使用，以启用路由、安全性、缓存等功能。
- en: Versioning of assemblies
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序集版本控制
- en: 'Version numbers in .NET are a combination of three numbers, with two optional
    additions. If you follow the rules of semantic versioning, the three numbers denote
    the following:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的版本号是三个数字的组合，带有两个可选的附加项。如果遵循语义版本规则，这三个数字表示以下内容：
- en: '**Major**: Breaking changes.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要**：破坏性更改。'
- en: '**Minor**: Non-breaking changes, including new features, and often bug fixes.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要**：非破坏性更改，包括新功能，通常还包括错误修复。'
- en: '**Patch**: Non-breaking bug fixes.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补丁**：非破坏性错误修复。'
- en: '**Good Practice**: When updating a NuGet package that you already use in a
    project, to be safe you should specify an optional flag to make sure that you
    only upgrade to the highest minor to avoid breaking changes, or to the highest
    patch if you are extra cautious and only want to receive bug fixes, as shown in
    the following commands: `Update-Package Newtonsoft.Json -ToHighestMinor` or `Update-Package
    Newtonsoft.Json -ToHighestPatch`.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在更新您已在项目中使用的NuGet包时，为了安全起见，您应该指定一个可选标志，以确保您仅升级到最高次要版本以避免破坏性更改，或者如果您特别谨慎并且只想接收错误修复，则升级到最高补丁，如下列命令所示：`Update-Package
    Newtonsoft.Json -ToHighestMinor` 或 `Update-Package Newtonsoft.Json -ToHighestPatch`。'
- en: 'Optionally, a version can include these:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，版本可以包括这些：
- en: '**Prerelease**: Unsupported preview releases.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预发布**：不支持的预览版本。'
- en: '**Build number**: Nightly builds.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建编号**：每日构建。'
- en: '**Good Practice**: Follow the rules of semantic versioning, as described at
    the following link: [http://semver.org](http://semver.org)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：遵循语义版本规则，详情请参见以下链接：[http://semver.org](http://semver.org)'
- en: Reading assembly metadata
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取程序集元数据
- en: 'Let''s explore working with attributes:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索属性操作：
- en: Use your preferred code editor to add a new console app named `WorkingWithReflection`
    to the `Chapter08` solution/workspace.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，在`Chapter08`解决方案/工作区中添加一个名为`WorkingWithReflection`的新控制台应用程序。
- en: In Visual Studio Code, select `WorkingWithReflection` as the active OmniSharp
    project.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithReflection`作为活动OmniSharp项目。
- en: 'At the top of `Program.cs`, import the namespace for reflection, as shown in
    the following code:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，导入反射命名空间，如下列代码所示：
- en: '[PRE86]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Add statements to get the console app''s assembly, output its name and location,
    and get all assembly-level attributes and output their types, as shown in the
    following code:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以获取控制台应用程序的程序集，输出其名称和位置，并获取所有程序集级属性并输出它们的类型，如下列代码所示：
- en: '[PRE87]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE88]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Note that because the full name of an assembly must uniquely identify the assembly,
    it is a combination of the following:'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，因为程序集的全名必须唯一标识程序集，所以它是以下内容的组合：
- en: '**Name**, for example, `WorkingWithReflection`'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**，例如，`WorkingWithReflection`'
- en: '**Version**, for example, `1.0.0.0`'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**，例如，`1.0.0.0`'
- en: '**Culture**, for example, `neutral`'
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文化**，例如，`neutral`'
- en: '**Public key token**, although this can be `null`'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公钥标记**，尽管这可以是`null`'
- en: Now that we know some of the attributes decorating the assembly, we can ask
    for them specifically.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 既然我们已经了解了一些装饰程序集的属性，我们可以专门请求它们。
- en: 'Add statements to get the `AssemblyInformationalVersionAttribute` and `AssemblyCompanyAttribute`
    classes and then output their values, as shown in the following code:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以获取`AssemblyInformationalVersionAttribute`和`AssemblyCompanyAttribute`类，然后输出它们的值，如下列代码所示：
- en: '[PRE89]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE90]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Hmmm, unless you set the version, it defaults to 1.0.0, and unless you set
    the company, it defaults to the name of the assembly. Let''s explicitly set this
    information. The legacy .NET Framework way to set these values was to add attributes
    in the C# source code file, as shown in the following code:'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嗯，除非设置版本，否则默认值为1.0.0，除非设置公司，否则默认值为程序集名称。让我们明确设置这些信息。在旧版.NET Framework中设置这些值的方法是在C#源代码文件中添加属性，如下所示：
- en: '[PRE91]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The Roslyn compiler used by .NET sets these attributes automatically, so we
    can't use the old way. Instead, they must be set in the project file.
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .NET使用的Roslyn编译器会自动设置这些属性，因此我们不能采用旧方法。相反，必须在项目文件中设置它们。
- en: 'Edit the `WorkingWithReflection.csproj` project file to add elements for version
    and company, as shown highlighted in the following markup:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`WorkingWithReflection.csproj`项目文件，添加版本和公司元素，如下所示高亮显示：
- en: '[PRE92]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示输出：
- en: '[PRE93]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Creating custom attributes
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义属性
- en: 'You can define your own attributes by inheriting from the `Attribute` class:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过继承`Attribute`类来定义自己的属性：
- en: Add a class file to your project named `CoderAttribute.cs`.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为`CoderAttribute.cs`的类文件。
- en: 'Define an attribute class that can decorate either classes or methods with
    two properties to store the name of a coder and the date they last modified some
    code, as shown in the following code:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个属性类，该类可以装饰类或方法，并存储程序员姓名和上次修改代码的日期这两个属性，如下所示：
- en: '[PRE94]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In `Program.cs`, import some namespaces, as shown in the following code:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入一些命名空间，如下所示：
- en: '[PRE95]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'At the bottom of `Program.cs`, add a class with a method, and decorate the
    method with the `Coder` attribute with data about two coders, as shown in the
    following code:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，添加一个带有方法的类，并用包含两位程序员信息的`Coder`属性装饰该方法，如下所示：
- en: '[PRE96]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In `Program.cs`, above the `Animal` class, add code to get the types, enumerate
    their members, read any `Coder` attributes on those members, and output the information,
    as shown in the following code:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在`Animal`类上方，添加代码以获取类型，枚举其成员，读取这些成员上的任何`Coder`属性，并输出信息，如下所示：
- en: '[PRE97]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Run the code and view the result, as shown in the following partial output:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示部分输出：
- en: '[PRE98]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: What is the `<Program>$+<>c` type?
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Program>$+<>c`类型是什么？'
- en: It is a compiler-generated **display class**. `<>` indicates compiler-generated
    and `c` indicates a display class. They are undocumented implementation details
    of the compiler and could change at any time. You can ignore them, so as an optional
    challenge, add statements to your console application to filter compiler-generated
    types by skipping types decorated with `CompilerGeneratedAttribute`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个编译器生成的**显示类**。`<>`表示编译器生成，`c`表示显示类。它们是编译器的未记录实现细节，可能会随时更改。你可以忽略它们，因此作为一个可选挑战，向你的控制台应用程序添加语句，通过跳过带有`CompilerGeneratedAttribute`装饰的类型来过滤编译器生成的类型。
- en: Doing more with reflection
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用反射实现更多功能
- en: 'This is just a taster of what can be achieved with reflection. We only used
    reflection to read metadata from our code. Reflection can also do the following:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是反射所能实现功能的一个尝鲜。我们仅使用反射从代码中读取元数据。反射还能执行以下操作：
- en: '**Dynamically load assemblies that are not currently referenced**: [https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability](https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态加载当前未引用的程序集**：[https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability](https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability)'
- en: '**Dynamically execute code**: [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke)'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态执行代码**：[https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke)'
- en: '**Dynamically generate new code and assemblies**: [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder)'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态生成新代码和程序集**：[https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder)'
- en: Working with images
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图像
- en: ImageSharp is a third-party cross-platform 2D graphics library. When .NET Core
    1.0 was in development, there was negative feedback from the community about the
    missing `System.Drawing` namespace for working with 2D images.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: ImageSharp是一个第三方跨平台2D图形库。当.NET Core 1.0正在开发时，社区对缺少用于处理2D图像的`System.Drawing`命名空间有负面反馈。
- en: The **ImageSharp** project was started to fill that gap for modern .NET applications.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '**ImageSharp**项目正是为了填补现代.NET应用中的这一空白而启动的。'
- en: In their official documentation for `System.Drawing`, Microsoft says, "The `System.Drawing`
    namespace is not recommended for new development due to not being supported within
    a Windows or ASP.NET service, and it is not cross-platform. ImageSharp and SkiaSharp
    are recommended as alternatives."
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在其官方文档中关于`System.Drawing`的部分指出：“由于不支持在Windows或ASP.NET服务中使用，且不支持跨平台，`System.Drawing`命名空间不建议用于新开发。推荐使用ImageSharp和SkiaSharp作为替代。”
- en: 'Let us see what can be achieved with ImageSharp:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ImageSharp能实现什么：
- en: Use your preferred code editor to add a new console app named `WorkingWithImages`
    to the `Chapter08` solution/workspace.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，向`Chapter08`解决方案/工作区添加一个名为`WorkingWithImages`的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithImages` as the active OmniSharp project.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithImages`作为活动OmniSharp项目。
- en: 'Create an `images` folder and download the nine images from the following link:
    [https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories](https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories)'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`images`目录，并从以下链接下载九张图片：[https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories](https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories)
- en: 'Add a package reference for `SixLabors.ImageSharp`, as shown in the following
    markup:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对`SixLabors.ImageSharp`的包引用，如下所示：
- en: '[PRE99]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Build the `WorkingWithImages` project.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`WorkingWithImages`项目。
- en: 'At the top of `Program.cs`, import some namespaces for working with images,
    as shown in the following code:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，导入一些用于处理图像的命名空间，如下所示：
- en: '[PRE100]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In `Program.cs`, enter statements to convert all the files in the images folder
    into grayscale thumbnails at one-tenth size, as shown in the following code:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句将`images`文件夹中的所有文件转换为灰度缩略图，大小为原图的十分之一，如下所示：
- en: '[PRE101]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Run the code.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。
- en: In the filesystem, open the `images` folder and note the much-smaller-in-bytes
    grayscale thumbnails, as shown in *Figure 8.1*:![A picture containing application  Description
    automatically generated](img/B17442_08_01.png)
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件系统中，打开`images`文件夹，注意字节数显著减少的灰度缩略图，如图*8.1*所示：![应用程序图片 自动生成的描述](img/B17442_08_01.png)
- en: 'Figure 8.1: Images after processing'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.1：处理后的图像
- en: 'ImageSharp also has NuGet packages for programmatically drawing images and
    working with images on the web, as shown in the following list:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: ImageSharp还提供了用于程序化绘制图像和处理网络图像的NuGet包，如下表所示：
- en: '`SixLabors.ImageSharp.Drawing`'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SixLabors.ImageSharp.Drawing`'
- en: '`SixLabors.ImageSharp.Web`'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SixLabors.ImageSharp.Web`'
- en: Internationalizing your code
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化您的代码
- en: 'Internationalization is the process of enabling your code to run correctly
    all over the world. It has two parts: **globalization** and **localization**.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化是使代码在全球范围内正确运行的过程。它包括两个部分：**全球化**和**本地化**。
- en: Globalization is about writing your code to accommodate multiple languages and
    region combinations. The combination of a language and a region is known as a
    culture. It is important for your code to know both the language and region because,
    for example, the date and currency formats are different in Quebec and Paris,
    despite them both using the French language.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 全球化意味着编写代码时要考虑多种语言和地区组合。语言与地区的组合被称为文化。代码需要了解语言和地区，因为例如魁北克和巴黎虽然都使用法语，但日期和货币格式却不同。
- en: There are **International Organization for Standardization** (**ISO**) codes
    for all culture combinations. For example, in the code `da-DK`, `da` indicates
    the Danish language and `DK` indicates the Denmark region, and in the code `fr-CA`,
    `fr` indicates the French language and `CA` indicates the Canada region.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文化组合都有**国际标准化组织**（**ISO**）代码。例如，代码`da-DK`中，`da`代表丹麦语，`DK`代表丹麦地区；而在代码`fr-CA`中，`fr`代表法语，`CA`代表加拿大地区。
- en: ISO is not an acronym. ISO is a reference to the Greek word *isos* (which means
    equal).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: ISO并非缩写。ISO是对希腊语单词*isos*（意为相等）的引用。
- en: Localization is about customizing the user interface to support a language,
    for example, changing the label of a button to be Close (`en`) or Fermer (`fr`).
    Since localization is more about the language, it doesn't always need to know
    about the region, although ironically enough, standardization (`en-US`) and standardisation
    (`en-GB`) suggest otherwise.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化是关于定制用户界面以支持一种语言，例如，将按钮的标签更改为关闭（`en`）或Fermer（`fr`）。由于本地化更多地涉及语言，因此它并不总是需要了解区域，尽管具有讽刺意味的是，标准化（`en-US`）和标准化（`en-GB`）暗示了相反的情况。
- en: Detecting and changing the current culture
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测和更改当前文化
- en: Internationalization is a huge topic on which several thousand-page books have
    been written. In this section, you will get a brief introduction to the basics
    using the `CultureInfo` type in the `System.Globalization` namespace.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化是一个庞大的主题，已有数千页的书籍专门论述。在本节中，你将通过`System.Globalization`命名空间中的`CultureInfo`类型简要了解基础知识。
- en: 'Let''s write some code:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码：
- en: Use your preferred code editor to add a new console app named `Internationalization`
    to the `Chapter08` solution/workspace.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器，在`Chapter08`解决方案/工作区中添加一个名为`Internationalization`的新控制台应用。
- en: In Visual Studio Code, select `Internationalization` as the active OmniSharp
    project.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Internationalization`作为活动的OmniSharp项目。
- en: 'At the top of `Program.cs`, import the namespace for using globalization types,
    as shown in the following code:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，导入用于使用全球化类型的命名空间，如下面的代码所示：
- en: '[PRE102]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Add statements to get the current globalization and localization cultures and
    output some information about them, and then prompt the user to enter a new culture
    code and show how that affects the formatting of common values such as dates and
    currency, as shown in the following code:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以获取当前的全球化文化和本地化文化，并输出有关它们的一些信息，然后提示用户输入新的文化代码，并展示这如何影响常见值（如日期和货币）的格式化，如下面的代码所示：
- en: '[PRE103]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: When you run an application, it automatically sets its thread to use the culture
    of the operating system. I am running my code in London, UK, so the thread is
    set to English (United Kingdom).
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你运行一个应用程序时，它会自动将其线程设置为使用操作系统的文化。我在英国伦敦运行我的代码，因此线程被设置为英语（英国）。
- en: The code prompts the user to enter an alternative ISO code. This allows your
    applications to replace the default culture at runtime.
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码提示用户输入替代的ISO代码。这允许你的应用程序在运行时替换默认文化。
- en: The application then uses standard format codes to output the day of the week
    using format code `dddd`; the number of minutes with thousand separators using
    format code `N0`; and the salary with the currency symbol. These adapt automatically,
    based on the thread's culture.
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序然后使用标准格式代码输出星期几，使用格式代码`dddd`；使用千位分隔符的分钟数，使用格式代码`N0`；以及带有货币符号的薪水。这些会根据线程的文化自动调整。
- en: 'Run the code and enter `en-GB` for the ISO code and then enter some sample
    data including a date in a format valid for British English, as shown in the following
    output:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并输入`en-GB`作为ISO代码，然后输入一些样本数据，包括英国英语中有效的日期格式，如下面的输出所示：
- en: '[PRE104]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If you enter `en-US` instead of `en-GB`, then you must enter the date using
    month/day/year.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你输入`en-US`而不是`en-GB`，则必须使用月/日/年的格式输入日期。
- en: 'Rerun the code and try a different culture, such as Danish in Denmark, as shown
    in the following output:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并尝试不同的文化，例如丹麦的丹麦语，如下面的输出所示：
- en: '[PRE105]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In this example, only the date and salary are globalized into Danish. The rest
    of the text is hardcoded as English. This book does not currently include how
    to translate text from one language to another. If you would like me to include
    that in the next edition, please let me know.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，只有日期和薪水被全球化为丹麦语。其余文本硬编码为英语。本书目前不包括如何将文本从一种语言翻译成另一种语言。如果你希望我在下一版中包含这一点，请告诉我。
- en: '**Good Practice**: Consider whether your application needs to be internationalized
    and plan for that before you start coding! Write down all the pieces of text in
    the user interface that will need to be localized. Think about all the data that
    will need to be globalized (date formats, number formats, and sorting text behavior).'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：考虑你的应用程序是否需要国际化，并在开始编码之前为此做好计划！写下用户界面中需要本地化的所有文本片段。考虑所有需要全球化的数据（日期格式、数字格式和排序文本行为）。'
- en: Practicing and exploring
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践和探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics in this chapter.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试您的知识和理解，进行一些实践练习，并深入研究本章的主题。
- en: Exercise 8.1 – Test your knowledge
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.1 – 测试您的知识
- en: 'Use the web to answer the following questions:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络回答以下问题：
- en: What is the maximum number of characters that can be stored in a `string` variable?
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`string`变量中最多可以存储多少个字符？
- en: When and why should you use a `SecureString` type?
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时以及为何应使用`SecureString`类型？
- en: When is it appropriate to use a `StringBuilder` class?
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时适合使用`StringBuilder`类？
- en: When should you use a `LinkedList<T>` class?
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应使用`LinkedList<T>`类？
- en: When should you use a `SortedDictionary<T>` class rather than a `SortedList<T>`
    class?
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应使用`SortedDictionary<T>`类而非`SortedList<T>`类？
- en: What is the ISO culture code for Welsh?
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 威尔士的ISO文化代码是什么？
- en: What is the difference between localization, globalization, and internationalization?
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地化、全球化与国际化之间有何区别？
- en: In a regular expression, what does `$` mean?
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正则表达式中，`$`是什么意思？
- en: In a regular expression, how can you represent digits?
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正则表达式中，如何表示数字？
- en: Why should you *not* use the official standard for email addresses to create
    a regular expression to validate a user's email address?
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为何不应使用电子邮件地址的官方标准来创建正则表达式以验证用户的电子邮件地址？
- en: Exercise 8.2 – Practice regular expressions
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.2 – 练习正则表达式
- en: 'In the `Chapter08` solution/workspace, create a console application named `Exercise02`
    that prompts the user to enter a regular expression and then prompts the user
    to enter some input and compare the two for a match until the user presses *Esc*,
    as shown in the following output:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter08`解决方案/工作区中，创建一个名为`Exercise02`的控制台应用程序，提示用户输入正则表达式，然后提示用户输入一些输入，并比较两者是否匹配，直到用户按下*Esc*，如下所示：
- en: '[PRE106]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Exercise 8.3 – Practice writing extension methods
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.3 – 练习编写扩展方法
- en: In the `Chapter08` solution/workspace, create a class library named `Exercise03`
    that defines extension methods that extend number types such as `BigInteger` and
    `int` with a method named `ToWords` that returns a `string` describing the number;
    for example, `18,000,000` would be eighteen million, and `18,456,002,032,011,000,007`
    would be eighteen quintillion, four hundred and fifty-six quadrillion, two trillion,
    thirty-two billion, eleven million, and seven.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter08`解决方案/工作区中，创建一个名为`Exercise03`的类库，该库定义了扩展数字类型（如`BigInteger`和`int`）的扩展方法，该方法名为`ToWords`，返回一个描述数字的`string`；例如，`18,000,000`将是“一千八百万”，而`18,456,002,032,011,000,007`将是“一千八百五十六万万亿，二万亿，三十二亿，一千一百万，七”。
- en: 'You can read more about names for large numbers at the following link: [https://en.wikipedia.org/wiki/Names_of_large_numbers](https://en.wikipedia.org/wiki/Names_of_large_numbers)'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中阅读更多关于大数名称的信息：[https://en.wikipedia.org/wiki/Names_of_large_numbers](https://en.wikipedia.org/wiki/Names_of_large_numbers)
- en: Exercise 8.4 – Explore topics
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.4 – 探索主题
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用以下页面上的链接，以了解更多关于本章所涵盖主题的详细信息：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types)'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types)'
- en: Summary
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you explored some choices for types to store and manipulate
    numbers, dates and times, and text including regular expressions, and which collections
    to use for storing multiple items; worked with indexes, ranges, and spans; used
    some network resources; reflected on code and attributes; manipulated images using
    a Microsoft-recommended third-party library; and learned how to internationalize
    your code.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您探索了用于存储和操作数字、日期和时间以及文本（包括正则表达式）的类型选择，以及用于存储多个项目的集合；处理了索引、范围和跨度；使用了某些网络资源；反思了代码和属性；使用微软推荐的第三方库操作图像；并学习了如何国际化您的代码。
- en: In the next chapter, we will manage files and streams, encode and decode text,
    and perform serialization.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，我们将管理文件和流，编码和解码文本，并执行序列化。
