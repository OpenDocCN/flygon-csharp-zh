- en: 08
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Common .NET Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about some common types that are included with .NET. These include
    types for manipulating numbers, text, collections, network access, reflection,
    and attributes; improving working with spans, indexes, and ranges; manipulating
    images; and internationalization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Working with numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dates and times
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with regular expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing multiple objects in collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with spans, indexes, and ranges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with network resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with reflection and attributes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalizing your code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with numbers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common types of data is numbers. The most common types in .NET
    for working with numbers are shown in the following table:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Example type(s) | Description |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `System` | `SByte`, `Int16`, `Int32`, `Int64` | Integers; that is, zero and
    positive and negative whole numbers |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Byte`, `UInt16`, `UInt32`, `UInt64` | Cardinals; that is, zero
    and positive whole numbers |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Half`, `Single`, `Double` | Reals; that is, floating-point numbers
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Decimal` | Accurate reals; that is, for use in science, engineering,
    or financial scenarios |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| `System.Numerics` | `BigInteger`, `Complex`, `Quaternion` | Arbitrarily large
    integers, complex numbers, and quaternion numbers |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: .NET has had the 32-bit float and 64-bit double types since .NET Framework 1.0\.
    The IEEE 754 specification also defines a 16-bit floating point standard. Machine
    learning and other algorithms would benefit from this smaller, lower-precision
    number type so Microsoft introduced the `System.Half` type with .NET 5 and later.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the C# language does not define a `half` alias so you must use the
    .NET type `System.Half`. This might change in the future.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Working with big integers
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The largest whole number that can be stored in .NET types that have a C# alias
    is about eighteen and a half quintillion, stored in an unsigned `long` integer.
    But what if you need to store numbers larger than that?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore numerics:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `Chapter08`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter08`'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithNumbers`'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and add a statement to import
    `System.Numerics`, as shown in the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add statements to output the maximum value of the `ulong` type, and a number
    with 30 digits using `BigInteger`, as shown in the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `40` in the format code means right-align 40 characters, so both numbers
    are lined up to the right-hand edge. The `N0` means use thousand separators and
    zero decimal places.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Working with complex numbers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complex number can be expressed as *a + bi*, where *a* and *b* are real numbers,
    and *i* is an imaginary unit, where *i*² *= −1*. If the real part *a* is zero,
    it is a pure imaginary number. If the imaginary part *b* is zero, it is a real
    number.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex numbers have practical applications in many **STEM** (**science, technology,
    engineering, and mathematics**) fields of study. Additionally, they are added
    by separately adding the real and imaginary parts of the summands; consider this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s explore complex numbers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to add two complex numbers, as shown in the
    following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Understanding quaternions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quaternions are a number system that extends complex numbers. They form a four-dimensional
    associative normed division algebra over the real numbers, and therefore also
    a domain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Huh? Yes, I know. I don't understand that either. Don't worry; we're not going
    to write any code using them! Suffice to say, they are good at describing spatial
    rotations, so video game engines use them, as do many computer simulations and
    flight control systems.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Working with text
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the other most common types of data for variables is text. The most
    common types in .NET for working with text are shown in the following table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Type | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Char` | Storage for a single text character |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| `System` | `String` | Storage for multiple text characters |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `System.Text` | `StringBuilder` | Efficiently manipulates strings |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `System.Text.RegularExpressions` | `Regex` | Efficiently pattern-matches
    strings |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: Getting the length of a string
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore some common tasks when working with text; for example, sometimes
    you need to find out the length of a piece of text stored in a `string` variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new console app named `WorkingWithText`
    to the `Chapter08` solution/workspace:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithText` as the active OmniSharp project.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithText` project, in `Program.cs`, add statements to define
    a variable to store the name of the city London, and then write its name and length
    to the console, as shown in the following code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Getting the characters of a string
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string` class uses an array of `char` internally to store the text. It
    also has an indexer, which means that we can use the array syntax to read its
    characters. Array indexes start at zero, so the third character will be at index
    2.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a statement to write the characters at the first and third positions in
    the `string` variable, as shown in the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Splitting a string
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to split some text wherever there is a character, such
    as a comma:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define a single `string` variable containing comma-separated
    city names, then use the `Split` method and specify that you want to treat commas
    as the separator, and then enumerate the returned array of `string` values, as
    shown in the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Later in this chapter, you will learn how to handle more complex scenarios.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Getting part of a string
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to get part of some text. The `IndexOf` method has nine
    overloads that return the index position of a specified `char` or `string` within
    a `string`. The `Substring` method has two overloads, as shown in the following
    list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`Substring(startIndex, length)`: returns a substring starting at `startIndex`
    and containing the next `length` characters.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Substring(startIndex)`: returns a substring starting at `startIndex` and containing
    all characters up to the end of the string.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s explore a simple example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a person''s full name in a `string` variable with a
    space character between the first and last name, find the position of the space,
    and then extract the first name and last name as two parts so that they can be
    recombined in a different order, as shown in the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the format of the initial full name was different, for example, `"LastName,
    FirstName"`, then the code would need to be different. As an optional exercise,
    try writing some statements that would change the input `"Jones, Alan"` into `"Alan
    Jones"`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Checking a string for content
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to check whether a piece of text starts or ends with some
    characters or contains some characters. You can achieve this with methods named
    `StartsWith`, `EndsWith`, and `Contains`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a `string` value and then check if it starts with or
    contains a couple of different `string` values, as shown in the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Joining, formatting, and other string members
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many other `string` members, as shown in the following table:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `Trim`, `TrimStart`, `TrimEnd` | These methods trim whitespace characters
    such as space, tab, and carriage return from the beginning and/or end. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `ToUpper`, `ToLower` | These convert all the characters into uppercase or
    lowercase. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `Insert`, `Remove` | These methods insert or remove some text. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `Replace` | This replaces some text with other text. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `string.Empty` | This can be used instead of allocating memory each time
    you use a literal `string` value using an empty pair of double quotes (`""`).
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `string.Concat` | This concatenates two `string` variables. The + operator
    does the equivalent when used between `string` operands. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `string.Join` | This concatenates one or more `string` variables with a character
    in between each one. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| `string.IsNullOrEmpty` | This checks whether a `string` variable is `null`
    or empty. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| `string.IsNullOrWhitespace` | This checks whether a `string` variable is
    `null` or whitespace; that is, a mix of any number of horizontal and vertical
    spacing characters, for example, tab, space, carriage return, line feed, and so
    on. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| `string.Format` | An alternative method to string interpolation for outputting
    formatted `string` values, which uses positioned instead of named parameters.
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: Some of the preceding methods are static methods. This means that the method
    can only be called from the type, not from a variable instance. In the preceding
    table, I indicated the static methods by prefixing them with `string.`, as in
    `string.Format`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore some of these methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to take an array of string values and combine them back together
    into a single string variable with separators using the `Join` method, as shown
    in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add statements to use positioned parameters and interpolated string formatting
    syntax to output the same three variables twice, as shown in the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we could have simplified the second statement because `WriteLine`
    supports the same format codes as `string.Format`, as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Building strings efficiently
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can concatenate two strings to make a new `string` using the `String.Concat`
    method or simply by using the `+` operator. But both of these choices are bad
    practice because .NET must create a completely new `string` in memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: This might not be noticeable if you are only adding two `string` values, but
    if you concatenate inside a loop with many iterations, it can have a significant
    negative impact on performance and memory use. In *Chapter 12*, *Improving Performance
    and Scalability Using Multitasking*, you will learn how to concatenate `string`
    variables efficiently using the `StringBuilder` type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Working with dates and times
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After numbers and text, the next most popular types of data to work with are
    dates and times. The two main types are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`DateTime`: represents a combined date and time value for a fixed point in
    time.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeSpan`: represents a duration of time.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two types are often used together. For example, if you subtract one `DateTime`
    value from another, the result is a `TimeSpan`. If you add a `TimeSpan` to a `DateTime`
    then the result is a `DateTime` value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Specifying date and time values
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common way to create a date and time value is to specify individual values
    for the date and time components like day and hour, as described in the following
    table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '| Date/time parameter | Value range |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `year` | 1 to 9999 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `month` | 1 to 12 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `day` | 1 to the number of days in that month |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `hour` | 0 to 23 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `minute` | 0 to 59 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `second` | 0 to 59 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: An alternative is to provide the value as a `string` to be parsed, but this
    can be misinterpreted depending on the default culture of the thread. For example,
    in the UK, dates are specified as day/month/year, compared to the US, where dates
    are specified as month/day/year.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是提供一个`string`值进行解析，但这可能会根据线程的默认文化被误解。例如，在英国，日期指定为日/月/年，而在美国，日期指定为月/日/年。
- en: 'Let''s see what you might want to do with dates and times:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你可能想要如何处理日期和时间：
- en: Use your preferred code editor to add a new console app named `WorkingWithTime`
    to the `Chapter08` solution/workspace.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器，在`Chapter08`解决方案/工作区中添加一个名为`WorkingWithTime`的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithTime` as the active OmniSharp project.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithTime`作为活动OmniSharp项目。
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    initialize some special date/time values, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句，然后添加语句以初始化一些特殊的日期/时间值，如以下代码所示：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add statements to define Christmas Day in 2021 (if this is in the past then
    use a future year) and display it in various ways, as shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义2021年的圣诞节（如果这已过去，则使用未来的一年），并以多种方式展示，如以下代码所示：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE24]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add statements to perform addition and subtraction with Christmas, as shown
    in the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以执行与圣诞节相关的加法和减法，如以下代码所示：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add statements to define the time on Christmas Day that your children might
    wake up to open presents, and display it in various ways, as shown in the following
    code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义圣诞节那天你的孩子们可能醒来打开礼物的时刻，并以多种方式展示，如以下代码所示：
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Globalization with dates and times
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球化与日期和时间
- en: 'The current culture controls how dates and times are parsed:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文化控制日期和时间的解析方式：
- en: At the top of `Program.cs`, import the `System.Globalization` namespace.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，导入`System.Globalization`命名空间。
- en: 'Add statements to show the current culture that is used to display date and
    time values, and then parse United States Independence Day and display it in various
    ways, as shown in the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以显示用于显示日期和时间值的当前文化，然后解析美国独立日并以多种方式展示，如以下代码所示：
- en: '[PRE29]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE30]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On my computer, the current culture is British English. If a date is given as
    4 July 2021, then it is correctly parsed regardless of whether the current culture
    is British or American. But if the date is given as 7/4/2021, then it is wrongly
    parsed as 7 April. You can override the current culture by specifying the correct
    culture as a provider when parsing, as shown in the third example above.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我的电脑上，当前文化是英式英语。如果给定日期为2021年7月4日，则无论当前文化是英式还是美式，都能正确解析。但如果日期给定为7/4/2021，则会被错误解析为4月7日。你可以通过在解析时指定正确的文化作为提供者来覆盖当前文化，如上文第三个示例所示。
- en: 'Add statements to loop from the year 2020 to 2025, displaying if the year is
    a leap year and how many days there are in February, and then show if Christmas
    and Independence Day are during daylight saving time, as shown in the following
    code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以循环从2020年到2025年，显示该年是否为闰年以及二月有多少天，然后展示圣诞节和独立日是否在夏令时期间，如以下代码所示：
- en: '[PRE31]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并记录结果，如以下输出所示：
- en: '[PRE32]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Working with only a date or a time
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅处理日期或时间
- en: .NET 6 introduces some new types for working with only a date value or only
    a time value named `DateOnly` and `TimeOnly`. These are better than using a `DateTime`
    value with a zero time to store a date-only value because it is type-safe and
    avoids misuse. `DateOnly` also maps better to database column types, for example,
    a `date` column in SQL Server. `TimeOnly` is good for setting alarms and scheduling
    regular meetings or events, and it maps to a `time` column in SQL Server.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use them to plan a party for the Queen of England:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define the Queen''s birthday, and a time for her party to
    start, and then combine the two values to make a calendar entry so we don''t miss
    her party, as shown in the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Pattern matching with regular expressions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are useful for validating input from the user. They are
    very powerful and can get very complicated. Almost all programming languages have
    support for regular expressions and use a common set of special characters to
    define them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out some example regular expressions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithRegularExpressions`
    to the `Chapter08` solution/workspace.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithRegularExpressions` as the active
    OmniSharp project.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import the following namespace:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Checking for digits entered as text
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by implementing the common example of validating number input:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to prompt the user to enter their age and then check that it
    is valid using a regular expression that looks for a digit character, as shown
    in the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note the following about the code:'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `@` character switches off the ability to use escape characters in the string.
    Escape characters are prefixed with a backslash. For example, `\t` means a tab
    and `\n` means a new line. When writing regular expressions, we need to disable
    this feature. To paraphrase the television show The West Wing, "Let backslash
    be backslash."
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once escape characters are disabled with `@`, then they can be interpreted by
    a regular expression. For example, `\d` means digit. You will learn more regular
    expressions that are prefixed with a backslash later in this topic.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code, enter a whole number such as `34` for the age, and view the result,
    as shown in the following output:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the code again, enter `carrots`, and view the result, as shown in the following
    output:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the code again, enter `bob30smith`, and view the result, as shown in the
    following output:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The regular expression we used is `\d`, which means *one digit*. However, it
    does not specify what can be entered before and after that one digit. This regular
    expression could be described in English as "Enter any characters you want as
    long as you enter at least one digit character."
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In regular expressions, you indicate the start of some input with the caret
    `^` symbol and the end of some input with the dollar `$` symbol. Let's use these
    symbols to indicate that we expect nothing else between the start and end of the
    input except for a digit.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the regular expression to `^\d$`, as shown highlighted in the following
    code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the code again and note that it rejects any input except a single digit.
    We want to allow one or more digits. To do this, we add a `+` after the `\d` expression
    to modify the meaning to one or more.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the regular expression, as shown highlighted in the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Run the code again and note the regular expression only allows zero or positive
    whole numbers of any length.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regular expression performance improvements
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The .NET types for working with regular expressions are used throughout the
    .NET platform and many of the apps built with it. As such, they have a significant
    impact on performance, but until now, they have not received much optimization
    attention from Microsoft.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 5 and later, the `System.Text.RegularExpressions` namespace has rewritten
    internals to squeeze out maximum performance. Common regular expression benchmarks
    using methods like `IsMatch` are now five times faster. And the best thing is,
    you do not have to change your code to get the benefits!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the syntax of a regular expression
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some common regular expression symbols that you can use in regular
    expressions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Meaning | Symbol | Meaning |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of input | `$` | End of input |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit | `\D` | A single NON-digit |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Whitespace | `\S` | NON-whitespace |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Word characters | `\W` | NON-word characters |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `[A-Za-z0-9]` | Range(s) of characters | `\^` | ^ (caret) character |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `[aeiou]` | Set of characters | `[^aeiou]` | NOT in a set of characters |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any single character | `\.` | . (dot) character |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: 'In addition, here are some regular expression quantifiers that affect the previous
    symbols in a regular expression:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Meaning | Symbol | Meaning |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more | `?` | One or none |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `{3}` | Exactly three | `{3,5}` | Three to five |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| `{3,}` | At least three | `{,3}` | Up to three |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: Examples of regular expressions
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some examples of regular expressions with a description of their meaning:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Meaning |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit somewhere in the input |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| `a` | The character *a* somewhere in the input |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| `Bob` | The word *Bob* somewhere in the input |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| `^Bob` | The word *Bob* at the start of the input |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| `Bob$` | The word *Bob* at the end of the input |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| `^\d{2}$` | Exactly two digits |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| `^[0-9]{2}$` | Exactly two digits |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Z]{4,}$` | At least four uppercase English letters in the ASCII character
    set only |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Za-z]{4,}$` | At least four upper or lowercase English letters in the
    ASCII character set only |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Z]{2}\d{3}$` | Two uppercase English letters in the ASCII character
    set and three digits only |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Za-z\u00c0-\u017e]+$` | At least one uppercase or lowercase English
    letter in the ASCII character set or European letters in the Unicode character
    set, as shown in the following list:ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿıŒœŠšŸ
    Žž |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '| `^d.g$` | The letter *d*, then any character, and then the letter *g*, so
    it would match both *dig* and *dog* or any single character between the *d* and
    *g* |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| `^d\.g$` | The letter *d*, then a dot (.), and then the letter *g*, so it
    would match *d.g* only |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '**Good Practice**: Use regular expressions to validate input from the user.
    The same regular expressions can be reused in other languages such as JavaScript
    and Python.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a complex comma-separated string
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned how to split a simple comma-separated string
    variable. But what about the following example of film titles?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `string` value uses double quotes around each film title. We can use these
    to identify whether we need to split on a comma (or not). The `Split` method is
    not powerful enough, so we can use a regular expression instead.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You can read a fuller explanation in the Stack Overflow
    article that inspired this task at the following link: [https://stackoverflow.com/questions/18144431/regex-to-split-a-csv](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'To include double quotes inside a `string` value, we prefix them with a backslash:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a complex comma-separated `string` variable, and then
    split it in a dumb way using the `Split` method, as shown in the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add statements to define a regular expression to split and write the film titles
    in a smart way, as shown in the following code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Storing multiple objects in collections
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another of the most common types of data is collections. If you need to store
    multiple values in a variable, then you can use a collection.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: A collection is a data structure in memory that can manage multiple items in
    different ways, although all collections have some shared functionality.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common types in .NET for working with collections are shown in the
    following table:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Example type(s) | Description |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections` | `IEnumerable`, `IEnumerable<T>` | Interfaces and
    base classes used by collections. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Generic` | `List<T>`, `Dictionary<T>`, `Queue<T>`,
    `Stack<T>` | Introduced in C# 2.0 with .NET Framework 2.0\. These collections
    allow you to specify the type you want to store using a generic type parameter
    (which is safer, faster, and more efficient). |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Concurrent` | `BlockingCollection`, `ConcurrentDictionary`,
    `ConcurrentQueue` | These collections are safe to use in multithreaded scenarios.
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Immutable` | `ImmutableArray`, `ImmutableDictionary`,
    `ImmutableList`, `ImmutableQueue` | Designed for scenarios where the contents
    of the original collection will never change, although they can create modified
    collections as a new instance. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: Common features of all collections
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All collections implement the `ICollection` interface; this means that they
    must have a `Count` property to tell you how many objects are in them, as shown
    in the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For example, if we had a collection named `passengers`, we could do this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'All collections implement the `IEnumerable` interface, which means that they
    can be iterated using the `foreach` statement. They must have a `GetEnumerator`
    method that returns an object that implements `IEnumerator`; this means that the
    returned `object` must have `MoveNext` and `Reset` methods for navigating through
    the collection and a `Current` property containing the current item in the collection,
    as shown in the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For example, to perform an action on each object in the `passengers` collection,
    we could write the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As well as `object`-based collection interfaces, there are also generic interfaces
    and classes, where the generic type defines the type stored in the collection,
    as shown in the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Improving performance by ensuring the capacity of a collection
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since .NET 1.1, types like `StringBuilder` have had a method named `EnsureCapacity`
    that can presize its internal storage array to the expected final size of the
    `string`. This improves performance because it does not have to repeatedly increment
    the size of the array as more characters are appended.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET Core 2.1, types like `Dictionary<T>` and `HashSet<T>` have also had
    `EnsureCapacity`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET 6 and later, collections like `List<T>`, `Queue<T>`, and `Stack<T>`
    now have an `EnsureCapacity` method too, as shown in the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Understanding collection choices
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several different choices of collection that you can use for different
    purposes: lists, dictionaries, stacks, queues, sets, and many other more specialized
    collections.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lists, that is, a type that implements `IList<T>`, are **ordered collections**,
    as shown in the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`IList<T>` derives from `ICollection<T>` so it has a `Count` property, and
    an `Add` method to put an item at the end of the collection, as well as an `Insert`
    method to put an item in the list at a specified position, and `RemoveAt` to remove
    an item at a specified position.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are a good choice when you want to manually control the order of items
    in a collection. Each item in a list has a unique index (or position) that is
    automatically assigned. Items can be any type defined by `T` and items can be
    duplicated. Indexes are `int` types and start from `0`, so the first item in a
    list is at index `0`, as shown in the following table:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '| Index | Item |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| 0 | London |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| 1 | Paris |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| 2 | London |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| 3 | Sydney |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: 'If a new item (for example, Santiago) is inserted between London and Sydney,
    then the index of Sydney is automatically incremented. Therefore, you must be
    aware that an item''s index can change after inserting or removing items, as shown
    in the following table:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '| Index | Item |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| 0 | London |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| 1 | Paris |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| 2 | London |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| 3 | Santiago |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| 4 | Sydney |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: Dictionaries
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dictionaries are a good choice when each **value** (or object) has a unique
    sub value (or a made-up value) that can be used as a **key** to quickly find a
    value in the collection later. The key must be unique. For example, if you are
    storing a list of people, you could choose to use a government-issued identity
    number as the key.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Think of the key as being like an index entry in a real-world dictionary. It
    allows you to quickly find the definition of a word because the words (for example,
    keys) are kept sorted, and if we know we're looking for the definition of *manatee*,
    we would jump to the middle of the dictionary to start looking, because the letter
    *M* is in the middle of the alphabet.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries in programming are similarly smart when looking something up.
    They must implement the interface `IDictionary<TKey, TValue>`, as shown in the
    following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Items in a dictionary are instances of the `struct`, aka the value type `KeyValuePair<TKey,
    TValue>`, where `TKey` is the type of the key and `TValue` is the type of the
    value, as shown in the following code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'An example `Dictionary<string, Person>` uses a `string` as the key and a `Person`
    instance as the value. `Dictionary<string, string>` uses `string` values for both,
    as shown in the following table:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| BSA | Bob Smith |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| MW | Max Williams |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| BSB | Bob Smith |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| AM | Amir Mohammed |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: Stacks
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stacks are a good choice when you want to implement **last-in, first-out** (**LIFO**)
    behavior. With a stack, you can only directly access or remove the one item at
    the top of the stack, although you can enumerate to read through the whole stack
    of items. You cannot, for example, directly access the second item in a stack.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: For example, word processors use a stack to remember the sequence of actions
    you have recently performed, and then when you press Ctrl + Z, it will undo the
    last action in the stack, and then the next-to-last action, and so on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Queues are a good choice when you want to implement the **first-in, first-out**
    (**FIFO**) behavior. With a queue, you can only directly access or remove the
    one item at the front of the queue, although you can enumerate to read through
    the whole queue of items. You cannot, for example, directly access the second
    item in a queue.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: For example, background processes use a queue to process work items in the order
    that they arrive, just like people standing in line at the post office.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: .NET 6 introduces the `PriorityQueue`, where each item in the queue has a priority
    value assigned as well as their position in the queue.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets are a good choice when you want to perform set operations between two collections.
    For example, you may have two collections of city names, and you want to know
    which names appear in both sets (known as the *intersect* between the sets). Items
    in a set must be unique.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Collection methods summary
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each collection has a different set of methods for adding and removing items,
    as shown in the following table:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '| Collection | Add methods | Remove methods | Description |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| List | `Add`, `Insert` | `Remove`, `RemoveAt` | Lists are ordered so items
    have an integer index position. `Add` will add a new item at the end of the list.
    `Insert` will add a new item at the index position specified. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | `Add` | `Remove` | Dictionaries are not ordered so items do
    not have integer index positions. You can check if a key has been used by calling
    the `ContainsKey` method. |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| Stack | `Push` | `Pop` | Stacks always add a new item at the top of the stack
    using the `Push` method. The first item is at the bottom. Items are always removed
    from the top of the stack using the `Pop` method. Call the `Peek` method to see
    this value without removing it. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| Queue | `Enqueue` | `Dequeue` | Queues always add a new item at the end of
    the queue using the `Enqueue` method. The first item is at the front of the queue.
    Items are always removed from the front of the queue using the `Dequeue` method.
    Call the `Peek` method to see this value without removing it. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: Working with lists
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore lists:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithCollections`
    to the `Chapter08` solution/workspace.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithCollections` as the active OmniSharp
    project.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then define a function
    to output a collection of `string` values with a title, as shown in the following
    code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define a static method named `WorkingWithLists` to illustrate some of the common
    ways of defining and working with lists, as shown in the following code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'At the top of `Program.cs`, after the namespace imports, call the `WorkingWithLists`
    method, as shown in the following code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Working with dictionaries
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore dictionaries:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, define a static method named `WorkingWithDictionaries` to
    illustrate some of the common ways of working with dictionaries, for example,
    looking up word definitions, as shown in the following code:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At the top of `Program.cs`, comment out the previous method call and then call
    the `WorkingWithDictionaries` method, as shown in the following code:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Working with queues
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore queues:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, define a static method named `WorkingWithQueues` to illustrate
    some of the common ways of working with queues, for example, handling customers
    in a queue for coffee, as shown in the following code:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: At the top of `Program.cs`, comment out the previous method calls and call the
    `WorkingWithQueues` method.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，并调用`WorkingWithQueues`方法。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE63]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Define a static method named `OutputPQ`, as shown in the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`OutputPQ`的静态方法，如下所示：
- en: '[PRE64]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that the `OutputPQ` method is generic. You can specify the two types used
    in the tuples that are passed in as `collection`.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，`OutputPQ`方法是泛型的。你可以指定作为`collection`传递的元组中使用的两个类型。
- en: 'Define a static method named `WorkingWithPriorityQueues`, as shown in the following
    code:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`WorkingWithPriorityQueues`的静态方法，如下所示：
- en: '[PRE65]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: At the top of `Program.cs`, comment out the previous method calls and call the
    `WorkingWithPriorityQueues` method.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，并调用`WorkingWithPriorityQueues`方法。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE66]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Sorting collections
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序集合
- en: A `List<T>` class can be sorted by manually calling its `Sort` method (but remember
    that the indexes of each item will change). Manually sorting a list of `string`
    values or other built-in types will work without extra effort on your part, but
    if you create a collection of your own type, then that type must implement an
    interface named `IComparable`. You learned how to do this in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`类可以通过手动调用其`Sort`方法进行排序（但请记住，每个项的索引会改变）。手动对`string`值或其他内置类型的列表进行排序无需额外努力，但如果你创建了自己的类型的集合，则该类型必须实现名为`IComparable`的接口。你在《第6章：实现接口和继承类》中学过如何做到这一点。'
- en: A `Stack<T>` or `Queue<T>` collection cannot be sorted because you wouldn't
    usually want that functionality; for example, you would probably never sort a
    queue of guests checking into a hotel. But sometimes, you might want to sort a
    dictionary or a set.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack<T>`或`Queue<T>`集合无法排序，因为你通常不需要这种功能；例如，你可能永远不会对入住酒店的客人队列进行排序。但有时，你可能想要对字典或集合进行排序。'
- en: Sometimes it would be useful to have an automatically sorted collection, that
    is, one that maintains the items in a sorted order as you add and remove them.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有时拥有一个自动排序的集合会很有用，即在添加和删除项时保持项的排序顺序。
- en: There are multiple auto-sorting collections to choose from. The differences
    between these sorted collections are often subtle but can have an impact on the
    memory requirements and performance of your application, so it is worth putting
    effort into picking the most appropriate option for your requirements.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种自动排序集合可供选择。这些排序集合之间的差异通常很微妙，但可能会影响应用程序的内存需求和性能，因此值得努力选择最适合你需求的选项。
- en: 'Some common auto-sorting collections are shown in the following table:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的自动排序集合如下表所示：
- en: '| Collection | Description |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | 描述 |'
- en: '| `SortedDictionary<TKey, TValue>` | This represents a collection of key/value
    pairs that are sorted by key. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `SortedDictionary<TKey, TValue>` | 这表示一个按键排序的键/值对集合。 |'
- en: '| `SortedList<TKey, TValue>` | This represents a collection of key/value pairs
    that are sorted by key. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `SortedList<TKey, TValue>` | 这表示一个按键排序的键/值对集合。 |'
- en: '| `SortedSet<T>` | This represents a collection of unique objects that are
    maintained in a sorted order. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `SortedSet<T>` | 这表示一个唯一的对象集合，这些对象按排序顺序维护。 |'
- en: More specialized collections
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更专业的集合
- en: There are a few other collections for special situations.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些用于特殊情况的集合。
- en: Working with a compact array of bit values
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用紧凑的位值数组
- en: The `System.Collections.BitArray` collection manages a compact array of bit
    values, which are represented as Booleans, where `true` indicates that the bit
    is on (value is 1) and `false` indicates the bit is off (value is 0).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.BitArray`集合管理一个紧凑的位值数组，这些位值表示为布尔值，其中`true`表示位已打开（值为1），`false`表示位已关闭（值为0）。'
- en: Working with efficient lists
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高效地使用列表
- en: The `System.Collections.Generics.LinkedList<T>` collection represents a doubly
    linked list where every item has a reference to its previous and next items. They
    provide better performance compared to `List<T>` for scenarios where you will
    frequently insert and remove items from the middle of the list. In a `LinkedList<T>`
    the items do not have to be rearranged in memory.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Generics.LinkedList<T>`集合表示一个双向链表，其中每个项都有对其前一个和下一个项的引用。与`List<T>`相比，在频繁从列表中间插入和删除项的场景中，它们提供了更好的性能。在`LinkedList<T>`中，项无需在内存中重新排列。'
- en: Using immutable collections
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不可变集合
- en: Sometimes you need to make a collection immutable, meaning that its members
    cannot change; that is, you cannot add or remove them.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要使集合不可变，这意味着其成员不可更改；即，你不能添加或删除它们。
- en: If you import the `System.Collections.Immutable` namespace, then any collection
    that implements `IEnumerable<T>` is given six extension methods to convert it
    into an immutable list, dictionary, hash set, and so on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入了`System.Collections.Immutable`命名空间，那么任何实现`IEnumerable<T>`的集合都会获得六个扩展方法，用于将其转换为不可变列表、字典、哈希集等。
- en: 'Let''s see a simple example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子：
- en: In the `WorkingWithCollections` project, in `Program.cs`, import the `System.Collections.Immutable`
    namespace.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithCollections`项目中，在`Program.cs`中，导入`System.Collections.Immutable`命名空间。
- en: 'In the `WorkingWithLists` method, add statements to the end of the method to
    convert the `cities` list into an immutable list and then add a new city to it,
    as shown in the following code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WorkingWithLists`方法中，在方法末尾添加语句，将`cities`列表转换为不可变列表，然后向其添加一个新城市，如下代码所示：
- en: '[PRE67]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: At the top of `Program.cs`, comment the previous method calls and uncomment
    the call to the `WorkingWithLists` method.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，注释掉之前的方法调用，并取消对`WorkingWithLists`方法调用的注释。
- en: 'Run the code, view the result, and note that the immutable list of cities does
    not get modified when you call the `Add` method on it; instead, it returns a new
    list with the newly added city, as shown in the following output:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意当对不可变城市列表调用`Add`方法时，该列表并未被修改；相反，它返回了一个包含新添加城市的新列表，如下输出所示：
- en: '[PRE68]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**Good Practice**: To improve performance, many applications store a shared
    copy of commonly accessed objects in a central cache. To safely allow multiple
    threads to work with those objects knowing they won''t change, you should make
    them immutable or use a concurrent collection type that you can read about at
    the following link: [https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：为了提高性能，许多应用程序在中央缓存中存储了常用对象的共享副本。为了安全地允许多个线程使用这些对象，同时确保它们不会被更改，你应该使它们不可变，或者使用并发集合类型，你可以在以下链接中了解相关信息：[https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent)'
- en: Good practice with collections
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的良好实践
- en: 'Let''s say you need to create a method to process a collection. For maximum
    flexibility, you could declare the input parameter to be `IEnumerable<T>` and
    make the method generic, as shown in the following code:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要创建一个处理集合的方法。为了最大程度地灵活，你可以声明输入参数为`IEnumerable<T>`，并使方法泛型化，如下代码所示：
- en: '[PRE69]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: I could pass an array, a list, a queue, a stack, or anything else that implements
    `IEnumerable<T>` into this method and it will process the items. However, the
    flexibility to pass any collection to this method comes at a performance cost.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将数组、列表、队列、栈或任何其他实现`IEnumerable<T>`的集合传递给此方法，它将处理这些项。然而，将任何集合传递给此方法的灵活性是以性能为代价的。
- en: 'One of the performance problems with `IEnumerable<T>` is also one of its benefits:
    deferred execution, also known as lazy loading. Types that implement this interface
    do not have to implement deferred execution, but many do.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`的一个性能问题同时也是其优点之一：延迟执行，亦称为懒加载。实现此接口的类型并非必须实现延迟执行，但许多类型确实如此。'
- en: 'But the worst performance problem with `IEnumerable<T>` is that the iteration
    has to allocate an object on the heap. To avoid this memory allocation, you should
    define your method using a concrete type, as shown highlighted in the following
    code:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 但`IEnumerable<T>`最糟糕的性能问题是迭代时必须在堆上分配一个对象。为了避免这种内存分配，你应该使用具体类型定义你的方法，如下代码中突出显示的部分所示：
- en: '[PRE70]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This will use the `List<T>.Enumerator GetEnumerator()` method that returns a
    `struct` instead of the `IEnumerator<T> GetEnumerator()` method that returns a
    reference type. Your code will be two to three times faster and require less memory.
    As with all recommendations related to performance, you should confirm the benefit
    by running performance tests on your actual code in a product environment. You
    will learn how to do this in *Chapter 12*, *Improving Performance and Scalability
    Using Multitasking*.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `List<T>.Enumerator GetEnumerator()` 方法，该方法返回一个 `struct`，而不是返回引用类型的 `IEnumerator<T>
    GetEnumerator()` 方法。您的代码将快两到三倍，并且需要更少的内存。与所有与性能相关的建议一样，您应该通过在产品环境中运行实际代码的性能测试来确认好处。您将在*第
    12 章*，*使用多任务提高性能和可扩展性*中学习如何做到这一点。
- en: Working with spans, indexes, and ranges
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理跨度、索引和范围
- en: One of Microsoft's goals with .NET Core 2.1 was to improve performance and resource
    usage. A key .NET feature that enables this is the `Span<T>` type.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 在 .NET Core 2.1 中的目标之一是提高性能和资源使用率。实现这一目标的关键 .NET 特性是 `Span<T>` 类型。
- en: Using memory efficiently using spans
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跨度高效利用内存
- en: When manipulating arrays, you will often create new copies of subsets of existing
    ones so that you can process just the subset. This is not efficient because duplicate
    objects must be created in memory.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作数组时，您通常会创建现有子集的新副本，以便仅处理该子集。这样做效率不高，因为必须在内存中创建重复对象。
- en: If you need to work with a subset of an array, use a **span** because it is
    like a window into the original array. This is more efficient in terms of memory
    usage and improves performance. Spans only work with arrays, not collections,
    because the memory must be contiguous.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要处理数组的子集，请使用**跨度**，因为它就像原始数组的窗口。这在内存使用方面更有效，并提高了性能。跨度仅适用于数组，不适用于集合，因为内存必须是连续的。
- en: 'Before we look at spans in more detail, we need to understand some related
    objects: indexes and ranges.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地了解跨度之前，我们需要了解一些相关对象：索引和范围。
- en: Identifying positions with the Index type
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Index 类型识别位置
- en: C# 8.0 introduced two features for identifying an item's index within an array
    and a range of items using two indexes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0 引入了两个特性，用于识别数组中项的索引以及使用两个索引的范围。
- en: 'You learned in the previous topic that objects in a list can be accessed by
    passing an integer into their indexer, as shown in the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 您在上一主题中学到，可以通过将整数传递给其索引器来访问列表中的对象，如下所示：
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `Index` value type is a more formal way of identifying a position, and
    supports counting from the end, as shown in the following code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index` 值类型是一种更正式的识别位置的方式，并支持从末尾计数，如下所示：'
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Identifying ranges with the Range type
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Range 类型识别范围
- en: 'The `Range` value type uses `Index` values to indicate the start and end of
    its range, using its constructor, C# syntax, or its static methods, as shown in
    the following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`Range` 值类型使用 `Index` 值来指示其范围的起始和结束，使用其构造函数、C# 语法或其静态方法，如下所示：'
- en: '[PRE73]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Extension methods have been added to `string` values (that internally use an
    array of `char`), `int` arrays, and spans to make ranges easier to work with.
    These extension methods accept a range as a parameter and return a `Span<T>`.
    This makes them very memory efficient.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 已向 `string` 值（内部使用 `char` 数组）、`int` 数组和跨度添加了扩展方法，以使范围更易于使用。这些扩展方法接受一个范围作为参数并返回一个
    `Span<T>`。这使得它们非常节省内存。
- en: Using indexes, ranges, and spans
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用索引、范围和跨度
- en: 'Let''s explore using indexes and ranges to return spans:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索使用索引和范围来返回跨度：
- en: Use your preferred code editor to add a new console app named `WorkingWithRanges`
    to the `Chapter08` solution/workspace.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器将名为 `WorkingWithRanges` 的新控制台应用程序添加到 `Chapter08` 解决方案/工作区。
- en: In Visual Studio Code, select `WorkingWithRanges` as the active OmniSharp project.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，选择 `WorkingWithRanges` 作为活动 OmniSharp 项目。
- en: 'In `Program.cs`, type statements to compare using the `string` type''s `Substring`
    method using ranges to extract parts of someone''s name, as shown in the following
    code:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，键入语句以使用 `string` 类型的 `Substring` 方法使用范围来提取某人姓名的部分，如下所示：
- en: '[PRE74]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE75]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Working with network resources
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理网络资源
- en: 'Sometimes you will need to work with network resources. The most common types
    in .NET for working with network resources are shown in the following table:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要处理网络资源。.NET 中用于处理网络资源的最常见类型如下表所示：
- en: '| Namespace | Example type(s) | Description |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `Dns`, `Uri`, `Cookie`, `WebClient`, `IPAddress` | These are
    for working with DNS servers, URIs, IP addresses, and so on. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `FtpStatusCode`, `FtpWebRequest`, `FtpWebResponse` | These
    are for working with FTP servers. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `HttpStatusCode`, `HttpWebRequest`, `HttpWebResponse` | These
    are for working with HTTP servers; that is, websites and services. Types from
    `System.Net.Http` are easier to use. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Http` | `HttpClient`, `HttpMethod`, `HttpRequestMessage`, `HttpResponseMessage`
    | These are for working with HTTP servers; that is, websites and services. You
    will learn how to use these in *Chapter 16*, *Building and Consuming Web Services*.
    |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Mail` | `Attachment`, `MailAddress`, `MailMessage`, `SmtpClient`
    | These are for working with SMTP servers; that is, sending email messages. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: '| `System.Net .NetworkInformation` | `IPStatus`, `NetworkChange`, `Ping`, `TcpStatistics`
    | These are for working with low-level network protocols. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
- en: Working with URIs, DNS, and IP addresses
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore some common types for working with network resources:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithNetworkResources`
    to the `Chapter08` solution/workspace.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithNetworkResources` as the active OmniSharp
    project.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for working with the network,
    as shown in the following code:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Type statements to prompt the user to enter a website address, and then use
    the `Uri` type to break it down into its parts, including the scheme (HTTP, FTP,
    and so on), port number, and host, as shown in the following code:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: For convenience, the code also allows the user to press ENTER to use an example
    URL.
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code, enter a valid website address or press ENTER, and view the result,
    as shown in the following output:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Add statements to get the IP address for the entered website, as shown in the
    following code:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Run the code, enter a valid website address or press ENTER, and view the result,
    as shown in the following output:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Pinging a server
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you will add code to ping a web server to check its health:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the namespace to get more information about networks, as shown in the
    following code:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Add statements to ping the entered website, as shown in the following code:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the code, press ENTER, and view the result, as shown in the following output
    on macOS:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Run the code again but this time enter [http://google.com](http://google.com),
    as shown in the following output:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Working with reflection and attributes
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reflection** is a programming feature that allows code to understand and
    manipulate itself. An assembly is made up of up to four parts:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly metadata and manifest**: Name, assembly, and file version, referenced
    assemblies, and so on.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type metadata**: Information about the types, their members, and so on.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IL code**: Implementation of methods, properties, constructors, and so on.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded resources** (optional): Images, strings, JavaScript, and so on.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The metadata comprises items of information about your code. The metadata is
    generated automatically from your code (for example, information about the types
    and members) or applied to your code using attributes.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes can be applied at multiple levels: to assemblies, to types, and
    to their members, as shown in the following code:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Attribute-based programming is used a lot in app models like ASP.NET Core to
    enable features like routing, security, and caching.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Versioning of assemblies
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Version numbers in .NET are a combination of three numbers, with two optional
    additions. If you follow the rules of semantic versioning, the three numbers denote
    the following:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '**Major**: Breaking changes.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: Non-breaking changes, including new features, and often bug fixes.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch**: Non-breaking bug fixes.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: When updating a NuGet package that you already use in a
    project, to be safe you should specify an optional flag to make sure that you
    only upgrade to the highest minor to avoid breaking changes, or to the highest
    patch if you are extra cautious and only want to receive bug fixes, as shown in
    the following commands: `Update-Package Newtonsoft.Json -ToHighestMinor` or `Update-Package
    Newtonsoft.Json -ToHighestPatch`.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, a version can include these:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerelease**: Unsupported preview releases.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build number**: Nightly builds.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Follow the rules of semantic versioning, as described at
    the following link: [http://semver.org](http://semver.org)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Reading assembly metadata
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore working with attributes:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithReflection`
    to the `Chapter08` solution/workspace.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithReflection` as the active OmniSharp
    project.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for reflection, as shown in
    the following code:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Add statements to get the console app''s assembly, output its name and location,
    and get all assembly-level attributes and output their types, as shown in the
    following code:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Note that because the full name of an assembly must uniquely identify the assembly,
    it is a combination of the following:'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Name**, for example, `WorkingWithReflection`'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**, for example, `1.0.0.0`'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Culture**, for example, `neutral`'
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public key token**, although this can be `null`'
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know some of the attributes decorating the assembly, we can ask
    for them specifically.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add statements to get the `AssemblyInformationalVersionAttribute` and `AssemblyCompanyAttribute`
    classes and then output their values, as shown in the following code:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Hmmm, unless you set the version, it defaults to 1.0.0, and unless you set
    the company, it defaults to the name of the assembly. Let''s explicitly set this
    information. The legacy .NET Framework way to set these values was to add attributes
    in the C# source code file, as shown in the following code:'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The Roslyn compiler used by .NET sets these attributes automatically, so we
    can't use the old way. Instead, they must be set in the project file.
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `WorkingWithReflection.csproj` project file to add elements for version
    and company, as shown highlighted in the following markup:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Creating custom attributes
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define your own attributes by inheriting from the `Attribute` class:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Add a class file to your project named `CoderAttribute.cs`.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define an attribute class that can decorate either classes or methods with
    two properties to store the name of a coder and the date they last modified some
    code, as shown in the following code:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In `Program.cs`, import some namespaces, as shown in the following code:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'At the bottom of `Program.cs`, add a class with a method, and decorate the
    method with the `Coder` attribute with data about two coders, as shown in the
    following code:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In `Program.cs`, above the `Animal` class, add code to get the types, enumerate
    their members, read any `Coder` attributes on those members, and output the information,
    as shown in the following code:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Run the code and view the result, as shown in the following partial output:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: What is the `<Program>$+<>c` type?
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: It is a compiler-generated **display class**. `<>` indicates compiler-generated
    and `c` indicates a display class. They are undocumented implementation details
    of the compiler and could change at any time. You can ignore them, so as an optional
    challenge, add statements to your console application to filter compiler-generated
    types by skipping types decorated with `CompilerGeneratedAttribute`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Doing more with reflection
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is just a taster of what can be achieved with reflection. We only used
    reflection to read metadata from our code. Reflection can also do the following:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamically load assemblies that are not currently referenced**: [https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability](https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamically execute code**: [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke)'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamically generate new code and assemblies**: [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder)'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ImageSharp is a third-party cross-platform 2D graphics library. When .NET Core
    1.0 was in development, there was negative feedback from the community about the
    missing `System.Drawing` namespace for working with 2D images.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: The **ImageSharp** project was started to fill that gap for modern .NET applications.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: In their official documentation for `System.Drawing`, Microsoft says, "The `System.Drawing`
    namespace is not recommended for new development due to not being supported within
    a Windows or ASP.NET service, and it is not cross-platform. ImageSharp and SkiaSharp
    are recommended as alternatives."
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what can be achieved with ImageSharp:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithImages`
    to the `Chapter08` solution/workspace.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithImages` as the active OmniSharp project.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `images` folder and download the nine images from the following link:
    [https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories](https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories)'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a package reference for `SixLabors.ImageSharp`, as shown in the following
    markup:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Build the `WorkingWithImages` project.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import some namespaces for working with images,
    as shown in the following code:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In `Program.cs`, enter statements to convert all the files in the images folder
    into grayscale thumbnails at one-tenth size, as shown in the following code:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Run the code.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the filesystem, open the `images` folder and note the much-smaller-in-bytes
    grayscale thumbnails, as shown in *Figure 8.1*:![A picture containing application  Description
    automatically generated](img/B17442_08_01.png)
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.1: Images after processing'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ImageSharp also has NuGet packages for programmatically drawing images and
    working with images on the web, as shown in the following list:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '`SixLabors.ImageSharp.Drawing`'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SixLabors.ImageSharp.Web`'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalizing your code
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internationalization is the process of enabling your code to run correctly
    all over the world. It has two parts: **globalization** and **localization**.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Globalization is about writing your code to accommodate multiple languages and
    region combinations. The combination of a language and a region is known as a
    culture. It is important for your code to know both the language and region because,
    for example, the date and currency formats are different in Quebec and Paris,
    despite them both using the French language.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: There are **International Organization for Standardization** (**ISO**) codes
    for all culture combinations. For example, in the code `da-DK`, `da` indicates
    the Danish language and `DK` indicates the Denmark region, and in the code `fr-CA`,
    `fr` indicates the French language and `CA` indicates the Canada region.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: ISO is not an acronym. ISO is a reference to the Greek word *isos* (which means
    equal).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Localization is about customizing the user interface to support a language,
    for example, changing the label of a button to be Close (`en`) or Fermer (`fr`).
    Since localization is more about the language, it doesn't always need to know
    about the region, although ironically enough, standardization (`en-US`) and standardisation
    (`en-GB`) suggest otherwise.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and changing the current culture
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internationalization is a huge topic on which several thousand-page books have
    been written. In this section, you will get a brief introduction to the basics
    using the `CultureInfo` type in the `System.Globalization` namespace.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `Internationalization`
    to the `Chapter08` solution/workspace.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Internationalization` as the active OmniSharp
    project.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for using globalization types,
    as shown in the following code:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Add statements to get the current globalization and localization cultures and
    output some information about them, and then prompt the user to enter a new culture
    code and show how that affects the formatting of common values such as dates and
    currency, as shown in the following code:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: When you run an application, it automatically sets its thread to use the culture
    of the operating system. I am running my code in London, UK, so the thread is
    set to English (United Kingdom).
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code prompts the user to enter an alternative ISO code. This allows your
    applications to replace the default culture at runtime.
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application then uses standard format codes to output the day of the week
    using format code `dddd`; the number of minutes with thousand separators using
    format code `N0`; and the salary with the currency symbol. These adapt automatically,
    based on the thread's culture.
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and enter `en-GB` for the ISO code and then enter some sample
    data including a date in a format valid for British English, as shown in the following
    output:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If you enter `en-US` instead of `en-GB`, then you must enter the date using
    month/day/year.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rerun the code and try a different culture, such as Danish in Denmark, as shown
    in the following output:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In this example, only the date and salary are globalized into Danish. The rest
    of the text is hardcoded as English. This book does not currently include how
    to translate text from one language to another. If you would like me to include
    that in the next edition, please let me know.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Consider whether your application needs to be internationalized
    and plan for that before you start coding! Write down all the pieces of text in
    the user interface that will need to be localized. Think about all the data that
    will need to be globalized (date formats, number formats, and sorting text behavior).'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics in this chapter.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.1 – Test your knowledge
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the web to answer the following questions:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: What is the maximum number of characters that can be stored in a `string` variable?
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why should you use a `SecureString` type?
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it appropriate to use a `StringBuilder` class?
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `LinkedList<T>` class?
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `SortedDictionary<T>` class rather than a `SortedList<T>`
    class?
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the ISO culture code for Welsh?
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between localization, globalization, and internationalization?
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a regular expression, what does `$` mean?
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a regular expression, how can you represent digits?
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you *not* use the official standard for email addresses to create
    a regular expression to validate a user's email address?
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 8.2 – Practice regular expressions
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter08` solution/workspace, create a console application named `Exercise02`
    that prompts the user to enter a regular expression and then prompts the user
    to enter some input and compare the two for a match until the user presses *Esc*,
    as shown in the following output:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Exercise 8.3 – Practice writing extension methods
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Chapter08` solution/workspace, create a class library named `Exercise03`
    that defines extension methods that extend number types such as `BigInteger` and
    `int` with a method named `ToWords` that returns a `string` describing the number;
    for example, `18,000,000` would be eighteen million, and `18,456,002,032,011,000,007`
    would be eighteen quintillion, four hundred and fifty-six quadrillion, two trillion,
    thirty-two billion, eleven million, and seven.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about names for large numbers at the following link: [https://en.wikipedia.org/wiki/Names_of_large_numbers](https://en.wikipedia.org/wiki/Names_of_large_numbers)'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.4 – Explore topics
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types)'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored some choices for types to store and manipulate
    numbers, dates and times, and text including regular expressions, and which collections
    to use for storing multiple items; worked with indexes, ranges, and spans; used
    some network resources; reflected on code and attributes; manipulated images using
    a Microsoft-recommended third-party library; and learned how to internationalize
    your code.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will manage files and streams, encode and decode text,
    and perform serialization.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
