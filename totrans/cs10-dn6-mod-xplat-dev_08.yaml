- en: 08
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Common .NET Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about some common types that are included with .NET. These include
    types for manipulating numbers, text, collections, network access, reflection,
    and attributes; improving working with spans, indexes, and ranges; manipulating
    images; and internationalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dates and times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing multiple objects in collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with spans, indexes, and ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with network resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with reflection and attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalizing your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common types of data is numbers. The most common types in .NET
    for working with numbers are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Example type(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `SByte`, `Int16`, `Int32`, `Int64` | Integers; that is, zero and
    positive and negative whole numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Byte`, `UInt16`, `UInt32`, `UInt64` | Cardinals; that is, zero
    and positive whole numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Half`, `Single`, `Double` | Reals; that is, floating-point numbers
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Decimal` | Accurate reals; that is, for use in science, engineering,
    or financial scenarios |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Numerics` | `BigInteger`, `Complex`, `Quaternion` | Arbitrarily large
    integers, complex numbers, and quaternion numbers |'
  prefs: []
  type: TYPE_TB
- en: .NET has had the 32-bit float and 64-bit double types since .NET Framework 1.0\.
    The IEEE 754 specification also defines a 16-bit floating point standard. Machine
    learning and other algorithms would benefit from this smaller, lower-precision
    number type so Microsoft introduced the `System.Half` type with .NET 5 and later.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the C# language does not define a `half` alias so you must use the
    .NET type `System.Half`. This might change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Working with big integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The largest whole number that can be stored in .NET types that have a C# alias
    is about eighteen and a half quintillion, stored in an unsigned `long` integer.
    But what if you need to store numbers larger than that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore numerics:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `Chapter08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter08`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithNumbers`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and add a statement to import
    `System.Numerics`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to output the maximum value of the `ulong` type, and a number
    with 30 digits using `BigInteger`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `40` in the format code means right-align 40 characters, so both numbers
    are lined up to the right-hand edge. The `N0` means use thousand separators and
    zero decimal places.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complex number can be expressed as *a + bi*, where *a* and *b* are real numbers,
    and *i* is an imaginary unit, where *i*² *= −1*. If the real part *a* is zero,
    it is a pure imaginary number. If the imaginary part *b* is zero, it is a real
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex numbers have practical applications in many **STEM** (**science, technology,
    engineering, and mathematics**) fields of study. Additionally, they are added
    by separately adding the real and imaginary parts of the summands; consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to add two complex numbers, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding quaternions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quaternions are a number system that extends complex numbers. They form a four-dimensional
    associative normed division algebra over the real numbers, and therefore also
    a domain.
  prefs: []
  type: TYPE_NORMAL
- en: Huh? Yes, I know. I don't understand that either. Don't worry; we're not going
    to write any code using them! Suffice to say, they are good at describing spatial
    rotations, so video game engines use them, as do many computer simulations and
    flight control systems.
  prefs: []
  type: TYPE_NORMAL
- en: Working with text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the other most common types of data for variables is text. The most
    common types in .NET for working with text are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Char` | Storage for a single text character |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `String` | Storage for multiple text characters |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Text` | `StringBuilder` | Efficiently manipulates strings |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Text.RegularExpressions` | `Regex` | Efficiently pattern-matches
    strings |'
  prefs: []
  type: TYPE_TB
- en: Getting the length of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore some common tasks when working with text; for example, sometimes
    you need to find out the length of a piece of text stored in a `string` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new console app named `WorkingWithText`
    to the `Chapter08` solution/workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithText` as the active OmniSharp project.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithText` project, in `Program.cs`, add statements to define
    a variable to store the name of the city London, and then write its name and length
    to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Getting the characters of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string` class uses an array of `char` internally to store the text. It
    also has an indexer, which means that we can use the array syntax to read its
    characters. Array indexes start at zero, so the third character will be at index
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a statement to write the characters at the first and third positions in
    the `string` variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Splitting a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to split some text wherever there is a character, such
    as a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define a single `string` variable containing comma-separated
    city names, then use the `Split` method and specify that you want to treat commas
    as the separator, and then enumerate the returned array of `string` values, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Later in this chapter, you will learn how to handle more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting part of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to get part of some text. The `IndexOf` method has nine
    overloads that return the index position of a specified `char` or `string` within
    a `string`. The `Substring` method has two overloads, as shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Substring(startIndex, length)`: returns a substring starting at `startIndex`
    and containing the next `length` characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Substring(startIndex)`: returns a substring starting at `startIndex` and containing
    all characters up to the end of the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s explore a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a person''s full name in a `string` variable with a
    space character between the first and last name, find the position of the space,
    and then extract the first name and last name as two parts so that they can be
    recombined in a different order, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the format of the initial full name was different, for example, `"LastName,
    FirstName"`, then the code would need to be different. As an optional exercise,
    try writing some statements that would change the input `"Jones, Alan"` into `"Alan
    Jones"`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking a string for content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to check whether a piece of text starts or ends with some
    characters or contains some characters. You can achieve this with methods named
    `StartsWith`, `EndsWith`, and `Contains`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a `string` value and then check if it starts with or
    contains a couple of different `string` values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Joining, formatting, and other string members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many other `string` members, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Trim`, `TrimStart`, `TrimEnd` | These methods trim whitespace characters
    such as space, tab, and carriage return from the beginning and/or end. |'
  prefs: []
  type: TYPE_TB
- en: '| `ToUpper`, `ToLower` | These convert all the characters into uppercase or
    lowercase. |'
  prefs: []
  type: TYPE_TB
- en: '| `Insert`, `Remove` | These methods insert or remove some text. |'
  prefs: []
  type: TYPE_TB
- en: '| `Replace` | This replaces some text with other text. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Empty` | This can be used instead of allocating memory each time
    you use a literal `string` value using an empty pair of double quotes (`""`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Concat` | This concatenates two `string` variables. The + operator
    does the equivalent when used between `string` operands. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Join` | This concatenates one or more `string` variables with a character
    in between each one. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.IsNullOrEmpty` | This checks whether a `string` variable is `null`
    or empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.IsNullOrWhitespace` | This checks whether a `string` variable is
    `null` or whitespace; that is, a mix of any number of horizontal and vertical
    spacing characters, for example, tab, space, carriage return, line feed, and so
    on. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Format` | An alternative method to string interpolation for outputting
    formatted `string` values, which uses positioned instead of named parameters.
    |'
  prefs: []
  type: TYPE_TB
- en: Some of the preceding methods are static methods. This means that the method
    can only be called from the type, not from a variable instance. In the preceding
    table, I indicated the static methods by prefixing them with `string.`, as in
    `string.Format`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore some of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to take an array of string values and combine them back together
    into a single string variable with separators using the `Join` method, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to use positioned parameters and interpolated string formatting
    syntax to output the same three variables twice, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we could have simplified the second statement because `WriteLine`
    supports the same format codes as `string.Format`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Building strings efficiently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can concatenate two strings to make a new `string` using the `String.Concat`
    method or simply by using the `+` operator. But both of these choices are bad
    practice because .NET must create a completely new `string` in memory.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be noticeable if you are only adding two `string` values, but
    if you concatenate inside a loop with many iterations, it can have a significant
    negative impact on performance and memory use. In *Chapter 12*, *Improving Performance
    and Scalability Using Multitasking*, you will learn how to concatenate `string`
    variables efficiently using the `StringBuilder` type.
  prefs: []
  type: TYPE_NORMAL
- en: Working with dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After numbers and text, the next most popular types of data to work with are
    dates and times. The two main types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DateTime`: represents a combined date and time value for a fixed point in
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeSpan`: represents a duration of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two types are often used together. For example, if you subtract one `DateTime`
    value from another, the result is a `TimeSpan`. If you add a `TimeSpan` to a `DateTime`
    then the result is a `DateTime` value.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying date and time values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common way to create a date and time value is to specify individual values
    for the date and time components like day and hour, as described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Date/time parameter | Value range |'
  prefs: []
  type: TYPE_TB
- en: '| `year` | 1 to 9999 |'
  prefs: []
  type: TYPE_TB
- en: '| `month` | 1 to 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `day` | 1 to the number of days in that month |'
  prefs: []
  type: TYPE_TB
- en: '| `hour` | 0 to 23 |'
  prefs: []
  type: TYPE_TB
- en: '| `minute` | 0 to 59 |'
  prefs: []
  type: TYPE_TB
- en: '| `second` | 0 to 59 |'
  prefs: []
  type: TYPE_TB
- en: An alternative is to provide the value as a `string` to be parsed, but this
    can be misinterpreted depending on the default culture of the thread. For example,
    in the UK, dates are specified as day/month/year, compared to the US, where dates
    are specified as month/day/year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what you might want to do with dates and times:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithTime`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithTime` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    initialize some special date/time values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to define Christmas Day in 2021 (if this is in the past then
    use a future year) and display it in various ways, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to perform addition and subtraction with Christmas, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to define the time on Christmas Day that your children might
    wake up to open presents, and display it in various ways, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Globalization with dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current culture controls how dates and times are parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs`, import the `System.Globalization` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to show the current culture that is used to display date and
    time values, and then parse United States Independence Day and display it in various
    ways, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On my computer, the current culture is British English. If a date is given as
    4 July 2021, then it is correctly parsed regardless of whether the current culture
    is British or American. But if the date is given as 7/4/2021, then it is wrongly
    parsed as 7 April. You can override the current culture by specifying the correct
    culture as a provider when parsing, as shown in the third example above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add statements to loop from the year 2020 to 2025, displaying if the year is
    a leap year and how many days there are in February, and then show if Christmas
    and Independence Day are during daylight saving time, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with only a date or a time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 6 introduces some new types for working with only a date value or only
    a time value named `DateOnly` and `TimeOnly`. These are better than using a `DateTime`
    value with a zero time to store a date-only value because it is type-safe and
    avoids misuse. `DateOnly` also maps better to database column types, for example,
    a `date` column in SQL Server. `TimeOnly` is good for setting alarms and scheduling
    regular meetings or events, and it maps to a `time` column in SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use them to plan a party for the Queen of England:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define the Queen''s birthday, and a time for her party to
    start, and then combine the two values to make a calendar entry so we don''t miss
    her party, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pattern matching with regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are useful for validating input from the user. They are
    very powerful and can get very complicated. Almost all programming languages have
    support for regular expressions and use a common set of special characters to
    define them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out some example regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithRegularExpressions`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithRegularExpressions` as the active
    OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import the following namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Checking for digits entered as text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by implementing the common example of validating number input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to prompt the user to enter their age and then check that it
    is valid using a regular expression that looks for a digit character, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following about the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `@` character switches off the ability to use escape characters in the string.
    Escape characters are prefixed with a backslash. For example, `\t` means a tab
    and `\n` means a new line. When writing regular expressions, we need to disable
    this feature. To paraphrase the television show The West Wing, "Let backslash
    be backslash."
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once escape characters are disabled with `@`, then they can be interpreted by
    a regular expression. For example, `\d` means digit. You will learn more regular
    expressions that are prefixed with a backslash later in this topic.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code, enter a whole number such as `34` for the age, and view the result,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again, enter `carrots`, and view the result, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again, enter `bob30smith`, and view the result, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The regular expression we used is `\d`, which means *one digit*. However, it
    does not specify what can be entered before and after that one digit. This regular
    expression could be described in English as "Enter any characters you want as
    long as you enter at least one digit character."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In regular expressions, you indicate the start of some input with the caret
    `^` symbol and the end of some input with the dollar `$` symbol. Let's use these
    symbols to indicate that we expect nothing else between the start and end of the
    input except for a digit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Change the regular expression to `^\d$`, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code again and note that it rejects any input except a single digit.
    We want to allow one or more digits. To do this, we add a `+` after the `\d` expression
    to modify the meaning to one or more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the regular expression, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code again and note the regular expression only allows zero or positive
    whole numbers of any length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regular expression performance improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The .NET types for working with regular expressions are used throughout the
    .NET platform and many of the apps built with it. As such, they have a significant
    impact on performance, but until now, they have not received much optimization
    attention from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 5 and later, the `System.Text.RegularExpressions` namespace has rewritten
    internals to squeeze out maximum performance. Common regular expression benchmarks
    using methods like `IsMatch` are now five times faster. And the best thing is,
    you do not have to change your code to get the benefits!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the syntax of a regular expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some common regular expression symbols that you can use in regular
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Meaning | Symbol | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of input | `$` | End of input |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit | `\D` | A single NON-digit |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Whitespace | `\S` | NON-whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Word characters | `\W` | NON-word characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Za-z0-9]` | Range(s) of characters | `\^` | ^ (caret) character |'
  prefs: []
  type: TYPE_TB
- en: '| `[aeiou]` | Set of characters | `[^aeiou]` | NOT in a set of characters |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any single character | `\.` | . (dot) character |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, here are some regular expression quantifiers that affect the previous
    symbols in a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Meaning | Symbol | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more | `?` | One or none |'
  prefs: []
  type: TYPE_TB
- en: '| `{3}` | Exactly three | `{3,5}` | Three to five |'
  prefs: []
  type: TYPE_TB
- en: '| `{3,}` | At least three | `{,3}` | Up to three |'
  prefs: []
  type: TYPE_TB
- en: Examples of regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some examples of regular expressions with a description of their meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | The character *a* somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `Bob` | The word *Bob* somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `^Bob` | The word *Bob* at the start of the input |'
  prefs: []
  type: TYPE_TB
- en: '| `Bob$` | The word *Bob* at the end of the input |'
  prefs: []
  type: TYPE_TB
- en: '| `^\d{2}$` | Exactly two digits |'
  prefs: []
  type: TYPE_TB
- en: '| `^[0-9]{2}$` | Exactly two digits |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Z]{4,}$` | At least four uppercase English letters in the ASCII character
    set only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Za-z]{4,}$` | At least four upper or lowercase English letters in the
    ASCII character set only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Z]{2}\d{3}$` | Two uppercase English letters in the ASCII character
    set and three digits only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Za-z\u00c0-\u017e]+$` | At least one uppercase or lowercase English
    letter in the ASCII character set or European letters in the Unicode character
    set, as shown in the following list:ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿıŒœŠšŸ
    Žž |'
  prefs: []
  type: TYPE_TB
- en: '| `^d.g$` | The letter *d*, then any character, and then the letter *g*, so
    it would match both *dig* and *dog* or any single character between the *d* and
    *g* |'
  prefs: []
  type: TYPE_TB
- en: '| `^d\.g$` | The letter *d*, then a dot (.), and then the letter *g*, so it
    would match *d.g* only |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice**: Use regular expressions to validate input from the user.
    The same regular expressions can be reused in other languages such as JavaScript
    and Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a complex comma-separated string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned how to split a simple comma-separated string
    variable. But what about the following example of film titles?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `string` value uses double quotes around each film title. We can use these
    to identify whether we need to split on a comma (or not). The `Split` method is
    not powerful enough, so we can use a regular expression instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You can read a fuller explanation in the Stack Overflow
    article that inspired this task at the following link: [https://stackoverflow.com/questions/18144431/regex-to-split-a-csv](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To include double quotes inside a `string` value, we prefix them with a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a complex comma-separated `string` variable, and then
    split it in a dumb way using the `Split` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to define a regular expression to split and write the film titles
    in a smart way, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Storing multiple objects in collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another of the most common types of data is collections. If you need to store
    multiple values in a variable, then you can use a collection.
  prefs: []
  type: TYPE_NORMAL
- en: A collection is a data structure in memory that can manage multiple items in
    different ways, although all collections have some shared functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common types in .NET for working with collections are shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Example type(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections` | `IEnumerable`, `IEnumerable<T>` | Interfaces and
    base classes used by collections. |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Generic` | `List<T>`, `Dictionary<T>`, `Queue<T>`,
    `Stack<T>` | Introduced in C# 2.0 with .NET Framework 2.0\. These collections
    allow you to specify the type you want to store using a generic type parameter
    (which is safer, faster, and more efficient). |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Concurrent` | `BlockingCollection`, `ConcurrentDictionary`,
    `ConcurrentQueue` | These collections are safe to use in multithreaded scenarios.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Immutable` | `ImmutableArray`, `ImmutableDictionary`,
    `ImmutableList`, `ImmutableQueue` | Designed for scenarios where the contents
    of the original collection will never change, although they can create modified
    collections as a new instance. |'
  prefs: []
  type: TYPE_TB
- en: Common features of all collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All collections implement the `ICollection` interface; this means that they
    must have a `Count` property to tell you how many objects are in them, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we had a collection named `passengers`, we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'All collections implement the `IEnumerable` interface, which means that they
    can be iterated using the `foreach` statement. They must have a `GetEnumerator`
    method that returns an object that implements `IEnumerator`; this means that the
    returned `object` must have `MoveNext` and `Reset` methods for navigating through
    the collection and a `Current` property containing the current item in the collection,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to perform an action on each object in the `passengers` collection,
    we could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as `object`-based collection interfaces, there are also generic interfaces
    and classes, where the generic type defines the type stored in the collection,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Improving performance by ensuring the capacity of a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since .NET 1.1, types like `StringBuilder` have had a method named `EnsureCapacity`
    that can presize its internal storage array to the expected final size of the
    `string`. This improves performance because it does not have to repeatedly increment
    the size of the array as more characters are appended.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET Core 2.1, types like `Dictionary<T>` and `HashSet<T>` have also had
    `EnsureCapacity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET 6 and later, collections like `List<T>`, `Queue<T>`, and `Stack<T>`
    now have an `EnsureCapacity` method too, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Understanding collection choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several different choices of collection that you can use for different
    purposes: lists, dictionaries, stacks, queues, sets, and many other more specialized
    collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lists, that is, a type that implements `IList<T>`, are **ordered collections**,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`IList<T>` derives from `ICollection<T>` so it has a `Count` property, and
    an `Add` method to put an item at the end of the collection, as well as an `Insert`
    method to put an item in the list at a specified position, and `RemoveAt` to remove
    an item at a specified position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are a good choice when you want to manually control the order of items
    in a collection. Each item in a list has a unique index (or position) that is
    automatically assigned. Items can be any type defined by `T` and items can be
    duplicated. Indexes are `int` types and start from `0`, so the first item in a
    list is at index `0`, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Index | Item |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Paris |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Sydney |'
  prefs: []
  type: TYPE_TB
- en: 'If a new item (for example, Santiago) is inserted between London and Sydney,
    then the index of Sydney is automatically incremented. Therefore, you must be
    aware that an item''s index can change after inserting or removing items, as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Index | Item |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Paris |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Santiago |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Sydney |'
  prefs: []
  type: TYPE_TB
- en: Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dictionaries are a good choice when each **value** (or object) has a unique
    sub value (or a made-up value) that can be used as a **key** to quickly find a
    value in the collection later. The key must be unique. For example, if you are
    storing a list of people, you could choose to use a government-issued identity
    number as the key.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the key as being like an index entry in a real-world dictionary. It
    allows you to quickly find the definition of a word because the words (for example,
    keys) are kept sorted, and if we know we're looking for the definition of *manatee*,
    we would jump to the middle of the dictionary to start looking, because the letter
    *M* is in the middle of the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries in programming are similarly smart when looking something up.
    They must implement the interface `IDictionary<TKey, TValue>`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Items in a dictionary are instances of the `struct`, aka the value type `KeyValuePair<TKey,
    TValue>`, where `TKey` is the type of the key and `TValue` is the type of the
    value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'An example `Dictionary<string, Person>` uses a `string` as the key and a `Person`
    instance as the value. `Dictionary<string, string>` uses `string` values for both,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| BSA | Bob Smith |'
  prefs: []
  type: TYPE_TB
- en: '| MW | Max Williams |'
  prefs: []
  type: TYPE_TB
- en: '| BSB | Bob Smith |'
  prefs: []
  type: TYPE_TB
- en: '| AM | Amir Mohammed |'
  prefs: []
  type: TYPE_TB
- en: Stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stacks are a good choice when you want to implement **last-in, first-out** (**LIFO**)
    behavior. With a stack, you can only directly access or remove the one item at
    the top of the stack, although you can enumerate to read through the whole stack
    of items. You cannot, for example, directly access the second item in a stack.
  prefs: []
  type: TYPE_NORMAL
- en: For example, word processors use a stack to remember the sequence of actions
    you have recently performed, and then when you press Ctrl + Z, it will undo the
    last action in the stack, and then the next-to-last action, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Queues are a good choice when you want to implement the **first-in, first-out**
    (**FIFO**) behavior. With a queue, you can only directly access or remove the
    one item at the front of the queue, although you can enumerate to read through
    the whole queue of items. You cannot, for example, directly access the second
    item in a queue.
  prefs: []
  type: TYPE_NORMAL
- en: For example, background processes use a queue to process work items in the order
    that they arrive, just like people standing in line at the post office.
  prefs: []
  type: TYPE_NORMAL
- en: .NET 6 introduces the `PriorityQueue`, where each item in the queue has a priority
    value assigned as well as their position in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets are a good choice when you want to perform set operations between two collections.
    For example, you may have two collections of city names, and you want to know
    which names appear in both sets (known as the *intersect* between the sets). Items
    in a set must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Collection methods summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each collection has a different set of methods for adding and removing items,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Collection | Add methods | Remove methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| List | `Add`, `Insert` | `Remove`, `RemoveAt` | Lists are ordered so items
    have an integer index position. `Add` will add a new item at the end of the list.
    `Insert` will add a new item at the index position specified. |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | `Add` | `Remove` | Dictionaries are not ordered so items do
    not have integer index positions. You can check if a key has been used by calling
    the `ContainsKey` method. |'
  prefs: []
  type: TYPE_TB
- en: '| Stack | `Push` | `Pop` | Stacks always add a new item at the top of the stack
    using the `Push` method. The first item is at the bottom. Items are always removed
    from the top of the stack using the `Pop` method. Call the `Peek` method to see
    this value without removing it. |'
  prefs: []
  type: TYPE_TB
- en: '| Queue | `Enqueue` | `Dequeue` | Queues always add a new item at the end of
    the queue using the `Enqueue` method. The first item is at the front of the queue.
    Items are always removed from the front of the queue using the `Dequeue` method.
    Call the `Peek` method to see this value without removing it. |'
  prefs: []
  type: TYPE_TB
- en: Working with lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore lists:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithCollections`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithCollections` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then define a function
    to output a collection of `string` values with a title, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a static method named `WorkingWithLists` to illustrate some of the common
    ways of defining and working with lists, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of `Program.cs`, after the namespace imports, call the `WorkingWithLists`
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, define a static method named `WorkingWithDictionaries` to
    illustrate some of the common ways of working with dictionaries, for example,
    looking up word definitions, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the top of `Program.cs`, comment out the previous method call and then call
    the `WorkingWithDictionaries` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore queues:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, define a static method named `WorkingWithQueues` to illustrate
    some of the common ways of working with queues, for example, handling customers
    in a queue for coffee, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of `Program.cs`, comment out the previous method calls and call the
    `WorkingWithQueues` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a static method named `OutputPQ`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `OutputPQ` method is generic. You can specify the two types used
    in the tuples that are passed in as `collection`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a static method named `WorkingWithPriorityQueues`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of `Program.cs`, comment out the previous method calls and call the
    `WorkingWithPriorityQueues` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sorting collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `List<T>` class can be sorted by manually calling its `Sort` method (but remember
    that the indexes of each item will change). Manually sorting a list of `string`
    values or other built-in types will work without extra effort on your part, but
    if you create a collection of your own type, then that type must implement an
    interface named `IComparable`. You learned how to do this in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: A `Stack<T>` or `Queue<T>` collection cannot be sorted because you wouldn't
    usually want that functionality; for example, you would probably never sort a
    queue of guests checking into a hotel. But sometimes, you might want to sort a
    dictionary or a set.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it would be useful to have an automatically sorted collection, that
    is, one that maintains the items in a sorted order as you add and remove them.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple auto-sorting collections to choose from. The differences
    between these sorted collections are often subtle but can have an impact on the
    memory requirements and performance of your application, so it is worth putting
    effort into picking the most appropriate option for your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common auto-sorting collections are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Collection | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedDictionary<TKey, TValue>` | This represents a collection of key/value
    pairs that are sorted by key. |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedList<TKey, TValue>` | This represents a collection of key/value pairs
    that are sorted by key. |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedSet<T>` | This represents a collection of unique objects that are
    maintained in a sorted order. |'
  prefs: []
  type: TYPE_TB
- en: More specialized collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few other collections for special situations.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a compact array of bit values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System.Collections.BitArray` collection manages a compact array of bit
    values, which are represented as Booleans, where `true` indicates that the bit
    is on (value is 1) and `false` indicates the bit is off (value is 0).
  prefs: []
  type: TYPE_NORMAL
- en: Working with efficient lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System.Collections.Generics.LinkedList<T>` collection represents a doubly
    linked list where every item has a reference to its previous and next items. They
    provide better performance compared to `List<T>` for scenarios where you will
    frequently insert and remove items from the middle of the list. In a `LinkedList<T>`
    the items do not have to be rearranged in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Using immutable collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you need to make a collection immutable, meaning that its members
    cannot change; that is, you cannot add or remove them.
  prefs: []
  type: TYPE_NORMAL
- en: If you import the `System.Collections.Immutable` namespace, then any collection
    that implements `IEnumerable<T>` is given six extension methods to convert it
    into an immutable list, dictionary, hash set, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WorkingWithCollections` project, in `Program.cs`, import the `System.Collections.Immutable`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithLists` method, add statements to the end of the method to
    convert the `cities` list into an immutable list and then add a new city to it,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of `Program.cs`, comment the previous method calls and uncomment
    the call to the `WorkingWithLists` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the immutable list of cities does
    not get modified when you call the `Add` method on it; instead, it returns a new
    list with the newly added city, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: To improve performance, many applications store a shared
    copy of commonly accessed objects in a central cache. To safely allow multiple
    threads to work with those objects knowing they won''t change, you should make
    them immutable or use a concurrent collection type that you can read about at
    the following link: [https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent)'
  prefs: []
  type: TYPE_NORMAL
- en: Good practice with collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say you need to create a method to process a collection. For maximum
    flexibility, you could declare the input parameter to be `IEnumerable<T>` and
    make the method generic, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: I could pass an array, a list, a queue, a stack, or anything else that implements
    `IEnumerable<T>` into this method and it will process the items. However, the
    flexibility to pass any collection to this method comes at a performance cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the performance problems with `IEnumerable<T>` is also one of its benefits:
    deferred execution, also known as lazy loading. Types that implement this interface
    do not have to implement deferred execution, but many do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the worst performance problem with `IEnumerable<T>` is that the iteration
    has to allocate an object on the heap. To avoid this memory allocation, you should
    define your method using a concrete type, as shown highlighted in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This will use the `List<T>.Enumerator GetEnumerator()` method that returns a
    `struct` instead of the `IEnumerator<T> GetEnumerator()` method that returns a
    reference type. Your code will be two to three times faster and require less memory.
    As with all recommendations related to performance, you should confirm the benefit
    by running performance tests on your actual code in a product environment. You
    will learn how to do this in *Chapter 12*, *Improving Performance and Scalability
    Using Multitasking*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with spans, indexes, and ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Microsoft's goals with .NET Core 2.1 was to improve performance and resource
    usage. A key .NET feature that enables this is the `Span<T>` type.
  prefs: []
  type: TYPE_NORMAL
- en: Using memory efficiently using spans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When manipulating arrays, you will often create new copies of subsets of existing
    ones so that you can process just the subset. This is not efficient because duplicate
    objects must be created in memory.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to work with a subset of an array, use a **span** because it is
    like a window into the original array. This is more efficient in terms of memory
    usage and improves performance. Spans only work with arrays, not collections,
    because the memory must be contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at spans in more detail, we need to understand some related
    objects: indexes and ranges.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying positions with the Index type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# 8.0 introduced two features for identifying an item's index within an array
    and a range of items using two indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned in the previous topic that objects in a list can be accessed by
    passing an integer into their indexer, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Index` value type is a more formal way of identifying a position, and
    supports counting from the end, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Identifying ranges with the Range type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Range` value type uses `Index` values to indicate the start and end of
    its range, using its constructor, C# syntax, or its static methods, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Extension methods have been added to `string` values (that internally use an
    array of `char`), `int` arrays, and spans to make ranges easier to work with.
    These extension methods accept a range as a parameter and return a `Span<T>`.
    This makes them very memory efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Using indexes, ranges, and spans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore using indexes and ranges to return spans:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithRanges`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithRanges` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, type statements to compare using the `string` type''s `Substring`
    method using ranges to extract parts of someone''s name, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with network resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you will need to work with network resources. The most common types
    in .NET for working with network resources are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Example type(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `Dns`, `Uri`, `Cookie`, `WebClient`, `IPAddress` | These are
    for working with DNS servers, URIs, IP addresses, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `FtpStatusCode`, `FtpWebRequest`, `FtpWebResponse` | These
    are for working with FTP servers. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `HttpStatusCode`, `HttpWebRequest`, `HttpWebResponse` | These
    are for working with HTTP servers; that is, websites and services. Types from
    `System.Net.Http` are easier to use. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Http` | `HttpClient`, `HttpMethod`, `HttpRequestMessage`, `HttpResponseMessage`
    | These are for working with HTTP servers; that is, websites and services. You
    will learn how to use these in *Chapter 16*, *Building and Consuming Web Services*.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Mail` | `Attachment`, `MailAddress`, `MailMessage`, `SmtpClient`
    | These are for working with SMTP servers; that is, sending email messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net .NetworkInformation` | `IPStatus`, `NetworkChange`, `Ping`, `TcpStatistics`
    | These are for working with low-level network protocols. |'
  prefs: []
  type: TYPE_TB
- en: Working with URIs, DNS, and IP addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore some common types for working with network resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithNetworkResources`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithNetworkResources` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for working with the network,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type statements to prompt the user to enter a website address, and then use
    the `Uri` type to break it down into its parts, including the scheme (HTTP, FTP,
    and so on), port number, and host, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For convenience, the code also allows the user to press ENTER to use an example
    URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code, enter a valid website address or press ENTER, and view the result,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to get the IP address for the entered website, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, enter a valid website address or press ENTER, and view the result,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pinging a server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you will add code to ping a web server to check its health:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the namespace to get more information about networks, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to ping the entered website, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code, press ENTER, and view the result, as shown in the following output
    on macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code again but this time enter [http://google.com](http://google.com),
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with reflection and attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reflection** is a programming feature that allows code to understand and
    manipulate itself. An assembly is made up of up to four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly metadata and manifest**: Name, assembly, and file version, referenced
    assemblies, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type metadata**: Information about the types, their members, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IL code**: Implementation of methods, properties, constructors, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded resources** (optional): Images, strings, JavaScript, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The metadata comprises items of information about your code. The metadata is
    generated automatically from your code (for example, information about the types
    and members) or applied to your code using attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes can be applied at multiple levels: to assemblies, to types, and
    to their members, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Attribute-based programming is used a lot in app models like ASP.NET Core to
    enable features like routing, security, and caching.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning of assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Version numbers in .NET are a combination of three numbers, with two optional
    additions. If you follow the rules of semantic versioning, the three numbers denote
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major**: Breaking changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: Non-breaking changes, including new features, and often bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch**: Non-breaking bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: When updating a NuGet package that you already use in a
    project, to be safe you should specify an optional flag to make sure that you
    only upgrade to the highest minor to avoid breaking changes, or to the highest
    patch if you are extra cautious and only want to receive bug fixes, as shown in
    the following commands: `Update-Package Newtonsoft.Json -ToHighestMinor` or `Update-Package
    Newtonsoft.Json -ToHighestPatch`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, a version can include these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerelease**: Unsupported preview releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build number**: Nightly builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: Follow the rules of semantic versioning, as described at
    the following link: [http://semver.org](http://semver.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Reading assembly metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore working with attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithReflection`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithReflection` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for reflection, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to get the console app''s assembly, output its name and location,
    and get all assembly-level attributes and output their types, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that because the full name of an assembly must uniquely identify the assembly,
    it is a combination of the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Name**, for example, `WorkingWithReflection`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**, for example, `1.0.0.0`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Culture**, for example, `neutral`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public key token**, although this can be `null`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know some of the attributes decorating the assembly, we can ask
    for them specifically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add statements to get the `AssemblyInformationalVersionAttribute` and `AssemblyCompanyAttribute`
    classes and then output their values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hmmm, unless you set the version, it defaults to 1.0.0, and unless you set
    the company, it defaults to the name of the assembly. Let''s explicitly set this
    information. The legacy .NET Framework way to set these values was to add attributes
    in the C# source code file, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Roslyn compiler used by .NET sets these attributes automatically, so we
    can't use the old way. Instead, they must be set in the project file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Edit the `WorkingWithReflection.csproj` project file to add elements for version
    and company, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating custom attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define your own attributes by inheriting from the `Attribute` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a class file to your project named `CoderAttribute.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define an attribute class that can decorate either classes or methods with
    two properties to store the name of a coder and the date they last modified some
    code, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, import some namespaces, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of `Program.cs`, add a class with a method, and decorate the
    method with the `Coder` attribute with data about two coders, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, above the `Animal` class, add code to get the types, enumerate
    their members, read any `Coder` attributes on those members, and output the information,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the `<Program>$+<>c` type?
  prefs: []
  type: TYPE_NORMAL
- en: It is a compiler-generated **display class**. `<>` indicates compiler-generated
    and `c` indicates a display class. They are undocumented implementation details
    of the compiler and could change at any time. You can ignore them, so as an optional
    challenge, add statements to your console application to filter compiler-generated
    types by skipping types decorated with `CompilerGeneratedAttribute`.
  prefs: []
  type: TYPE_NORMAL
- en: Doing more with reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is just a taster of what can be achieved with reflection. We only used
    reflection to read metadata from our code. Reflection can also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamically load assemblies that are not currently referenced**: [https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability](https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamically execute code**: [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamically generate new code and assemblies**: [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ImageSharp is a third-party cross-platform 2D graphics library. When .NET Core
    1.0 was in development, there was negative feedback from the community about the
    missing `System.Drawing` namespace for working with 2D images.
  prefs: []
  type: TYPE_NORMAL
- en: The **ImageSharp** project was started to fill that gap for modern .NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: In their official documentation for `System.Drawing`, Microsoft says, "The `System.Drawing`
    namespace is not recommended for new development due to not being supported within
    a Windows or ASP.NET service, and it is not cross-platform. ImageSharp and SkiaSharp
    are recommended as alternatives."
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what can be achieved with ImageSharp:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithImages`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithImages` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `images` folder and download the nine images from the following link:
    [https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories](https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a package reference for `SixLabors.ImageSharp`, as shown in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `WorkingWithImages` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import some namespaces for working with images,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, enter statements to convert all the files in the images folder
    into grayscale thumbnails at one-tenth size, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the filesystem, open the `images` folder and note the much-smaller-in-bytes
    grayscale thumbnails, as shown in *Figure 8.1*:![A picture containing application  Description
    automatically generated](img/B17442_08_01.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.1: Images after processing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ImageSharp also has NuGet packages for programmatically drawing images and
    working with images on the web, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SixLabors.ImageSharp.Drawing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SixLabors.ImageSharp.Web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalizing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internationalization is the process of enabling your code to run correctly
    all over the world. It has two parts: **globalization** and **localization**.'
  prefs: []
  type: TYPE_NORMAL
- en: Globalization is about writing your code to accommodate multiple languages and
    region combinations. The combination of a language and a region is known as a
    culture. It is important for your code to know both the language and region because,
    for example, the date and currency formats are different in Quebec and Paris,
    despite them both using the French language.
  prefs: []
  type: TYPE_NORMAL
- en: There are **International Organization for Standardization** (**ISO**) codes
    for all culture combinations. For example, in the code `da-DK`, `da` indicates
    the Danish language and `DK` indicates the Denmark region, and in the code `fr-CA`,
    `fr` indicates the French language and `CA` indicates the Canada region.
  prefs: []
  type: TYPE_NORMAL
- en: ISO is not an acronym. ISO is a reference to the Greek word *isos* (which means
    equal).
  prefs: []
  type: TYPE_NORMAL
- en: Localization is about customizing the user interface to support a language,
    for example, changing the label of a button to be Close (`en`) or Fermer (`fr`).
    Since localization is more about the language, it doesn't always need to know
    about the region, although ironically enough, standardization (`en-US`) and standardisation
    (`en-GB`) suggest otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and changing the current culture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internationalization is a huge topic on which several thousand-page books have
    been written. In this section, you will get a brief introduction to the basics
    using the `CultureInfo` type in the `System.Globalization` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `Internationalization`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Internationalization` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs`, import the namespace for using globalization types,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add statements to get the current globalization and localization cultures and
    output some information about them, and then prompt the user to enter a new culture
    code and show how that affects the formatting of common values such as dates and
    currency, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run an application, it automatically sets its thread to use the culture
    of the operating system. I am running my code in London, UK, so the thread is
    set to English (United Kingdom).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code prompts the user to enter an alternative ISO code. This allows your
    applications to replace the default culture at runtime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application then uses standard format codes to output the day of the week
    using format code `dddd`; the number of minutes with thousand separators using
    format code `N0`; and the salary with the currency symbol. These adapt automatically,
    based on the thread's culture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and enter `en-GB` for the ISO code and then enter some sample
    data including a date in a format valid for British English, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you enter `en-US` instead of `en-GB`, then you must enter the date using
    month/day/year.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rerun the code and try a different culture, such as Danish in Denmark, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, only the date and salary are globalized into Danish. The rest
    of the text is hardcoded as English. This book does not currently include how
    to translate text from one language to another. If you would like me to include
    that in the next edition, please let me know.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Consider whether your application needs to be internationalized
    and plan for that before you start coding! Write down all the pieces of text in
    the user interface that will need to be localized. Think about all the data that
    will need to be globalized (date formats, number formats, and sorting text behavior).'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the web to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the maximum number of characters that can be stored in a `string` variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why should you use a `SecureString` type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it appropriate to use a `StringBuilder` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `LinkedList<T>` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `SortedDictionary<T>` class rather than a `SortedList<T>`
    class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the ISO culture code for Welsh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between localization, globalization, and internationalization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a regular expression, what does `$` mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a regular expression, how can you represent digits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you *not* use the official standard for email addresses to create
    a regular expression to validate a user's email address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 8.2 – Practice regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter08` solution/workspace, create a console application named `Exercise02`
    that prompts the user to enter a regular expression and then prompts the user
    to enter some input and compare the two for a match until the user presses *Esc*,
    as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 8.3 – Practice writing extension methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Chapter08` solution/workspace, create a class library named `Exercise03`
    that defines extension methods that extend number types such as `BigInteger` and
    `int` with a method named `ToWords` that returns a `string` describing the number;
    for example, `18,000,000` would be eighteen million, and `18,456,002,032,011,000,007`
    would be eighteen quintillion, four hundred and fifty-six quadrillion, two trillion,
    thirty-two billion, eleven million, and seven.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about names for large numbers at the following link: [https://en.wikipedia.org/wiki/Names_of_large_numbers](https://en.wikipedia.org/wiki/Names_of_large_numbers)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored some choices for types to store and manipulate
    numbers, dates and times, and text including regular expressions, and which collections
    to use for storing multiple items; worked with indexes, ranges, and spans; used
    some network resources; reflected on code and attributes; manipulated images using
    a Microsoft-recommended third-party library; and learned how to internationalize
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will manage files and streams, encode and decode text,
    and perform serialization.
  prefs: []
  type: TYPE_NORMAL
