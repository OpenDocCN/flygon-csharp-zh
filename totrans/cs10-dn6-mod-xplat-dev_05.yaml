- en: '05'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Your Own Types with Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about making your own types using **object-oriented programming**
    (**OOP**). You will learn about all the different categories of members that a
    type can have, including fields to store data and methods to perform actions.
    You will use OOP concepts such as aggregation and encapsulation. You will also
    learn about language features such as tuple syntax support, out variables, inferred
    tuple names, and default literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Talking about OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building class libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data with fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and calling methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling access with properties and indexers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talking about OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object in the real world is a thing, such as a car or a person, whereas an
    object in programming often represents something in the real world, such as a
    product or bank account, but this can also be something more abstract.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, we use the `class` (mostly) or `struct` (sometimes) C# keywords to define
    a type of object. You will learn about the difference between classes and structs
    in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*. You can think
    of a type as being a blueprint or template for an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts of OOP are briefly described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** is the combination of the data and actions that are related
    to an object. For example, a `BankAccount` type might have data, such as `Balance`
    and `AccountName`, as well as actions, such as `Deposit` and `Withdraw`. When
    encapsulating, you often want to control what can access those actions and the
    data, for example, restricting how the internal state of an object can be accessed
    or modified from the outside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition** is about what an object is made of. For example, a `Car` is
    composed of different parts, such as four `Wheel` objects, several `Seat` objects,
    and an `Engine`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation** is about what can be combined with an object. For example,
    a `Person` is not part of a `Car` object, but they could sit in the driver''s
    `Seat` and then become the car''s `Driver`—two separate objects that are aggregated
    together to form a new component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance** is about reusing code by having a **subclass** derive from
    a **base** or **superclass**. All functionality in the base class is inherited
    by and becomes available in the **derived** class. For example, the base or super
    `Exception` class has some members that have the same implementation across all
    exceptions, and the sub or derived `SqlException` class inherits those members
    and has extra members only relevant to when a SQL database exception occurs, like
    a property for the database connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction** is about capturing the core idea of an object and ignoring
    the details or specifics. C# has the `abstract` keyword that formalizes this concept.
    If a class is not explicitly **abstract**, then it can be described as being **concrete**.
    Base or superclasses are often abstract, for example, the superclass `Stream`
    is abstract, and its subclasses, like `FileStream` and `MemoryStream`, are concrete.
    Only concrete classes can be used to create objects; abstract classes can only
    be used as the base for other classes because they are missing some implementation.
    Abstraction is a tricky balance. If you make a class more abstract, more classes
    will be able to inherit from it, but at the same time, there will be less functionality
    to share.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism** is about allowing a derived class to override an inherited
    action to provide custom behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building class libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class library assemblies group types together into easily deployable units (DLL
    files). Apart from when you learned about unit testing, you have only created
    console applications or .NET Interactive notebooks to contain your code. To make
    the code that you write reusable across multiple projects, you should put it in
    class library assemblies, just like Microsoft does.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first task is to create a reusable .NET class library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred coding tool to create a new class library, as defined in
    the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter05`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PacktLibrary`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `PacktLibrary.csproj` file, and note that by default class libraries
    target .NET 6 and therefore can only work with other .NET 6-compatible assemblies,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the framework to target .NET Standard 2.0 and remove the entries that
    enable nullable and implicit usings, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and close the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the file named `Class1.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile the project so that other projects can reference it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, enter the following command: `dotnet build`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Build** | **Build PacktLibrary**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: To use the latest C# language and .NET platform features,
    put types in a .NET 6 class library. To support legacy .NET platforms like .NET
    Core, .NET Framework, and Xamarin, put types that you might reuse in a.NET Standard
    2.0 class library.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a class in a namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next task is to define a class that will represent a person:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class file named `Person.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Statically import `System.Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the namespace to `Packt.Shared`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: We''re doing this because it is important to put your classes
    in a logically named namespace. A better namespace name would be domain-specific,
    for example, `System.Numerics` for types related to advanced numbers. In this
    case, the types we will create are `Person`, `BankAccount`, and `WondersOfTheWorld`
    and they do not have a typical domain so we will use the more generic `Packt.Shared`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your class file should now look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the C# keyword `public` is applied before class. This keyword is an
    **access modifier**, and it allows for any other code to access this class.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not explicitly apply the `public` keyword, then it will only be accessible
    within the assembly that defined it. This is because the implicit access modifier
    for a class is `internal`. We need this class to be accessible outside the assembly,
    so we must make sure it is `public`.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying namespace declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To simplify your code if you are targeting .NET 6.0 and therefore using C#
    10 or later, you can end a namespace declaration with a semi-colon and remove
    the braces, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is known as a file-scoped namespace declaration. You can only have one
    file-scoped namespace per file. We will use this in a class library that targets
    .NET 6.0 later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Put each type that you create in its own file so that you
    can use file-scoped namespace declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This type does not yet have any members encapsulated within it. We will create
    some over the following pages. Members can be fields, methods, or specialized
    versions of both. You''ll find a description of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fields** are used to store data. There are also three specialized categories
    of field, as shown in the following bullets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant**: The data never changes. The compiler literally copies the data
    into any code that reads it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-only**: The data cannot change after the class is instantiated, but
    the data can be calculated or loaded from an external source at the time of instantiation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event**: The data references one or more methods that you want to execute
    when something happens, such as clicking on a button or responding to a request
    from some other code. Events will be covered in *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods** are used to execute statements. You saw some examples when you
    learned about functions in *Chapter 4*, *Writing, Debugging, and Testing Functions*.
    There are also four specialized categories of method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor**: The statements execute when you use the `new` keyword to allocate
    memory to instantiate a class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property**: The statements execute when you get or set data. The data is
    commonly stored in a field but could be stored externally or calculated at runtime.
    Properties are the preferred way to encapsulate fields unless the memory address
    of the field needs to be exposed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexer**: The statements execute when you get or set data using "array"
    syntax `[]`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operator**: The statements execute when you use an operator like `+` and
    `/` on operands of your type.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will make an instance of the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing an assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can instantiate a class, we need to reference the assembly that contains
    it from another project. We will use the class in a console app:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new console app to the `Chapter05` workspace/solution
    named `PeopleApp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `PeopleApp` as the active OmniSharp project. When you see the pop-up
    warning message saying that required assets are missing, click **Yes** to add
    them.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit `PeopleApp.csproj` to add a project reference to `PacktLibrary`, as shown
    highlighted in the following markup:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In a terminal, enter a command to compile the `PeopleApp` project and its dependency
    `PacktLibrary` project, as shown in the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the startup project for the solution to the current selection.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Solution Explorer**, select the `PeopleApp` project, navigate to **Project**
    | **Add Project Reference…**, check the box to select the `PacktLibrary` project,
    and then click **OK**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Build** | **Build PeopleApp**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing a namespace to use a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are ready to write statements to work with the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PeopleApp` project/folder, open `Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `Program.cs` file, delete the comment, and add statements
    to import the namespace for our `Person` class and statically import the `Console`
    class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Person` type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Output the instance using a textual description of itself.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `new` keyword allocates memory for the object and initializes any internal
    data. We could use `var` in place of the `Person` class name, but then we would
    need to specify `Person` after the `new` keyword, as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might be wondering, "Why does the `bob` variable have a method named `ToString`?
    The `Person` class is empty!" Don't worry, we're about to find out!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Understanding objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although our `Person` class did not explicitly choose to inherit from a type,
    all types ultimately inherit directly or indirectly from a special type named
    `System.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `ToString` method in the `System.Object` type simply
    outputs the full namespace and type name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the original `Person` class, we could have explicitly told the compiler
    that `Person` inherits from the `System.Object` type, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When class B inherits from class A, we say that A is the base or superclass
    and B is the derived or subclass. In this case, `System.Object` is the base or
    superclass and `Person` is the derived or subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the C# alias keyword `object`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Inheriting from System.Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s make our class explicitly inherit from `object` and then review what
    members all objects have:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify your `Person` class to explicitly inherit from `object`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click inside the `object` keyword and press F12, or right-click on the `object`
    keyword and choose **Go to Definition**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the Microsoft-defined `System.Object` type and its members. This
    is something you don''t need to understand the details of yet, but notice that
    it has a method named `ToString`, as shown in *Figure 5.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17442_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: System.Object class definition'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Assume other programmers know that if inheritance is not
    specified, the class will inherit from `System.Object`.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing data within fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be defining a selection of fields in the class to store
    information about a person.
  prefs: []
  type: TYPE_NORMAL
- en: Defining fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that we have decided that a person is composed of a name and a date
    of birth. We will encapsulate these two values inside a person, and the values
    will be visible outside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Person` class, write statements to declare two public fields for
    storing a person''s name and date of birth, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can use any type for a field, including arrays and collections such as lists
    and dictionaries. These would be used if you needed to store multiple values in
    one named field. In this example, a person only has one name and one date of birth.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part of encapsulation is choosing how visible the members are.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, as we did with the class, we explicitly applied the `public` keyword
    to these fields. If we hadn't, then they would be implicitly `private` to the
    class, which means they are accessible only inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four access modifier keywords, and two combinations of access modifier
    keywords that you can apply to a class member, like a field or method, as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Access Modifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `private` | Member is accessible inside the type only. This is the default.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `internal` | Member is accessible inside the type and any type in the same
    assembly. |'
  prefs: []
  type: TYPE_TB
- en: '| `protected` | Member is accessible inside the type and any type that inherits
    from the type. |'
  prefs: []
  type: TYPE_TB
- en: '| `public` | Member is accessible everywhere. |'
  prefs: []
  type: TYPE_TB
- en: '| `internal``protected` | Member is accessible inside the type, any type in
    the same assembly, and any type that inherits from the type. Equivalent to a fictional
    access modifier named `internal_or_protected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `private``protected` | Member is accessible inside the type and any type
    that inherits from the type and is in the same assembly. Equivalent to a fictional
    access modifier named `internal_and_protected`. This combination is only available
    with C# 7.2 or later. |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice**: Explicitly apply one of the access modifiers to all type
    members, even if you want to use the implicit access modifier for members, which
    is `private`. Additionally, fields should usually be `private` or `protected`,
    and you should then create `public` properties to get or set the field values.
    This is because it controls access. You will do this later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting and outputting field values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we will use those fields in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs`, make sure the `System` namespace is imported. We
    need to do this to use the `DateTime` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After instantiating `bob`, add statements to set his name and date of birth,
    and then output those fields formatted nicely, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could have used string interpolation too, but for long strings it will wrap
    over multiple lines, which can be harder to read in a printed book. In the code
    examples in this book, remember that `{0}` is a placeholder for `arg0`, and so
    on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your output may look different based on your locale, that is, language and culture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The format code for `arg1` is made of several parts. `dddd` means the name of
    the day of the week. `d` means the number of the day of the month. `MMMM` means
    the name of the month. Lowercase `m` is used for minutes in time values. `yyyy`
    means the full number of the year. `yy` would mean the two-digit year.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also initialize fields using a shorthand **object initializer** syntax
    using curly braces. Let's see how.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add statements underneath the existing code to create another new person named
    Alice. Note the different format code for the date of birth when writing her to
    the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Storing a value using an enum type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, a value needs to be one of a limited set of options. For example,
    there are seven ancient wonders of the world, and a person may have one favorite.
    At other times, a value needs to be a combination of a limited set of options.
    For example, a person may have a bucket list of ancient world wonders they want
    to visit. We are able to store this data by defining an `enum` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `enum` type is a very efficient way of storing one or more choices because,
    internally, it uses integer values in combination with a lookup table of `string`
    descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new file to the `PacktLibrary` project named `WondersOfTheAncientWorld.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `WondersOfTheAncientWorld.cs` file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: If you use are writing code in a .NET Interactive notebook,
    then the code cell containing the `enum` must be above the code cell defining
    the `Person` class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Person` class, add the following statement to your list of fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `enum` value is internally stored as an `int` for efficiency. The `int`
    values are automatically assigned starting at `0`, so the third world wonder in
    our `enum` has a value of `2`. You can assign `int` values that are not listed
    in the `enum`. They will output as the `int` value instead of a name since a match
    will not be found.
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple values using an enum type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the bucket list, we could create an array or collection of instances of
    the `enum`, and collections will be explained later in this chapter, but there
    is a better way. We can combine multiple choices into a single value using `enum`
    **flags**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `enum` by decorating it with the `[System.Flags]` attribute, and
    explicitly set a `byte` value for each wonder that represents different bit columns,
    as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are assigning explicit values for each choice that would not overlap when
    looking at the bits stored in memory. We should also decorate the `enum` type
    with the `System.Flags` attribute so that when the value is returned it can automatically
    match with multiple values as a comma-separated `string` instead of returning
    an `int` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Normally, an `enum` type uses an `int` variable internally, but since we don't
    need values that big, we can reduce memory requirements by 75%, that is, 1 byte
    per value instead of 4 bytes, by telling it to use a `byte` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we want to indicate that our bucket list includes the *Hanging Gardens of
    Babylon* and the *Mausoleum at Halicarnassus* ancient world wonders, then we would
    want the `16` and `2` bits set to `1`. In other words, we would store the value
    `18`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'In the `Person` class, add the following statement to your list of fields,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to set the bucket list using the `|` operator
    (bitwise logical OR) to combine the enum values. We could also set the value using
    the number 18 cast into the enum type, as shown in the comment, but we shouldn''t
    because that would make the code harder to understand, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Use the `enum` values to store combinations of discrete
    options. Derive an `enum` type from `byte` if there are up to eight options, from
    `ushort` if there are up to 16 options, from `uint` if there are up to 32 options,
    and from `ulong` if there are up to 64 options.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple values using collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now add a field to store a person''s children. This is an example of
    aggregation because children are instances of a class that is related to the current
    person but are not part of the person itself. We will use a generic `List<T>`
    collection type that can store an ordered collection of any type. You will learn
    more about collections in *Chapter 8*, *Working with Common .NET Types*. For now,
    just follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, import the `System.Collections.Generic` namespace, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a new field in the `Person` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`List<Person>` is read aloud as "list of Person," for example, "the type of
    the property named `Children` is a list of `Person` instances." We explicitly
    changed the class library to target .NET Standard 2.0 (that uses the C# 7 compiler),
    so we cannot use target-typed new to initialize the `Children` field. If we had
    left it targeting .NET 6.0, then we could use target-typed new, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We must ensure the collection is initialized to a new instance of a list of
    `Person` before we can add items to it, otherwise, the field will be `null` and
    it will throw runtime exceptions when we try to use any of its members like `Add`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generic collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The angle brackets in the `List<T>` type is a feature of C# called **generics**
    that was introduced in 2005 with C# 2.0\. It's a fancy term for making a collection
    **strongly typed**, that is, the compiler knows specifically what type of object
    can be stored in the collection. Generics improve the performance and correctness
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strongly typed** has a different meaning to **statically typed**. The old
    `System.Collection` types are statically typed to contain weakly typed `System.Object`
    items. The newer `System.Collection.Generic` types are statically typed to contain
    strongly typed `<T>` instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Ironically, the term *generics* means we can use a more specific static type!
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to add two children for `Bob` and then show
    how many children he has and what their names are, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We could also use a `foreach` statement to enumerate over the collection. As
    an extra challenge, change the `for` statement to output the same information
    using `foreach`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Making a field static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fields that we have created so far have all been **instance** members, meaning
    that a different value of each field exists for each instance of the class that
    is created. The `alice` and `bob` variables have different `Name` values.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you want to define a field that only has one value that is shared
    across all instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are called **static** *members* because fields are not the only members
    that can be static. Let''s see what can be achieved using `static` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `BankAccount.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class to give it three fields, two instance fields and one static
    field, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each instance of `BankAccount` will have its own `AccountName` and `Balance`
    values, but all instances will share a single `InterestRate` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to set the shared interest rate and then create
    two instances of the `BankAccount` type, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`:C` is a format code that tells .NET to use the currency format for the numbers.
    In *Chapter 8*, *Working with Common .NET Types*, you will learn how to control
    the culture that determines the currency symbol. For now, it will use the default
    for your operating system installation. I live in London, UK, hence my output
    shows British Pounds (£).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the additional output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fields are not the only members that can be static. Constructors, methods, properties,
    and other members can also be static.
  prefs: []
  type: TYPE_NORMAL
- en: Making a field constant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the value of a field will never ever change, you can use the `const` keyword
    and assign a literal value at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the value of a constant field, you must write the name of the class,
    not the name of an instance of the class. In `Program.cs`, add a statement to
    write Bob''s name and species to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Examples of `const` fields in Microsoft types include `System.Int32.MaxValue`
    and `System.Math.PI` because neither value will ever change, as you can see in
    *Figure 5.2*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17442_05_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 5.2: Examples of constants'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Constants are not always the best choice for two important
    reasons: the value must be known at compile time, and it must be expressible as
    a literal `string`, `Boolean`, or number value. Every reference to the `const`
    field is replaced with the literal value at compile time, which will, therefore,
    not be reflected if the value changes in a future version and you do not recompile
    any assemblies that reference it to get the new value.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a field read-only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often a better choice for fields that should not change is to mark them as
    read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add a statement to declare an instance read-only field to store
    a person''s home planet, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement to write Bob''s name and home planet to the
    console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Use read-only fields over constant fields for two important
    reasons: the value can be calculated or loaded at runtime and can be expressed
    using any executable statement. So, a read-only field can be set using a constructor
    or a field assignment. Every reference to the field is a live reference, so any
    future changes will be correctly reflected by the calling code.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also declare `static` `readonly` fields whose values will be shared
    across all instances of the type.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing fields with constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fields often need to be initialized at runtime. You do this in a constructor
    that will be called when you make an instance of the class using the `new` keyword.
    Constructors execute before any fields are set by the code that is using the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements after the existing read-only `HomePlanet` field
    to define a second read-only field and then set the `Name` and `Instantiated`
    fields in a constructor, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to instantiate a new person and then output
    its initial field values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining multiple constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can have multiple constructors in a type. This is especially useful to
    encourage developers to set initial values for fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a second constructor that allows a
    developer to set initial values for the person''s name and home planet, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create another person using the constructor
    with two parameters, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Constructors are a special category of method. Let's look at methods in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and calling methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Methods** are members of a type that execute a block of statements. They
    are functions that belong to a type.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning values from methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods can return a single value or return nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: A method that performs some actions but does not return a value indicates this
    with the `void` type before the name of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method that performs some actions and returns a value indicates this with
    the type of the return value before the name of the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the next task, you will create two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WriteToConsole`: This will perform an action (writing some text to the console),
    but it will return nothing from the method, indicated by the `void` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetOrigin`: This will return a text value, indicated by the `string` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define the two methods that I described earlier,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the two methods, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Combining multiple returned values using tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each method can only return a single value that has a single type. That type
    could be a simple type, such as `string` in the previous example, a complex type,
    such as `Person`, or a collection type, such as `List<Person>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to define a method named `GetTheData` that needs to return
    both a `string` value and an `int` value. We could define a new class named `TextAndNumber`
    with a `string` field and an `int` field, and return an instance of that complex
    type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: But defining a class just to combine two values together is unnecessary, because
    in modern versions of C# we can use **tuples**. Tuples are an efficient way to
    combine two or more values into a single unit. I pronounce them as tuh-ples but
    I have heard other developers pronounce them as too-ples. To-may-toe, to-mah-toe,
    po-tay-toe, po-tah-toe, I guess.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples have been a part of some languages such as F# since their first version,
    but .NET only added support for them with .NET 4.0 in 2010 using the `System.Tuple`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Language support for tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It was only with C# 7.0 in 2017 that C# added language syntax support for tuples
    using the parentheses characters `()` and at the same time, .NET added a new `System.ValueTuple`
    type that is more efficient in some common scenarios than the old .NET 4.0 `System.Tuple`
    type. The C# tuple syntax uses the more efficient one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method that returns a tuple that
    combines a `string` and `int`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the `GetFruit` method and then output
    the tuple''s fields automatically named `Item1` and `Item2`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Naming the fields of a tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To access the fields of a tuple, the default names are `Item1`, `Item2`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly specify the field names:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method that returns a tuple with
    named fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the method and output the tuple''s
    named fields, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inferring tuple names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are constructing a tuple from another object, you can use a feature introduced
    in C# 7.1 called **tuple name inference**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create two tuples, made of a `string` and `int` value each,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In C# 7.0, both things would use the `Item1` and `Item2` naming schemes. In
    C# 7.1 and later, `thing2` can infer the names `Name` and `Count`.
  prefs: []
  type: TYPE_NORMAL
- en: Deconstructing tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also deconstruct tuples into separate variables. The deconstructing
    declaration has the same syntax as named field tuples, but without a named variable
    for the tuple, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This has the effect of splitting the tuple into its parts and assigning those
    parts to new variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to deconstruct the tuple returned from the
    `GetFruit` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deconstructing types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tuples are not the only type that can be deconstructed. Any type can have special
    methods named `Deconstruct` that break down the object into parts. Let''s implement
    some for the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add two `Deconstruct` methods with `out` parameters defined
    for the parts we want to deconstruct into, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to deconstruct `bob`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining and passing parameters to methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods can have parameters passed to them to change their behavior. Parameters
    are defined a bit like variable declarations but inside the parentheses of the
    method, as you saw earlier in this chapter with constructors. Let''s see more
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define two methods, the first without parameters
    and the second with one parameter, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to call the two methods and write the return
    value to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When typing a statement that calls a method, IntelliSense shows a tooltip with
    the name and type of any parameters, and the return type of the method, as shown
    in *Figure 5.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, website  Description automatically generated](img/B17442_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: An IntelliSense tooltip for a method with no overloads'
  prefs: []
  type: TYPE_NORMAL
- en: Overloading methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of having two different method names, we could give both methods the
    same name. This is allowed because the methods each have a different signature.
  prefs: []
  type: TYPE_NORMAL
- en: A **method signature** is a list of parameter types that can be passed when
    calling the method. Overloaded methods cannot differ only in the return type.
  prefs: []
  type: TYPE_NORMAL
- en: In `Person.cs`, change the name of the `SayHelloTo` method to `SayHello`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs`, change the method call to use the `SayHello` method, and note
    that the quick info for the method tells you that it has one additional overload,
    1/2, as well as 2/2, as shown in *Figure 5.4*:![Graphical user interface  Description
    automatically generated with medium confidence](img/B17442_05_04.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.4: An IntelliSense tooltip for an overloaded method'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Use overloaded methods to simplify your class by making
    it appear to have fewer methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing optional and named parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to simplify methods is to make parameters optional. You make a parameter
    optional by assigning a default value inside the method parameter list. Optional
    parameters must always come last in the list of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a method with three optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define the method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement to call the method and write its return value
    to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Watch IntelliSense appear as you type the code. You will see a tooltip, showing
    the three optional parameters with their default values, as shown in *Figure 5.5*:![Graphical
    user interface, text, application, chat or text message  Description automatically
    generated](img/B17442_05_05.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 5.5: IntelliSense showing optional parameters as you type code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and see the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default values for the `command` and `number` parameters have been replaced,
    but the default for `active` is still `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Naming parameter values when calling methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Optional parameters are often combined with naming parameters when you call
    the method, because naming a parameter allows the values to be passed in a different
    order than how they were declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter but using named parameters,
    so that the order they are passed through can be swapped around, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can even use named parameters to skip over optional parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter using positional order, skip the `number` parameter, and use the named
    `active` parameter, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Controlling how parameters are passed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a parameter is passed into a method, it can be passed in one of three
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By **value** (this is the default): Think of these as being *in-only*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By **reference** as a `ref` parameter: Think of these as being *in-and-out*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an `out` parameter: Think of these as being *out-only*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see some examples of passing parameters in and out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method with three parameters, one
    `in` parameter, one `ref` parameter, and one `out` parameter, as shown in the
    following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to declare some `int` variables and pass them
    into the method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When passing a variable as a parameter by default, its current value gets passed,
    not the variable itself. Therefore, `x` has a copy of the value of the `a` variable.
    The `a` variable retains its original value of `10`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When passing a variable as a `ref` parameter, a reference to the variable gets
    passed into the method. Therefore, `y` is a reference to `b`. The `b` variable
    gets incremented when the `y` parameter gets incremented.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When passing a variable as an `out` parameter, a reference to the variable gets
    passed into the method. Therefore, `z` is a reference to `c`. The value of the
    `c` variable gets replaced by whatever code executes inside the method. We could
    simplify the code in the `Main` method by not assigning the value `30` to the
    `c` variable since it will always be replaced anyway.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified out parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C# 7.0 and later, we can simplify code that uses the out variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to declare some more variables including an
    `out` parameter named `f` declared inline, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Understanding ref returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C# 7.0 or later, the `ref` keyword is not just for passing parameters into
    a method; it can also be applied to the `return` value. This allows an external
    variable to reference an internal variable and modify its value after the method
    call. This might be useful in advanced scenarios, for example, passing around
    placeholders into big data structures, but it's beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting classes using partial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on large projects with multiple team members, or when working with
    especially large and complex class implementations, it is useful to be able to
    split the definition of a class across multiple files. You do this using the `partial`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we want to add statements to the `Person` class that are automatically
    generated by a tool like an object-relational mapper that reads schema information
    from a database. If the class is defined as `partial`, then we can split the class
    into an autogenerated code file and a manually edited code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code that simulates this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add the `partial` keyword, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `PacktLibrary` project/folder, add a new class file named `PersonAutoGen.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to the new file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The rest of the code we write for this chapter will be written in the `PersonAutoGen.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling access with properties and indexers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, you created a method named `GetOrigin` that returned a `string` containing
    the name and origin of the person. Languages such as Java do this a lot. C# has
    a better way: properties.'
  prefs: []
  type: TYPE_NORMAL
- en: A property is simply a method (or a pair of methods) that acts and looks like
    a field when you want to get or set a value, thereby simplifying the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Defining read-only properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `readonly` property only has a `get` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, in the `Person` class, add statements to define three
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first property will perform the same role as the `GetOrigin` method using
    the property syntax that works with all versions of C# (although, it uses the
    string interpolation syntax from C# 6 and later).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The second property will return a greeting message using the lambda expression
    body `=>` syntax from C# 6 and later.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The third property will calculate the person's age.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: This isn''t the best way to calculate someone''s age, but
    we aren''t learning how to calculate an age from a date of birth. If you need
    to do that properly, read the discussion at the following link: [https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add the statements to get the properties, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output shows 49 because I ran the console application on August 15, 2021
    when Sam was 49 years old.
  prefs: []
  type: TYPE_NORMAL
- en: Defining settable properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a settable property, you must use the older syntax and provide a
    pair of methods—not just a `get` part, but also a `set` part:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, add statements to define a `string` property that has
    both a `get` and `set` method (also known as a getter and setter), as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although you have not manually created a field to store the person's favorite
    ice cream, it is there, automatically created by the compiler for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes, you need more control over what happens when a property is set. In
    this scenario, you must use a more detailed syntax and manually create a `private`
    field to store the value for the property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, add statements to define a `string` field and `string`
    property that has both a `get` and `set`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Avoid adding too much code to your getters and setters.
    This could indicate a problem with your design. Consider adding private methods
    that you then call in setters and getters to simplify your implementations.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to set Sam''s favorite ice cream and color,
    and then write them out, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try to set the color to any value other than red, green, or blue, then
    the code will throw an exception. The calling code could then use a `try` statement
    to display the error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Good Practice**: Use properties instead of fields when you want to validate
    what value can be stored when you want to data bind in XAML, which we will cover
    in *Chapter 19*, *Building Mobile and Desktop Apps Using .NET MAUI*, and when
    you want to read and write to a field without using a method pair like `GetAge`
    and `SetAge`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Requiring properties to be set during instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# 10 introduces the `required` modifier. If you use it on a property, the
    compiler will ensure that you set the property to a value when you instantiate
    it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If you attempt to instantiate a `Book` without setting the `Isbn` property
    you will see a compiler error, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `required` keyword might not make it into the final release version of .NET
    6 so treat this section as theoretical.
  prefs: []
  type: TYPE_NORMAL
- en: Defining indexers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexers allow the calling code to use the array syntax to access a property.
    For example, the `string` type defines an **indexer** so that the calling code
    can access individual characters in the `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define an indexer to simplify access to the children of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PersonAutoGen.cs`, add statements to define an indexer to get and set a
    child using the index of the child, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can overload indexers so that different types can be used for their parameters.
    For example, as well as passing an `int` value, you could also pass a `string`
    value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to add two children to `Sam`, and then access
    the first and second child using the longer `Children` field and the shorter indexer
    syntax, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pattern matching with objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to basic pattern matching. In this section, we will explore
    pattern matching in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and referencing a .NET 6 class library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The enhanced pattern matching features are only available in modern .NET class
    libraries that support C# 9 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new class library named `PacktLibraryModern`
    to the workspace/solution named `Chapter05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `PeopleApp` project, add a reference to the `PacktLibraryModern` class
    library, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the `PeopleApp` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining flight passengers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will define some classes that represent various types of
    passengers on a flight and then we will use a switch expression with pattern matching
    to determine the cost of their flight.
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryModern` project/folder, rename the file `Class1.cs` to `FlightPatterns.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `FlightPatterns.cs`, add statements to define three types of passengers
    with different properties, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to define an object array containing five passengers
    of various types and property values, and then enumerate them, outputting the
    cost of their flight, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While reviewing the preceding code, note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To pattern match on the properties of an object, you must name a local variable
    that can then be used in an expression like `p`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To pattern match on a type only, you can use `_` to discard the local variable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The switch expression also uses `_` to represent its default branch.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enhancements to pattern matching in C# 9 or later
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous examples worked with C# 8\. Now we will look at some enhancements
    in C# 9 and later. First, you no longer need to use the underscore to discard
    when doing type matching:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the C# 8 syntax and add C# 9 and later syntax
    to modify the branches for first-class passengers to use a nested switch expression
    and the new support for conditionals like `>`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the code to view the results, and note they are the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You could also use the relational pattern in combination with the property
    pattern to avoid the nested switch expression, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Working with records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the new records language feature of C# 9 and later, let
    us see some other related new features.
  prefs: []
  type: TYPE_NORMAL
- en: Init-only properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have used object initialization syntax to instantiate objects and set initial
    properties throughout this chapter. Those properties can also be changed after
    instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you want to treat properties like `readonly` fields so they can be
    set during instantiation but not after. The new `init` keyword enables this. It
    can be used in place of the `set` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibraryModern` project/folder, add a new file named `Records.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Records.cs`, define an immutable person class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to instantiate a new immutable person and then
    try to change one of its properties, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile the console app and note the compile error, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comment out the attempt to set the `FirstName` property after instantiation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Init-only properties provide some immutability to C#. You can take the concept
    further by using **records**. These are defined by using the `record` keyword
    instead of the `class` keyword. That can make the whole object immutable, and
    it acts like a value when compared. We will discuss equality and comparisons of
    classes, records, and value types in more detail in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Records should not have any state (properties and fields) that changes after
    instantiation. Instead, the idea is that you create new records from existing
    ones with any changed state. This is called non-destructive mutation. To do this,
    C# 9 introduced the `with` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Records.cs`, add a record named `ImmutableVehicle`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to create a `car` and then a mutated copy of
    it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code to view the results, and note the change to the car color in the
    mutated copy, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Positional data members in records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The syntax for defining a record can be greatly simplified using positional
    data members.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying data members in records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of using object initialization syntax with curly braces, sometimes
    you might prefer to provide a constructor with positional parameters as you saw
    earlier in this chapter. You can also combine this with a deconstructor for splitting
    the object into individual parts, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties, constructor, and deconstructor can be generated for you:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Records.cs`, add statements to define another record using simplified syntax
    known as positional records, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, add statements to construct and deconstruct immutable animals,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see records again when we look at C# 10 support for creating `struct`
    records in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the six combinations of access modifier keywords and what do they do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `static`, `const`, and `readonly` keywords
    when applied to a type member?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a constructor do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you apply the `[Flags]` attribute to an `enum` type when you want
    to store combined values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `partial` keyword useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a tuple?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `record` keyword do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does overloading mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a field and a property?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make a method parameter optional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 5.2 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about making your own types using OOP. You learned
    about some of the different categories of members that a type can have, including
    fields to store data and methods to perform actions, and you used OOP concepts,
    such as aggregation and encapsulation. You saw examples of how to use modern C#
    features like relational and property pattern matching enhancements, init-only
    properties, and records.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will take these concepts further by defining delegates
    and events, implementing interfaces, and inheriting from existing classes.
  prefs: []
  type: TYPE_NORMAL
