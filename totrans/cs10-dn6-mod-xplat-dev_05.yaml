- en: '05'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '05'
- en: Building Your Own Types with Object-Oriented Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面向对象编程构建自己的类型
- en: This chapter is about making your own types using **object-oriented programming**
    (**OOP**). You will learn about all the different categories of members that a
    type can have, including fields to store data and methods to perform actions.
    You will use OOP concepts such as aggregation and encapsulation. You will also
    learn about language features such as tuple syntax support, out variables, inferred
    tuple names, and default literals.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于使用**面向对象编程**（**OOP**）创建自己的类型。你将了解类型可以拥有的所有不同类别的成员，包括存储数据的字段和执行操作的方法。你将使用OOP概念，如聚合和封装。你还将了解语言特性，如元组语法支持、输出变量、推断元组名称和默认文字。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Talking about OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谈论OOP
- en: Building class libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建类库
- en: Storing data with fields
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字段存储数据
- en: Writing and calling methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和调用方法
- en: Controlling access with properties and indexers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和索引器控制访问
- en: Pattern matching with objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象进行模式匹配
- en: Working with records
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录
- en: Talking about OOP
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谈论OOP
- en: An object in the real world is a thing, such as a car or a person, whereas an
    object in programming often represents something in the real world, such as a
    product or bank account, but this can also be something more abstract.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的对象是某个事物，比如汽车或人，而在编程中，对象通常代表现实世界中的某个事物，比如产品或银行账户，但也可能是更抽象的东西。
- en: In C#, we use the `class` (mostly) or `struct` (sometimes) C# keywords to define
    a type of object. You will learn about the difference between classes and structs
    in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*. You can think
    of a type as being a blueprint or template for an object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们使用`class`（大多数情况下）或`struct`（有时）C#关键字来定义对象类型。你将在*第6章*，*实现接口和继承类*中了解类和结构之间的区别。你可以将类型视为对象的蓝图或模板。
- en: 'The concepts of OOP are briefly described here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OOP的概念简要描述如下：
- en: '**Encapsulation** is the combination of the data and actions that are related
    to an object. For example, a `BankAccount` type might have data, such as `Balance`
    and `AccountName`, as well as actions, such as `Deposit` and `Withdraw`. When
    encapsulating, you often want to control what can access those actions and the
    data, for example, restricting how the internal state of an object can be accessed
    or modified from the outside.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**是与对象相关的数据和操作的组合。例如，`BankAccount`类型可能具有数据，如`Balance`和`AccountName`，以及操作，如`Deposit`和`Withdraw`。在封装时，你通常希望控制可以访问这些操作和数据的内容，例如，限制从外部访问或修改对象的内部状态。'
- en: '**Composition** is about what an object is made of. For example, a `Car` is
    composed of different parts, such as four `Wheel` objects, several `Seat` objects,
    and an `Engine`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**是关于对象由什么构成的。例如，`Car`由不同的部分组成，例如四个`Wheel`对象，几个`Seat`对象和一个`Engine`。'
- en: '**Aggregation** is about what can be combined with an object. For example,
    a `Person` is not part of a `Car` object, but they could sit in the driver''s
    `Seat` and then become the car''s `Driver`—two separate objects that are aggregated
    together to form a new component.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**是关于可以与对象结合的内容。例如，`Person`不是`Car`对象的一部分，但他们可以坐在驾驶员的`Seat`上，然后成为汽车的`Driver`——两个独立的对象聚合在一起形成一个新的组件。'
- en: '**Inheritance** is about reusing code by having a **subclass** derive from
    a **base** or **superclass**. All functionality in the base class is inherited
    by and becomes available in the **derived** class. For example, the base or super
    `Exception` class has some members that have the same implementation across all
    exceptions, and the sub or derived `SqlException` class inherits those members
    and has extra members only relevant to when a SQL database exception occurs, like
    a property for the database connection.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**是通过让**子类**从**基类**或**超类**派生来重用代码。基类中的所有功能都被继承并可在**派生**类中使用。例如，基类或超类`Exception`具有一些成员，这些成员在所有异常中具有相同的实现，而子类或派生类`SqlException`继承了这些成员，并且具有仅与SQL数据库异常发生时相关的额外成员，例如数据库连接的属性。'
- en: '**Abstraction** is about capturing the core idea of an object and ignoring
    the details or specifics. C# has the `abstract` keyword that formalizes this concept.
    If a class is not explicitly **abstract**, then it can be described as being **concrete**.
    Base or superclasses are often abstract, for example, the superclass `Stream`
    is abstract, and its subclasses, like `FileStream` and `MemoryStream`, are concrete.
    Only concrete classes can be used to create objects; abstract classes can only
    be used as the base for other classes because they are missing some implementation.
    Abstraction is a tricky balance. If you make a class more abstract, more classes
    will be able to inherit from it, but at the same time, there will be less functionality
    to share.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**是捕捉对象核心思想并忽略细节或具体内容的概念。C#有`abstract`关键字正式化这一概念。如果一个类没有明确地**抽象**，那么它可以被描述为**具体**的。基类或超类通常是抽象的，例如，超类`Stream`是抽象的，而它的子类，如`FileStream`和`MemoryStream`，是具体的。只有具体类可以用来创建对象；抽象类只能用作其他类的基类，因为它们缺少一些实现。抽象是一个棘手的平衡。如果你使一个类更抽象，更多的类将能够继承自它，但同时，可共享的功能将更少。'
- en: '**Polymorphism** is about allowing a derived class to override an inherited
    action to provide custom behavior.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**是指允许派生类覆盖继承的操作以提供自定义行为。'
- en: Building class libraries
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建类库
- en: Class library assemblies group types together into easily deployable units (DLL
    files). Apart from when you learned about unit testing, you have only created
    console applications or .NET Interactive notebooks to contain your code. To make
    the code that you write reusable across multiple projects, you should put it in
    class library assemblies, just like Microsoft does.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类库程序集将类型组合成易于部署的单元（DLL文件）。除了学习单元测试时，你只创建了控制台应用程序或.NET Interactive笔记本以包含你的代码。为了使你编写的代码可跨多个项目重用，你应该将其放入类库程序集中，就像Microsoft所做的那样。
- en: Creating a class library
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类库
- en: 'The first task is to create a reusable .NET class library:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是创建一个可重用的.NET类库：
- en: 'Use your preferred coding tool to create a new class library, as defined in
    the following list:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编码工具创建一个新的类库，如下列表所定义：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Workspace/solution file and folder: `Chapter05`'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter05`
- en: 'Project file and folder: `PacktLibrary`'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PacktLibrary`
- en: 'Open the `PacktLibrary.csproj` file, and note that by default class libraries
    target .NET 6 and therefore can only work with other .NET 6-compatible assemblies,
    as shown in the following markup:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PacktLibrary.csproj`文件，并注意默认情况下类库面向.NET 6，因此只能与其他.NET 6兼容的程序集一起工作，如下面的标记所示：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify the framework to target .NET Standard 2.0 and remove the entries that
    enable nullable and implicit usings, as shown highlighted in the following markup:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将框架修改为目标.NET Standard 2.0，并删除启用可空引用类型和隐式using的条目，如下面的标记中突出显示的那样：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save and close the file.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭文件。
- en: Delete the file named `Class1.cs`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除名为`Class1.cs`的文件。
- en: 'Compile the project so that other projects can reference it later:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译项目以便其他项目稍后可以引用它：
- en: 'In Visual Studio Code, enter the following command: `dotnet build`.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，输入以下命令：`dotnet build`。
- en: In Visual Studio, navigate to **Build** | **Build PacktLibrary**.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航到**生成** | **生成PacktLibrary**。
- en: '**Good Practice**: To use the latest C# language and .NET platform features,
    put types in a .NET 6 class library. To support legacy .NET platforms like .NET
    Core, .NET Framework, and Xamarin, put types that you might reuse in a.NET Standard
    2.0 class library.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：为了使用最新的C#语言和.NET平台特性，将类型放入.NET 6类库中。为了支持如.NET Core、.NET Framework和Xamarin等遗留.NET平台，将可能重用的类型放入.NET
    Standard 2.0类库中。'
- en: Defining a class in a namespace
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在命名空间中定义一个类
- en: 'The next task is to define a class that will represent a person:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务是定义一个代表人的类：
- en: Add a new class file named `Person.cs`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Person.cs`的新类文件。
- en: Statically import `System.Console`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态导入`System.Console`。
- en: Set the namespace to `Packt.Shared`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命名空间设置为`Packt.Shared`。
- en: '**Good Practice**: We''re doing this because it is important to put your classes
    in a logically named namespace. A better namespace name would be domain-specific,
    for example, `System.Numerics` for types related to advanced numbers. In this
    case, the types we will create are `Person`, `BankAccount`, and `WondersOfTheWorld`
    and they do not have a typical domain so we will use the more generic `Packt.Shared`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：我们这样做是因为将你的类放在逻辑命名的命名空间中很重要。更好的命名空间名称应该是特定领域的，例如，`System.Numerics`用于与高级数字相关的类型。在这种情况下，我们将创建的类型是`Person`，`BankAccount`和`WondersOfTheWorld`，它们没有典型的领域，因此我们将使用更通用的`Packt.Shared`。'
- en: 'Your class file should now look like the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的类文件现在应该看起来像以下代码：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the C# keyword `public` is applied before class. This keyword is an
    **access modifier**, and it allows for any other code to access this class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C#关键字`public`在类之前应用。这个关键字是**访问修饰符**，它允许任何其他代码访问这个类。
- en: If you do not explicitly apply the `public` keyword, then it will only be accessible
    within the assembly that defined it. This is because the implicit access modifier
    for a class is `internal`. We need this class to be accessible outside the assembly,
    so we must make sure it is `public`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有明确应用`public`关键字，那么它将只能在定义它的程序集中访问。这是因为类的默认访问修饰符是`internal`。我们需要这个类在程序集外部可访问，因此必须确保它是`public`。
- en: Simplifying namespace declarations
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化命名空间声明
- en: 'To simplify your code if you are targeting .NET 6.0 and therefore using C#
    10 or later, you can end a namespace declaration with a semi-colon and remove
    the braces, as shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你针对的是.NET 6.0，因此使用C# 10或更高版本，你可以用分号结束命名空间声明并删除大括号，如下所示：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is known as a file-scoped namespace declaration. You can only have one
    file-scoped namespace per file. We will use this in a class library that targets
    .NET 6.0 later in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为文件范围的命名空间声明。每个文件只能有一个文件范围的命名空间。我们将在本章后面针对.NET 6.0的类库中使用这个。
- en: '**Good Practice**: Put each type that you create in its own file so that you
    can use file-scoped namespace declarations.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：将你创建的每个类型放在其自己的文件中，以便你可以使用文件范围的命名空间声明。'
- en: Understanding members
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解成员
- en: 'This type does not yet have any members encapsulated within it. We will create
    some over the following pages. Members can be fields, methods, or specialized
    versions of both. You''ll find a description of them here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型还没有任何成员封装在其中。我们将在接下来的页面上创建一些。成员可以是字段、方法或两者的特殊版本。你将在这里找到它们的描述：
- en: '**Fields** are used to store data. There are also three specialized categories
    of field, as shown in the following bullets:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段**用于存储数据。还有三种特殊类别的字段，如下所示：'
- en: '**Constant**: The data never changes. The compiler literally copies the data
    into any code that reads it.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：数据永不改变。编译器会将数据直接复制到任何读取它的代码中。'
- en: '**Read-only**: The data cannot change after the class is instantiated, but
    the data can be calculated or loaded from an external source at the time of instantiation.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只读**：类实例化后数据不能改变，但数据可以在实例化时计算或从外部源加载。'
- en: '**Event**: The data references one or more methods that you want to execute
    when something happens, such as clicking on a button or responding to a request
    from some other code. Events will be covered in *Chapter 6*, *Implementing Interfaces
    and Inheriting Classes*.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：数据引用一个或多个你希望在某些事情发生时执行的方法，例如点击按钮或响应来自其他代码的请求。事件将在*第6章*，*实现接口和继承类*中介绍。'
- en: '**Methods** are used to execute statements. You saw some examples when you
    learned about functions in *Chapter 4*, *Writing, Debugging, and Testing Functions*.
    There are also four specialized categories of method:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**用于执行语句。你在学习*第4章*，*编写、调试和测试函数*中的函数时看到了一些例子。还有四种特殊类别的方法：'
- en: '**Constructor**: The statements execute when you use the `new` keyword to allocate
    memory to instantiate a class.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：当你使用`new`关键字分配内存以实例化类时执行语句。'
- en: '**Property**: The statements execute when you get or set data. The data is
    commonly stored in a field but could be stored externally or calculated at runtime.
    Properties are the preferred way to encapsulate fields unless the memory address
    of the field needs to be exposed.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：当你获取或设置数据时执行语句。数据通常存储在字段中，但也可能存储在外部或在运行时计算。属性是封装字段的首选方式，除非需要暴露字段的内存地址。'
- en: '**Indexer**: The statements execute when you get or set data using "array"
    syntax `[]`.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引器**：当你使用"数组"语法`[]`获取或设置数据时，执行这些语句。'
- en: '**Operator**: The statements execute when you use an operator like `+` and
    `/` on operands of your type.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运算符**：当你在你的类型的操作数上使用运算符如`+`和`/`时，执行这些语句。'
- en: Instantiating a class
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化一个类
- en: In this section, we will make an instance of the `Person` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个`Person`类的实例。
- en: Referencing an assembly
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用程序集
- en: 'Before we can instantiate a class, we need to reference the assembly that contains
    it from another project. We will use the class in a console app:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够实例化一个类之前，我们需要从另一个项目引用包含该类的程序集。我们将在控制台应用程序中使用该类：
- en: Use your preferred coding tool to add a new console app to the `Chapter05` workspace/solution
    named `PeopleApp`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的编码工具，在`Chapter05`工作区/解决方案中添加一个名为`PeopleApp`的新控制台应用程序。
- en: 'If you are using Visual Studio Code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是Visual Studio Code：
- en: Select `PeopleApp` as the active OmniSharp project. When you see the pop-up
    warning message saying that required assets are missing, click **Yes** to add
    them.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`PeopleApp`作为活动OmniSharp项目。当你看到弹出警告消息说缺少必需资产时，点击**是**以添加它们。
- en: 'Edit `PeopleApp.csproj` to add a project reference to `PacktLibrary`, as shown
    highlighted in the following markup:'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`PeopleApp.csproj`以添加对`PacktLibrary`的项目引用，如下所示突出显示：
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In a terminal, enter a command to compile the `PeopleApp` project and its dependency
    `PacktLibrary` project, as shown in the following command:'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，输入命令编译`PeopleApp`项目及其依赖项`PacktLibrary`项目，如下所示：
- en: '[PRE5]'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you are using Visual Studio:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是Visual Studio：
- en: Set the startup project for the solution to the current selection.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解决方案的启动项目设置为当前选择。
- en: In **Solution Explorer**, select the `PeopleApp` project, navigate to **Project**
    | **Add Project Reference…**, check the box to select the `PacktLibrary` project,
    and then click **OK**.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解决方案资源管理器**中，选择`PeopleApp`项目，导航至**项目** | **添加项目引用…**，勾选复选框选择`PacktLibrary`项目，然后点击**确定**。'
- en: Navigate to **Build** | **Build PeopleApp**.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至**生成** | **生成PeopleApp**。
- en: Importing a namespace to use a type
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入命名空间以使用类型
- en: 'Now, we are ready to write statements to work with the `Person` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好编写与`Person`类交互的语句了：
- en: In the `PeopleApp` project/folder, open `Program.cs`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目/文件夹中，打开`Program.cs`。
- en: 'At the top of the `Program.cs` file, delete the comment, and add statements
    to import the namespace for our `Person` class and statically import the `Console`
    class, as shown in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件顶部，删除注释，并添加语句以导入我们`Person`类的命名空间并静态导入`Console`类，如下所示：
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `Program.cs`, add statements to:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加以下语句：
- en: Create an instance of the `Person` type.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`Person`类型的实例。
- en: Output the instance using a textual description of itself.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自身的文本描述输出实例。
- en: 'The `new` keyword allocates memory for the object and initializes any internal
    data. We could use `var` in place of the `Person` class name, but then we would
    need to specify `Person` after the `new` keyword, as shown in the following code:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`new`关键字为对象分配内存并初始化任何内部数据。我们可以使用`var`代替`Person`类名，但随后我们需要在`new`关键字后指定`Person`，如下所示：'
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might be wondering, "Why does the `bob` variable have a method named `ToString`?
    The `Person` class is empty!" Don't worry, we're about to find out!
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会疑惑，“为什么`bob`变量有一个名为`ToString`的方法？`Person`类是空的！”别担心，我们即将揭晓！
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Understanding objects
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解对象
- en: Although our `Person` class did not explicitly choose to inherit from a type,
    all types ultimately inherit directly or indirectly from a special type named
    `System.Object`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的`Person`类没有明确选择继承自某个类型，但所有类型最终都直接或间接继承自一个名为`System.Object`的特殊类型。
- en: The implementation of the `ToString` method in the `System.Object` type simply
    outputs the full namespace and type name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Object`类型中`ToString`方法的实现仅输出完整的命名空间和类型名称。'
- en: 'Back in the original `Person` class, we could have explicitly told the compiler
    that `Person` inherits from the `System.Object` type, as shown in the following
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回到原始的`Person`类，我们本可以明确告诉编译器`Person`继承自`System.Object`类型，如下所示：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When class B inherits from class A, we say that A is the base or superclass
    and B is the derived or subclass. In this case, `System.Object` is the base or
    superclass and `Person` is the derived or subclass.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当类B继承自类A时，我们称A为基类或父类，B为派生类或子类。在这种情况下，`System.Object`是基类或父类，`Person`是派生类或子类。
- en: 'You can also use the C# alias keyword `object`, as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用C#别名关键字`object`，如下列代码所示：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Inheriting from System.Object
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承自System.Object
- en: 'Let''s make our class explicitly inherit from `object` and then review what
    members all objects have:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使我们的类显式继承自`object`，然后回顾所有对象拥有的成员：
- en: Modify your `Person` class to explicitly inherit from `object`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`Person`类，使其显式继承自`object`。
- en: Click inside the `object` keyword and press F12, or right-click on the `object`
    keyword and choose **Go to Definition**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`object`关键字内部，按F12，或者右键点击`object`关键字并选择**转到定义**。
- en: 'You will see the Microsoft-defined `System.Object` type and its members. This
    is something you don''t need to understand the details of yet, but notice that
    it has a method named `ToString`, as shown in *Figure 5.1*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到微软定义的`System.Object`类型及其成员。这方面的细节你目前无需了解，但请注意它有一个名为`ToString`的方法，如*图5.1*所示：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17442_05_01.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件 描述自动生成](img/B17442_05_01.png)'
- en: 'Figure 5.1: System.Object class definition'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**图5.1**：System.Object类定义'
- en: '**Good Practice**: Assume other programmers know that if inheritance is not
    specified, the class will inherit from `System.Object`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：假设其他程序员知道，如果未指定继承，则类将继承自`System.Object`。'
- en: Storing data within fields
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字段中存储数据
- en: In this section, we will be defining a selection of fields in the class to store
    information about a person.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义类中的一系列字段，用于存储有关个人的信息。
- en: Defining fields
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义字段
- en: Let's say that we have decided that a person is composed of a name and a date
    of birth. We will encapsulate these two values inside a person, and the values
    will be visible outside it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已决定一个人由姓名和出生日期组成。我们将把这两个值封装在一个人内部，并且这些值对外可见。
- en: 'Inside the `Person` class, write statements to declare two public fields for
    storing a person''s name and date of birth, as shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Person`类内部，编写语句以声明两个公共字段，用于存储一个人的姓名和出生日期，如下列代码所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can use any type for a field, including arrays and collections such as lists
    and dictionaries. These would be used if you needed to store multiple values in
    one named field. In this example, a person only has one name and one date of birth.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 字段可以使用任何类型，包括数组和集合，如列表和字典。如果你需要在单个命名字段中存储多个值，这些类型就会派上用场。在本例中，一个人只有一个名字和一个出生日期。
- en: Understanding access modifiers
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解访问修饰符
- en: Part of encapsulation is choosing how visible the members are.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的一部分是选择成员的可见性。
- en: Note that, as we did with the class, we explicitly applied the `public` keyword
    to these fields. If we hadn't, then they would be implicitly `private` to the
    class, which means they are accessible only inside the class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如我们对类所做的那样，我们明确地对这些字段应用了`public`关键字。如果我们没有这样做，那么它们将默认为`private`，这意味着它们只能在类内部访问。
- en: 'There are four access modifier keywords, and two combinations of access modifier
    keywords that you can apply to a class member, like a field or method, as shown
    in the following table:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个访问修饰符关键字，以及两种访问修饰符关键字的组合，你可以将其应用于类成员，如字段或方法，如下表所示：
- en: '| Access Modifier | Description |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 访问修饰符 | 描述 |'
- en: '| `private` | Member is accessible inside the type only. This is the default.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `private` | 成员仅在类型内部可访问。这是默认设置。 |'
- en: '| `internal` | Member is accessible inside the type and any type in the same
    assembly. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `internal` | 成员在类型内部及同一程序集中的任何类型均可访问。 |'
- en: '| `protected` | Member is accessible inside the type and any type that inherits
    from the type. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `protected` | 成员在类型内部及其任何派生类型中均可访问。 |'
- en: '| `public` | Member is accessible everywhere. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `public` | 成员在任何地方均可访问。 |'
- en: '| `internal``protected` | Member is accessible inside the type, any type in
    the same assembly, and any type that inherits from the type. Equivalent to a fictional
    access modifier named `internal_or_protected`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `internal``protected` | 成员在类型内部、同一程序集中的任何类型以及任何派生类型中均可访问。相当于一个虚构的访问修饰符，名为`internal_or_protected`。
    |'
- en: '| `private``protected` | Member is accessible inside the type and any type
    that inherits from the type and is in the same assembly. Equivalent to a fictional
    access modifier named `internal_and_protected`. This combination is only available
    with C# 7.2 or later. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `private``protected` | 成员在类型内部、任何派生类型以及同一程序集中均可访问。相当于一个虚构的访问修饰符，名为`internal_and_protected`。这种组合仅在C#
    7.2或更高版本中可用。 |'
- en: '**Good Practice**: Explicitly apply one of the access modifiers to all type
    members, even if you want to use the implicit access modifier for members, which
    is `private`. Additionally, fields should usually be `private` or `protected`,
    and you should then create `public` properties to get or set the field values.
    This is because it controls access. You will do this later in the chapter.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：明确地对所有类型成员应用一个访问修饰符，即使你想要使用成员的隐式访问修饰符，即`private`。此外，字段通常应该是`private`或`protected`，然后你应该创建`public`属性来获取或设置字段值。这是因为它控制访问。你将在本章后面这样做。'
- en: Setting and outputting field values
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和输出字段值
- en: 'Now we will use those fields in your code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在你的代码中使用这些字段：
- en: At the top of `Program.cs`, make sure the `System` namespace is imported. We
    need to do this to use the `DateTime` type.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，确保导入了`System`命名空间。我们需要这样做才能使用`DateTime`类型。
- en: 'After instantiating `bob`, add statements to set his name and date of birth,
    and then output those fields formatted nicely, as shown in the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化`bob`后，添加语句以设置他的姓名和出生日期，然后以美观的格式输出这些字段，如下所示：
- en: '[PRE12]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We could have used string interpolation too, but for long strings it will wrap
    over multiple lines, which can be harder to read in a printed book. In the code
    examples in this book, remember that `{0}` is a placeholder for `arg0`, and so
    on.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们本可以使用字符串插值，但对于长字符串，它会在多行上换行，这在印刷书籍中可能更难以阅读。在本书的代码示例中，请记住`{0}`是`arg0`的占位符，依此类推。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE13]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Your output may look different based on your locale, that is, language and culture.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据你的地区设置（即语言和文化），你的输出可能看起来不同。
- en: The format code for `arg1` is made of several parts. `dddd` means the name of
    the day of the week. `d` means the number of the day of the month. `MMMM` means
    the name of the month. Lowercase `m` is used for minutes in time values. `yyyy`
    means the full number of the year. `yy` would mean the two-digit year.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`arg1`的格式代码由几个部分组成。`dddd`表示星期几的名称。`d`表示月份中的日期号。`MMMM`表示月份的名称。小写的`m`用于时间值中的分钟。`yyyy`表示年份的完整数字。`yy`表示两位数的年份。'
- en: You can also initialize fields using a shorthand **object initializer** syntax
    using curly braces. Let's see how.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还可以使用花括号的简写**对象初始化器**语法初始化字段。让我们看看如何操作。
- en: 'Add statements underneath the existing code to create another new person named
    Alice. Note the different format code for the date of birth when writing her to
    the console, as shown in the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有代码下方添加语句以创建另一个名为Alice的新人。注意在向控制台输出她的出生日期时使用的不同格式代码，如下所示：
- en: '[PRE14]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE15]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Storing a value using an enum type
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用枚举类型存储值
- en: Sometimes, a value needs to be one of a limited set of options. For example,
    there are seven ancient wonders of the world, and a person may have one favorite.
    At other times, a value needs to be a combination of a limited set of options.
    For example, a person may have a bucket list of ancient world wonders they want
    to visit. We are able to store this data by defining an `enum` type.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个值需要是有限选项集中的一个。例如，世界上有七大古代奇迹，一个人可能有一个最喜欢的。在其他时候，一个值需要是有限选项集的组合。例如，一个人可能有一个他们想要访问的古代世界奇迹的遗愿清单。我们能够通过定义一个枚举类型来存储这些数据。
- en: 'An `enum` type is a very efficient way of storing one or more choices because,
    internally, it uses integer values in combination with a lookup table of `string`
    descriptions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型是一种非常高效的方式来存储一个或多个选择，因为它内部使用整数值与`string`描述的查找表相结合：
- en: Add a new file to the `PacktLibrary` project named `WondersOfTheAncientWorld.cs`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`PacktLibrary`项目添加一个名为`WondersOfTheAncientWorld.cs`的新文件。
- en: 'Modify the `WondersOfTheAncientWorld.cs` file, as shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`WondersOfTheAncientWorld.cs`文件，如下所示：
- en: '[PRE16]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Good Practice**: If you use are writing code in a .NET Interactive notebook,
    then the code cell containing the `enum` must be above the code cell defining
    the `Person` class.'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：如果你在.NET Interactive笔记本中编写代码，那么包含`enum`的代码单元格必须位于定义`Person`类的代码单元格之上。'
- en: 'In the `Person` class, add the following statement to your list of fields:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`类中，向字段列表添加以下语句：
- en: '[PRE17]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `Program.cs`, add the following statements:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加以下语句：
- en: '[PRE18]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE19]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `enum` value is internally stored as an `int` for efficiency. The `int`
    values are automatically assigned starting at `0`, so the third world wonder in
    our `enum` has a value of `2`. You can assign `int` values that are not listed
    in the `enum`. They will output as the `int` value instead of a name since a match
    will not be found.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`值内部作为`int`存储以提高效率。`int`值从`0`开始自动分配，因此我们的`enum`中的第三个世界奇迹的值为`2`。你可以分配`enum`中未列出的`int`值。如果找不到匹配项，它们将输出为`int`值而不是名称。'
- en: Storing multiple values using an enum type
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用枚举类型存储多个值
- en: 'For the bucket list, we could create an array or collection of instances of
    the `enum`, and collections will be explained later in this chapter, but there
    is a better way. We can combine multiple choices into a single value using `enum`
    **flags**:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于愿望清单，我们可以创建一个`enum`实例的数组或集合，本章后面将解释集合，但有一个更好的方法。我们可以使用`enum`**标志**将多个选择合并为一个值：
- en: 'Modify the `enum` by decorating it with the `[System.Flags]` attribute, and
    explicitly set a `byte` value for each wonder that represents different bit columns,
    as shown highlighted in the following code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为`enum`添加`[System.Flags]`属性进行修改，并为每个代表不同位列的奇迹显式设置一个`byte`值，如下列代码中突出显示的那样：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are assigning explicit values for each choice that would not overlap when
    looking at the bits stored in memory. We should also decorate the `enum` type
    with the `System.Flags` attribute so that when the value is returned it can automatically
    match with multiple values as a comma-separated `string` instead of returning
    an `int` value.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在为每个选择分配明确的值，这些值在查看内存中存储的位时不会重叠。我们还应该用`System.Flags`属性装饰`enum`类型，以便当值返回时，它可以自动与多个值匹配，作为逗号分隔的`string`而不是返回`int`值。
- en: Normally, an `enum` type uses an `int` variable internally, but since we don't
    need values that big, we can reduce memory requirements by 75%, that is, 1 byte
    per value instead of 4 bytes, by telling it to use a `byte` variable.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，`enum`类型内部使用`int`变量，但由于我们不需要那么大的值，我们可以通过告诉它使用`byte`变量来减少75%的内存需求，即每个值1字节而不是4字节。
- en: 'If we want to indicate that our bucket list includes the *Hanging Gardens of
    Babylon* and the *Mausoleum at Halicarnassus* ancient world wonders, then we would
    want the `16` and `2` bits set to `1`. In other words, we would store the value
    `18`:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想表明我们的愿望清单包括*巴比伦空中花园*和*哈利卡纳苏斯的摩索拉斯陵墓*这两大古代世界奇迹，那么我们希望将`16`和`2`位设置为`1`。换句话说，我们将存储值`18`：
- en: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 |'
- en: 'In the `Person` class, add the following statement to your list of fields,
    as shown in the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`类中，添加以下语句到你的字段列表中，如下列代码所示：
- en: '[PRE21]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `Program.cs`, add statements to set the bucket list using the `|` operator
    (bitwise logical OR) to combine the enum values. We could also set the value using
    the number 18 cast into the enum type, as shown in the comment, but we shouldn''t
    because that would make the code harder to understand, as shown in the following
    code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句使用`|`运算符（按位逻辑或）来组合`enum`值以设置愿望清单。我们也可以使用数字18强制转换为`enum`类型来设置值，如注释所示，但我们不应该这样做，因为这会使代码更难以理解，如下列代码所示：
- en: '[PRE22]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE23]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Good Practice**: Use the `enum` values to store combinations of discrete
    options. Derive an `enum` type from `byte` if there are up to eight options, from
    `ushort` if there are up to 16 options, from `uint` if there are up to 32 options,
    and from `ulong` if there are up to 64 options.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：使用`enum`值来存储离散选项的组合。如果有最多8个选项，则从`byte`派生`enum`类型；如果有最多16个选项，则从`ushort`派生；如果有最多32个选项，则从`uint`派生；如果有最多64个选项，则从`ulong`派生。'
- en: Storing multiple values using collections
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合存储多个值
- en: 'Let''s now add a field to store a person''s children. This is an example of
    aggregation because children are instances of a class that is related to the current
    person but are not part of the person itself. We will use a generic `List<T>`
    collection type that can store an ordered collection of any type. You will learn
    more about collections in *Chapter 8*, *Working with Common .NET Types*. For now,
    just follow along:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个字段来存储一个人的子女。这是一个聚合的例子，因为子女是与当前人物相关联的类的实例，但并不属于该人物本身。我们将使用泛型`List<T>`集合类型，它可以存储任何类型的有序集合。你将在*第8章*，*使用常见的.NET类型*中了解更多关于集合的内容。现在，只需跟随操作：
- en: 'In `Person.cs`, import the `System.Collections.Generic` namespace, as shown
    in the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，导入`System.Collections.Generic`命名空间，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare a new field in the `Person` class, as shown in the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`类中声明一个新字段，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`List<Person>` is read aloud as "list of Person," for example, "the type of
    the property named `Children` is a list of `Person` instances." We explicitly
    changed the class library to target .NET Standard 2.0 (that uses the C# 7 compiler),
    so we cannot use target-typed new to initialize the `Children` field. If we had
    left it targeting .NET 6.0, then we could use target-typed new, as shown in the
    following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<Person>`读作“Person列表”，例如，“名为`Children`的属性的类型是`Person`实例的列表。”我们明确地将类库的目标更改为.NET
    Standard 2.0（使用C# 7编译器），因此我们不能使用目标类型的新来初始化`Children`字段。如果我们保持目标为.NET 6.0，那么我们可以使用目标类型的新，如下面的代码所示：'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We must ensure the collection is initialized to a new instance of a list of
    `Person` before we can add items to it, otherwise, the field will be `null` and
    it will throw runtime exceptions when we try to use any of its members like `Add`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保在向集合添加项之前，集合已初始化为一个新的`Person`列表实例，否则字段将为`null`，当我们尝试使用其任何成员（如`Add`）时，将抛出运行时异常。
- en: Understanding generic collections
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解泛型集合
- en: The angle brackets in the `List<T>` type is a feature of C# called **generics**
    that was introduced in 2005 with C# 2.0\. It's a fancy term for making a collection
    **strongly typed**, that is, the compiler knows specifically what type of object
    can be stored in the collection. Generics improve the performance and correctness
    of your code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`类型中的尖括号是C#的一个特性，称为**泛型**，于2005年随C# 2.0引入。这是一个用于创建**强类型**集合的术语，即编译器明确知道集合中可以存储哪种类型的对象。泛型提高了代码的性能和正确性。'
- en: '**Strongly typed** has a different meaning to **statically typed**. The old
    `System.Collection` types are statically typed to contain weakly typed `System.Object`
    items. The newer `System.Collection.Generic` types are statically typed to contain
    strongly typed `<T>` instances.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**强类型**与**静态类型**有不同的含义。旧的`System.Collection`类型静态地包含弱类型的`System.Object`项。新的`System.Collection.Generic`类型静态地包含强类型的`<T>`实例。'
- en: Ironically, the term *generics* means we can use a more specific static type!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 讽刺的是，*泛型*这一术语意味着我们可以使用更具体的静态类型！
- en: 'In `Program.cs`, add statements to add two children for `Bob` and then show
    how many children he has and what their names are, as shown in the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句为`Bob`添加两个孩子，然后展示他有多少孩子以及他们的名字，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We could also use a `foreach` statement to enumerate over the collection. As
    an extra challenge, change the `for` statement to output the same information
    using `foreach`.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用`foreach`语句来遍历集合。作为额外的挑战，将`for`语句改为使用`foreach`输出相同的信息。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE28]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Making a field static
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字段设为静态
- en: The fields that we have created so far have all been **instance** members, meaning
    that a different value of each field exists for each instance of the class that
    is created. The `alice` and `bob` variables have different `Name` values.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们创建的字段都是**实例**成员，意味着每个字段在创建的每个类实例中都有不同的值。`alice`和`bob`变量具有不同的`Name`值。
- en: Sometimes, you want to define a field that only has one value that is shared
    across all instances.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望定义一个在所有实例中共享的单一值的字段。
- en: 'These are called **static** *members* because fields are not the only members
    that can be static. Let''s see what can be achieved using `static` fields:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为**静态** *成员*，因为字段不是唯一可以静态的成员。让我们看看使用`static`字段可以实现什么：
- en: In the `PacktLibrary` project, add a new class file named `BankAccount.cs`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，添加一个名为`BankAccount.cs`的新类文件。
- en: 'Modify the class to give it three fields, two instance fields and one static
    field, as shown in the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类，使其具有三个字段，两个实例字段和一个静态字段，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each instance of `BankAccount` will have its own `AccountName` and `Balance`
    values, but all instances will share a single `InterestRate` value.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个`BankAccount`实例都将有自己的`AccountName`和`Balance`值，但所有实例将共享一个`InterestRate`值。
- en: 'In `Program.cs`, add statements to set the shared interest rate and then create
    two instances of the `BankAccount` type, as shown in the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以设置共享的利率，然后创建两个`BankAccount`类型的实例，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`:C` is a format code that tells .NET to use the currency format for the numbers.
    In *Chapter 8*, *Working with Common .NET Types*, you will learn how to control
    the culture that determines the currency symbol. For now, it will use the default
    for your operating system installation. I live in London, UK, hence my output
    shows British Pounds (£).'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`:C`是一个格式代码，告诉.NET使用货币格式显示数字。在第8章《使用常见的.NET类型》中，你将学习如何控制决定货币符号的文化。目前，它将使用你操作系统安装的默认设置。我住在英国伦敦，因此我的输出显示的是英镑（£）。'
- en: 'Run the code and view the additional output:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看附加输出：
- en: '[PRE31]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Fields are not the only members that can be static. Constructors, methods, properties,
    and other members can also be static.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 字段并非唯一可声明为静态的成员。构造函数、方法、属性及其他成员也可以是静态的。
- en: Making a field constant
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字段设为常量
- en: 'If the value of a field will never ever change, you can use the `const` keyword
    and assign a literal value at compile time:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个字段的值永远不会改变，你可以使用`const`关键字，并在编译时赋值一个字面量：
- en: 'In `Person.cs`, add the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加以下代码：
- en: '[PRE32]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To get the value of a constant field, you must write the name of the class,
    not the name of an instance of the class. In `Program.cs`, add a statement to
    write Bob''s name and species to the console, as shown in the following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取常量字段的值，你必须写出类名，而不是类的实例名。在`Program.cs`中，添加一条语句，将Bob的名字和物种输出到控制台，如下所示：
- en: '[PRE33]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE34]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Examples of `const` fields in Microsoft types include `System.Int32.MaxValue`
    and `System.Math.PI` because neither value will ever change, as you can see in
    *Figure 5.2*:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 微软类型中的`const`字段示例包括`System.Int32.MaxValue`和`System.Math.PI`，因为这两个值永远不会改变，如图5.2所示：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B17442_05_02.png)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件 描述自动生成](img/B17442_05_02.png)'
- en: 'Figure 5.2: Examples of constants'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：常量示例
- en: '**Good Practice**: Constants are not always the best choice for two important
    reasons: the value must be known at compile time, and it must be expressible as
    a literal `string`, `Boolean`, or number value. Every reference to the `const`
    field is replaced with the literal value at compile time, which will, therefore,
    not be reflected if the value changes in a future version and you do not recompile
    any assemblies that reference it to get the new value.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：常量并不总是最佳选择，原因有二：其值必须在编译时已知，并且必须能表示为字面量`string`、`Boolean`或数值。对`const`字段的每次引用在编译时都会被替换为字面量值，因此，如果未来版本中该值发生变化，且你未重新编译引用它的任何程序集以获取新值，则不会反映这一变化。'
- en: Making a field read-only
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将字段设为只读
- en: 'Often a better choice for fields that should not change is to mark them as
    read-only:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不应更改的字段，通常更好的选择是将其标记为只读：
- en: 'In `Person.cs`, add a statement to declare an instance read-only field to store
    a person''s home planet, as shown in the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加一条语句，声明一个实例只读字段以存储人的母星，如下所示：
- en: '[PRE35]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In `Program.cs`, add a statement to write Bob''s name and home planet to the
    console, as shown in the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句，将Bob的名字和母星输出到控制台，如下所示：
- en: '[PRE36]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE37]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Good Practice**: Use read-only fields over constant fields for two important
    reasons: the value can be calculated or loaded at runtime and can be expressed
    using any executable statement. So, a read-only field can be set using a constructor
    or a field assignment. Every reference to the field is a live reference, so any
    future changes will be correctly reflected by the calling code.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：出于两个重要原因，建议使用只读字段而非常量字段：其值可以在运行时计算或加载，并且可以使用任何可执行语句来表达。因此，只读字段可以通过构造函数或字段赋值来设置。对字段的每次引用都是活跃的，因此任何未来的更改都将被调用代码正确反映。'
- en: You can also declare `static` `readonly` fields whose values will be shared
    across all instances of the type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明`static` `readonly`字段，其值将在该类型的所有实例之间共享。
- en: Initializing fields with constructors
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数初始化字段
- en: Fields often need to be initialized at runtime. You do this in a constructor
    that will be called when you make an instance of the class using the `new` keyword.
    Constructors execute before any fields are set by the code that is using the type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 字段通常需要在运行时初始化。你可以在构造函数中执行此操作，该构造函数将在使用`new`关键字创建类的实例时被调用。构造函数在任何字段被使用该类型的代码设置之前执行。
- en: 'In `Person.cs`, add statements after the existing read-only `HomePlanet` field
    to define a second read-only field and then set the `Name` and `Instantiated`
    fields in a constructor, as shown highlighted in the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，在现有的只读`HomePlanet`字段之后添加语句以定义第二个只读字段，然后在构造函数中设置`Name`和`Instantiated`字段，如下面的代码中突出显示的那样：
- en: '[PRE38]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `Program.cs`, add statements to instantiate a new person and then output
    its initial field values, as shown in the following code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以实例化一个新的人，然后输出其初始字段值，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE40]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Defining multiple constructors
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义多个构造函数
- en: 'You can have multiple constructors in a type. This is especially useful to
    encourage developers to set initial values for fields:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类型中可以有多个构造函数。这对于鼓励开发者在字段上设置初始值特别有用：
- en: 'In `Person.cs`, add statements to define a second constructor that allows a
    developer to set initial values for the person''s name and home planet, as shown
    in the following code:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义第二个构造函数，允许开发者为人的姓名和家乡星球设置初始值，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In `Program.cs`, add statements to create another person using the constructor
    with two parameters, as shown in the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以使用带有两个参数的构造函数创建另一个人，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the code and view the result:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果：
- en: '[PRE43]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Constructors are a special category of method. Let's look at methods in more
    detail.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一种特殊的方法类别。让我们更详细地看看方法。
- en: Writing and calling methods
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和调用方法
- en: '**Methods** are members of a type that execute a block of statements. They
    are functions that belong to a type.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**是一种类型的成员，它执行一组语句。它们是属于某个类型的函数。'
- en: Returning values from methods
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从方法中返回值
- en: 'Methods can return a single value or return nothing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以返回单个值或不返回任何值：
- en: A method that performs some actions but does not return a value indicates this
    with the `void` type before the name of the method.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行某些操作但不返回值的方法通过在方法名称前使用`void`类型来表示这一点。
- en: A method that performs some actions and returns a value indicates this with
    the type of the return value before the name of the method.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行某些操作并返回值的方法通过在方法名称前使用返回值的类型来表示这一点。
- en: 'For example, in the next task, you will create two methods:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下一个任务中，你将创建两个方法：
- en: '`WriteToConsole`: This will perform an action (writing some text to the console),
    but it will return nothing from the method, indicated by the `void` keyword.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteToConsole`：这将执行一个动作（向控制台写入一些文本），但它不会从方法中返回任何内容，由`void`关键字表示。'
- en: '`GetOrigin`: This will return a text value, indicated by the `string` keyword.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetOrigin`：这将返回一个文本值，由`string`关键字表示。'
- en: 'Let''s write the code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码：
- en: 'In `Person.cs`, add statements to define the two methods that I described earlier,
    as shown in the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义我之前描述的两种方法，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In `Program.cs`, add statements to call the two methods, as shown in the following
    code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以调用这两个方法，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE46]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Combining multiple returned values using tuples
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元组组合多个返回值
- en: Each method can only return a single value that has a single type. That type
    could be a simple type, such as `string` in the previous example, a complex type,
    such as `Person`, or a collection type, such as `List<Person>`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法只能返回一个具有单一类型的值。该类型可以是简单类型，如前例中的`string`，复杂类型，如`Person`，或集合类型，如`List<Person>`。
- en: 'Imagine that we want to define a method named `GetTheData` that needs to return
    both a `string` value and an `int` value. We could define a new class named `TextAndNumber`
    with a `string` field and an `int` field, and return an instance of that complex
    type, as shown in the following code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定义一个名为`GetTheData`的方法，该方法需要返回一个`string`值和一个`int`值。我们可以定义一个名为`TextAndNumber`的新类，其中包含一个`string`字段和一个`int`字段，并返回该复杂类型的实例，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: But defining a class just to combine two values together is unnecessary, because
    in modern versions of C# we can use **tuples**. Tuples are an efficient way to
    combine two or more values into a single unit. I pronounce them as tuh-ples but
    I have heard other developers pronounce them as too-ples. To-may-toe, to-mah-toe,
    po-tay-toe, po-tah-toe, I guess.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅仅为了组合两个值而定义一个类是不必要的，因为在现代版本的C#中我们可以使用**元组**。元组是一种高效地将两个或更多值组合成单一单元的方式。我发音为tuh-ples，但我听说其他开发者发音为too-ples。番茄，西红柿，土豆，马铃薯，我想。
- en: Tuples have been a part of some languages such as F# since their first version,
    but .NET only added support for them with .NET 4.0 in 2010 using the `System.Tuple`
    type.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 元组自F#等语言的第一个版本以来就一直是其中的一部分，但.NET直到2010年使用`System.Tuple`类型才在.NET 4.0中添加了对它们的支持。
- en: Language support for tuples
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言对元组的支持
- en: It was only with C# 7.0 in 2017 that C# added language syntax support for tuples
    using the parentheses characters `()` and at the same time, .NET added a new `System.ValueTuple`
    type that is more efficient in some common scenarios than the old .NET 4.0 `System.Tuple`
    type. The C# tuple syntax uses the more efficient one.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2017年C# 7.0，C#才通过使用圆括号字符`()`添加了对元组的语言语法支持，同时.NET引入了一个新的`System.ValueTuple`类型，在某些常见场景下比旧的.NET
    4.0 `System.Tuple`类型更高效。C#的元组语法使用了更高效的那个。
- en: 'Let''s explore tuples:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索元组：
- en: 'In `Person.cs`, add statements to define a method that returns a tuple that
    combines a `string` and `int`, as shown in the following code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义一个返回结合了`string`和`int`的元组的方法，如下列代码所示：
- en: '[PRE48]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In `Program.cs`, add statements to call the `GetFruit` method and then output
    the tuple''s fields automatically named `Item1` and `Item2`, as shown in the following
    code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以调用`GetFruit`方法，然后自动输出名为`Item1`和`Item2`的元组字段，如下列代码所示：
- en: '[PRE49]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE50]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Naming the fields of a tuple
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名元组的字段
- en: To access the fields of a tuple, the default names are `Item1`, `Item2`, and
    so on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问元组的字段，默认名称是`Item1`、`Item2`等。
- en: 'You can explicitly specify the field names:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以显式指定字段名称：
- en: 'In `Person.cs`, add statements to define a method that returns a tuple with
    named fields, as shown in the following code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义一个返回具有命名字段的元组的方法，如下列代码所示：
- en: '[PRE51]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In `Program.cs`, add statements to call the method and output the tuple''s
    named fields, as shown in the following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以调用该方法并输出元组的命名字段，如下列代码所示：
- en: '[PRE52]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE53]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Inferring tuple names
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断元组名称
- en: If you are constructing a tuple from another object, you can use a feature introduced
    in C# 7.1 called **tuple name inference**.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从另一个对象构建元组，你可以使用C# 7.1引入的特性，称为**元组名称推断**。
- en: 'In `Program.cs`, create two tuples, made of a `string` and `int` value each,
    as shown in the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建两个元组，每个元组由一个`string`和一个`int`值组成，如下列代码所示：
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In C# 7.0, both things would use the `Item1` and `Item2` naming schemes. In
    C# 7.1 and later, `thing2` can infer the names `Name` and `Count`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中，两者都会使用`Item1`和`Item2`命名方案。在C# 7.1及更高版本中，`thing2`可以推断出名称`Name`和`Count`。
- en: Deconstructing tuples
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构元组
- en: 'You can also deconstruct tuples into separate variables. The deconstructing
    declaration has the same syntax as named field tuples, but without a named variable
    for the tuple, as shown in the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将元组解构成单独的变量。解构声明的语法与命名字段元组相同，但没有为元组指定名称的变量，如下列代码所示：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This has the effect of splitting the tuple into its parts and assigning those
    parts to new variables.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有将元组分解为其各个部分并将这些部分分配给新变量的效果。
- en: 'In `Program.cs`, add statements to deconstruct the tuple returned from the
    `GetFruit` method, as shown in the following code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以解构从`GetFruit`方法返回的元组，如下列代码所示：
- en: '[PRE56]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE57]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Deconstructing types
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构类型
- en: 'Tuples are not the only type that can be deconstructed. Any type can have special
    methods named `Deconstruct` that break down the object into parts. Let''s implement
    some for the `Person` class:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 元组并非唯一可被解构的类型。任何类型都可以有名为`Deconstruct`的特殊方法，这些方法能将对象分解为各个部分。让我们为`Person`类实现一些这样的方法：
- en: 'In `Person.cs`, add two `Deconstruct` methods with `out` parameters defined
    for the parts we want to deconstruct into, as shown in the following code:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加两个`Deconstruct`方法，为我们要分解的部分定义`out`参数，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `Program.cs`, add statements to deconstruct `bob`, as shown in the following
    code:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以分解`bob`，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE60]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Defining and passing parameters to methods
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和传递参数给方法
- en: 'Methods can have parameters passed to them to change their behavior. Parameters
    are defined a bit like variable declarations but inside the parentheses of the
    method, as you saw earlier in this chapter with constructors. Let''s see more
    examples:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以接收参数来改变其行为。参数的定义有点像变量声明，但位于方法的括号内，正如本章前面在构造函数中看到的那样。我们来看更多例子：
- en: 'In `Person.cs`, add statements to define two methods, the first without parameters
    and the second with one parameter, as shown in the following code:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义两种方法，第一种没有参数，第二种有一个参数，如下面的代码所示：
- en: '[PRE61]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In `Program.cs`, add statements to call the two methods and write the return
    value to the console, as shown in the following code:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以调用这两种方法，并将返回值写入控制台，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run the code and view the result:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果：
- en: '[PRE63]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When typing a statement that calls a method, IntelliSense shows a tooltip with
    the name and type of any parameters, and the return type of the method, as shown
    in *Figure 5.3*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入调用方法的语句时，IntelliSense会显示一个工具提示，其中包含任何参数的名称和类型，以及方法的返回类型，如*图5.3*所示：
- en: '![Graphical user interface, text, website  Description automatically generated](img/B17442_05_03.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，网站 描述自动生成](img/B17442_05_03.png)'
- en: 'Figure 5.3: An IntelliSense tooltip for a method with no overloads'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.3*：没有重载的方法的IntelliSense工具提示'
- en: Overloading methods
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: Instead of having two different method names, we could give both methods the
    same name. This is allowed because the methods each have a different signature.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必为两种不同的方法取不同的名字，可以给这两种方法取相同的名字。这是允许的，因为这两种方法的签名不同。
- en: A **method signature** is a list of parameter types that can be passed when
    calling the method. Overloaded methods cannot differ only in the return type.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法签名**是一系列参数类型，可以在调用方法时传递。重载方法不能仅在返回类型上有所不同。'
- en: In `Person.cs`, change the name of the `SayHelloTo` method to `SayHello`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，将`SayHelloTo`方法的名称更改为`SayHello`。
- en: In `Program.cs`, change the method call to use the `SayHello` method, and note
    that the quick info for the method tells you that it has one additional overload,
    1/2, as well as 2/2, as shown in *Figure 5.4*:![Graphical user interface  Description
    automatically generated with medium confidence](img/B17442_05_04.png)
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，将方法调用更改为使用`SayHello`方法，并注意方法的快速信息告诉你它有一个额外的重载，1/2，以及2/2，如*图5.4*所示：![图形用户界面
    描述自动生成，中等置信度](img/B17442_05_04.png)
- en: 'Figure 5.4: An IntelliSense tooltip for an overloaded method'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.4*：有重载的方法的IntelliSense工具提示'
- en: '**Good Practice**: Use overloaded methods to simplify your class by making
    it appear to have fewer methods.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：使用重载方法简化类，使其看起来方法更少。'
- en: Passing optional and named parameters
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递可选和命名参数
- en: Another way to simplify methods is to make parameters optional. You make a parameter
    optional by assigning a default value inside the method parameter list. Optional
    parameters must always come last in the list of parameters.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种简化方法的方式是使参数可选。通过在方法参数列表中赋予默认值，可以使参数成为可选参数。可选参数必须始终位于参数列表的最后。
- en: 'We will now create a method with three optional parameters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个具有三个可选参数的方法：
- en: 'In `Person.cs`, add statements to define the method, as shown in the following
    code:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义该方法，如下面的代码所示：
- en: '[PRE64]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In `Program.cs`, add a statement to call the method and write its return value
    to the console, as shown in the following code:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句以调用该方法，并将返回值写入控制台，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Watch IntelliSense appear as you type the code. You will see a tooltip, showing
    the three optional parameters with their default values, as shown in *Figure 5.5*:![Graphical
    user interface, text, application, chat or text message  Description automatically
    generated](img/B17442_05_05.png)
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着你输入代码，观察IntelliSense的出现。你会看到一个工具提示，显示三个可选参数及其默认值，如*图5.5*所示：![图形用户界面，文本，应用程序，聊天或短信
    描述自动生成](img/B17442_05_05.png)
- en: 'Figure 5.5: IntelliSense showing optional parameters as you type code'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.5：IntelliSense 显示您键入代码时的可选参数
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE66]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter, as shown in the following
    code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句，为`command`参数传递一个`string`值，为`number`参数传递一个`double`值，如下所示：
- en: '[PRE67]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the code and see the result, as shown in the following output:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE68]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The default values for the `command` and `number` parameters have been replaced,
    but the default for `active` is still `true`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`command`和`number`参数的默认值已被替换，但`active`的默认值仍然是`true`。'
- en: Naming parameter values when calling methods
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用方法时命名参数值
- en: Optional parameters are often combined with naming parameters when you call
    the method, because naming a parameter allows the values to be passed in a different
    order than how they were declared.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法时，可选参数通常与命名参数结合使用，因为命名参数允许值以与声明不同的顺序传递。
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter and a `double` value for the `number` parameter but using named parameters,
    so that the order they are passed through can be swapped around, as shown in the
    following code:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句，为`command`参数传递一个`string`值，为`number`参数传递一个`double`值，但使用命名参数，以便它们传递的顺序可以互换，如下所示：
- en: '[PRE69]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE70]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can even use named parameters to skip over optional parameters.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您甚至可以使用命名参数跳过可选参数。
- en: 'In `Program.cs`, add a statement to pass a `string` value for the `command`
    parameter using positional order, skip the `number` parameter, and use the named
    `active` parameter, as shown in the following code:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一条语句，按位置顺序为`command`参数传递一个`string`值，跳过`number`参数，并使用命名的`active`参数，如下所示：
- en: '[PRE71]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE72]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Controlling how parameters are passed
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制参数的传递方式
- en: 'When a parameter is passed into a method, it can be passed in one of three
    ways:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数传递给方法时，它可以以三种方式之一传递：
- en: 'By **value** (this is the default): Think of these as being *in-only*.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**值**（默认方式）：将其视为*仅输入*。
- en: 'By **reference** as a `ref` parameter: Think of these as being *in-and-out*.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**引用**作为`ref`参数：将其视为*进出*。
- en: 'As an `out` parameter: Think of these as being *out-only*.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`out`参数：将其视为*仅输出*。
- en: 'Let''s see some examples of passing parameters in and out:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些参数传递的例子：
- en: 'In `Person.cs`, add statements to define a method with three parameters, one
    `in` parameter, one `ref` parameter, and one `out` parameter, as shown in the
    following method:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加语句以定义一个带有三个参数的方法，一个`in`参数，一个`ref`参数，以及一个`out`参数，如下所示：
- en: '[PRE73]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In `Program.cs`, add statements to declare some `int` variables and pass them
    into the method, as shown in the following code:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以声明一些`int`变量并将它们传递给方法，如下所示：
- en: '[PRE74]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE75]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: When passing a variable as a parameter by default, its current value gets passed,
    not the variable itself. Therefore, `x` has a copy of the value of the `a` variable.
    The `a` variable retains its original value of `10`.
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当默认传递变量作为参数时，传递的是其当前值，而不是变量本身。因此，`x`是`a`变量值的副本。`a`变量保持其原始值`10`。
- en: When passing a variable as a `ref` parameter, a reference to the variable gets
    passed into the method. Therefore, `y` is a reference to `b`. The `b` variable
    gets incremented when the `y` parameter gets incremented.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将变量作为`ref`参数传递时，变量的引用被传递到方法中。因此，`y`是对`b`的引用。当`y`参数递增时，`b`变量也随之递增。
- en: When passing a variable as an `out` parameter, a reference to the variable gets
    passed into the method. Therefore, `z` is a reference to `c`. The value of the
    `c` variable gets replaced by whatever code executes inside the method. We could
    simplify the code in the `Main` method by not assigning the value `30` to the
    `c` variable since it will always be replaced anyway.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将变量作为`out`参数传递时，变量的引用被传递到方法中。因此，`z`是对`c`的引用。`c`变量的值被方法内部执行的代码所替换。我们可以在`Main`方法中简化代码，不将值`30`赋给`c`变量，因为它总是会被替换。
- en: Simplified out parameters
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化`out`参数
- en: In C# 7.0 and later, we can simplify code that uses the out variables.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0及更高版本中，我们可以简化使用out变量的代码。
- en: 'In `Program.cs`, add statements to declare some more variables including an
    `out` parameter named `f` declared inline, as shown in the following code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以声明更多变量，包括一个名为`f`的内联声明的`out`参数，如下所示：
- en: '[PRE76]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Understanding ref returns
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解ref返回
- en: In C# 7.0 or later, the `ref` keyword is not just for passing parameters into
    a method; it can also be applied to the `return` value. This allows an external
    variable to reference an internal variable and modify its value after the method
    call. This might be useful in advanced scenarios, for example, passing around
    placeholders into big data structures, but it's beyond the scope of this book.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0或更高版本中，`ref`关键字不仅用于向方法传递参数；它还可以应用于`return`值。这使得外部变量可以引用内部变量并在方法调用后修改其值。这在高级场景中可能有用，例如，在大数据结构中传递占位符，但这超出了本书的范围。
- en: Splitting classes using partial
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用partial拆分类
- en: When working on large projects with multiple team members, or when working with
    especially large and complex class implementations, it is useful to be able to
    split the definition of a class across multiple files. You do this using the `partial`
    keyword.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型项目或与多个团队成员合作时，或者在处理特别庞大且复杂的类实现时，能够将类的定义拆分到多个文件中非常有用。您可以通过使用`partial`关键字来实现这一点。
- en: Imagine we want to add statements to the `Person` class that are automatically
    generated by a tool like an object-relational mapper that reads schema information
    from a database. If the class is defined as `partial`, then we can split the class
    into an autogenerated code file and a manually edited code file.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 设想我们希望向`Person`类添加由类似对象关系映射器（ORM）的工具自动生成的语句，该工具从数据库读取架构信息。如果该类定义为`partial`，那么我们可以将类拆分为一个自动生成代码文件和一个手动编辑代码文件。
- en: 'Let''s write some code that simulates this example:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来模拟此示例：
- en: 'In `Person.cs`, add the `partial` keyword, as shown highlighted in the following
    code:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，添加`partial`关键字，如下所示突出显示：
- en: '[PRE77]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the `PacktLibrary` project/folder, add a new class file named `PersonAutoGen.cs`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目/文件夹中，添加一个名为`PersonAutoGen.cs`的新类文件。
- en: 'Add statements to the new file, as shown in the following code:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向新文件添加语句，如下所示：
- en: '[PRE78]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The rest of the code we write for this chapter will be written in the `PersonAutoGen.cs`
    file.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余代码将在`PersonAutoGen.cs`文件中编写。
- en: Controlling access with properties and indexers
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过属性和索引器控制访问
- en: 'Earlier, you created a method named `GetOrigin` that returned a `string` containing
    the name and origin of the person. Languages such as Java do this a lot. C# has
    a better way: properties.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您创建了一个名为`GetOrigin`的方法，该方法返回一个包含人员姓名和来源的`string`。诸如Java之类的语言经常这样做。C#有更好的方法：属性。
- en: A property is simply a method (or a pair of methods) that acts and looks like
    a field when you want to get or set a value, thereby simplifying the syntax.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 属性本质上是一个方法（或一对方法），当您想要获取或设置值时，它表现得像字段一样，从而简化了语法。
- en: Defining read-only properties
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义只读属性
- en: A `readonly` property only has a `get` implementation.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`readonly`属性仅具有`get`实现。
- en: 'In `PersonAutoGen.cs`, in the `Person` class, add statements to define three
    properties:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，在`Person`类中，添加语句以定义三个属性：
- en: The first property will perform the same role as the `GetOrigin` method using
    the property syntax that works with all versions of C# (although, it uses the
    string interpolation syntax from C# 6 and later).
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个属性将使用适用于所有C#版本的属性语法执行与`GetOrigin`方法相同的角色（尽管它使用了C# 6及更高版本中的字符串插值语法）。
- en: The second property will return a greeting message using the lambda expression
    body `=>` syntax from C# 6 and later.
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个属性将使用C# 6及更高版本中的lambda表达式体`=>`语法返回一条问候消息。
- en: The third property will calculate the person's age.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个属性将计算该人的年龄。
- en: 'Here''s the code:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE79]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '**Good Practice**: This isn''t the best way to calculate someone''s age, but
    we aren''t learning how to calculate an age from a date of birth. If you need
    to do that properly, read the discussion at the following link: [https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c)'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：这不是计算某人年龄的最佳方法，但我们并非学习如何从出生日期计算年龄。若需正确执行此操作，请阅读以下链接中的讨论：[https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c](https://stackoverflow.com/questions/9/how-do-i-calculate-someones-age-in-c)'
- en: 'In `Program.cs`, add the statements to get the properties, as shown in the
    following code:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加获取属性的语句，如下列代码所示：
- en: '[PRE80]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE81]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The output shows 49 because I ran the console application on August 15, 2021
    when Sam was 49 years old.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示49，因为我在2021年8月15日运行了控制台应用程序，当时Sam 49岁。
- en: Defining settable properties
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义可设置的属性
- en: 'To create a settable property, you must use the older syntax and provide a
    pair of methods—not just a `get` part, but also a `set` part:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可设置的属性，您必须使用较旧的语法并提供一对方法——不仅仅是`get`部分，还包括`set`部分：
- en: 'In `PersonAutoGen.cs`, add statements to define a `string` property that has
    both a `get` and `set` method (also known as a getter and setter), as shown in
    the following code:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句以定义一个具有`get`和`set`方法（也称为getter和setter）的`string`属性，如下列代码所示：
- en: '[PRE82]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Although you have not manually created a field to store the person's favorite
    ice cream, it is there, automatically created by the compiler for you.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管您没有手动创建一个字段来存储某人的最爱冰淇淋，但它确实存在，由编译器自动为您创建。
- en: Sometimes, you need more control over what happens when a property is set. In
    this scenario, you must use a more detailed syntax and manually create a `private`
    field to store the value for the property.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，您需要更多控制权来决定属性设置时发生的情况。在这种情况下，您必须使用更详细的语法并手动创建一个`private`字段来存储该属性的值。
- en: 'In `PersonAutoGen.cs`, add statements to define a `string` field and `string`
    property that has both a `get` and `set`, as shown in the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句以定义一个`string`字段和一个具有`get`和`set`的`string`属性，如下列代码所示：
- en: '[PRE83]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**Good Practice**: Avoid adding too much code to your getters and setters.
    This could indicate a problem with your design. Consider adding private methods
    that you then call in setters and getters to simplify your implementations.'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：避免在您的getter和setter中添加过多代码。这可能表明您的设计存在问题。考虑添加私有方法，然后在setter和getter中调用这些方法，以简化您的实现。'
- en: 'In `Program.cs`, add statements to set Sam''s favorite ice cream and color,
    and then write them out, as shown in the following code:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以设置Sam的最爱冰淇淋和颜色，然后将其写出，如下列代码所示：
- en: '[PRE84]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下列输出所示：
- en: '[PRE85]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If you try to set the color to any value other than red, green, or blue, then
    the code will throw an exception. The calling code could then use a `try` statement
    to display the error message.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您尝试将颜色设置为除红色、绿色或蓝色之外的任何值，则代码将抛出异常。调用代码随后可以使用`try`语句来显示错误消息。
- en: '**Good Practice**: Use properties instead of fields when you want to validate
    what value can be stored when you want to data bind in XAML, which we will cover
    in *Chapter 19*, *Building Mobile and Desktop Apps Using .NET MAUI*, and when
    you want to read and write to a field without using a method pair like `GetAge`
    and `SetAge`.'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：当您希望验证可以存储的值时，或者在希望进行XAML数据绑定时（我们将在*第19章*，*使用.NET MAUI构建移动和桌面应用*中介绍），以及当您希望在不使用`GetAge`和`SetAge`这样的方法对的情况下读写字段时，请使用属性而不是字段。'
- en: Requiring properties to be set during instantiation
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要求在实例化时设置属性
- en: 'C# 10 introduces the `required` modifier. If you use it on a property, the
    compiler will ensure that you set the property to a value when you instantiate
    it, as shown in the following code:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10引入了`required`修饰符。如果您将其用于属性，编译器将确保在实例化时为该属性设置一个值，如下列代码所示：
- en: '[PRE86]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If you attempt to instantiate a `Book` without setting the `Isbn` property
    you will see a compiler error, as shown in the following code:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试实例化一个`Book`而不设置`Isbn`属性，您将看到一个编译器错误，如下列代码所示：
- en: '[PRE87]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `required` keyword might not make it into the final release version of .NET
    6 so treat this section as theoretical.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`required`关键字可能不会出现在.NET 6的最终发布版本中，因此请将本节视为理论性的。'
- en: Defining indexers
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义索引器
- en: Indexers allow the calling code to use the array syntax to access a property.
    For example, the `string` type defines an **indexer** so that the calling code
    can access individual characters in the `string`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器允许调用代码使用数组语法来访问属性。例如，`string`类型定义了一个**索引器**，以便调用代码可以访问`string`中的单个字符。
- en: 'We will define an indexer to simplify access to the children of a person:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个索引器，以简化对某人子女的访问：
- en: 'In `PersonAutoGen.cs`, add statements to define an indexer to get and set a
    child using the index of the child, as shown in the following code:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonAutoGen.cs`中，添加语句定义一个索引器，以使用孩子的索引获取和设置孩子，如下所示：
- en: '[PRE88]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You can overload indexers so that different types can be used for their parameters.
    For example, as well as passing an `int` value, you could also pass a `string`
    value.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以重载索引器，以便不同的类型可以用于其参数。例如，除了传递一个`int`值外，您还可以传递一个`string`值。
- en: 'In `Program.cs`, add statements to add two children to `Sam`, and then access
    the first and second child using the longer `Children` field and the shorter indexer
    syntax, as shown in the following code:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句向`Sam`添加两个孩子，然后使用较长的`Children`字段和较短的索引器语法访问第一个和第二个孩子，如下所示：
- en: '[PRE89]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE90]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Pattern matching with objects
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的模式匹配
- en: In *Chapter 3*, *Controlling Flow, Converting Types, and Handling Exceptions*,
    you were introduced to basic pattern matching. In this section, we will explore
    pattern matching in more detail.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*控制流程、转换类型和处理异常*中，您被介绍了基本的模式匹配。在本节中，我们将更详细地探讨模式匹配。
- en: Creating and referencing a .NET 6 class library
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并引用.NET 6类库
- en: The enhanced pattern matching features are only available in modern .NET class
    libraries that support C# 9 or later.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 增强的模式匹配特性仅在支持C# 9或更高版本的现代.NET类库中可用。
- en: Use your preferred coding tool to add a new class library named `PacktLibraryModern`
    to the workspace/solution named `Chapter05`.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的编码工具，在名为`Chapter05`的工作区/解决方案中添加一个名为`PacktLibraryModern`的新类库。
- en: 'In the `PeopleApp` project, add a reference to the `PacktLibraryModern` class
    library, as shown highlighted in the following markup:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中，添加对`PacktLibraryModern`类库的引用，如下所示：
- en: '[PRE91]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Build the `PeopleApp` project.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目。
- en: Defining flight passengers
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义飞行乘客
- en: In this example, we will define some classes that represent various types of
    passengers on a flight and then we will use a switch expression with pattern matching
    to determine the cost of their flight.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将定义一些代表飞行中各种类型乘客的类，然后我们将使用带有模式匹配的switch表达式来确定他们的飞行费用。
- en: In the `PacktLibraryModern` project/folder, rename the file `Class1.cs` to `FlightPatterns.cs`.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibraryModern`项目/文件夹中，将文件`Class1.cs`重命名为`FlightPatterns.cs`。
- en: 'In `FlightPatterns.cs`, add statements to define three types of passengers
    with different properties, as shown in the following code:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FlightPatterns.cs`中，添加语句定义三种具有不同属性的乘客类型，如下所示：
- en: '[PRE92]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In `Program.cs`, add statements to define an object array containing five passengers
    of various types and property values, and then enumerate them, outputting the
    cost of their flight, as shown in the following code:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句定义一个包含五种不同类型和属性值的乘客对象数组，然后枚举它们，输出他们的飞行费用，如下所示：
- en: '[PRE93]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'While reviewing the preceding code, note the following:'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在审查前面的代码时，请注意以下几点：
- en: To pattern match on the properties of an object, you must name a local variable
    that can then be used in an expression like `p`.
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要对对象的属性进行模式匹配，您必须命名一个局部变量，该变量随后可以在表达式中使用，如`p`。
- en: To pattern match on a type only, you can use `_` to discard the local variable.
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对类型进行模式匹配时，可以使用`_`来丢弃局部变量。
- en: The switch expression also uses `_` to represent its default branch.
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: switch表达式也使用`_`来表示其默认分支。
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE94]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Enhancements to pattern matching in C# 9 or later
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 9或更高版本中模式匹配的增强
- en: 'The previous examples worked with C# 8\. Now we will look at some enhancements
    in C# 9 and later. First, you no longer need to use the underscore to discard
    when doing type matching:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用的是C# 8。现在我们将看看C# 9及更高版本的一些增强功能。首先，进行类型匹配时不再需要使用下划线来丢弃：
- en: 'In `Program.cs`, comment out the C# 8 syntax and add C# 9 and later syntax
    to modify the branches for first-class passengers to use a nested switch expression
    and the new support for conditionals like `>`, as shown in the following code:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，注释掉C# 8语法，添加C# 9及更高版本的语法，修改头等舱乘客的分支，使用嵌套的switch表达式和新的条件支持，如`>`，如下所示：
- en: '[PRE95]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Run the code to view the results, and note they are the same as before.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，并注意它们与之前相同。
- en: 'You could also use the relational pattern in combination with the property
    pattern to avoid the nested switch expression, as shown in the following code:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以结合使用关系模式和属性模式来避免嵌套的switch表达式，如下面的代码所示：
- en: '[PRE96]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Working with records
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理记录
- en: Before we dive into the new records language feature of C# 9 and later, let
    us see some other related new features.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解C# 9及更高版本的新记录语言特性之前，让我们先看看一些其他相关的新特性。
- en: Init-only properties
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Init-only属性
- en: You have used object initialization syntax to instantiate objects and set initial
    properties throughout this chapter. Those properties can also be changed after
    instantiation.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中使用了对象初始化语法来实例化对象并设置初始属性。那些属性也可以在实例化后更改。
- en: 'Sometimes you want to treat properties like `readonly` fields so they can be
    set during instantiation but not after. The new `init` keyword enables this. It
    can be used in place of the `set` keyword:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望将属性视为`只读`字段，以便它们可以在实例化期间设置，但不能在此之后设置。新的`init`关键字使这成为可能。它可以用来替代`set`关键字：
- en: In the `PacktLibraryModern` project/folder, add a new file named `Records.cs`.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibraryModern`项目/文件夹中，添加一个名为`Records.cs`的新文件。
- en: 'In `Records.cs`, define an immutable person class, as shown in the following
    code:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Records.cs`中，定义一个不可变人员类，如下面的代码所示：
- en: '[PRE97]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In `Program.cs`, add statements to instantiate a new immutable person and then
    try to change one of its properties, as shown in the following code:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以实例化一个新的不可变人员，然后尝试更改其一个属性，如下面的代码所示：
- en: '[PRE98]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Compile the console app and note the compile error, as shown in the following
    output:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译控制台应用程序并注意编译错误，如下面的输出所示：
- en: '[PRE99]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Comment out the attempt to set the `FirstName` property after instantiation.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉尝试在实例化后设置`FirstName`属性的代码。
- en: Understanding records
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解记录
- en: Init-only properties provide some immutability to C#. You can take the concept
    further by using **records**. These are defined by using the `record` keyword
    instead of the `class` keyword. That can make the whole object immutable, and
    it acts like a value when compared. We will discuss equality and comparisons of
    classes, records, and value types in more detail in *Chapter 6*, *Implementing
    Interfaces and Inheriting Classes*.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Init-only属性为C#提供了一些不可变性。您可以通过使用**记录**将这一概念进一步推进。这些是通过使用`record`关键字而不是`class`关键字来定义的。这可以使整个对象不可变，并且在比较时它表现得像一个值。我们将在*第6章*，*实现接口和继承类*中更详细地讨论类、记录和值类型的相等性和比较。
- en: 'Records should not have any state (properties and fields) that changes after
    instantiation. Instead, the idea is that you create new records from existing
    ones with any changed state. This is called non-destructive mutation. To do this,
    C# 9 introduced the `with` keyword:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 记录不应具有在实例化后更改的任何状态（属性和字段）。相反，想法是您从现有记录创建新记录，其中包含任何更改的状态。这称为非破坏性突变。为此，C# 9引入了`with`关键字：
- en: 'In `Records.cs`, add a record named `ImmutableVehicle`, as shown in the following
    code:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Records.cs`中，添加一个名为`ImmutableVehicle`的记录，如下面的代码所示：
- en: '[PRE100]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In `Program.cs`, add statements to create a `car` and then a mutated copy of
    it, as shown in the following code:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以创建一辆`车`，然后创建其变异副本，如下面的代码所示：
- en: '[PRE101]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Run the code to view the results, and note the change to the car color in the
    mutated copy, as shown in the following output:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，并注意变异副本中汽车颜色的变化，如下面的输出所示：
- en: '[PRE102]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Positional data members in records
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录中的位置数据成员
- en: The syntax for defining a record can be greatly simplified using positional
    data members.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 定义记录的语法可以通过使用位置数据成员大大简化。
- en: Simplifying data members in records
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化记录中的数据成员
- en: 'Instead of using object initialization syntax with curly braces, sometimes
    you might prefer to provide a constructor with positional parameters as you saw
    earlier in this chapter. You can also combine this with a deconstructor for splitting
    the object into individual parts, as shown in the following code:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用花括号的对象初始化语法，有时您可能更愿意提供带有位置参数的构造函数，正如您在本章前面所见。您还可以将此与析构函数结合使用，以将对象分解为各个部分，如下面的代码所示：
- en: '[PRE103]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The properties, constructor, and deconstructor can be generated for you:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 属性、构造函数和析构函数可以为您自动生成：
- en: 'In `Records.cs`, add statements to define another record using simplified syntax
    known as positional records, as shown in the following code:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Records.cs`中，添加语句以使用称为位置记录的简化语法定义另一个记录，如下面的代码所示：
- en: '[PRE104]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In `Program.cs`, add statements to construct and deconstruct immutable animals,
    as shown in the following code:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句以构造和析构不可变动物，如下列代码所示：
- en: '[PRE105]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Run the application and view the results, as shown in the following output:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并查看结果，如下列输出所示：
- en: '[PRE106]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You will see records again when we look at C# 10 support for creating `struct`
    records in *Chapter 6*, *Implementing Interfaces and Inheriting Classes*.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看C# 10支持创建`struct`记录时，你将在*第6章*，*实现接口和继承类*中再次看到记录。
- en: Practicing and exploring
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践与探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试你的知识和理解，进行一些实践操作，并深入研究本章的主题。
- en: Exercise 5.1 – Test your knowledge
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What are the six combinations of access modifier keywords and what do they do?
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问修饰符关键字的六种组合是什么，它们各自的作用是什么？
- en: What is the difference between the `static`, `const`, and `readonly` keywords
    when applied to a type member?
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用于类型成员时，`static`、`const`和`readonly`关键字之间有何区别？
- en: What does a constructor do?
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数的作用是什么？
- en: Why should you apply the `[Flags]` attribute to an `enum` type when you want
    to store combined values?
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想要存储组合值时，为什么应该对`enum`类型应用`[Flags]`属性？
- en: Why is the `partial` keyword useful?
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`partial`关键字有用？
- en: What is a tuple?
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是元组？
- en: What does the `record` keyword do?
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`record`关键字的作用是什么？'
- en: What does overloading mean?
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载是什么意思？
- en: What is the difference between a field and a property?
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段和属性之间有什么区别？
- en: How do you make a method parameter optional?
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使方法参数变为可选？
- en: Exercise 5.2 – Explore topics
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.2 – 探索主题
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接来了解更多关于本章所涵盖主题的详细信息：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-5---building-your-own-types-with-object-oriented-programming)'
- en: Summary
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about making your own types using OOP. You learned
    about some of the different categories of members that a type can have, including
    fields to store data and methods to perform actions, and you used OOP concepts,
    such as aggregation and encapsulation. You saw examples of how to use modern C#
    features like relational and property pattern matching enhancements, init-only
    properties, and records.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用面向对象编程（OOP）创建自己的类型。你了解了类型可以拥有的不同类别的成员，包括用于存储数据的字段和执行操作的方法，并运用了OOP概念，如聚合和封装。你看到了如何使用现代C#特性，如关系和属性模式匹配增强、仅初始化属性以及记录的示例。
- en: In the next chapter, you will take these concepts further by defining delegates
    and events, implementing interfaces, and inheriting from existing classes.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过定义委托和事件、实现接口以及继承现有类来进一步应用这些概念。
