- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving Performance and Scalability Using Multitasking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about allowing multiple actions to occur at the same time to
    improve performance, scalability, and user productivity for the applications that
    you build.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding processes, threads, and tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring performance and resource usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tasks asynchronously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing access to shared resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `async` and `await`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding processes, threads, and tasks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **process**, with one example being each of the console applications we have
    created, has resources like memory and threads allocated to it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: A **thread** executes your code, statement by statement. By default, each process
    only has one thread, and this can cause problems when we need to do more than
    one task at the same time. Threads are also responsible for keeping track of things
    like the currently authenticated user and any internationalization rules that
    should be followed for the current language and region.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Windows and most other modern operating systems use **preemptive multitasking**,
    which simulates the parallel execution of tasks. It divides the processor time
    among the threads, allocating a **time slice** to each thread one after another.
    The current thread is suspended when its time slice finishes. The processor then
    allows another thread to run for a time slice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: When Windows switches from one thread to another, it saves the context of the
    thread and reloads the previously saved context of the next thread in the thread
    queue. This takes both time and resources to complete.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, if you have a small number of complex pieces of work and you
    want complete control over them, then you could create and manage individual `Thread`
    instances. If you have one main thread and multiple small pieces of work that
    can be executed in the background, then you can use the `ThreadPool` class to
    add delegate instances that point to those pieces of work implemented as methods
    to a queue, and they will be automatically allocated to threads in the thread
    pool.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the `Task` type to manage threads at a higher abstraction
    level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Threads may have to compete for and also wait for access to shared resources,
    such as variables, files, and database objects. There are types for managing this
    that you will see in action later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the task, doubling the number of threads (workers) to perform a
    task does not halve the number of seconds that it will take to complete that task.
    In fact, it can increase the duration of the task.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Never assume that more threads will improve performance!
    Run performance tests on a baseline code implementation without multiple threads,
    and then again on a code implementation with multiple threads. You should also
    perform performance tests in a staging environment that is as close as possible
    to the production environment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring performance and resource usage
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can improve the performance of any code, we need to be able to monitor
    its speed and efficiency to record a baseline that we can then measure improvements
    against.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the efficiency of types
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is the best type to use for a scenario? To answer this question, we need
    to carefully consider what we mean by "best", and through this, we should consider
    the following factors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Functionality**: This can be decided by checking whether the type provides
    the features you need.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory size**: This can be decided by the number of bytes of memory the type
    takes up.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: This can be decided by how fast the type is.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Future needs**: This depends on the changes in requirements and maintainability.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be scenarios, such as when storing numbers, where multiple types
    have the same functionality, so we will need to consider memory and performance
    to make a choice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: If we need to store millions of numbers, then the best type to use would be
    the one that requires the fewest bytes of memory. But if we only need to store
    a few numbers, yet we need to perform lots of calculations on them, then the best
    type to use would be the one that runs fastest on a specific CPU.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: You have seen the use of the `sizeof()` function, which shows the number of
    bytes a single instance of a type uses in memory. When we are storing a large
    number of values in more complex data structures, such as arrays and lists, then
    we need a better way of measuring memory usage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: You can read lots of advice online and in books, but the only way to know for
    sure what the best type would be for your code is to compare the types yourself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to write code to monitor the actual
    memory requirements and performance when using different types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Today a `short` variable might be the best choice, but it might be an even better
    choice to use an `int` variable, even though it takes twice as much space in the
    memory. This is because we might need a wider range of values to be stored in
    the future.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important metric that developers often forget: maintenance. This
    is a measure of how much effort another programmer would have to put in to understand
    and modify your code. If you make a nonobvious choice of type without explaining
    that choice with a helpful comment, then it might confuse the programmer who comes
    along later and needs to fix a bug or add a feature.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring performance and memory using diagnostics
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `System.Diagnostics` namespace has lots of useful types for monitoring
    your code. The first useful type that we will look at is the `Stopwatch` type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter12`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class library project, as defined in the following list:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter12`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `MonitoringLib`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter12`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `MonitoringApp`'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `MonitoringApp` as the active OmniSharp project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `MonitoringLib` project, rename the `Class1.cs` file to `Recorder.cs`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MonitoringApp` project, add a project reference to the `MonitoringLib`
    class library, as shown in the following markup:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build the `MonitoringApp` project.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Useful members of the Stopwatch and Process types
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Stopwatch` type has some useful members, as shown in the following table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `Restart` method | This resets the elapsed time to zero and then starts the
    timer. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| `Stop` method | This stops the timer. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `Elapsed` property | This is the elapsed time stored as a `TimeSpan` format
    (for example, hours:minutes:seconds) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `ElapsedMilliseconds` property | This is the elapsed time in milliseconds
    stored as an `Int64` value. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: 'The `Process` type has some useful members, as shown in the following table:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `VirtualMemorySize64` | This displays the amount of virtual memory, in bytes,
    allocated for the process. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `WorkingSet64` | This displays the amount of physical memory, in bytes, allocated
    for the process. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: Implementing a Recorder class
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create a `Recorder` class that makes it easy to monitor time and memory
    resource usage. To implement our `Recorder` class, we will use the `Stopwatch`
    and `Process` classes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Recorder.cs`, change its contents to use a `Stopwatch` instance to record
    timings and the current `Process` instance to record memory usage, as shown in
    the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Start` method of the `Recorder` class uses the `GC` type (garbage collector)
    to ensure that any currently allocated but not referenced memory is collected
    before recording the amount of used memory. This is an advanced technique that
    you should almost never use in application code.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, write statements to start and stop the `Recorder` while generating
    an array of 10,000 integers, as shown in the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Remember that the time elapsed is randomly between 5 and 10 seconds. Your results
    will vary. For example, when run on my Mac mini M1, less physical memory but more
    virtual memory was used, as shown in the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Measuring the efficiency of processing strings
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you've seen how the `Stopwatch` and `Process` types can be used to
    monitor your code, we will use them to evaluate the best way to process `string`
    variables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the previous statements by wrapping them in multi-line
    comment characters: `/* */`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write statements to create an array of 50,000 `int` variables and then concatenate
    them with commas as separators using a `string` and `StringBuilder` class, as
    shown in the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can summarize the results as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The `string` class with the `+` operator used about 14 MB of physical memory,
    1.5 MB of virtual memory, and took 1.5 seconds.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StringBuilder` class used 12 KB of physical memory, zero virtual memory,
    and took less than 1 millisecond.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this scenario, `StringBuilder` is more than 1,000 times faster and about
    10,000 times more memory efficient when concatenating text! This is because `string`
    concatenation creates a new `string` each time you use it because `string` values
    are immutable so they can be safely pooled for reuse. `StringBuilder` creates
    a single buffer while it appends more characters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid using the `String.Concat` method or the `+` operator
    inside loops. Use `StringBuilder` instead.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned how to measure the performance and resource efficiency
    of your code using types built into .NET, let's learn about a NuGet package that
    provides more sophisticated performance measurements.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring performance and memory using Benchmark.NET
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a popular benchmarking NuGet package for .NET that Microsoft uses
    in its blog posts about performance improvements, so it is good for .NET developers
    to know how it works and use it for their own performance testing. Let''s see
    how we could use it to compare performance between `string` concatenation and
    `StringBuilder`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `Benchmarking`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Benchmarking` as the active OmniSharp project.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a package reference to Benchmark.NET, remembering that you can find out
    the latest version and use that instead of the version I used, as shown in the
    following markup:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Build the project to restore packages.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then import the namespace
    for running benchmarks, as shown in the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add a new class file named `StringBenchmarks.cs`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `StringBenchmarks.cs`, add statements to define a class with methods for
    each benchmark you want to run, in this case, two methods that both combine twenty
    numbers comma-separated using either `string` concatenation or `StringBuilder`,
    as shown in the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `Program.cs`, add a statement to run the benchmarks, as shown in the following
    code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In Visual Studio 2022, in the toolbar, set **Solution Configurations** to **Release**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, in a terminal, use the `dotnet run --configuration Release`
    command.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the console app and note the results, including some artifacts like report
    files, and the most important, a summary table that shows that `string` concatenation
    took a mean of 412.990 ns and `StringBuilder` took a mean of 275.082 ns, as shown
    in the following partial output and in *Figure 12.1*:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/B17442_13_02.png)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 12.1: Summary table that shows StringBuilder takes 69% of the time compared
    to string concatenation'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Outliers` section is especially interesting because it shows that not only
    is `string` concatenation slower than `StringBuilder`, but it is also more inconsistent
    in how long it takes. Your results will vary, of course.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: You have now seen two ways to measure performance. Now let's see how we can
    run tasks asynchronously to potentially improve performance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Running tasks asynchronously
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how multiple tasks can be run simultaneously (at the same time),
    we will create a console application that needs to execute three methods.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be three methods that need to be executed: the first takes 3 seconds,
    the second takes 2 seconds, and the third takes 1 second. To simulate that work,
    we can use the `Thread` class to tell the current thread to go to sleep for a
    specified number of milliseconds.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple actions synchronously
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we make the tasks run simultaneously, we will run them synchronously,
    that is, one after the other.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `WorkingWithTasks`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithTasks` as the active OmniSharp project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, import the namespace to work with a stopwatch (namespaces
    for working with threading and tasks are implicitly imported), and statically
    import `Console`, as shown in the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the bottom of `Program.cs`, create a method to output information about
    the current thread, as shown in the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the bottom of `Program.cs`, add three methods that simulate work, as shown
    in the following code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At the top of `Program.cs`, add statements to call the method to output information
    about the thread, define and start a stopwatch, call the three simulated work
    methods, and then output the milliseconds elapsed, as shown in the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the code, view the result, and note that when there is only one unnamed
    foreground thread doing the work, the total time required is just over 6 seconds,
    as shown in the following output:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running multiple actions asynchronously using tasks
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Thread` class has been available since the first version of .NET and can
    be used to create new threads and manage them, but it can be tricky to work with
    directly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 4.0 introduced the `Task` class in 2010, which is a wrapper around
    a thread that enables easier creation and management. Managing multiple threads
    wrapped in tasks will allow our code to execute at the same time, aka asynchronously.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Each `Task` has a `Status` property and a `CreationOptions` property. A `Task`
    has a `ContinueWith` method that can be customized with the `TaskContinuationOptions`
    enum, and can be managed with the `TaskFactory` class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Starting tasks
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will look at three ways to start the methods using `Task` instances. There
    are links in the GitHub repository to articles that discuss the pros and cons.
    Each has a slightly different syntax, but they all define a `Task` and start it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the calls to the three methods and their associated console message,
    and add statements to create and start three tasks, one for each method, as shown
    highlighted in the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the code, view the result, and note that the elapsed milliseconds appear
    almost immediately. This is because each of the three methods is now being executed
    by three new background worker threads allocated from the thread pool, as shown
    in the following output:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is even possible that the console app will end before one or more of the
    tasks have a chance to start and write to the console!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for tasks
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to wait for a task to complete before continuing. To do
    this, you can use the `Wait` method on a `Task` instance, or the `WaitAll` or
    `WaitAny` static methods on an array of tasks, as described in the following table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `t.Wait()` | This waits for the task instance named `t` to complete execution.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `Task.WaitAny(Task[])` | This waits for any of the tasks in the array to
    complete execution. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `Task.WaitAll(Task[])` | This waits for all the tasks in the array to complete
    execution. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: Using wait methods with tasks
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see how we can use these wait methods to fix the problem with our console
    app.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements after creating the three tasks and before outputting
    the elapsed time to combine references to the three tasks into an array and pass
    them to the `WaitAll` method, as shown in the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the code and view the result, and note the original thread will pause on
    the call to `WaitAll`, waiting for all three tasks to finish before outputting
    the elapsed time, which is a little over 3 seconds, as shown in the following
    output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The three new threads execute their code simultaneously, and they can potentially
    start in any order. `MethodC` should finish first because it takes only 1 second,
    then `MethodB`, which takes 2 seconds, and finally `MethodA`, because it takes
    3 seconds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: However, the actual CPU used has a big effect on the results. It is the CPU
    that allocates time slices to each process to allow them to execute their threads.
    You have no control over when the methods run.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with another task
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all three tasks can be performed at the same time, then waiting for all tasks
    to finish will be all we need to do. However, often a task is dependent on the
    output from another task. To handle this scenario, we need to define **continuation
    tasks**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We will create some methods to simulate a call to a web service that returns
    a monetary amount that then needs to be used to retrieve how many products cost
    more than that amount in a database. The result returned from the first method
    needs to be fed into the input of the second method. This time, instead of waiting
    for fixed amounts of time, we will use the `Random` class to wait for a random
    interval between 2 and 4 seconds for each method call to simulate the work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, add two methods that simulate calling a web
    service and a database-stored procedure, as shown in the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Comment out the calls to the previous three tasks by wrapping them in multiline
    comment characters, `/* */`. Leave the statement that outputs the elapsed milliseconds.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements before the existing statement to output the total time, as shown
    in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might see different threads running the web service and stored procedure
    calls as in the output above (threads 4 and 6), or the same thread might be reused
    since it is no longer busy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Nested and child tasks
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as defining dependencies between tasks, you can define nested and child
    tasks. A **nested task** is a task that is created inside another task. A **child
    task** is a nested task that must finish before its parent task is allowed to
    finish.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how these types of tasks work:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `NestedAndChildTasks`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `NestedAndChildTasks` as the active OmniSharp
    project.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, statically import `Console`,
    and then add two methods, one of which starts a task to run the other, as shown
    in the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Above the methods, add statements to start a task to run the outer method and
    wait for it to finish before stopping, as shown in the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that, although we wait for the outer task to finish, its inner task does
    not have to finish as well. In fact, the outer task might finish, and the console
    app could end, before the inner task even starts!
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To link these nested tasks as parent and child, we must use a special option.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the existing code that defines the inner task to add a `TaskCreationOption`
    value of `AttachedToParent`, as shown highlighted in the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the code, view the result, and note that the inner task must finish before
    the outer task can, as shown in the following output:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `OuterMethod` can finish before the `InnerMethod`, as shown by its writing
    to the console, but its task must wait, as shown by the console not stopping until
    both the outer and inner tasks finish.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping tasks around other objects
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you might have a method that you want to be asynchronous, but the
    result to be returned is not itself a task. You can wrap the return value in a
    successfully completed task, return an exception, or indicate that the task was
    canceled by using one of the methods shown in the following table:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `FromResult<TResult>(TResult)` | Creates a `Task<TResult>` object whose `Result`
    property is the non-task result and whose `Status` property is `RanToCompletion`.
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `FromException<TResult>(Exception)` | Creates a `Task<TResult>` that''s completed
    with a specified exception. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `FromCanceled<TResult>(CancellationToken)` | Creates a `Task<TResult>` that''s
    completed due to cancellation with a specified cancellation token. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: 'These methods are useful when you need to:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Implement an interface that has async methods, but your implementation is synchronous.
    This is common for websites and services.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock asynchronous implementations during unit testing.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 7*, *Packaging and Distributing .NET Types*, we created a class
    library with functions to check valid XML, passwords, and hex codes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had wanted to make those methods conform to an interface that requires
    a `Task<T>` to be returned, we could use these helpful methods, as shown in the
    following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the method you need to implement returns a `Task` (equivalent to `void`
    in a synchronous method) then you can return a predefined completed `Task` object,
    as shown in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Synchronizing access to shared resources
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have multiple threads executing at the same time, there is a possibility
    that two or more of the threads may access the same variable or another resource
    at the same time, and as a result, may cause a problem. For this reason, you should
    carefully consider how to make your code **thread-safe**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The simplest mechanism for implementing thread safety is to use an object variable
    as a flag or traffic light to indicate when a shared resource has an exclusive
    lock applied.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In William Golding's *Lord of the Flies*, Piggy and Ralph spot a conch shell
    and use it to call a meeting. The boys impose a "rule of the conch" on themselves,
    deciding that no one can speak unless they're holding the conch.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: I like to name the object variable I use for implementing thread-safe code the
    "conch." When a thread has the conch, no other thread should access the shared
    resource(s) represented by that conch. Note that I say, *should*. Only code that
    respects the conch enables synchronized access. A conch is not a lock.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore a couple of types that can be used to synchronize access to
    shared resources:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`Monitor`: An object that can be used by multiple threads to check if they
    should access a shared resource within the same process.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Interlocked`: An object for manipulating simple numeric types at the CPU level.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a resource from multiple threads
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `SynchronizingResourceAccess`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `SynchronizingResourceAccess` as the active OmniSharp
    project.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    do the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the namespace for diagnostic types like `Stopwatch`.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Statically import the `Console` type.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs`, create a static class with two fields:'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A field to generate random wait times.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `string` field to store a message (this is a shared resource).
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Above the class, create two static methods that add a letter, A or B, to the
    shared `string` five times in a loop, and wait for a random interval of up to
    2 seconds for each iteration:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After the namespace imports, write statements to execute both methods on separate
    threads using a pair of tasks and wait for them to complete before outputting
    the elapsed milliseconds, as shown in the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This shows that both threads were modifying the message concurrently. In an
    actual application, this could be a problem. But we can prevent concurrent access
    by applying a mutually exclusive lock to a conch object and code to the two methods
    to voluntarily check the conch before modifying the shared resource, which we
    will do in the following section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Applying a mutually exclusive lock to a conch
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's use a conch to ensure that only one thread accesses the shared resource
    at a time.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SharedObjects`, declare and instantiate an `object` variable to act as
    a conch, as shown in the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In both `MethodA` and `MethodB`, add a `lock` statement for the conch around
    the `for` statements, as shown highlighted in the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Good Practice**: Note that since checking the conch is voluntary, if you
    only use the `lock` statement in one of the two methods, the shared resource will
    continue to be accessed by both methods. Make sure that all methods that access
    a shared resource respect the conch.'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although the time elapsed was longer, only one method at a time could access
    the shared resource. Either `MethodA` or `MethodB` can start first. Once a method
    has finished its work on the shared resource, then the conch gets released, and
    the other method has the chance to do its work.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the lock statement
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might wonder what the `lock` statement does when it "locks" an object variable
    (hint: it does not lock the object!), as shown in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The C# compiler changes the `lock` statement into a `try`-`finally` statement
    that uses the `Monitor` class to *enter* and *exit* the conch object (I like to
    think of it as *take* and *release* the conch object), as shown in the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When a thread calls `Monitor.Enter` on any object, aka reference type, it checks
    to see if some other thread has already taken the conch. If it has, the thread
    waits. If it has not, the thread takes the conch and gets on with its work on
    the shared resource. Once the thread has finished its work, it calls `Monitor.Exit`,
    releasing the conch. If another thread was waiting, it can now take the conch
    and do its work. This requires all threads to respect the conch by calling `Monitor.Enter`
    and `Monitor.Exit` appropriately.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deadlocks
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knowing how the `lock` statement is translated by the compiler to method calls
    on the `Monitor` class is also important because using the `lock` statement can
    cause a deadlock.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Deadlocks can occur when there are two or more shared resources (each with
    a conch to monitor which thread is currently doing work on each shared resource),
    and the following sequence of events happens:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Thread X "locks" conch A and starts working on shared resource A.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread Y "locks" conch B and starts working on shared resource B.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While still working on resource A, thread X needs to also work with resource
    B, and so it attempts to "lock" conch B but is blocked because thread Y already
    has conch B.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While still working on resource B, thread Y needs to also work with resource
    A, and so it attempts to "lock" conch A but is blocked because thread X already
    has conch A.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One way to prevent deadlocks is to specify a timeout when attempting to get
    a lock. To do this, you must manually use the `Monitor` class instead of using
    the `lock` statement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your code to replace the `lock` statements with code that tries to enter
    the conch with a timeout and outputs an error and then exits the monitor, allowing
    other threads to enter the monitor, as shown highlighted in the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the code and view the result, which should return the same results as before
    (although either A or B could grab the conch first) but is better code because
    it will prevent potential deadlocks.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: Only use the `lock` keyword if you can write your code such
    that it avoids potential deadlocks. If you cannot avoid potential deadlocks, then
    always use the `Monitor.TryEnter` method instead of `lock`, in combination with
    a `try`-`finally` statement, so that you can supply a timeout and one of the threads
    will back out of a deadlock if it occurs. You can read more about good threading
    practices at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing events
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 6*, *Implementing Interfaces and Inheriting Classes*, you learned
    how to raise and handle events. But .NET events are not thread-safe, so you should
    avoid using them in multithreaded scenarios and follow the standard event raising
    code I showed you earlier.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning that .NET events are not thread-safe, some developers attempt
    to use exclusive locks when adding and removing event handlers or when raising
    an event, as shown in the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Good Practice**: You can read more about events and thread-safety at the
    following link: [https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'But it is complicated, as explained by Stephen Cleary in the following blog
    post: [https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Making CPU operations atomic
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Atomic is from the Greek word **atomos**, which means *undividable*. It is important
    to understand which operations are atomic in multithreading because if they are
    not atomic, then they could be interrupted by another thread partway through their
    operation. Is the C# increment operator atomic, as shown in the following code?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is not atomic! Incrementing an integer requires the following three CPU
    operations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Load a value from an instance variable into a register.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the value.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the value in the instance variable.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread could be interrupted after executing the first two steps. A second
    thread could then execute all three steps. When the first thread resumes execution,
    it will overwrite the value in the variable, and the effect of the increment or
    decrement performed by the second thread will be lost!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a type named `Interlocked` that can perform atomic actions on value
    types, such as integers and floats. Let''s see it in action:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare another field in the `SharedObjects` class that will count how many
    operations have occurred, as shown in the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In both methods A and B, inside the `for` statement and after modifying the
    `string` value, add a statement to safely increment the counter, as shown in the
    following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After outputting the elapsed time, write the current value of the counter to
    the console, as shown in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the code and view the result, as shown highlighted in the following output:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Observant readers will realize that the existing conch object protects all shared
    resources accessed within a block of code locked by the conch, and therefore it
    is actually unnecessary to use `Interlocked` in this specific example. But if
    we had not already been protecting another shared resource like `Message` then
    using `Interlocked` would be necessary.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Applying other types of synchronization
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Monitor` and `Interlocked` are mutually exclusive locks that are simple and
    effective, but sometimes, you need more advanced options to synchronize access
    to shared resources, as shown in the following table:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| `ReaderWriterLock` and `ReaderWriterLockSlim` | These allow multiple threads
    to be in **read mode**, one thread to be in **write mode** with exclusive ownership
    of the write lock, and one thread that has read access to be in **upgradeable
    read mode**, from which the thread can upgrade to write mode without having to
    relinquish its read access to the resource. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| `Mutex` | Like `Monitor`, this provides exclusive access to a shared resource,
    except it is used for inter-process synchronization. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| `Semaphore` and `SemaphoreSlim` | These limit the number of threads that
    can access a resource or pool of resources concurrently by defining slots. This
    is known as resource throttling rather than resource locking. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| `AutoResetEvent` and `ManualResetEvent` | Event wait handles allow threads
    to synchronize activities by signaling each other and by waiting for each other''s
    signals. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: Understanding async and await
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# 5 introduced two C# keywords when working with the `Task` type. They are
    especially useful for the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multitasking for a **graphical user interface** (**GUI**).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the scalability of web applications and web services.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 15*, *Building Websites Using the Model-View-Controller Pattern*,
    we will see how the `async` and `await` keywords can improve scalability for websites.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 19*, *Building Mobile and Desktop Apps Using .NET MAUI*, we will
    see how the `async` and `await` keywords can implement multitasking for a GUI.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: But for now, let's learn the theory of why these two C# keywords were introduced,
    and then later you will see them used in practice.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Improving responsiveness for console apps
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the limitations with console applications is that you can only use the
    `await` keyword inside methods that are marked as `async` but C# 7 and earlier
    do not allow the `Main` method to be marked as async! Luckily, a new feature introduced
    in C# 7.1 was support for `async` in `Main`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncConsole`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `AsyncConsole` as the active OmniSharp project.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and statically import `Console`,
    as shown in the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add statements to create an `HttpClient` instance, make a request for Apple''s
    home page, and output how many bytes it has, as shown in the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Build the project and note that it builds successfully. In .NET 5 and earlier,
    you would have seen an error message, as shown in the following output:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You would have had to add the `async` keyword to the `Main` method and change
    its return type to `Task`. With .NET 6 and later, the console app project template
    uses the top-level program feature to automatically define the `Program` class
    with an asynchronous `Main` method for you.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, which is likely to have a different number
    of bytes since Apple changes its home page frequently, as shown in the following
    output:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Improving responsiveness for GUI apps
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this book, we have only built console applications. Life for a programmer
    gets more complicated when building web applications, web services, and apps with
    GUIs such as Windows desktop and mobile apps.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason for this is that for a GUI app, there is a special thread: the **user
    interface** (**UI**) thread.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two rules for working in GUIs:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Do not perform long-running tasks on the UI thread.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not access UI elements on any thread except the UI thread.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle these rules, programmers used to have to write complex code to ensure
    that long- running tasks were executed by a non-UI thread, but once complete,
    the results of the task were safely passed to the UI thread to present to the
    user. It could quickly get messy!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, with C# 5 and later, you have the use of `async` and `await`. They
    allow you to continue to write your code as if it is synchronous, which keeps
    your code clean and easy to understand, but underneath, the C# compiler creates
    a complex state machine and keeps track of running threads. It's kind of magical!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example. We will build a Windows desktop app using WPF that gets
    employees from the Northwind database in an SQL Server database using low-level
    types like `SqlConnection`, `SqlCommand`, and `SqlDataReader`. You will only be
    able to complete this task if you have Windows and the Northwind database stored
    in SQL Server. This is the only section in this book that is not cross-platform
    and modern (WPF is 16 years old!).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are focusing on making a GUI app responsive. You will learn
    about XAML and building cross-platform GUI apps in *Chapter 19*, *Building Mobile
    and Desktop Apps Using .NET MAUI*. Since this book does not cover WPF elsewhere,
    I thought this task would be a good opportunity to at least see an example app
    built using WPF even if we do not look at it in detail.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Let's go!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio 2022 for Windows, add a new **WPF Application
    [C#]** project named `WpfResponsive` to the `Chapter12` solution. If you are using
    Visual Studio Code, use the following command: `dotnet new wpf`.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project file, note the output type is a Windows EXE, the target framework
    is .NET 6 for Windows (it will not run on other platforms like macOS and Linux),
    and the project uses WPF.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a package reference for `Microsoft.Data.SqlClient` to the project, as shown
    highlighted in the following markup:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Build the project to restore packages.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml`, in the `<Grid>` element, add elements to define two buttons,
    a text box and a list box, laid out vertically in a stack panel, as shown highlighted
    in the following markup:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Visual Studio 2022 for Windows has good support for building WPF apps and will
    provide IntelliSense as you edit code and XAML markup. Visual Studio Code does
    not.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml.cs`, in the `MainWindow` class, import the `System.Diagnostics`
    and `Microsoft.Data.SqlClient` namespaces, then create two `string` constants
    for the database connection string and SQL statement and create event handlers
    for clicking on the two buttons that use those `string` constants to open a connection
    to the Northwind database and populate the list box with the ids and names of
    all employees, as shown in the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note the following:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The SQL statement uses the SQL Server command `WAITFOR DELAY` to simulate processing
    that takes five seconds. It then selects three columns from the `Employees` table.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployeesSyncButton_Click` event handler uses synchronous methods to
    open a connection and fetch the employee rows.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployeesAsyncButton_Click` event handler is marked as `async` and uses
    asynchronous methods with the `await` keyword to open a connection and fetch the
    employee rows.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Both event handlers use a stopwatch to record the number of milliseconds the
    operation takes and add it to the list box.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the WPF app without debugging.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is responsive.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Get Employees Synchronously** button.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to click in the text box, and note the GUI is not responsive.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for at least five seconds until the list box is filled with employees.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is responsive again.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Get Employees Asynchronously** button.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is still responsive
    while it performs the operation. Continue typing until the list box is filled
    with the employees.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the difference in timings for the two operations. The UI is blocked when
    fetching data synchronously, while the UI remains responsive when fetching data
    asynchronously.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the WPF app.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improving scalability for web applications and web services
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `async` and `await` keywords can also be applied on the server side when
    building websites, applications, and services. From the client application's point
    of view, nothing changes (or they might even notice a small increase in the time
    taken for a request to return). So, from a single client's point of view, the
    use of `async` and `await` to implement multitasking on the server side makes
    their experience worse!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, additional, cheaper worker threads are created to wait for
    long-running tasks to finish so that expensive I/O threads can handle other client
    requests instead of being blocked. This improves the overall scalability of a
    web application or service. More clients can be supported simultaneously.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Common types that support multitasking
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many common types that have asynchronous methods that you can await,
    as shown in the following table:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Methods |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| `DbContext<T>` | `AddAsync`, `AddRangeAsync`, `FindAsync`, and `SaveChangesAsync`
    |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| `DbSet<T>` | `AddAsync`, `AddRangeAsync`, `ForEachAsync`, `SumAsync`, `ToListAsync`,
    `ToDictionaryAsync`, `AverageAsync`, and `CountAsync` |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| `HttpClient` | `GetAsync`, `PostAsync`, `PutAsync`, `DeleteAsync`, and `SendAsync`
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| `StreamReader` | `ReadAsync`, `ReadLineAsync`, and `ReadToEndAsync` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| `StreamWriter` | `WriteAsync`, `WriteLineAsync`, and `FlushAsync` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '**Good Practice**: Any time you see a method that ends in the suffix `Async`,
    check to see whether it returns `Task` or `Task<T>`. If it does, then you could
    use it instead of the synchronous non-`Async` suffixed method. Remember to call
    it using `await` and decorate your method with `async`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Using await in catch blocks
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `async` and `await` were first introduced in C# 5, it was only possible
    to use the `await` keyword in a `try` block, but not in a `catch` block. In C#
    6 and later, it is now possible to use `await` in both `try` and `catch` blocks.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Working with async streams
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With .NET Core 3.0, Microsoft introduced the asynchronous processing of streams.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'You can complete a tutorial about async streams at the following link: [https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Before C# 8.0 and .NET Core 3.0, the `await` keyword only worked with tasks
    that return scalar values. Async stream support in .NET Standard 2.1 allows an
    `async` method to return a sequence of values.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a simulated example that returns three random integers as an async
    stream.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncEnumerable`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `AsyncEnumerable` as the active OmniSharp project.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements and statically import `Console`,
    as shown in the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'At the bottom of `Program.cs`, create a method that uses the `yield` keyword
    to return a random sequence of three numbers asynchronously, as shown in the following
    code:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Above `GetNumbersAsync`, add statements to enumerate the sequence of numbers,
    as shown in the following code:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Practicing and exploring
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.1 – Test your knowledge
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: What information can you find out about a process?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How accurate is the `Stopwatch` class?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By convention, what suffix should be applied to a method that returns `Task`
    or `Task<T>`?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the `await` keyword inside a method, what keyword must be applied to
    the method declaration?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a child task?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you avoid the `lock` keyword?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `Interlocked` class?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `Mutex` class instead of the `Monitor` class?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应使用`Mutex`类而不是`Monitor`类？
- en: What is the benefit of using `async` and `await` in a website or web service?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网站或网络服务中使用`async`和`await`有何好处？
- en: Can you cancel a task? If so, how?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能取消一个任务吗？如果可以，如何操作？
- en: Exercise 12.2 – Explore topics
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.2 – 探索主题
- en: 'Use the links on the following webpage to learn more detail about the topics
    covered in this chapter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用以下网页上的链接，以了解更多关于本章所涵盖主题的详细信息：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章 - 使用多任务提高性能和可扩展性](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)'
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned not only how to define and start a task but also
    how to wait for one or more tasks to finish and how to control task completion
    order. You've also learned how to synchronize access to shared resources and the
    magic behind `async` and `await`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你不仅学会了如何定义和启动任务，还学会了如何等待一个或多个任务完成，以及如何控制任务完成的顺序。你还学习了如何同步访问共享资源以及`async`和`await`背后的奥秘。
- en: In the seven chapters that follow, you will learn how to create applications
    for the **app models**, aka **workloads** supported by .NET, such as websites
    and services, and cross-platform desktop and mobile apps.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的七章中，你将学习如何为.NET支持的**应用模型**，即**工作负载**，创建应用程序，例如网站和服务，以及跨平台的桌面和移动应用。
