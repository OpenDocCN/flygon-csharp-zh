- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Improving Performance and Scalability Using Multitasking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多任务处理提高性能和可扩展性
- en: This chapter is about allowing multiple actions to occur at the same time to
    improve performance, scalability, and user productivity for the applications that
    you build.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在通过允许多个操作同时发生，以提高您构建的应用程序的性能、可扩展性和用户生产力。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding processes, threads, and tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解进程、线程和任务
- en: Monitoring performance and resource usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控性能和资源使用情况
- en: Running tasks asynchronously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: Synchronizing access to shared resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: Understanding `async` and `await`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`async`和`await`
- en: Understanding processes, threads, and tasks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解进程、线程和任务
- en: A **process**, with one example being each of the console applications we have
    created, has resources like memory and threads allocated to it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程**，例如我们创建的每个控制台应用程序，都分配有内存和线程等资源。'
- en: A **thread** executes your code, statement by statement. By default, each process
    only has one thread, and this can cause problems when we need to do more than
    one task at the same time. Threads are also responsible for keeping track of things
    like the currently authenticated user and any internationalization rules that
    should be followed for the current language and region.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**执行您的代码，逐条语句执行。默认情况下，每个进程只有一个线程，当我们需要同时执行多个任务时，这可能会导致问题。线程还负责跟踪当前已验证的用户以及应遵循的当前语言和区域的任何国际化规则等事项。'
- en: Windows and most other modern operating systems use **preemptive multitasking**,
    which simulates the parallel execution of tasks. It divides the processor time
    among the threads, allocating a **time slice** to each thread one after another.
    The current thread is suspended when its time slice finishes. The processor then
    allows another thread to run for a time slice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和大多数其他现代操作系统使用**抢占式多任务处理**，它模拟任务的并行执行。它将处理器时间分配给各个线程，为每个线程分配一个**时间片**，一个接一个。当当前线程的时间片结束时，它会被挂起，处理器随后允许另一个线程运行一个时间片。
- en: When Windows switches from one thread to another, it saves the context of the
    thread and reloads the previously saved context of the next thread in the thread
    queue. This takes both time and resources to complete.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当Windows从一个线程切换到另一个线程时，它会保存当前线程的上下文，并重新加载线程队列中下一个线程之前保存的上下文。这个过程需要时间和资源来完成。
- en: As a developer, if you have a small number of complex pieces of work and you
    want complete control over them, then you could create and manage individual `Thread`
    instances. If you have one main thread and multiple small pieces of work that
    can be executed in the background, then you can use the `ThreadPool` class to
    add delegate instances that point to those pieces of work implemented as methods
    to a queue, and they will be automatically allocated to threads in the thread
    pool.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，如果您有少量复杂的工作且希望完全控制它们，那么您可以创建和管理单独的`Thread`实例。如果您有一个主线程和多个可以在后台执行的小任务，那么您可以使用`ThreadPool`类将指向这些作为方法实现的任务的委托实例添加到队列中，它们将自动分配给线程池中的线程。
- en: In this chapter, we will use the `Task` type to manage threads at a higher abstraction
    level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`Task`类型以更高的抽象级别管理线程。
- en: Threads may have to compete for and also wait for access to shared resources,
    such as variables, files, and database objects. There are types for managing this
    that you will see in action later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可能需要竞争和等待访问共享资源，例如变量、文件和数据库对象。本章后面您将看到用于管理这些资源的各种类型。
- en: Depending on the task, doubling the number of threads (workers) to perform a
    task does not halve the number of seconds that it will take to complete that task.
    In fact, it can increase the duration of the task.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据任务的不同，将执行任务的线程（工作者）数量加倍并不一定会将完成任务所需的时间减半。事实上，它可能会增加任务的持续时间。
- en: '**Good Practice**: Never assume that more threads will improve performance!
    Run performance tests on a baseline code implementation without multiple threads,
    and then again on a code implementation with multiple threads. You should also
    perform performance tests in a staging environment that is as close as possible
    to the production environment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：切勿假设增加线程数量会提高性能！在未使用多线程的基准代码实现上运行性能测试，然后在使用了多线程的代码实现上再次运行。您还应在尽可能接近生产环境的预生产环境中进行性能测试。'
- en: Monitoring performance and resource usage
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控性能和资源使用
- en: Before we can improve the performance of any code, we need to be able to monitor
    its speed and efficiency to record a baseline that we can then measure improvements
    against.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够改进任何代码的性能之前，我们需要能够监控其速度和效率，以记录一个基准，然后我们可以据此衡量改进。
- en: Evaluating the efficiency of types
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估类型的效率
- en: 'What is the best type to use for a scenario? To answer this question, we need
    to carefully consider what we mean by "best", and through this, we should consider
    the following factors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个场景，最佳类型是什么？要回答这个问题，我们需要仔细考虑我们所说的“最佳”是什么意思，并通过这一点，我们应该考虑以下因素：
- en: '**Functionality**: This can be decided by checking whether the type provides
    the features you need.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性**：这可以通过检查类型是否提供了你所需的功能来决定。'
- en: '**Memory size**: This can be decided by the number of bytes of memory the type
    takes up.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存大小**：这可以通过类型占用的内存字节数来决定。'
- en: '**Performance**: This can be decided by how fast the type is.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：这可以通过类型的运行速度来决定。'
- en: '**Future needs**: This depends on the changes in requirements and maintainability.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未来需求**：这取决于需求和可维护性的变化。'
- en: There will be scenarios, such as when storing numbers, where multiple types
    have the same functionality, so we will need to consider memory and performance
    to make a choice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储数字等场景中，将会有多种类型具有相同的功能，因此我们需要考虑内存和性能来做出选择。
- en: If we need to store millions of numbers, then the best type to use would be
    the one that requires the fewest bytes of memory. But if we only need to store
    a few numbers, yet we need to perform lots of calculations on them, then the best
    type to use would be the one that runs fastest on a specific CPU.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要存储数百万个数字，那么最佳类型将是占用内存字节数最少的那个。但如果我们只需要存储几个数字，而我们又需要对它们进行大量计算，那么最佳类型将是在特定CPU上运行最快的那个。
- en: You have seen the use of the `sizeof()` function, which shows the number of
    bytes a single instance of a type uses in memory. When we are storing a large
    number of values in more complex data structures, such as arrays and lists, then
    we need a better way of measuring memory usage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经见过使用`sizeof()`函数的情况，它显示了内存中一个类型实例所占用的字节数。当我们存储大量值在更复杂的数据结构中，如数组和列表时，我们需要一种更好的方法来测量内存使用情况。
- en: You can read lots of advice online and in books, but the only way to know for
    sure what the best type would be for your code is to compare the types yourself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在网上和书籍中阅读大量建议，但确定哪种类型最适合你的代码的唯一方法是自己比较这些类型。
- en: In the next section, you will learn how to write code to monitor the actual
    memory requirements and performance when using different types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何编写代码来监控使用不同类型时的实际内存需求和性能。
- en: Today a `short` variable might be the best choice, but it might be an even better
    choice to use an `int` variable, even though it takes twice as much space in the
    memory. This is because we might need a wider range of values to be stored in
    the future.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，`short`变量可能是最佳选择，但使用`int`变量可能是更好的选择，尽管它在内存中占用两倍的空间。这是因为我们将来可能需要存储更广泛的值。
- en: 'There is an important metric that developers often forget: maintenance. This
    is a measure of how much effort another programmer would have to put in to understand
    and modify your code. If you make a nonobvious choice of type without explaining
    that choice with a helpful comment, then it might confuse the programmer who comes
    along later and needs to fix a bug or add a feature.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常忽视的一个重要指标是维护性。这是衡量另一个程序员为了理解和修改你的代码需要付出多少努力的指标。如果你做出一个不明显的类型选择，并且没有用有帮助的注释解释这个选择，那么可能会让后来需要修复错误或添加功能的程序员感到困惑。
- en: Monitoring performance and memory using diagnostics
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用诊断监控性能和内存
- en: 'The `System.Diagnostics` namespace has lots of useful types for monitoring
    your code. The first useful type that we will look at is the `Stopwatch` type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics`命名空间包含许多用于监控代码的有用类型。我们将首先查看的有用类型是`Stopwatch`类型：'
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter12`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的编程工具创建一个名为`Chapter12`的新工作区/解决方案。
- en: 'Add a class library project, as defined in the following list:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类库项目，如以下列表所定义：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Workspace/solution file and folder: `Chapter12`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter12`
- en: 'Project file and folder: `MonitoringLib`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`MonitoringLib`
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用程序项目，如下所列：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter12`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`Chapter12`
- en: 'Project file and folder: `MonitoringApp`'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`MonitoringApp`
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，将解决方案的启动项目设置为当前选择的项目。
- en: In Visual Studio Code, select `MonitoringApp` as the active OmniSharp project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`MonitoringApp`作为活动的OmniSharp项目。
- en: In the `MonitoringLib` project, rename the `Class1.cs` file to `Recorder.cs`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MonitoringLib`项目中，将`Class1.cs`文件重命名为`Recorder.cs`。
- en: 'In the `MonitoringApp` project, add a project reference to the `MonitoringLib`
    class library, as shown in the following markup:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MonitoringApp`项目中，添加对`MonitoringLib`类库的项目引用，如下所示：
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build the `MonitoringApp` project.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`MonitoringApp`项目。
- en: Useful members of the Stopwatch and Process types
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用的Stopwatch和Process类型成员
- en: 'The `Stopwatch` type has some useful members, as shown in the following table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch`类型有一些有用的成员，如下表所示：'
- en: '| Member | Description |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| `Restart` method | This resets the elapsed time to zero and then starts the
    timer. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Restart` 方法 | 这会将经过时间重置为零，然后启动计时器。 |'
- en: '| `Stop` method | This stops the timer. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Stop` 方法 | 这会停止计时器。 |'
- en: '| `Elapsed` property | This is the elapsed time stored as a `TimeSpan` format
    (for example, hours:minutes:seconds) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Elapsed` 属性 | 这是以`TimeSpan`格式存储的经过时间（例如，小时:分钟:秒） |'
- en: '| `ElapsedMilliseconds` property | This is the elapsed time in milliseconds
    stored as an `Int64` value. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `ElapsedMilliseconds` 属性 | 这是以毫秒为单位的经过时间，存储为`Int64`值。 |'
- en: 'The `Process` type has some useful members, as shown in the following table:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process`类型有一些有用的成员，如下表所示：'
- en: '| Member | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| `VirtualMemorySize64` | This displays the amount of virtual memory, in bytes,
    allocated for the process. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `VirtualMemorySize64` | 这显示了为进程分配的虚拟内存量，单位为字节。 |'
- en: '| `WorkingSet64` | This displays the amount of physical memory, in bytes, allocated
    for the process. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `WorkingSet64` | 这显示了为进程分配的物理内存量，单位为字节。 |'
- en: Implementing a Recorder class
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个Recorder类
- en: 'We will create a `Recorder` class that makes it easy to monitor time and memory
    resource usage. To implement our `Recorder` class, we will use the `Stopwatch`
    and `Process` classes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Recorder`类，使监控时间和内存资源使用变得简单。为了实现我们的`Recorder`类，我们将使用`Stopwatch`和`Process`类：
- en: 'In `Recorder.cs`, change its contents to use a `Stopwatch` instance to record
    timings and the current `Process` instance to record memory usage, as shown in
    the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recorder.cs`中，修改其内容以使用`Stopwatch`实例记录时间，并使用当前`Process`实例记录内存使用情况，如下所示：
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Start` method of the `Recorder` class uses the `GC` type (garbage collector)
    to ensure that any currently allocated but not referenced memory is collected
    before recording the amount of used memory. This is an advanced technique that
    you should almost never use in application code.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Recorder`类的`Start`方法使用`GC`类型（垃圾收集器）确保在记录已用内存量之前，收集任何当前已分配但未引用的内存。这是一种高级技术，您几乎不应在应用程序代码中使用。'
- en: 'In `Program.cs`, write statements to start and stop the `Recorder` while generating
    an array of 10,000 integers, as shown in the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，编写语句以在生成10,000个整数的数组时启动和停止`Recorder`，如下所示：
- en: '[PRE2]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Remember that the time elapsed is randomly between 5 and 10 seconds. Your results
    will vary. For example, when run on my Mac mini M1, less physical memory but more
    virtual memory was used, as shown in the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，时间间隔随机在5到10秒之间，您的结果可能会有所不同。例如，在我的Mac mini M1上运行时，虽然物理内存较少，但虚拟内存使用更多，如下所示：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Measuring the efficiency of processing strings
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量字符串处理的效率
- en: Now that you've seen how the `Stopwatch` and `Process` types can be used to
    monitor your code, we will use them to evaluate the best way to process `string`
    variables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经了解了如何使用`Stopwatch`和`Process`类型来监控您的代码，我们将使用它们来评估处理`string`变量的最佳方式。
- en: 'In `Program.cs`, comment out the previous statements by wrapping them in multi-line
    comment characters: `/* */`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，通过使用多行注释字符`/* */`将之前的语句注释掉。
- en: 'Write statements to create an array of 50,000 `int` variables and then concatenate
    them with commas as separators using a `string` and `StringBuilder` class, as
    shown in the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语句以创建一个包含50,000个`int`变量的数组，然后使用`string`和`StringBuilder`类用逗号作为分隔符将它们连接起来，如下所示：
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下所示：
- en: '[PRE6]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can summarize the results as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结结果如下：
- en: The `string` class with the `+` operator used about 14 MB of physical memory,
    1.5 MB of virtual memory, and took 1.5 seconds.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`类使用`+`运算符大约使用了14 MB的物理内存，1.5 MB的虚拟内存，耗时1.5秒。'
- en: The `StringBuilder` class used 12 KB of physical memory, zero virtual memory,
    and took less than 1 millisecond.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringBuilder`类使用了12 KB的物理内存，零虚拟内存，耗时不到1毫秒。'
- en: In this scenario, `StringBuilder` is more than 1,000 times faster and about
    10,000 times more memory efficient when concatenating text! This is because `string`
    concatenation creates a new `string` each time you use it because `string` values
    are immutable so they can be safely pooled for reuse. `StringBuilder` creates
    a single buffer while it appends more characters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`StringBuilder`在连接文本时速度快了1000多倍，内存效率提高了约10000倍！这是因为`string`连接每次使用时都会创建一个新的`string`，因为`string`值是不可变的，所以它们可以安全地池化以供重用。`StringBuilder`在追加更多字符时创建一个单一缓冲区。
- en: '**Good Practice**: Avoid using the `String.Concat` method or the `+` operator
    inside loops. Use `StringBuilder` instead.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：避免在循环内部使用`String.Concat`方法或`+`运算符。改用`StringBuilder`。'
- en: Now that you've learned how to measure the performance and resource efficiency
    of your code using types built into .NET, let's learn about a NuGet package that
    provides more sophisticated performance measurements.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经学会了如何使用.NET内置类型来衡量代码的性能和资源效率，接下来让我们了解一个提供更复杂性能测量的NuGet包。
- en: Monitoring performance and memory using Benchmark.NET
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Benchmark.NET监控性能和内存
- en: 'There is a popular benchmarking NuGet package for .NET that Microsoft uses
    in its blog posts about performance improvements, so it is good for .NET developers
    to know how it works and use it for their own performance testing. Let''s see
    how we could use it to compare performance between `string` concatenation and
    `StringBuilder`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个流行的.NET基准测试NuGet包，微软在其关于性能改进的博客文章中使用，因此对于.NET开发者来说，了解其工作原理并用于自己的性能测试是很有益的。让我们看看如何使用它来比较`string`连接和`StringBuilder`的性能：
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `Benchmarking`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，向名为`Benchmarking`的`Chapter12`解决方案/工作区添加一个新的控制台应用程序。
- en: In Visual Studio Code, select `Benchmarking` as the active OmniSharp project.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Benchmarking`作为活动OmniSharp项目。
- en: 'Add a package reference to Benchmark.NET, remembering that you can find out
    the latest version and use that instead of the version I used, as shown in the
    following markup:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对Benchmark.NET的包引用，记住您可以查找最新版本并使用它，而不是我使用的版本，如下所示：
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Build the project to restore packages.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: 'In `Program.cs`, delete the existing statements and then import the namespace
    for running benchmarks, as shown in the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句，然后导入运行基准测试的命名空间，如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add a new class file named `StringBenchmarks.cs`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`StringBenchmarks.cs`的新类文件。
- en: 'In `StringBenchmarks.cs`, add statements to define a class with methods for
    each benchmark you want to run, in this case, two methods that both combine twenty
    numbers comma-separated using either `string` concatenation or `StringBuilder`,
    as shown in the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StringBenchmarks.cs`中，添加语句来定义一个包含每个基准测试所需方法的类，在这种情况下，两个方法都使用`string`连接或`StringBuilder`将二十个数字以逗号分隔进行组合，如下所示：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `Program.cs`, add a statement to run the benchmarks, as shown in the following
    code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个语句来运行基准测试，如下所示：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In Visual Studio 2022, in the toolbar, set **Solution Configurations** to **Release**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，在工具栏上，将**解决方案配置**设置为**发布**。
- en: In Visual Studio Code, in a terminal, use the `dotnet run --configuration Release`
    command.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在终端中使用`dotnet run --configuration Release`命令。
- en: 'Run the console app and note the results, including some artifacts like report
    files, and the most important, a summary table that shows that `string` concatenation
    took a mean of 412.990 ns and `StringBuilder` took a mean of 275.082 ns, as shown
    in the following partial output and in *Figure 12.1*:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用并注意结果，包括一些报告文件等附属物，以及最重要的，一张总结表显示`string`拼接平均耗时412.990 ns，而`StringBuilder`平均耗时275.082
    ns，如下部分输出及*图12.1*所示：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/B17442_13_02.png)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17442_13_02.png)'
- en: 'Figure 12.1: Summary table that shows StringBuilder takes 69% of the time compared
    to string concatenation'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.1：总结表显示StringBuilder耗时为字符串拼接的69%
- en: The `Outliers` section is especially interesting because it shows that not only
    is `string` concatenation slower than `StringBuilder`, but it is also more inconsistent
    in how long it takes. Your results will vary, of course.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Outliers`部分尤为有趣，因为它表明不仅`string`拼接比`StringBuilder`慢，而且其耗时也更不稳定。当然，你的结果可能会有所不同。'
- en: You have now seen two ways to measure performance. Now let's see how we can
    run tasks asynchronously to potentially improve performance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经见识了两种性能测量方法。现在让我们看看如何异步运行任务以潜在提升性能。
- en: Running tasks asynchronously
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步执行任务
- en: To understand how multiple tasks can be run simultaneously (at the same time),
    we will create a console application that needs to execute three methods.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何同时运行多个任务（同时进行），我们将创建一个需要执行三个方法的控制台应用程序。
- en: 'There will be three methods that need to be executed: the first takes 3 seconds,
    the second takes 2 seconds, and the third takes 1 second. To simulate that work,
    we can use the `Thread` class to tell the current thread to go to sleep for a
    specified number of milliseconds.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行三种方法：第一种耗时3秒，第二种耗时2秒，第三种耗时1秒。为了模拟这项工作，我们可以使用`Thread`类让当前线程休眠指定毫秒数。
- en: Running multiple actions synchronously
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步执行多个操作
- en: Before we make the tasks run simultaneously, we will run them synchronously,
    that is, one after the other.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们让任务同时运行之前，我们将同步运行它们，即一个接一个地执行。
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `WorkingWithTasks`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器，在`Chapter12`解决方案/工作区中添加一个名为`WorkingWithTasks`的新控制台应用。
- en: In Visual Studio Code, select `WorkingWithTasks` as the active OmniSharp project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`WorkingWithTasks`作为活动OmniSharp项目。
- en: 'In `Program.cs`, import the namespace to work with a stopwatch (namespaces
    for working with threading and tasks are implicitly imported), and statically
    import `Console`, as shown in the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，导入用于操作秒表的命名空间（与线程和任务相关的命名空间已隐式导入），并静态导入`Console`，如下代码所示：
- en: '[PRE12]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the bottom of `Program.cs`, create a method to output information about
    the current thread, as shown in the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个方法输出当前线程信息，如下代码所示：
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the bottom of `Program.cs`, add three methods that simulate work, as shown
    in the following code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，添加三个模拟工作的方法，如下代码所示：
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At the top of `Program.cs`, add statements to call the method to output information
    about the thread, define and start a stopwatch, call the three simulated work
    methods, and then output the milliseconds elapsed, as shown in the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`顶部，添加语句调用输出线程信息的方法，定义并启动秒表，调用三个模拟工作方法，然后输出经过的毫秒数，如下代码所示：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the code, view the result, and note that when there is only one unnamed
    foreground thread doing the work, the total time required is just over 6 seconds,
    as shown in the following output:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意当仅有一个未命名前台线程执行任务时，所需总时间略超过6秒，如下输出所示：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running multiple actions asynchronously using tasks
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用任务异步执行多个操作
- en: The `Thread` class has been available since the first version of .NET and can
    be used to create new threads and manage them, but it can be tricky to work with
    directly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类自.NET的首个版本起就已存在，可用于创建新线程并管理它们，但直接使用可能较为棘手。'
- en: .NET Framework 4.0 introduced the `Task` class in 2010, which is a wrapper around
    a thread that enables easier creation and management. Managing multiple threads
    wrapped in tasks will allow our code to execute at the same time, aka asynchronously.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework 4.0于2010年引入了`Task`类，它是对线程的封装，使得创建和管理更为简便。通过管理多个封装在任务中的线程，我们的代码将能够同时执行，即异步执行。
- en: Each `Task` has a `Status` property and a `CreationOptions` property. A `Task`
    has a `ContinueWith` method that can be customized with the `TaskContinuationOptions`
    enum, and can be managed with the `TaskFactory` class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Task`都有一个`Status`属性和一个`CreationOptions`属性。`Task`有一个`ContinueWith`方法，可以通过`TaskContinuationOptions`枚举进行定制，并可以使用`TaskFactory`类进行管理。
- en: Starting tasks
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动任务
- en: 'We will look at three ways to start the methods using `Task` instances. There
    are links in the GitHub repository to articles that discuss the pros and cons.
    Each has a slightly different syntax, but they all define a `Task` and start it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨三种使用`Task`实例启动方法的方式。GitHub仓库中的链接指向了讨论这些方法优缺点的文章。每种方法的语法略有不同，但它们都定义了一个`Task`并启动它：
- en: 'Comment out the calls to the three methods and their associated console message,
    and add statements to create and start three tasks, one for each method, as shown
    highlighted in the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉对三个方法及其相关控制台消息的调用，并添加语句以创建和启动三个任务，每个方法一个，如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the code, view the result, and note that the elapsed milliseconds appear
    almost immediately. This is because each of the three methods is now being executed
    by three new background worker threads allocated from the thread pool, as shown
    in the following output:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意耗时毫秒数几乎立即出现。这是因为三个方法现在正由线程池分配的三个新后台工作线程执行，如下所示：
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is even possible that the console app will end before one or more of the
    tasks have a chance to start and write to the console!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至有可能控制台应用在任务有机会启动并写入控制台之前就结束了！
- en: Waiting for tasks
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待任务
- en: 'Sometimes, you need to wait for a task to complete before continuing. To do
    this, you can use the `Wait` method on a `Task` instance, or the `WaitAll` or
    `WaitAny` static methods on an array of tasks, as described in the following table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要等待一个任务完成后再继续。为此，你可以使用`Task`实例上的`Wait`方法，或者使用`Task`数组上的`WaitAll`或`WaitAny`静态方法，如下表所述：
- en: '| Method | Description |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `t.Wait()` | This waits for the task instance named `t` to complete execution.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `t.Wait()` | 这会等待名为`t`的任务实例完成执行。 |'
- en: '| `Task.WaitAny(Task[])` | This waits for any of the tasks in the array to
    complete execution. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `Task.WaitAny(Task[])` | 这会等待数组中的任意任务完成执行。 |'
- en: '| `Task.WaitAll(Task[])` | This waits for all the tasks in the array to complete
    execution. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `Task.WaitAll(Task[])` | 这会等待数组中的所有任务完成执行。 |'
- en: Using wait methods with tasks
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用任务的等待方法
- en: Let's see how we can use these wait methods to fix the problem with our console
    app.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些等待方法来解决我们控制台应用的问题。
- en: 'In `Program.cs`, add statements after creating the three tasks and before outputting
    the elapsed time to combine references to the three tasks into an array and pass
    them to the `WaitAll` method, as shown in the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在创建三个任务和输出耗时之间添加语句，将三个任务的引用合并到一个数组中，并将其传递给`WaitAll`方法，如下所示：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the code and view the result, and note the original thread will pause on
    the call to `WaitAll`, waiting for all three tasks to finish before outputting
    the elapsed time, which is a little over 3 seconds, as shown in the following
    output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，注意原始线程将在调用`WaitAll`时暂停，等待所有三个任务完成后再输出耗时，耗时略超过3秒，如下所示：
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The three new threads execute their code simultaneously, and they can potentially
    start in any order. `MethodC` should finish first because it takes only 1 second,
    then `MethodB`, which takes 2 seconds, and finally `MethodA`, because it takes
    3 seconds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 三个新线程同时执行其代码，并且它们可能以任意顺序启动。`MethodC`应该最先完成，因为它仅需1秒，接着是耗时2秒的`MethodB`，最后是耗时3秒的`MethodA`。
- en: However, the actual CPU used has a big effect on the results. It is the CPU
    that allocates time slices to each process to allow them to execute their threads.
    You have no control over when the methods run.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际的CPU使用对结果有很大影响。是CPU为每个进程分配时间片以允许它们执行其线程。你无法控制方法何时运行。
- en: Continuing with another task
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续执行另一个任务
- en: If all three tasks can be performed at the same time, then waiting for all tasks
    to finish will be all we need to do. However, often a task is dependent on the
    output from another task. To handle this scenario, we need to define **continuation
    tasks**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有三个任务都能同时执行，那么等待所有任务完成就是我们所需做的全部。然而，通常一个任务依赖于另一个任务的输出。为了处理这种情况，我们需要定义**延续任务**。
- en: We will create some methods to simulate a call to a web service that returns
    a monetary amount that then needs to be used to retrieve how many products cost
    more than that amount in a database. The result returned from the first method
    needs to be fed into the input of the second method. This time, instead of waiting
    for fixed amounts of time, we will use the `Random` class to wait for a random
    interval between 2 and 4 seconds for each method call to simulate the work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一些方法来模拟对返回货币金额的网络服务的调用，然后需要使用该金额来检索数据库中有多少产品成本超过该金额。从第一个方法返回的结果需要输入到第二个方法的输入中。这次，我们将使用`Random`类而不是等待固定时间，为每次方法调用等待2到4秒之间的随机间隔来模拟工作。
- en: 'At the bottom of `Program.cs`, add two methods that simulate calling a web
    service and a database-stored procedure, as shown in the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，添加两个方法来模拟调用网络服务和数据库存储过程，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Comment out the calls to the previous three tasks by wrapping them in multiline
    comment characters, `/* */`. Leave the statement that outputs the elapsed milliseconds.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将它们包裹在多行注释字符`/* */`中来注释掉对前三个任务的调用。保留输出经过的毫秒数的语句。
- en: 'Add statements before the existing statement to output the total time, as shown
    in the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有语句之前添加语句以输出总时间，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might see different threads running the web service and stored procedure
    calls as in the output above (threads 4 and 6), or the same thread might be reused
    since it is no longer busy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到不同的线程运行网络服务和存储过程调用，如上面的输出所示（线程4和6），或者同一线程可能会被重用，因为它不再忙碌。
- en: Nested and child tasks
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套和子任务
- en: As well as defining dependencies between tasks, you can define nested and child
    tasks. A **nested task** is a task that is created inside another task. A **child
    task** is a nested task that must finish before its parent task is allowed to
    finish.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义任务之间的依赖关系外，您还可以定义嵌套和子任务。**嵌套任务**是在另一个任务内部创建的任务。**子任务**是必须在其父任务允许完成之前完成的嵌套任务。
- en: 'Let''s explore how these types of tasks work:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些类型的任务是如何工作的：
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `NestedAndChildTasks`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器，在`Chapter12`解决方案/工作区中添加一个名为`NestedAndChildTasks`的新控制台应用程序。
- en: In Visual Studio Code, select `NestedAndChildTasks` as the active OmniSharp
    project.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`NestedAndChildTasks`作为活动OmniSharp项目。
- en: 'In `Program.cs`, delete the existing statements, statically import `Console`,
    and then add two methods, one of which starts a task to run the other, as shown
    in the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句，静态导入`Console`，然后添加两个方法，其中一个方法启动一个任务来运行另一个方法，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Above the methods, add statements to start a task to run the outer method and
    wait for it to finish before stopping, as shown in the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法上方，添加语句以启动一个任务来运行外部方法并在停止前等待其完成，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE26]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that, although we wait for the outer task to finish, its inner task does
    not have to finish as well. In fact, the outer task might finish, and the console
    app could end, before the inner task even starts!
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，尽管我们等待外部任务完成，但其内部任务不必同时完成。事实上，外部任务可能完成，控制台应用程序可能结束，甚至在内部任务开始之前！
- en: To link these nested tasks as parent and child, we must use a special option.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将这些嵌套任务链接为父任务和子任务，我们必须使用一个特殊选项。
- en: 'Modify the existing code that defines the inner task to add a `TaskCreationOption`
    value of `AttachedToParent`, as shown highlighted in the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改定义内部任务的现有代码，添加一个`TaskCreationOption`值为`AttachedToParent`，如下面的代码中突出显示所示：
- en: '[PRE27]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the code, view the result, and note that the inner task must finish before
    the outer task can, as shown in the following output:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意内部任务必须在完成外部任务之前完成，如下面的输出所示：
- en: '[PRE28]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `OuterMethod` can finish before the `InnerMethod`, as shown by its writing
    to the console, but its task must wait, as shown by the console not stopping until
    both the outer and inner tasks finish.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`OuterMethod`可以在`InnerMethod`之前完成，如其在控制台上的输出所示，但其任务必须等待，如控制台在内外任务都完成之前不会停止所示。
- en: Wrapping tasks around other objects
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 围绕其他对象包装任务
- en: 'Sometimes you might have a method that you want to be asynchronous, but the
    result to be returned is not itself a task. You can wrap the return value in a
    successfully completed task, return an exception, or indicate that the task was
    canceled by using one of the methods shown in the following table:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能有一个想要异步的方法，但返回的结果本身不是一个任务。你可以将返回值包装在一个成功完成的任务中，返回一个异常，或者通过使用下表中所示的方法来表示任务已被取消：
- en: '| Method | Description |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `FromResult<TResult>(TResult)` | Creates a `Task<TResult>` object whose `Result`
    property is the non-task result and whose `Status` property is `RanToCompletion`.
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `FromResult<TResult>(TResult)` | 创建一个`Task<TResult>`对象，其`Result`属性是非任务结果，其`Status`属性是`RanToCompletion`。
    |'
- en: '| `FromException<TResult>(Exception)` | Creates a `Task<TResult>` that''s completed
    with a specified exception. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `FromException<TResult>(Exception)` | 创建一个因指定异常而完成的`Task<TResult>`。 |'
- en: '| `FromCanceled<TResult>(CancellationToken)` | Creates a `Task<TResult>` that''s
    completed due to cancellation with a specified cancellation token. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `FromCanceled<TResult>(CancellationToken)` | 创建一个因指定取消令牌而完成的`Task<TResult>`。
    |'
- en: 'These methods are useful when you need to:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在你需要时很有用：
- en: Implement an interface that has async methods, but your implementation is synchronous.
    This is common for websites and services.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现具有异步方法的接口，但你的实现是同步的。这在网站和服务中很常见。
- en: Mock asynchronous implementations during unit testing.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试期间模拟异步实现。
- en: In *Chapter 7*, *Packaging and Distributing .NET Types*, we created a class
    library with functions to check valid XML, passwords, and hex codes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在《第7章：打包和分发.NET类型》中，我们创建了一个类库，用于检查有效的XML、密码和十六进制代码。
- en: 'If we had wanted to make those methods conform to an interface that requires
    a `Task<T>` to be returned, we could use these helpful methods, as shown in the
    following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让那些方法符合要求返回`Task<T>`的接口，我们可以使用这些有用的方法，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the method you need to implement returns a `Task` (equivalent to `void`
    in a synchronous method) then you can return a predefined completed `Task` object,
    as shown in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要实现的方法返回一个`Task`（相当于同步方法中的`void`），那么你可以返回一个预定义的已完成`Task`对象，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Synchronizing access to shared resources
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: When you have multiple threads executing at the same time, there is a possibility
    that two or more of the threads may access the same variable or another resource
    at the same time, and as a result, may cause a problem. For this reason, you should
    carefully consider how to make your code **thread-safe**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程同时执行时，有可能两个或更多线程会同时访问同一变量或其他资源，从而可能导致问题。因此，你应该仔细考虑如何使你的代码**线程安全**。
- en: The simplest mechanism for implementing thread safety is to use an object variable
    as a flag or traffic light to indicate when a shared resource has an exclusive
    lock applied.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实现线程安全最简单的机制是使用对象变量作为标志或交通灯，以指示何时对共享资源应用了独占锁。
- en: In William Golding's *Lord of the Flies*, Piggy and Ralph spot a conch shell
    and use it to call a meeting. The boys impose a "rule of the conch" on themselves,
    deciding that no one can speak unless they're holding the conch.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在威廉·戈尔丁的《*蝇王*》中，皮吉和拉尔夫发现了一个海螺壳，并用它召集会议。男孩们自行制定了“海螺规则”，决定只有持有海螺的人才能发言。
- en: I like to name the object variable I use for implementing thread-safe code the
    "conch." When a thread has the conch, no other thread should access the shared
    resource(s) represented by that conch. Note that I say, *should*. Only code that
    respects the conch enables synchronized access. A conch is not a lock.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将用于实现线程安全代码的对象变量命名为“海螺”。当一个线程持有海螺时，其他任何线程都不应访问由该海螺表示的共享资源。请注意，我说的是“不应”。只有尊重海螺的代码才能实现同步访问。海螺不是锁。
- en: 'We will explore a couple of types that can be used to synchronize access to
    shared resources:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨几种可用于同步访问共享资源的类型：
- en: '`Monitor`: An object that can be used by multiple threads to check if they
    should access a shared resource within the same process.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Monitor`：一个可被多个线程用来检查是否应在同一进程内访问共享资源的对象。'
- en: '`Interlocked`: An object for manipulating simple numeric types at the CPU level.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interlocked`：一个用于在CPU级别操作简单数值类型的对象。'
- en: Accessing a resource from multiple threads
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程访问资源
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `SynchronizingResourceAccess`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器，在`Chapter12`解决方案/工作区中添加一个名为`SynchronizingResourceAccess`的新控制台应用。
- en: In Visual Studio Code, select `SynchronizingResourceAccess` as the active OmniSharp
    project.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`SynchronizingResourceAccess`作为活动OmniSharp项目。
- en: 'In `Program.cs`, delete the existing statements and then add statements to
    do the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句，然后添加执行以下操作的语句：
- en: Import the namespace for diagnostic types like `Stopwatch`.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入诊断类型（如`Stopwatch`）的命名空间。
- en: Statically import the `Console` type.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态导入`Console`类型。
- en: 'At the bottom of `Program.cs`, create a static class with two fields:'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个具有两个字段的静态类：
- en: A field to generate random wait times.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机等待时间的字段。
- en: A `string` field to store a message (this is a shared resource).
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`string`字段用于存储消息（这是一个共享资源）。
- en: 'Above the class, create two static methods that add a letter, A or B, to the
    shared `string` five times in a loop, and wait for a random interval of up to
    2 seconds for each iteration:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类上方，创建两个静态方法，它们在循环中五次向共享`string`添加字母A或B，并为每次迭代等待最多2秒的随机间隔：
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After the namespace imports, write statements to execute both methods on separate
    threads using a pair of tasks and wait for them to complete before outputting
    the elapsed milliseconds, as shown in the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命名空间导入之后，编写语句以使用一对任务在单独的线程上执行两个方法，并在输出经过的毫秒数之前等待它们完成，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE33]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This shows that both threads were modifying the message concurrently. In an
    actual application, this could be a problem. But we can prevent concurrent access
    by applying a mutually exclusive lock to a conch object and code to the two methods
    to voluntarily check the conch before modifying the shared resource, which we
    will do in the following section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明两个线程都在并发地修改消息。在实际应用中，这可能是个问题。但我们可以通过对海螺对象应用互斥锁，并让两个方法在修改共享资源前自愿检查海螺，来防止并发访问，我们将在下一节中这样做。
- en: Applying a mutually exclusive lock to a conch
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对海螺应用互斥锁
- en: Now, let's use a conch to ensure that only one thread accesses the shared resource
    at a time.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用海螺确保一次只有一个线程访问共享资源。
- en: 'In `SharedObjects`, declare and instantiate an `object` variable to act as
    a conch, as shown in the following code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedObjects`中，声明并实例化一个`object`变量作为海螺，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In both `MethodA` and `MethodB`, add a `lock` statement for the conch around
    the `for` statements, as shown highlighted in the following code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MethodA`和`MethodB`中，在`for`循环周围添加一个`lock`语句，以锁定海螺，如下面的高亮代码所示：
- en: '[PRE35]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Good Practice**: Note that since checking the conch is voluntary, if you
    only use the `lock` statement in one of the two methods, the shared resource will
    continue to be accessed by both methods. Make sure that all methods that access
    a shared resource respect the conch.'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最佳实践**：请注意，由于检查海螺是自愿的，如果你只在两个方法中的一个使用`lock`语句，共享资源将继续被两个方法访问。确保所有访问共享资源的方法都尊重海螺。'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE36]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although the time elapsed was longer, only one method at a time could access
    the shared resource. Either `MethodA` or `MethodB` can start first. Once a method
    has finished its work on the shared resource, then the conch gets released, and
    the other method has the chance to do its work.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管耗时更长，但一次只能有一个方法访问共享资源。`MethodA`或`MethodB`可以先开始。一旦某个方法完成了对共享资源的操作，海螺就会被释放，另一个方法就有机会执行其任务。
- en: Understanding the lock statement
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解锁语句
- en: 'You might wonder what the `lock` statement does when it "locks" an object variable
    (hint: it does not lock the object!), as shown in the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇`lock`语句在“锁定”对象变量时做了什么（提示：它并没有锁定对象！），如下面的代码所示：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The C# compiler changes the `lock` statement into a `try`-`finally` statement
    that uses the `Monitor` class to *enter* and *exit* the conch object (I like to
    think of it as *take* and *release* the conch object), as shown in the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: C#编译器将`lock`语句转换为使用`Monitor`类*进入*和*退出*海螺对象的`try`-`finally`语句（我喜欢将其视为*获取*和*释放*海螺对象），如下面的代码所示：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When a thread calls `Monitor.Enter` on any object, aka reference type, it checks
    to see if some other thread has already taken the conch. If it has, the thread
    waits. If it has not, the thread takes the conch and gets on with its work on
    the shared resource. Once the thread has finished its work, it calls `Monitor.Exit`,
    releasing the conch. If another thread was waiting, it can now take the conch
    and do its work. This requires all threads to respect the conch by calling `Monitor.Enter`
    and `Monitor.Exit` appropriately.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程对任何对象（即引用类型）调用`Monitor.Enter`时，它会检查是否有其他线程已经获取了海螺。如果已经获取，线程等待。如果没有，线程获取海螺并继续处理共享资源。一旦线程完成其工作，它调用`Monitor.Exit`，释放海螺。如果另一个线程正在等待，现在它可以获取海螺并执行其工作。这要求所有线程通过适当调用`Monitor.Enter`和`Monitor.Exit`来尊重海螺。
- en: Avoiding deadlocks
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免死锁
- en: Knowing how the `lock` statement is translated by the compiler to method calls
    on the `Monitor` class is also important because using the `lock` statement can
    cause a deadlock.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`lock`语句如何被编译器转换为`Monitor`类上的方法调用也很重要，因为使用`lock`语句可能导致死锁。
- en: 'Deadlocks can occur when there are two or more shared resources (each with
    a conch to monitor which thread is currently doing work on each shared resource),
    and the following sequence of events happens:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在两个或多个共享资源（每个资源都有一个海螺来监控当前哪个线程正在处理该共享资源）时，可能会发生死锁，如果以下事件序列发生：
- en: Thread X "locks" conch A and starts working on shared resource A.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程X“锁定”海螺A并开始处理共享资源A。
- en: Thread Y "locks" conch B and starts working on shared resource B.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程Y“锁定”海螺B并开始处理共享资源B。
- en: While still working on resource A, thread X needs to also work with resource
    B, and so it attempts to "lock" conch B but is blocked because thread Y already
    has conch B.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程X在仍在处理资源A的同时，也需要与资源B合作，因此它试图“锁定”海螺B，但由于线程Y已经拥有海螺B而被阻塞。
- en: While still working on resource B, thread Y needs to also work with resource
    A, and so it attempts to "lock" conch A but is blocked because thread X already
    has conch A.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程Y在仍在处理资源B的同时，也需要与资源A合作，因此它试图“锁定”海螺A，但由于线程X已经拥有海螺A而被阻塞。
- en: One way to prevent deadlocks is to specify a timeout when attempting to get
    a lock. To do this, you must manually use the `Monitor` class instead of using
    the `lock` statement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 防止死锁的一种方法是在尝试获取锁时指定超时。为此，你必须手动使用`Monitor`类而不是使用`lock`语句。
- en: 'Modify your code to replace the `lock` statements with code that tries to enter
    the conch with a timeout and outputs an error and then exits the monitor, allowing
    other threads to enter the monitor, as shown highlighted in the following code:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的代码，将`lock`语句替换为尝试在超时后进入海螺的代码，并输出错误，然后退出监视器，允许其他线程进入监视器，如下所示高亮显示的代码：
- en: '[PRE39]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the code and view the result, which should return the same results as before
    (although either A or B could grab the conch first) but is better code because
    it will prevent potential deadlocks.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，结果应与之前相同（尽管A或B可能首先抓住海螺），但这是更好的代码，因为它将防止潜在的死锁。
- en: '**Good Practice**: Only use the `lock` keyword if you can write your code such
    that it avoids potential deadlocks. If you cannot avoid potential deadlocks, then
    always use the `Monitor.TryEnter` method instead of `lock`, in combination with
    a `try`-`finally` statement, so that you can supply a timeout and one of the threads
    will back out of a deadlock if it occurs. You can read more about good threading
    practices at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：仅在你能编写避免潜在死锁的代码时使用`lock`关键字。如果你无法避免潜在死锁，则始终使用`Monitor.TryEnter`方法代替`lock`，并结合`try`-`finally`语句，以便你可以提供超时，如果发生死锁，其中一个线程将退出。你可以在以下链接阅读更多关于良好线程实践的内容：[https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)'
- en: Synchronizing events
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步事件
- en: In *Chapter 6*, *Implementing Interfaces and Inheriting Classes*, you learned
    how to raise and handle events. But .NET events are not thread-safe, so you should
    avoid using them in multithreaded scenarios and follow the standard event raising
    code I showed you earlier.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*，*实现接口和继承类*中，你学习了如何引发和处理事件。但.NET事件不是线程安全的，因此你应该避免在多线程场景中使用它们，并遵循我之前展示的标准事件引发代码。
- en: 'After learning that .NET events are not thread-safe, some developers attempt
    to use exclusive locks when adding and removing event handlers or when raising
    an event, as shown in the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解到.NET事件不是线程安全的之后，一些开发者尝试在添加和移除事件处理程序或触发事件时使用独占锁，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Good Practice**: You can read more about events and thread-safety at the
    following link: [https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**：您可以在以下链接中了解更多关于事件和线程安全的信息：[https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)'
- en: 'But it is complicated, as explained by Stephen Cleary in the following blog
    post: [https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但这很复杂，正如Stephen Cleary在以下博客文章中所解释的：[https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)
- en: Making CPU operations atomic
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使CPU操作原子化
- en: Atomic is from the Greek word **atomos**, which means *undividable*. It is important
    to understand which operations are atomic in multithreading because if they are
    not atomic, then they could be interrupted by another thread partway through their
    operation. Is the C# increment operator atomic, as shown in the following code?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 原子一词来自希腊语**atomos**，意为*不可分割*。理解多线程中哪些操作是原子的很重要，因为如果它们不是原子的，那么它们可能会在操作中途被另一个线程中断。C#的增量运算符是原子的吗，如下面的代码所示？
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is not atomic! Incrementing an integer requires the following three CPU
    operations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是原子的！递增一个整数需要以下三个CPU操作：
- en: Load a value from an instance variable into a register.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从实例变量加载一个值到寄存器。
- en: Increment the value.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递增该值。
- en: Store the value in the instance variable.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值存储在实例变量中。
- en: A thread could be interrupted after executing the first two steps. A second
    thread could then execute all three steps. When the first thread resumes execution,
    it will overwrite the value in the variable, and the effect of the increment or
    decrement performed by the second thread will be lost!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程在执行前两步后可能会被中断。第二个线程随后可以执行所有三个步骤。当第一个线程恢复执行时，它将覆盖变量中的值，第二个线程执行的增减操作的效果将会丢失！
- en: 'There is a type named `Interlocked` that can perform atomic actions on value
    types, such as integers and floats. Let''s see it in action:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`Interlocked`的类型，可以对值类型（如整数和浮点数）执行原子操作。让我们看看它的实际应用：
- en: 'Declare another field in the `SharedObjects` class that will count how many
    operations have occurred, as shown in the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedObjects`类中声明另一个字段，用于计数已发生的操作次数，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In both methods A and B, inside the `for` statement and after modifying the
    `string` value, add a statement to safely increment the counter, as shown in the
    following code:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法A和B中，在`for`语句内并在修改`string`值后，添加一个语句以安全地递增计数器，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After outputting the elapsed time, write the current value of the counter to
    the console, as shown in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出经过的时间后，将计数器的当前值写入控制台，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the code and view the result, as shown highlighted in the following output:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE45]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Observant readers will realize that the existing conch object protects all shared
    resources accessed within a block of code locked by the conch, and therefore it
    is actually unnecessary to use `Interlocked` in this specific example. But if
    we had not already been protecting another shared resource like `Message` then
    using `Interlocked` would be necessary.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会意识到，现有的海螺对象保护了锁定代码块内访问的所有共享资源，因此在这个特定的例子中实际上不需要使用`Interlocked`。但如果我们没有保护另一个像`Message`这样的共享资源，那么使用`Interlocked`将是必要的。
- en: Applying other types of synchronization
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用其他类型的同步
- en: '`Monitor` and `Interlocked` are mutually exclusive locks that are simple and
    effective, but sometimes, you need more advanced options to synchronize access
    to shared resources, as shown in the following table:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monitor`和`Interlocked`是互斥锁，它们简单有效，但有时，您需要更高级的选项来同步对共享资源的访问，如下表所示：'
- en: '| Type | Description |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| `ReaderWriterLock` and `ReaderWriterLockSlim` | These allow multiple threads
    to be in **read mode**, one thread to be in **write mode** with exclusive ownership
    of the write lock, and one thread that has read access to be in **upgradeable
    read mode**, from which the thread can upgrade to write mode without having to
    relinquish its read access to the resource. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `ReaderWriterLock`和`ReaderWriterLockSlim` | 这些允许多个线程处于**读模式**，一个线程处于**写模式**，拥有写锁的独占所有权，以及一个线程，该线程具有对资源的读访问权限，并处于**可升级读模式**，从中线程可以升级到写模式，而无需放弃其对资源的读访问权限。
    |'
- en: '| `Mutex` | Like `Monitor`, this provides exclusive access to a shared resource,
    except it is used for inter-process synchronization. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `Mutex` | 类似于`Monitor`，它为共享资源提供独占访问，但用于进程间同步。 |'
- en: '| `Semaphore` and `SemaphoreSlim` | These limit the number of threads that
    can access a resource or pool of resources concurrently by defining slots. This
    is known as resource throttling rather than resource locking. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `Semaphore`和`SemaphoreSlim` | 这些通过定义槽限制可以同时访问资源或资源池的线程数量。这被称为资源节流，而不是资源锁定。
    |'
- en: '| `AutoResetEvent` and `ManualResetEvent` | Event wait handles allow threads
    to synchronize activities by signaling each other and by waiting for each other''s
    signals. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `AutoResetEvent`和`ManualResetEvent` | 事件等待句柄允许线程通过相互发送信号和等待彼此的信号来同步活动。 |'
- en: Understanding async and await
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异步和等待
- en: 'C# 5 introduced two C# keywords when working with the `Task` type. They are
    especially useful for the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: C# 5在处理`Task`类型时引入了两个C#关键字。它们特别适用于以下情况：
- en: Implementing multitasking for a **graphical user interface** (**GUI**).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为**图形用户界面**(**GUI**)实现多任务处理。
- en: Improving the scalability of web applications and web services.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升Web应用和Web服务的可扩展性。
- en: In *Chapter 15*, *Building Websites Using the Model-View-Controller Pattern*,
    we will see how the `async` and `await` keywords can improve scalability for websites.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第15章*，*使用模型-视图-控制器模式构建网站*中，我们将看到`async`和`await`关键字如何提升网站的可扩展性。
- en: In *Chapter 19*, *Building Mobile and Desktop Apps Using .NET MAUI*, we will
    see how the `async` and `await` keywords can implement multitasking for a GUI.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第19章*，*使用.NET MAUI构建移动和桌面应用*中，我们将看到`async`和`await`关键字如何实现GUI的多任务处理。
- en: But for now, let's learn the theory of why these two C# keywords were introduced,
    and then later you will see them used in practice.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，让我们先学习这两个C#关键字被引入的理论原因，之后您将看到它们在实践中的应用。
- en: Improving responsiveness for console apps
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高控制台应用的响应性
- en: 'One of the limitations with console applications is that you can only use the
    `await` keyword inside methods that are marked as `async` but C# 7 and earlier
    do not allow the `Main` method to be marked as async! Luckily, a new feature introduced
    in C# 7.1 was support for `async` in `Main`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序的一个限制是，您只能在标记为`async`的方法中使用`await`关键字，但C# 7及更早版本不允许将`Main`方法标记为异步！幸运的是，C#
    7.1引入了一个新特性，即支持`Main`中的`async`：
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncConsole`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您偏好的代码编辑器，向`Chapter12`解决方案/工作区中添加一个名为`AsyncConsole`的新控制台应用。
- en: In Visual Studio Code, select `AsyncConsole` as the active OmniSharp project.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`AsyncConsole`作为活动的OmniSharp项目。
- en: 'In `Program.cs`, delete the existing statements and statically import `Console`,
    as shown in the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句并静态导入`Console`，如下所示：
- en: '[PRE46]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add statements to create an `HttpClient` instance, make a request for Apple''s
    home page, and output how many bytes it has, as shown in the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以创建`HttpClient`实例，请求Apple主页，并输出其字节数，如下所示：
- en: '[PRE47]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Build the project and note that it builds successfully. In .NET 5 and earlier,
    you would have seen an error message, as shown in the following output:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并注意它成功构建。在.NET 5及更早版本中，您会看到一条错误消息，如下所示：
- en: '[PRE48]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You would have had to add the `async` keyword to the `Main` method and change
    its return type to `Task`. With .NET 6 and later, the console app project template
    uses the top-level program feature to automatically define the `Program` class
    with an asynchronous `Main` method for you.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您本需要向`Main`方法添加`async`关键字并将其返回类型更改为`Task`。使用.NET 6及更高版本，控制台应用项目模板利用顶级程序功能自动为您定义具有异步`Main`方法的`Program`类。
- en: 'Run the code and view the result, which is likely to have a different number
    of bytes since Apple changes its home page frequently, as shown in the following
    output:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，由于苹果经常更改其主页，因此结果可能会有不同的字节数，如下面的输出所示：
- en: '[PRE49]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Improving responsiveness for GUI apps
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高GUI应用程序的响应性
- en: So far in this book, we have only built console applications. Life for a programmer
    gets more complicated when building web applications, web services, and apps with
    GUIs such as Windows desktop and mobile apps.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中我们只构建了控制台应用程序。当构建Web应用程序、Web服务以及带有GUI的应用程序（如Windows桌面和移动应用程序）时，程序员的生活会变得更加复杂。
- en: 'One reason for this is that for a GUI app, there is a special thread: the **user
    interface** (**UI**) thread.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 原因之一是，对于图形用户界面（GUI）应用程序，存在一个特殊的线程：**用户界面**（**UI**）线程。
- en: 'There are two rules for working in GUIs:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI中工作的两条规则：
- en: Do not perform long-running tasks on the UI thread.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在UI线程上执行长时间运行的任务。
- en: Do not access UI elements on any thread except the UI thread.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在除UI线程以外的任何线程上访问UI元素。
- en: To handle these rules, programmers used to have to write complex code to ensure
    that long- running tasks were executed by a non-UI thread, but once complete,
    the results of the task were safely passed to the UI thread to present to the
    user. It could quickly get messy!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些规则，程序员过去不得不编写复杂的代码来确保长时间运行的任务由非UI线程执行，但一旦完成，任务的结果会安全地传递给UI线程以呈现给用户。这很快就会变得混乱！
- en: Luckily, with C# 5 and later, you have the use of `async` and `await`. They
    allow you to continue to write your code as if it is synchronous, which keeps
    your code clean and easy to understand, but underneath, the C# compiler creates
    a complex state machine and keeps track of running threads. It's kind of magical!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用C# 5及更高版本，你可以使用`async`和`await`。它们允许你继续以同步方式编写代码，这使得代码保持清晰易懂，但在底层，C#编译器创建了一个复杂的**状态机**并跟踪运行线程。这有点神奇！
- en: Let's see an example. We will build a Windows desktop app using WPF that gets
    employees from the Northwind database in an SQL Server database using low-level
    types like `SqlConnection`, `SqlCommand`, and `SqlDataReader`. You will only be
    able to complete this task if you have Windows and the Northwind database stored
    in SQL Server. This is the only section in this book that is not cross-platform
    and modern (WPF is 16 years old!).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。我们将使用WPF构建一个Windows桌面应用程序，该应用程序从SQL Server数据库中的Northwind数据库获取员工信息，使用低级类型如`SqlConnection`、`SqlCommand`和`SqlDataReader`。只有当你拥有Windows和存储在SQL
    Server中的Northwind数据库时，你才能完成此任务。这是本书中唯一不跨平台且现代的部分（WPF已有16年历史！）。
- en: At this point, we are focusing on making a GUI app responsive. You will learn
    about XAML and building cross-platform GUI apps in *Chapter 19*, *Building Mobile
    and Desktop Apps Using .NET MAUI*. Since this book does not cover WPF elsewhere,
    I thought this task would be a good opportunity to at least see an example app
    built using WPF even if we do not look at it in detail.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们专注于使GUI应用程序具有响应性。你将在*第19章*，*使用.NET MAUI构建移动和桌面应用程序*中学习XAML和构建跨平台GUI应用程序。由于本书其他部分不涉及WPF，我认为这是一个很好的机会，至少可以看到一个使用WPF构建的示例应用程序，即使我们不详细讨论它。
- en: Let's go!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧！
- en: 'If you are using Visual Studio 2022 for Windows, add a new **WPF Application
    [C#]** project named `WpfResponsive` to the `Chapter12` solution. If you are using
    Visual Studio Code, use the following command: `dotnet new wpf`.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows上的Visual Studio 2022，请向`Chapter12`解决方案中添加一个名为`WpfResponsive`的**WPF应用程序[C#]**项目。如果你使用的是Visual
    Studio Code，请使用以下命令：`dotnet new wpf`。
- en: In the project file, note the output type is a Windows EXE, the target framework
    is .NET 6 for Windows (it will not run on other platforms like macOS and Linux),
    and the project uses WPF.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件中，注意输出类型是Windows EXE，目标框架是面向Windows的.NET 6（它不会在其他平台如macOS和Linux上运行），并且项目使用了WPF。
- en: 'Add a package reference for `Microsoft.Data.SqlClient` to the project, as shown
    highlighted in the following markup:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加对`Microsoft.Data.SqlClient`的包引用，如下面的标记中突出显示的那样：
- en: '[PRE50]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Build the project to restore packages.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: 'In `MainWindow.xaml`, in the `<Grid>` element, add elements to define two buttons,
    a text box and a list box, laid out vertically in a stack panel, as shown highlighted
    in the following markup:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml`中，在`<Grid>`元素内，添加元素以定义两个按钮、一个文本框和一个列表框，它们在堆栈面板中垂直布局，如下面的标记中突出显示的那样：
- en: '[PRE51]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Visual Studio 2022 for Windows has good support for building WPF apps and will
    provide IntelliSense as you edit code and XAML markup. Visual Studio Code does
    not.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows上的Visual Studio 2022对构建WPF应用提供了良好的支持，并在编辑代码和XAML标记时提供IntelliSense。Visual
    Studio Code则不支持。
- en: 'In `MainWindow.xaml.cs`, in the `MainWindow` class, import the `System.Diagnostics`
    and `Microsoft.Data.SqlClient` namespaces, then create two `string` constants
    for the database connection string and SQL statement and create event handlers
    for clicking on the two buttons that use those `string` constants to open a connection
    to the Northwind database and populate the list box with the ids and names of
    all employees, as shown in the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow.xaml.cs`中，在`MainWindow`类中，导入`System.Diagnostics`和`Microsoft.Data.SqlClient`命名空间，然后创建两个`string`常量用于数据库连接字符串和SQL语句，并为两个按钮的点击创建事件处理程序，使用这些`string`常量打开与Northwind数据库的连接，并在列表框中填充所有员工的ID和姓名，如下所示：
- en: '[PRE52]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note the following:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The SQL statement uses the SQL Server command `WAITFOR DELAY` to simulate processing
    that takes five seconds. It then selects three columns from the `Employees` table.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL语句使用SQL Server命令`WAITFOR DELAY`模拟耗时五秒的处理过程，然后从`Employees`表中选择三个列。
- en: The `GetEmployeesSyncButton_Click` event handler uses synchronous methods to
    open a connection and fetch the employee rows.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetEmployeesSyncButton_Click`事件处理程序使用同步方法打开连接并获取员工行。'
- en: The `GetEmployeesAsyncButton_Click` event handler is marked as `async` and uses
    asynchronous methods with the `await` keyword to open a connection and fetch the
    employee rows.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetEmployeesAsyncButton_Click`事件处理程序标记为`async`，并使用带有`await`关键字的异步方法打开连接并获取员工行。'
- en: Both event handlers use a stopwatch to record the number of milliseconds the
    operation takes and add it to the list box.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个事件处理程序均使用秒表记录操作耗费的毫秒数，并将其添加到列表框中。
- en: Start the WPF app without debugging.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动WPF应用，无需调试。
- en: Click in the text box, enter some text, and note the GUI is responsive.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本框，输入一些文本，注意GUI响应。
- en: Click the **Get Employees Synchronously** button.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**同步获取员工**按钮。
- en: Try to click in the text box, and note the GUI is not responsive.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试点击文本框，注意GUI无响应。
- en: Wait for at least five seconds until the list box is filled with employees.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待至少五秒钟，直到列表框中填满员工信息。
- en: Click in the text box, enter some text, and note the GUI is responsive again.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本框，输入一些文本，注意GUI再次响应。
- en: Click the **Get Employees Asynchronously** button.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**异步获取员工**按钮。
- en: Click in the text box, enter some text, and note the GUI is still responsive
    while it performs the operation. Continue typing until the list box is filled
    with the employees.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本框，输入一些文本，注意在执行操作时GUI仍然响应。继续输入，直到列表框中填满员工信息。
- en: Note the difference in timings for the two operations. The UI is blocked when
    fetching data synchronously, while the UI remains responsive when fetching data
    asynchronously.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意两次操作的时间差异。同步获取数据时UI被阻塞，而异步获取数据时UI保持响应。
- en: Close the WPF app.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭WPF应用。
- en: Improving scalability for web applications and web services
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升Web应用和Web服务的可扩展性。
- en: The `async` and `await` keywords can also be applied on the server side when
    building websites, applications, and services. From the client application's point
    of view, nothing changes (or they might even notice a small increase in the time
    taken for a request to return). So, from a single client's point of view, the
    use of `async` and `await` to implement multitasking on the server side makes
    their experience worse!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`和`await`关键字在构建网站、应用程序和服务时也可应用于服务器端。从客户端应用程序的角度来看，没有任何变化（或者他们甚至可能注意到请求返回所需时间略有增加）。因此，从单个客户端的角度来看，使用`async`和`await`在服务器端实现多任务处理会使他们的体验变差！'
- en: On the server side, additional, cheaper worker threads are created to wait for
    long-running tasks to finish so that expensive I/O threads can handle other client
    requests instead of being blocked. This improves the overall scalability of a
    web application or service. More clients can be supported simultaneously.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，创建额外的、成本较低的工作线程来等待长时间运行的任务完成，以便昂贵的I/O线程可以处理其他客户端请求，而不是被阻塞。这提高了Web应用或服务的整体可扩展性。可以同时支持更多客户端。
- en: Common types that support multitasking
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多任务处理的常见类型
- en: 'There are many common types that have asynchronous methods that you can await,
    as shown in the following table:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见类型都具有异步方法，你可以等待这些方法，如下表所示：
- en: '| Type | Methods |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 方法 |'
- en: '| `DbContext<T>` | `AddAsync`, `AddRangeAsync`, `FindAsync`, and `SaveChangesAsync`
    |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `DbContext<T>` | `AddAsync`, `AddRangeAsync`, `FindAsync`, 和 `SaveChangesAsync`
    |'
- en: '| `DbSet<T>` | `AddAsync`, `AddRangeAsync`, `ForEachAsync`, `SumAsync`, `ToListAsync`,
    `ToDictionaryAsync`, `AverageAsync`, and `CountAsync` |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `DbSet<T>` | `AddAsync`, `AddRangeAsync`, `ForEachAsync`, `SumAsync`, `ToListAsync`,
    `ToDictionaryAsync`, `AverageAsync`, 和 `CountAsync` |'
- en: '| `HttpClient` | `GetAsync`, `PostAsync`, `PutAsync`, `DeleteAsync`, and `SendAsync`
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `HttpClient` | `GetAsync`, `PostAsync`, `PutAsync`, `DeleteAsync`, 和 `SendAsync`
    |'
- en: '| `StreamReader` | `ReadAsync`, `ReadLineAsync`, and `ReadToEndAsync` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `StreamReader` | `ReadAsync`, `ReadLineAsync`, 和 `ReadToEndAsync` |'
- en: '| `StreamWriter` | `WriteAsync`, `WriteLineAsync`, and `FlushAsync` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `StreamWriter` | `WriteAsync`, `WriteLineAsync`, 和 `FlushAsync` |'
- en: '**Good Practice**: Any time you see a method that ends in the suffix `Async`,
    check to see whether it returns `Task` or `Task<T>`. If it does, then you could
    use it instead of the synchronous non-`Async` suffixed method. Remember to call
    it using `await` and decorate your method with `async`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：每当看到以`Async`为后缀的方法时，检查它是否返回`Task`或`Task<T>`。如果是，那么你可以使用它代替同步的非`Async`后缀方法。记得使用`await`调用它，并为你的方法添加`async`修饰符。'
- en: Using await in catch blocks
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在catch块中使用await
- en: When `async` and `await` were first introduced in C# 5, it was only possible
    to use the `await` keyword in a `try` block, but not in a `catch` block. In C#
    6 and later, it is now possible to use `await` in both `try` and `catch` blocks.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 5中首次引入`async`和`await`时，只能在`try`块中使用`await`关键字，而不能在`catch`块中使用。在C# 6及更高版本中，现在可以在`try`和`catch`块中都使用`await`。
- en: Working with async streams
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异步流
- en: With .NET Core 3.0, Microsoft introduced the asynchronous processing of streams.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 随着.NET Core 3.0的推出，微软引入了流异步处理。
- en: 'You can complete a tutorial about async streams at the following link: [https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接完成关于异步流的教程：[https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)
- en: Before C# 8.0 and .NET Core 3.0, the `await` keyword only worked with tasks
    that return scalar values. Async stream support in .NET Standard 2.1 allows an
    `async` method to return a sequence of values.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8.0和.NET Core 3.0之前，`await`关键字仅适用于返回标量值的任务。.NET Standard 2.1中的异步流支持允许`async`方法返回一系列值。
- en: Let's see a simulated example that returns three random integers as an async
    stream.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个模拟示例，该示例返回三个随机整数作为异步流。
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncEnumerable`.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你偏好的代码编辑器，在`Chapter12`解决方案/工作区中添加一个名为`AsyncEnumerable`的新控制台应用。
- en: In Visual Studio Code, select `AsyncEnumerable` as the active OmniSharp project.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`AsyncEnumerable`作为活动的OmniSharp项目。
- en: 'In `Program.cs`, delete the existing statements and statically import `Console`,
    as shown in the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有语句并静态导入`Console`，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'At the bottom of `Program.cs`, create a method that uses the `yield` keyword
    to return a random sequence of three numbers asynchronously, as shown in the following
    code:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`底部，创建一个使用`yield`关键字异步返回三个随机数字序列的方法，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Above `GetNumbersAsync`, add statements to enumerate the sequence of numbers,
    as shown in the following code:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetNumbersAsync`上方，添加语句以枚举数字序列，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '[PRE56]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Practicing and exploring
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践与探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题，进行实践操作，并深入研究本章主题，来测试你的知识和理解。
- en: Exercise 12.1 – Test your knowledge
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.1 – 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What information can you find out about a process?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于进程，你能了解到哪些信息？
- en: How accurate is the `Stopwatch` class?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stopwatch`类的精确度如何？'
- en: By convention, what suffix should be applied to a method that returns `Task`
    or `Task<T>`?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照惯例，返回`Task`或`Task<T>`的方法应附加什么后缀？
- en: To use the `await` keyword inside a method, what keyword must be applied to
    the method declaration?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在方法内部使用`await`关键字，方法声明必须应用什么关键字？
- en: How do you create a child task?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建子任务？
- en: Why should you avoid the `lock` keyword?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要避免使用`lock`关键字？
- en: When should you use the `Interlocked` class?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应使用`Interlocked`类？
- en: When should you use the `Mutex` class instead of the `Monitor` class?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应使用`Mutex`类而不是`Monitor`类？
- en: What is the benefit of using `async` and `await` in a website or web service?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网站或网络服务中使用`async`和`await`有何好处？
- en: Can you cancel a task? If so, how?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能取消一个任务吗？如果可以，如何操作？
- en: Exercise 12.2 – Explore topics
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.2 – 探索主题
- en: 'Use the links on the following webpage to learn more detail about the topics
    covered in this chapter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用以下网页上的链接，以了解更多关于本章所涵盖主题的详细信息：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章 - 使用多任务提高性能和可扩展性](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)'
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned not only how to define and start a task but also
    how to wait for one or more tasks to finish and how to control task completion
    order. You've also learned how to synchronize access to shared resources and the
    magic behind `async` and `await`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你不仅学会了如何定义和启动任务，还学会了如何等待一个或多个任务完成，以及如何控制任务完成的顺序。你还学习了如何同步访问共享资源以及`async`和`await`背后的奥秘。
- en: In the seven chapters that follow, you will learn how to create applications
    for the **app models**, aka **workloads** supported by .NET, such as websites
    and services, and cross-platform desktop and mobile apps.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的七章中，你将学习如何为.NET支持的**应用模型**，即**工作负载**，创建应用程序，例如网站和服务，以及跨平台的桌面和移动应用。
